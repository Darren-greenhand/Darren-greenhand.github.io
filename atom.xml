<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮华一隅</title>
  
  <subtitle>See more, see further.      own the courage to change, be willing to challenge</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-18T13:41:20.139Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Darren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二次数模</title>
    <link href="http://example.com/2021/04/18/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%95%B0%E6%A8%A1/"/>
    <id>http://example.com/2021/04/18/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%95%B0%E6%A8%A1/</id>
    <published>2021-04-17T16:25:21.000Z</published>
    <updated>2021-04-18T13:41:20.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大一下新生赛"><a href="#大一下新生赛" class="headerlink" title="大一下新生赛"></a>大一下新生赛</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        4.16-4.18日，数模新生赛开赛，这是我参加的第二次数模，也是某博，某锐俩巨佬参加的第一次数模。这次数模过程和理想过程仍有较大差距，在第二天晚上，暂时起不到作用（可能有作用但是不知道。。），我开始在两位辛勤的巨佬面前写起了日记。</p><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><p>​        这次赛前准备。。。非常不理想，主要是临时起意打数模，并且沉迷学习线代和机器学习前置数学知识等，再加上蓝桥杯和数据结构作业带来的压力，导致准备非常不充分，在赛前一晚上疯狂准备，恶补了数模的一些概念，准备了一些画图软件以供使用。并没有提前学习其他的数学建模知识。</p><h2 id="开赛"><a href="#开赛" class="headerlink" title="开赛"></a>开赛</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>​        被某博骗去考了个假的蓝桥杯，明明是星期天才考淦，但是因此翘掉了早上的体育课嘿嘿，因祸得福。。。吧，早上花了3个小时分析题目，但是这里太急了，发生了 <strong>第一个错误：没有逐字逐句的分析题目</strong>，数模题目中，由于许多概念都不熟悉，一不小心就离题千里，就像本次数模发生了好几次纠正理解偏差，一定要真正读懂题意！！</p><p>​        博找了个超好的地方，物质条件远胜酒店，而且各种条件超级方便，这为后面三天的爆肝和肆意讨论提供了非常棒的场所支持，果然。。生活中总是藏着一些不为人见的好地方哈哈。。。</p><p>​        见面后，三个人很快进入状态，开始各抒己见，但是都得出了大致一致的结论，而且受我上午找的资料带来的影响很深（我的锅嘤嘤嘤），一开始都跑偏了，而且这里团队也出现了一个问题，就是<strong>揪住了某个点</strong>，比如那个宕机是啥不放，这样子大概浪费了30分钟，所幸。。。吃过上次的亏，即使止住了，嘿嘿还好队友很棒，没有上次那么咳咳。。</p><p>​        然后我们从头开始梳理题意，一开始就发现一堆概念不会。。啥负载啊，什么什么的，这个时候其实有一个小错误：就是<strong>不了解数模规则</strong>，开始准备随意设变量，这就跟我上次一样哈哈:joy:，这次还好我有一点点经验，不然会浪费很多时间，这确实提醒，一定要熟悉比赛的规则，有方向的用力！还有讨论过程中好几次陷入某个牛角尖，偏离主线，不过这个问题马上就被众人杜绝了，这就是大佬的学习能力嘛，可怕:man_shrugging:，还好是队友哈哈，下次打数模肯定不会这么被动了。</p><p>​        开始我们关注点放在云计算上，找了一堆“调度算法”，静态的，动态的，想着是找一个能够满足约束条件的现实模型，然后对他选择一个算法，比如启发式算法啊，巴拉巴拉的，结果弄了半天，甚至拉上了xxx，分析头疼到晚上八点，然后。。。我从头看题的时候tm的灵光一现。。这个第一句话。。。“并行计算”，tm的是个这么大的方向！所以，<strong>一定要细读题目，确保真正理解题意</strong>，我全国一卷130的语文，阅读题从来都是接近满分，就这还被坑了好久，而且后面第二句也是个被忽略的点好像。切记啊！！！</p><p>​        晚上，我犯了个打错。。就是“偷懒”，我感觉三个人一起想有些浪费，而队伍里没有会写论文的人！！！然后我当时挺慌，就马上临时抱佛脚，开始找了个b站好点的教程开始啃格式和写作要求，虽然读完发现真的很重要，但是这本来是可以避免的，这也导致我错过了他们的思路，后来的分析从3个人变成了2个人，我只能提供技术支持，还有准备本不应该在建模时准备的模板啥的。。第一天比正常效率低很多，一方面是因为上午下午都有一些事情，如果是正规比赛，<strong>绝对要提前做好准备</strong>，不过我们不至于请假哈哈QWQ。</p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>​        八点起床嘿嘿嘿，果然还是没有太大的压力，聚在一起以后大家又开始继续一些错误的思路，但是少了一位神秘大佬的帮助QWQ，我仍是尽量借助自己辛勤经营了大半年的信息搜索系统，尽量帮大佬们准备资料，然后就是努力啃教程，这部分主要是他们俩讨论，研究，下午的时候。。。大家心态都炸了，我因为连续看了6，7小时教程好恶心，他们也是长期的高速思考，而且中途不断推翻，假设新模型，这个他们是真辛苦，我大概受不了:cry:。</p><p>​        然后下午大概四点有一段时间挺浮躁的，还好不久，而且有了一个突破，于是还是熬过去了，五点就赶紧去吃饭缓解一下，干饭的时候交流了一下，其实我们仨可以组一个长期队伍，队伍里仨，应该说是各有特色，而且智商都不戳，理解能力和沟通能力都挺好（外联每月之星带带我吧QWQ）。</p><p>​        <em>我应该算是那种不喜欢钻研，喜欢寻找各种各样方便的工具（有兴趣找我拿噢，各种功能的小软件，小网站，还有很多领域的最佳学习路线我都有。。。吧），而且了解很多各个领域，但是都是一知半解，而且英语还不戳，高中英语挺好，四级660，语文也行，不如以后向写论文和制作图片，爬虫收集数据，辅助方向发展。。但是不能拉下基本知识学习</em></p><p>​        <em>锐佬很强，他的电脑让我一言难尽。。。只能说基本配废了（和我同款），不过他啃问题是真的强，看论文也看得下去，不像我。。神马鬼论文，看十几篇就快死了（每篇都是浏览大意然后甩给队友嘿嘿），这样的特点是真的强，不过锐佬感觉比较适合钻研某个问题，而不是总结方向。</em></p><p>​        <em>博佬也很强，感觉是我们俩的综合版嘛，电脑还不戳，好歹不会像大部分的电脑一样被我嫌弃。。。智商也很高，能和锐佬一起讨论，并提出很多建设性的意见，流弊！！！而且会的小工具啥的也挺多的，不戳不戳，以后不愁找不到女朋友。。。啊不是偏题了。</em></p><p>​        <em>个人感觉以后分工可以是：三个人读题，然后一起弄清楚概念，我尽量帮助他们提供资料和工具，图片上的支援（跑腿买奶茶也行O(∩_∩)O），然后三个人开始建模，先确定正确的方向，然后开始现场学习相关理论，（主要靠锐佬和博佬），然后建模！这个还得学公式的使用，不过我买了Axmath永久的，到时候看看怎么分任务，最后开始写论文，如果是美赛，我可以直接查谷歌翻译敲，国赛我就尽量在他们肝的时候写一些内容比如问题分析，重述啥的。大概设想吧只是。。。</em></p><p>​        周二晚上，仍然讨论到九点才开始写论文，这时我也基本了解了工具和写法，并写了个总结快速给他们介绍了一下，然后写出了问题重述和大致模板，他俩也肝出了（好苦啊。。我看的都苦，一点一点的挤出了）问题分析，中途还出了几个让人心态爆炸的bug（我记得有一个是好像以为从头理解错了啥的。。搞得我整个人都佛了，好歹后来好像⚪回来了）。</p><p>​        明早蓝桥杯，但是估计打不了多久，也没啥准备，数模最难的论文主体，那些公式和图片！！表格啥的。。哎，希望这个能有个稍微不错的结果，不要太打击人吧！锐哥好像还在肝，真是辛苦了。:vulcan_salute:</p><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>​        打完了！！！！！！！！没想到啊，蓝桥杯我和x博俩菜笔十一点就交卷了哈哈，都只写了三道题，然后赶紧回来打数模，真的，要是打到一点，这次数模绝对凉凉，从上午开始逐步写论文，做图片，调格式，还有棒队友们打公式。。。中午草草的吃了一餐饭，回来连觉都没睡，将符号和公式慢慢实现成了论文，不过写的时候还是出现了很多的问题，比如本来负责写论文的我，由于听不懂他们在讲什么。。。好多地方没法写，只能帮忙做做语言上的修改和格式上的美化。。。呜呜呜我是废物QWQ，还有就是效率，锐哥写公式效率有亿点慢，对电脑的操作也不行。。。或者说是不是他把电脑配炸了。。但是即使这样，一切还是比较顺利的进行着，当然，中途比较混乱，有时候一会写这个，一会写那个，这里有个问题就是他俩，甚至我都对论文内容不是很熟悉，有好几次都是写错位置，还需要改改放到别的地方啥的，这是个新手问题吧哈哈哈QWQ。</p><p>​        最后心态还是很炸的，因为只有不到一个小时写摘要，还有一些其他的补充内容，比如问题一的结论图都是临时x博赶紧随便编的，我当时心态还炸了哈哈，以后这些工具还是得多学学，别再坑队友了，而且搞到最后才发现连第二问都没做，我把第一问一部分抽取过来，加上某锐临时写的一长段瞎编的，凑成了奇奇怪怪的第二个问题哈哈哈哈哈。</p><p>​        最后十分钟！汇总成一篇摘要，调好格式，导出PDF，在27分的时候提交了，提交了以后发现要压缩，又赶回来压缩了重新交了一份，交完后整个人都要飞了，博博放了植物大战僵尸背景曲哈哈，我们仨光在原地兴奋就兴奋了20分钟，有好队友真的爽啊！虽然我们这次过程比起正规比赛还差的很远，但是那种氛围是真的喜欢，这就是好队友加成吧！</p><p>​        晚上第一次去了传说中的海底捞，真的惊艳到了！服务员小哥哥小姐姐超级超级好，还有各种想不到的服务！真是上帝般的体验，我们仨说了几百句谢谢哈哈，有些不习惯这么好的服务，而且菜也超级好吃，总的来说真的体验炒鸡炒鸡棒，让本就好的心情锦上添花！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>谢谢两位大佬这仨天的陪伴，真的开心！</p><p>希望下次打数模的时候我们每个人都有了极大的进步！下次就是真正的比赛了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大一下新生赛&quot;&gt;&lt;a href=&quot;#大一下新生赛&quot; class=&quot;headerlink&quot; title=&quot;大一下新生赛&quot;&gt;&lt;/a&gt;大一下新生赛&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="log" scheme="http://example.com/categories/log/"/>
    
    
    <category term="数模" scheme="http://example.com/tags/%E6%95%B0%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>数模论文格式和内容</title>
    <link href="http://example.com/2021/04/15/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2021/04/15/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87/</id>
    <published>2021-04-15T15:26:54.000Z</published>
    <updated>2021-04-17T13:46:31.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排版格式"><a href="#排版格式" class="headerlink" title="排版格式"></a>排版格式</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416163718840.png" alt="image-20210416163718840" style="zoom:33%;" /><p>表格，图形之类的，还有Excel可视化啥的</p><p>公式，公式识别</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>word vs Latex</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416164354583.png" alt="image-20210416164354583" style="zoom: 33%;" /><p>国赛Latex用得少，而美赛用得很多Latex</p><p><strong>优秀论文排版</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416165419679.png" alt="image-20210416165419679" style="zoom:50%;" /><p>图形的配色。。避免大段的空行，不要水空间。格式规范，审美哈哈哈</p><h2 id="word基础"><a href="#word基础" class="headerlink" title="word基础"></a>word基础</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000312818.png" alt="image-20210417000312818" style="zoom:50%;" /><h3 id="常用功能和快捷键"><a href="#常用功能和快捷键" class="headerlink" title="常用功能和快捷键"></a>常用功能和快捷键</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000618699.png" alt="image-20210417000618699" style="zoom:50%;" /><p>比如空格显示为小点</p></li><li><p>打印预览功能</p></li></ul><hr><ul><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000906546.png" alt="image-20210417000906546" style="zoom:50%;" /></li><li><p>强大的F4，在ppt和excel都能用，重复上一步操作，但是仅仅记录一步噢</p><p>对光标所在的符合要求的对象进行该操作</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001349006.png" alt="image-20210417001349006" style="zoom: 67%;" /></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001611043.png" alt="image-20210417001611043" style="zoom:50%;" /></li><li><p>“书签栏” 对选中的功能使用“添加到快速访问工具栏”</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001949722.png" alt="image-20210417001949722" style="zoom:33%;" /></li><li><p>每个功能区的<strong>右下角是完整菜单</strong></p></li></ul><hr><p><strong>字体功能区</strong></p><ul><li>粘贴选项，常用的只保留文本，还有强大的粘贴为图片，比如把ppt的形状复制过来</li><li>格式刷：单击只能用一次，双击可以连续使用，Esc取消</li><li>上下标是俩个X2<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417103542242.png" alt="image-20210417103542242"></li><li>字体颜色，背景颜色，艺术字！加拼音，更改大小写，清除所有格式</li></ul><hr><p><strong>段落功能区</strong></p><ul><li><p>对齐，两端对齐一般好看，行间距，底纹，框线（用光标）</p></li><li><p>加编号，调整缩进量</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417105224584.png" alt="image-20210417105224584"></p></li><li><p>重复编号，左边有一个自动更重编号，按住ctrl选中多行再添加编号</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417105657108.png" alt="image-20210417105657108"></p><p>这两个勾，很可能会<strong>坑人</strong></p></li><li><p>图片上方紧接着有文字，可以设置段前行距</p><p><img src="C:/Users/Lenovo/Desktop/image-20210417105834906.png" alt="image-20210417105834906"></p></li></ul><hr><p><strong>插入功能区</strong></p><ul><li>页面-&gt;封面 空白页（原理是分页符）</li><li>插入表格记得行和列是和线性代数反的，选中文本-&gt;<strong>文本转换为表格</strong></li><li>插入图片-&gt;此设备，调段落格式，小心首行缩进导致左边间距更大</li><li>插入形状，新建画布，和ppt一样</li><li>插入页眉，每一页都有，去掉横线方法：去除格式，改一改缩进，还有页码</li><li>插入文本框，四周型和嵌入性，浮于文字上方，改边框的形状轮廓</li></ul><hr><p><strong>布局功能区</strong></p><ul><li>页边距，页面方向，分成两栏，但是图片太宽则不行，两栏三栏</li><li>分隔符里的分节符，默认整个文档是一节，要分节来<strong>防止全局操作</strong></li><li>视图有标尺，选中表格，双击标尺，就可以改一些设置，包括纸张方向</li></ul><h3 id="样式和多级列表"><a href="#样式和多级列表" class="headerlink" title="样式和多级列表"></a>样式和多级列表</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417111817711.png" alt="image-20210417111817711" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417112018930.png" alt="image-20210417112018930" style="zoom: 33%;" /><p>还可用于导航窗格导航</p><p><strong>目录！！！</strong></p><p>引用-&gt;目录，直接根据标题插入目录，还可以直接设置格式</p><p>导出为PDF的时候！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417112706180.png" alt="image-20210417112706180" style="zoom:33%;" /><h3 id="国赛规范和模板制作"><a href="#国赛规范和模板制作" class="headerlink" title="*国赛规范和模板制作"></a>*国赛规范和模板制作</h3><p>在官网查资料。。这里是2020版的，最后两页为纸质版才有的</p><p>第二页开始编号，</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417114000963.png" alt="image-20210417114000963" style="zoom:50%;" /><p>页边距2.5厘米，其他细节格式根据赛区自定，如果没有赛区要求，则自己定：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417114133736.png" alt="image-20210417114133736" style="zoom: 50%;" /><hr><ul><li>调出标题三，样式右下角，管理样式，推荐，显示标题3</li><li>右键样式进入设置，先设置中文，再设置英文</li><li>段落直接用所有脚本设置黑体，记得取消加粗</li><li>新建一个“图片和表格”样式</li></ul><hr><p><strong>多级列表</strong></p><p>空白处创建新的多级列表，更多，链接到样式，加上标题的格式</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417140707541.png" alt="image-20210417140707541" style="zoom:33%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417140728583.png" alt="image-20210417140728583"></p><p>编号之后改成空格</p><p>二级标题勾选：正规格式编号</p><p>关闭文档，重新打开，把标题的缩进都去掉</p><p>国赛控制在页边距，可以根据内容调整页边距大小</p><hr><p>加个页码，记得把缩进关了，把上面的横线清除格式</p><h3 id="表格制作"><a href="#表格制作" class="headerlink" title="表格制作"></a>表格制作</h3><p>左上角的十字，全选表格和拖动位置，右下角拖动更改表格大小，居中对齐</p><p>退格键删除表格，delete键清空内容，虚线是“查看网格线”，其实啥都没有</p><p>布局里面调一下布局方式，还有个自动调整功能，用的不是很多</p><p>左下角和右上角分别是插入行和列</p><p>可以用边框刷，也可以设置上下左右边框这样的</p><p>记得在上面写一行字，写表格标题</p><hr><p>表格样式就是模板一样的</p><p>把文字环绕设置成无，因为一拖动就会自动设置成环绕</p><p>改了样式后，记得在段落里把样式里的首行缩进改成无</p><h4 id="长表格"><a href="#长表格" class="headerlink" title="长表格"></a>长表格</h4><p>行数太多了，把标题多复制一份，然后套用三线表，改一下对齐方式，加一条中间的竖直边框</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145355812.png" alt="image-20210417145355812"></p><h4 id="宽表格"><a href="#宽表格" class="headerlink" title="宽表格"></a>宽表格</h4><p>列数太多了，可以使用横向排列之类的，但是建模肯定要分行，用Excel帮忙</p><p>记得加上续表俩字</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145727529.png" alt="image-20210417145727529"></p><h4 id="拼接表格"><a href="#拼接表格" class="headerlink" title="拼接表格"></a>拼接表格</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145851642.png" alt="image-20210417145851642"></p><p>当作一个整体，中间这一列设置为无边框</p><h4 id="有合并单元格"><a href="#有合并单元格" class="headerlink" title="有合并单元格"></a>有合并单元格</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417150114299.png" alt="image-20210417150114299"></p><p>在Excel里面就可以使用合并单元格，给特定单元格加框线</p><p>分隔效果是加了无色的竖线</p><p>有一些特殊软件生成的表格跳过了</p><h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417150937068.png" alt="image-20210417150937068"></p><p>取消所有框线，加上部分下框线</p><h4 id="自动编号"><a href="#自动编号" class="headerlink" title="自动编号"></a>自动编号</h4><p>引用-&gt;插入题注，勾选自动插入题注，来自动更新</p><p>还可以关联你写的引用和相应表：交叉引用，引用类型为表，这样会自动变化，要刷新F9</p><p>但其实比赛论文不太需要这些，直接手打就好了。</p><p>表前的文字和表格间距0.5行。。可以用上面的段后</p><h3 id="图形制作和排版"><a href="#图形制作和排版" class="headerlink" title="图形制作和排版"></a>图形制作和排版</h3><p>国赛风格简约，黑白，而美赛。。。很酷</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155000260.png" alt="image-20210417155000260" style="zoom:50%;" /><p>以后得自学前两者</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155446780.png" alt="image-20210417155446780"></p><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155639823.png" alt="image-20210417155639823"></p><p>调好缩进，直接右键转化为smartart，先选大类，再选小类</p><p>设计里更改颜色啥的，然后再在格式里面调整具体的样式，粘贴为图片</p><p>还有Xmind和process on</p><h4 id="简单示意图"><a href="#简单示意图" class="headerlink" title="简单示意图"></a>简单示意图</h4><p><strong>ppt绘制</strong></p><p>插入各种形状，无填充等样式，添加形状，文本窗格</p><p>格式里有<strong>对齐和横向分布在右边</strong>，旋转</p><p>C + 按住图形可以直接拖出新的，按住shift拉线不会歪</p><p>选中需要的图形，右键组合，还能取消组合</p><p>图表标题通用的。。写在下面就好了</p><p>强大的ppt组合图形，组合可以嵌套</p><hr><p><strong>任意多边形</strong>记住shift不动，Esc就画完了</p><p>曲线大致描几个点，格式，形状轮廓，箭头和样式啥的</p><p>竟然是iconfont阿里巴巴卧槽，下SVG格式的，没想到哇</p><hr><p><strong>ppt后期加工</strong></p><p>其实也还是加一堆图形哈哈，</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417171000183.png" alt="image-20210417171000183" style="zoom:50%;" /><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417171042537.png" alt="image-20210417171042537" style="zoom: 50%;" /><p>选择全部，居中对齐什么的，processOn</p><p>YeD之类的</p><h4 id="物理示意图"><a href="#物理示意图" class="headerlink" title="物理示意图"></a>物理示意图</h4><p>直接ppt，哈哈哈，AxGlyph软件，和Axmath一样是word插件</p><p>ppt，绘制圆，按照ctrl就是标准⚪，还能调节角度卧槽。还有旋转。</p><hr><p>还有亿图（有水印），有很多模板，美赛用的多</p><p>GeoGraph，动态的，免费的</p><p><strong>Echarts，需要一定的前端，数据可视化方向的</strong></p><p>也可以学python中的pyecharts这个包</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417181153530.png" alt="image-20210417181153530" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417181547695.png" alt="image-20210417181547695" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417184523976.png" alt="image-20210417184523976" style="zoom:50%;" /><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417213014215.png" alt="image-20210417213014215" style="zoom:50%;" /><p>直接查到论文，然后引用</p><p>正文格式，编号格式，手动添加上标</p><h3 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417213539208.png" alt="image-20210417213539208"></p><p><strong>mathpix</strong></p><h1 id="写作方法"><a href="#写作方法" class="headerlink" title="写作方法"></a>写作方法</h1><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417184905778.png" alt="image-20210417184905778"></p><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>基于啊哈哈。。50%</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185146499.png" alt="image-20210417185146499" style="zoom:50%;" /><p>表达准确。。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185252729.png" alt="image-20210417185252729" style="zoom:50%;" /><p>最后写，反复修改</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185510665.png" alt="image-20210417185510665" style="zoom:50%;" /><p>平均800-1000</p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185558584.png" alt="image-20210417185558584" style="zoom:50%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185925628.png" alt="image-20210417185925628" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190146004.png" alt="image-20210417190146004" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190320644.png" alt="image-20210417190320644" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190458831.png" alt="image-20210417190458831" style="zoom:50%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190805813.png" alt="image-20210417190805813" style="zoom:50%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190834259.png" alt="image-20210417190834259" style="zoom:50%;" /><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191010259.png" alt="image-20210417191010259" style="zoom:50%;" /><p>多放主要模型！</p><h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h2><p>一级标题的第一个</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191206893.png" alt="image-20210417191206893" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191311203.png" alt="image-20210417191311203" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191358234.png" alt="image-20210417191358234" style="zoom:50%;" /><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191500357.png" alt="image-20210417191500357" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191905011.png" alt="image-20210417191905011" style="zoom:50%;" /><p>甚至思维导图和思维框图</p><h2 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417192156795.png" alt="image-20210417192156795" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417192226678.png" alt="image-20210417192226678" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417195904468.png" alt="image-20210417195904468" style="zoom:50%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417200139452.png" alt="image-20210417200139452" style="zoom:50%;" /><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417200444421.png" alt="image-20210417200444421"></p><p>写在最后。。不是所有都要放。</p><h2 id="模型建立与求解"><a href="#模型建立与求解" class="headerlink" title="模型建立与求解"></a>模型建立与求解</h2><p>ps：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201120942.png" alt="image-20210417201120942" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201501252.png" alt="image-20210417201501252" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201700798.png" alt="image-20210417201700798" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201731556.png" alt="image-20210417201731556" style="zoom:50%;" /><p>这就是结合的利用</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201821269.png" alt="image-20210417201821269" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201950243.png" alt="image-20210417201950243" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202044451.png" alt="image-20210417202044451" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202306738.png" alt="image-20210417202306738" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202327970.png" alt="image-20210417202327970" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202413624.png" alt="image-20210417202413624" style="zoom: 33%;" /><h2 id="模型分析或检验"><a href="#模型分析或检验" class="headerlink" title="模型分析或检验"></a>模型分析或检验</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202623048.png" alt="image-20210417202623048" style="zoom:33%;" /><h3 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417203408032.png" alt="image-20210417203408032" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211229051.png" alt="image-20210417211229051" style="zoom:33%;" /><h3 id="稳定性检验"><a href="#稳定性检验" class="headerlink" title="稳定性检验"></a>稳定性检验</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211856247.png" alt="image-20210417211856247" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211955682.png" alt="image-20210417211955682" style="zoom:33%;" /><h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212037424.png" alt="image-20210417212037424" style="zoom:33%;" /><h2 id="评价，改进-推广"><a href="#评价，改进-推广" class="headerlink" title="评价，改进(推广)"></a>评价，改进(推广)</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212142176.png" alt="image-20210417212142176" style="zoom:33%;" /><h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212253184.png" alt="image-20210417212253184" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212402948.png" alt="image-20210417212402948" style="zoom:33%;" /><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212528558.png" alt="image-20210417212528558" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212627609.png" alt="image-20210417212627609" style="zoom:33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排版格式&quot;&gt;&lt;a href=&quot;#排版格式&quot; class=&quot;headerlink&quot; title=&quot;排版格式&quot;&gt;&lt;/a&gt;排版格式&lt;/h1&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-gre</summary>
      
    
    
    
    <category term="数模" scheme="http://example.com/categories/%E6%95%B0%E6%A8%A1/"/>
    
    
    <category term="数模论文" scheme="http://example.com/tags/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>linear algebra</title>
    <link href="http://example.com/2021/04/12/linear-algebra/"/>
    <id>http://example.com/2021/04/12/linear-algebra/</id>
    <published>2021-04-12T04:38:47.000Z</published>
    <updated>2021-04-16T08:22:40.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>为了学机器学习，重拾已经快忘干净的线代，接着上学期看的MIT，从头开始看起，没有考试的压力，单纯的探索线代世界，实在是太快乐了！而从中发现的诸多新鲜的，被忽略的知识，更是让人相见恨晚。</p><h1 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h1><h2 id="1-方程组的几何解释"><a href="#1-方程组的几何解释" class="headerlink" title="1.方程组的几何解释"></a>1.方程组的几何解释</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412124757970.png" alt="image-20210412124757970" style="zoom:33%;" /><p>老师给出了方程组（n维）按行来解和按列来解完全不一样的几何意义</p><p>按行：</p><p>每一个方程都得出n-1维的超平面，最后交出一个点</p><p>按列：</p><p>每个方程都是n维中的一个向量，最后进行线性组合，得出结果</p><p>显然按列意义更强，也更符合“线性”这一说。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412125559614.png" alt="image-20210412125559614" style="zoom:33%;" /><p>这样子真的好理解很多！</p><h2 id="2-矩阵消元"><a href="#2-矩阵消元" class="headerlink" title="2.矩阵消元"></a>2.矩阵消元</h2><p>也是高斯，听说现在有更高效的了</p><p>依次用主元pivot消去下列的⚪，主元为0则用下面不为0的行变换，如果全为0，那就是一个奇异矩阵。。。“坏矩阵”</p><p>解出Upper上三角矩阵后，就可以回代了</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412131953821.png" alt="image-20210412131953821"></p><p>从Ax = B  到  Ux = C</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412132249094.png" alt="image-20210412132249094" style="zoom:33%;" /><p><em><strong>即分别用行和列进行矩阵操作</strong></em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412132432705.png" alt="image-20210412132432705" style="zoom:50%;" /><p>然后从行列对矩阵的影响引出了初等矩阵E elementary</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412132624337.png" alt="image-20210412132624337" style="zoom:33%;" /><p>所以我们原来学的教材是逻辑有问题的，先引入了初等矩阵的概念，然后告诉我们有这些性质。</p><p>像MIT就解释的很好，先引入了左右矩阵其实是对矩阵的行和列进行线性组合，然后由单位矩阵不影响出发，推导出初等矩阵会具有这些作用！</p><p><strong>那甚么矩阵可以一次完成A -&gt; U呢？</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412181828766.png" alt="image-20210412181828766" style="zoom:33%;" /><p>当然是一堆初等矩阵的叠加啦！而这是通过增减括号实现的，associative law 结合律，证明非常复杂。。</p><p>permutation 置换</p><h2 id="3-乘法和逆矩阵"><a href="#3-乘法和逆矩阵" class="headerlink" title="3.乘法和逆矩阵"></a>3.乘法和逆矩阵</h2><p>他是这样引入逆矩阵的</p><p>初等矩阵会对某个矩阵进行变换，那逆矩阵相当于抵消这个变换，将其复原。</p><p>效果就是，初等矩阵再X逆矩阵得到 单位矩阵，即不进行行列变换</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412182739963.png" alt="image-20210412182739963" style="zoom:50%;" /><p>矩阵乘法。。没有新奇的地方，还是原来的概念</p><p>不过中国是一开始就这样讲，他是铺垫了整行整列，再分析单个元素。。都不错吧</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412183207354.png" alt="image-20210412183207354" style="zoom: 33%;" /><p>但是。。。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412183220306.png" alt="image-20210412183220306" style="zoom:50%;" /><p>来了来了！整行整列的</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412183305325.png" alt="image-20210412183305325" style="zoom:50%;" /><p>其实还建立在第一章基础之上</p><p>因为在我们分析某一列时<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412183352548.png" alt="image-20210412183352548" style="zoom:50%;" /></p><p>我们就可以把右矩阵拆成多条对矩阵的排列再合起来，左边同理</p><p>A(mxn) B(nxp) = C(mxp)   列的角度看，C的各列，是A中各列的线性组合，B为组合方法</p><p>第三种方法就是按行同理啦</p><p>第四种方法！用列乘行，会得到一个完整的矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412183942271.png" alt="image-20210412183942271" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412184048797.png" alt="image-20210412184048797" style="zoom:50%;" /><p><strong>列X行得到的矩阵，列空间和行空间都是一条直线</strong></p><p>第五种，分块相乘，他并没有过多解释，好像在他眼里。。这跟普通矩阵性质一样的。</p><hr><p>可逆就是非奇异！invertible  non-singular</p><p>为什么没有逆！3B1B的解释非常清晰，维度是不可能升高的</p><p>他从单位矩阵出发分析，[1 3 / 2 6]这构成一条线，而单位向量不在这条线上</p><p>另一个解释，如果存在向量X使得AX = 0，但是X不是0向量，那样总能成立<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412185525071.png" alt="image-20210412185525071"></p><p>如果有逆，左右×一个逆，得出x为0，与x不为0相悖，看来这么课也不是像3B1B一样那么痴迷几何</p><p><strong>因为A -&gt; 0时其列能通过线性组合（非零向量0）得到0，但是不可逆矩阵只可以通过0来达到</strong></p><p>但是也必须提个醒，不能太依赖几何，更高深的问题抽象程度太高，难以借用几何</p><p>现在继续回到可逆情况，可以通过第一节学的方法快速解决，解n（此处2）个方程罢了</p><p>这回到了高斯思想，但是右侧是两列，它引出了Jordan思想</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412190308614.png" alt="image-20210412190308614"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412190523846.png" alt="image-20210412190523846"></p><p>！！！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412190656445.png" alt="image-20210412190656445" style="zoom: 50%;" /><p>Jordan说，两个一起来吧，不就是解俩吗，于是右侧写成了一个矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412190923982.png" alt="image-20210412190923982" style="zoom:50%;" /><p>而当左侧还原成原先（单位阵）的时候，右侧得出了每一列的还原方式，合起来就是可逆矩阵，还原每一列</p><p>但是比起高斯只消到U，他还要继续消掉上面的得到单位阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412191048072.png" alt="image-20210412191048072" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412191237395.png" alt="image-20210412191237395" style="zoom:50%;" /><p>分开想，E*A = I  E就是A逆，然后I * A逆得到A逆，怎么理解都行哈哈</p><h2 id="4-A的LU分解"><a href="#4-A的LU分解" class="headerlink" title="4.A的LU分解"></a>4.A的LU分解</h2><p>transpose 转置  upper   lower</p><p>消元快完了，A=LU是最基本的分解，我们之前把A消到U，但是中间的联系是什么？</p><p>——是<strong>L</strong></p><p>因为总是消除下面的，所以上面的乘以某倍数到下面，变成了L矩阵</p><p><em>插一句：二阶矩阵逆是主对角线交换，副对角线变号</em></p><p>首先研究不进行行变换的</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412195154414.png" alt="image-20210412195154414"></p><p>为什么要把这些初等矩阵除到右边？</p><p><em>初等矩阵简单的变换完全可以根据意义直接写出逆，比如2倍乘下来，那就-2倍乘下来抵消</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412195611223.png" alt="image-20210412195611223" style="zoom: 33%;" /><p>上面是E，下面是L</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412200221340.png" alt="image-20210412200221340"></p><p>L的顺序不会引入奇怪的“杂质”比如那个10，而且消元的乘数还留在矩阵里面一目了然，就是2和5</p><p>第一行乘2加到第二行，第二行再乘5加到第三行</p><p><strong>而这也是最牛逼的地方，想得到L不需要运算（没有行变换的情况）</strong>，只要：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412200416518.png" alt="image-20210412200416518"></p><p><strong>可以在得到LU的过程可以抛开A</strong>，比如完成A的第二行的消元，得到了U中新的第二行，同时得到了<strong>消元用的乘数</strong></p><p>这样就不用管A了，信息都在LU里，E不重要，但：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412195950377.png" alt="image-20210412195950377"></p><hr><p>拓展：nxn矩阵要进行多少次操作，指的是计算机的操作</p><p>我们这里讲一次乘法+一次减法算一次操作</p><p>n的平方 + n-1的平方 +………..   n(n+1)(2n+1)/6  约等于1/3n的三次方 或者说从1-n对n平方积分</p><p>但线性代数是离散的，，以后不准用微积分哈哈</p><p>这是A的，b的是n的平方次</p><hr><p>下面允许行互换</p><p>3 x 3矩阵行互换的可能性一共有6种，其实是有序排列 <strong>n!</strong></p><p>这个矩阵群怎么相乘都在6个之中，逆矩阵也在6个之中哈哈</p><h2 id="5-转置，置换，向量空间R"><a href="#5-转置，置换，向量空间R" class="headerlink" title="5.转置，置换，向量空间R"></a>5.转置，置换，向量空间R</h2><p>真正的线性代数开始于向量空间！</p><p>继续上节课的话题，再碰到需要行变换的时候，A=LU怎么处理，他介绍了Matlab的方法</p><p>Matlab不仅检查0元，还检查趋近0的主元，因为这些非常难处理的</p><p>答案是</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412202651492.png" alt="image-20210412202651492" style="zoom:50%;" /><p>P是行重新排列的单位矩阵，又称<strong>置换矩阵，对A进行行置换</strong></p><p>记住n阶矩阵的数量n!，置换矩阵的<strong>逆矩阵等于其转置</strong>，还有一个<strong>很关键的性质</strong>，这可真是数量稀少</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412203042685.png" alt="image-20210412203042685" style="zoom:50%;" /><p>还有一个书上的性质</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412203439256.png" alt="image-20210412203439256" style="zoom: 25%;" /><p>证明很简单。。利用对称矩阵性质，本身 = 转置</p><hr><p>来了，向量空间</p><p>向量有什么性质：加法，数乘，这是基础，而且要满足一些规则</p><p>R2(up)  代表二维实向量域，所有向量空间必须有原点，就是零向量</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412204019656.png" alt="image-20210412204019656" style="zoom:50%;" /><p>向量空间的性质：</p><p>加减，数乘，线性运算。八条规则，而且最关键的是运算完以后仍在原空间内</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412204207306.png" alt="image-20210412204207306" style="zoom: 33%;" /><p>即对线性组合“封闭”</p><p>而满足这些性质，却不包含所有二维向量的，引出子空间</p><p>子空间必须穿过原点，因为必须允许数乘0而得到一个0向量</p><p>现在列出R2的子空间</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412204746785.png" alt="image-20210412204746785" style="zoom: 50%;" /><p>然后R3有四种，多了一种过原点的平面</p><p>现在考虑这个<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412205044363.png" alt="image-20210412205044363"></p><p>A的列的所有线性组合会构成一个子空间，线性组合意味着进行加法和数乘两种运算</p><p>只要包含了所有线性组合，必然会张成一个子空间，叫列空间，C(A)</p><p>也是今天的核心思想，通过某些向量构造一个向量空间，关键是对其进行线性组合后仍在该空间内。</p><p>这个思维应该理解，就是在n维空间中，m个n维向量张成一个子空间。。挺好理解的哈哈</p><h2 id="6-列空间和零空间"><a href="#6-列空间和零空间" class="headerlink" title="6.列空间和零空间"></a>6.列空间和零空间</h2><p>假设俩子空间，平面P和直线L  PUL = 存在两者里的所有向量</p><p>这个集合不是子空间，连加法都显然不封闭。</p><p>但对于任何子空间， S并T却一定是子空间，这相当于条件增加了，想象其中两个向量，他们对于S和T任一一个都满足子空间的性质，合起来当然仍然满足</p><p>这是两个很重要的结论。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412211300192.png" alt="image-20210412211300192" style="zoom:50%;" /><p>而这个A的列空间由所有列的线性组合张成，那具体是怎样的呢</p><p>下面把他和线性方程组联系起来，因为：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412211454511.png" alt="image-20210412211454511"></p><p>这里的目的就是研究Ax = b，对任意右侧向量都有解吗？</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412211635844.png" alt="image-20210412211635844"></p><p>首先注意，方程组不总有解，比如这里的3个列向量无法张成整个四维空间</p><p>而且这里四个方程，3个未知数，通常我们认为此时无解，但是</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412211759888.png" alt="image-20210412211759888"></p><p>今天的问题就是取怎样的b能符合这种👆</p><p>b为0当然是一个解，而实际情况是当且仅当b属于A的列空间，即b是各列的线性组合，这也是为啥老师喜欢列空间，这能告诉我们何时方程有解。淦，他竟然讲了independent 线性无关卧槽</p><p>这里可以描述为<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412212443287.png" alt="image-20210412212443287" style="zoom:33%;" /></p><hr><p>现在讲零空间嘿嘿，这是一种<strong>完全不同</strong>的子空间！Nullspace</p><p>它不包含b，它包含x，看看这个关键字“零”，因此它包含Ax = 0中所有的解</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412212655491.png" alt="image-20210412212655491" style="zoom:50%;" /><p>这些x向量包含3个分量，因此零空间是R3的子空间</p><p>对于m x n矩阵  列空间的维度是m  零空间是n，因为列的个数n，等于未知数的个数</p><p>现在开始找零空间，正常应该消元，但是这里直接可以看出来</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412213300727.png" alt="image-20210412213300727" style="zoom:33%;" /><p>现在来检验，这确实张成一个空间，很容易用性质验证。。</p><p>现在到关键了，对于Ax = b</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412213808400.png" alt="image-20210412213808400"></p><p>两个问题：1. 所有解x构成向量空间吗？    当然不。</p><p>这里的<strong>解</strong>有很多个，但是他们不构成子空间，它其实是一个<strong>不穿过原点的平面，或直线</strong>，子空间平移</p><p>所以，向量空间必须包含0，<strong>如果考虑的是是x，那么Ax 一定等于 0</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412214027947.png" alt="image-20210412214027947" style="zoom: 33%;" /><p>已知的信息只有向量必须满足的方程组。</p><p>这就是两种构筑子空间的方法：</p><ol><li>从向量出发，通过线性组合构筑向量空间</li><li>也可以从一个方程组中，通过让x满足特定条件来得到子空间</li></ol><p>终于理解了。。当年咋都看不懂，不要死扣几何意义。。真的信我。。诱人但坑人</p><h2 id="7-求解AX-0主变量-特解"><a href="#7-求解AX-0主变量-特解" class="headerlink" title="7.求解AX = 0主变量 特解"></a>7.求解AX = 0主变量 特解</h2><p>这节课是定义到算法的转折</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412214959512.png" alt="image-20210412214959512"></p><p>还是消元，不过是长方形，所以即使出现0⚪我们仍要继续</p><p>注意，消元的时候解是不会变的，因此零空间也不会变</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412215120182.png" alt="image-20210412215120182" style="zoom: 33%;" /><p>这里第二列消元没法了。。这说明第二列是前面列的<strong>线性组合</strong>，但我们继续</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412215233635.png" alt="image-20210412215233635" style="zoom:33%;" /><p>这次只有两个主元，这个数量我们称为rank，秩，<strong>意义非凡</strong></p><p>这里区别列为 主列 pivot columns 和自由列 free columns，现在要求的是Ux = 0</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412215501466.png" alt="image-20210412215501466"></p><p>这里又到回代的过程，而自由列对应的自由变量可以自由取。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412215621954.png" alt="image-20210412215621954"></p><p>此处赋值（一般的我们倾向于给一个1，其他为0）后得到了一个x特解，当然，它的任意倍数也是解。</p><p>然后再给自由变量赋值，得到另一个（组）解，然后就可以构造出零向量空间。简单的证明。。u满足，v满足，那么u+v也满足之类的。。这就是结论，<strong>零空间是特解的线性组合张成的。每个自由变量对应一个特解</strong></p><p>m x n   r个主元（即r个方程起作用）  n-r个自由变量</p><p>下面谈到 简化行阶梯型式，用 R替代  把U的主元上面的给消掉，使主元所在列除了主元均为0，再把主元所在行做加减（不影响解），使得主元为1</p><p>rref()函数直接得出👆，如果用这个矩阵回代，就是RX=<strong>0 这个过程A -&gt; U -&gt; R 解均相同</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412222103731.png" alt="image-20210412222103731" style="zoom: 67%;" /><p><strong>典型在I 是个R X R矩阵   则Rx = 0  这里求解构造一个“零空间矩阵”N，各列由特解组成，即RN=0</strong></p><p>显然<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412222327626.png" alt="image-20210412222327626" style="zoom:33%;" />可以达到目的，但如果左边写成[主元 自由]  那N的上面就是-F 下面是主元<strong>而这也正是特解（由自由变的和主的组成）构成的矩阵</strong>，该矩阵可由null（）求出</p><p><strong>Matlab</strong>先算出R，然后找出主变量和自由变量，将1和0分配到自由变量中，复制出主变量，他会使用回代（I是单位阵，<strong>F是自由部分</strong>）得到这个矩阵很迷，<strong>因为I F其实是 两种x的特殊形式吧</strong>，本来左边也应该写成俩个x，然后推出右边，但是左边可以等效化成这个好形式，那再好不过了</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412222807202.png" alt="image-20210412222807202" style="zoom:50%;" /><p>这是回代的最终结果。意味着<strong>主变量(一条) + F乘自由变量(一条) = 0(主变量总数+自由变量总数 = n)<strong>（卧槽我懂了，x那一列里面有自由变量，也有不能变，要求的主变量）（这里每项都是矩阵）如果我们给xfree（自由变量）分配</strong>单位阵，那么主变量就等于 -F</strong>，下个例子就是这样干的</p><p>矩阵主列的个数与其转置相同，秩相同，举个例子</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412224133262.png" alt="image-20210412224133262"></p><p>然后给自由变量赋值，这里是x[]最下面那个，<strong>如果赋0，则主变量都为0没啥意义，还是给1</strong></p><p>就求出<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412224403553.png" alt="image-20210412224403553" style="zoom:50%;" />检验正确，其<strong>主变量（俩-1）刚好为-F</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412223319067.png" alt="image-20210412223319067" style="zoom:50%;" />这里的F就是右边那俩竖着的1</p><p>最后得到的解空间<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412223401018.png" alt="image-20210412223401018" style="zoom: 33%;" /></p><p>验证了之前的结果！全新的看法啊。。妙啊！！！！！！！！！！</p><p>那这样子也太好算了吧，左边化成[I F]的过程其实就已经把方程解完了</p><h2 id="8-求解Ax-b可解性和解的结构"><a href="#8-求解Ax-b可解性和解的结构" class="headerlink" title="8.求解Ax = b可解性和解的结构"></a>8.求解Ax = b可解性和解的结构</h2><p>Ax = b 是否有解，有多少解</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413233103119.png" alt="image-20210413233103119" style="zoom:50%;" /><p>Augmented matrix 增广矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413233326657.png" alt="image-20210413233326657" style="zoom:50%;" /><p>这就是有解的条件，左边等价右边，这是显然的，而不是给个概念哈哈</p><p>所以solvability: </p><p>当且仅当b属于A的列空间，即是A各列的线性组合</p><p>如果A各行的线性组合得到0，b端的分量也必为0</p><p>这两种描述是等价的</p><hr><p>下面到算法：<strong>求Ax=b的所有解</strong></p><p>第一步，找一个特解</p><p>因为变量数多于方程数，能找出一堆解，方便的做法是令<strong>所有自由变量为0</strong></p><p>然后求出主变量，组成一个特解</p><p>接下来的关键是，可以加上零空间中的任意x，因为不会影响结果，即为所求全部解</p><p>他给的证明也是<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413234026689.png" alt="image-20210413234026689" style="zoom:50%;" /></p><p><em><strong>解为：特解加上零空间内任意向量</strong></em>     x = xp + xn</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413234346430.png" alt="image-20210413234346430" style="zoom: 33%;" /><p>但此时并不过原点，而是穿过xp（特解），不是子空间，而是子空间从原点平移得到的二维平面</p><hr><p>m x n矩阵  秩（主元数）为 r      r&lt;=m  and  r&lt;=n   两种<strong>满秩情况</strong></p><p><strong>列满秩(r = n ,r&lt;m)：</strong></p><p>没有自由变量，零空间里只有一个零向量  Ax = b 如果有解，那么只剩下一个特解！！</p><p>或者无解，所以只有 0 或 1 个解</p><p>一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413235134468.png" alt="image-20210413235134468" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413235213091.png" alt="image-20210413235213091" style="zoom:25%;" /></p><p>最终化为最简是上面单位阵，下面为0</p><p>此时Ax = b 只有当b正好位于那个二维子空间才有解，此时特解显然为两列之合[4 3 7 6]`</p><p>当然，是可以为 0 的</p><hr><p><strong>行满秩(r = m ,r&lt;n)：</strong></p><p>问题：b取什么时，Ax= b有解？</p><p>消元时，不会出现零行！因此b没有要求（出现零行则b为0那个要求）</p><p><strong>所以对任意b，Ax = b 都有解</strong></p><p><strong>此时有r/m个主变量，自由变量为 n - r/n - m 个</strong></p><p>还是上面那个例子，转置一下</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413235826318.png" alt="image-20210413235826318" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413235844601.png" alt="image-20210413235844601" style="zoom:25%;" /></p><p>还记得那个 I F吗</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412222327626.png" alt="image-20210412222327626" style="zoom:33%;" /><p>这里就是那种情况，所以说这部分构成零空间的特殊解！牛啊！</p><p>这里左边的 I 和 右边的 F 是可以<strong>交织，混搭</strong>的！</p><p><strong>此时总有无穷解，因为总是有零空间需要处理</strong></p><hr><p>r = m = n，这意味着这是一个令人愉快的可逆矩阵</p><p>而简化后就是单位阵</p><p>零空间只包含零向量，而且这种情况肯定有解，所以，必然仅有一个<strong>唯一解</strong>！！！</p><p>突然感觉好委屈QWQ，当年线代讲空间的时候，理解了好久，现在直接二倍速看懂了</p><hr><p>那 r&lt;m , r&lt;n 的情况就很显然了</p><p>又存在零空间，又可能出现零行，<strong>所以要么无解，要么无穷多解</strong></p><p>所以秩包含了好多有用的信息，这节课为什么没有早点明白QWQ，太惨了</p><p>他给的图是：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414000943462.png" alt="image-20210414000943462" style="zoom:50%;" /><p>感谢strang老师！</p><h2 id="9-线性相关性、基、维数"><a href="#9-线性相关性、基、维数" class="headerlink" title="9.线性相关性、基、维数"></a>9.线性相关性、基、维数</h2><p>线性无关是用来形容向量组，而不是矩阵</p><p>它对无关的定义和我们学的一样。只要出现零向量就必然线性相关。很好理解。</p><p>列向量相关 &lt;=&gt; 零空间存在除了零向量以外的向量,r&lt;n</p><p>列向量无关 &lt;=&gt; 零空间仅存在零向量,r&lt;n ，无自由变量</p><p>向量组“<strong>生成（span）</strong>”一个空间：</p><p><strong>这个空间包含这些向量的所有线性组合</strong></p><hr><p>某空间的基：</p><p>一个拥有两大性质：线性无关，且张成整个空间 的向量组</p><p><strong>子空间的基包含这个子空间的全部有用信息</strong></p><p>对于<strong>方阵</strong>，所选的向量组为基的条件是组成的矩阵<strong>可逆</strong>，显然</p><hr><p>维数：</p><p>每个空间，基向量的个数即为空间的维数</p><p>当然这里讨论的是完整的n维空间，而不是残破的子空间</p><p>矩阵的秩 = 空间的维数 = 主元数量</p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210414092552773.png" alt="image-20210414092552773" style="zoom:50%;" /><p>而在这个秩为2的例子里，零空间的基可以分别设1 0 来找</p><p>零空间的维度是自由变量的个数</p><h2 id="10-四个基本子空间"><a href="#10-四个基本子空间" class="headerlink" title="10.四个基本子空间"></a>10.四个基本子空间</h2><p>核心内容，四个子空间的关系</p><p>其中行空间也是所有行向量的线性组合，<strong>或者说A转置的列的所有组合</strong>，这样考虑就可以使用之前的结论</p><p>列空间C(A)   零空间N(A)   行空间C(AT)   左零空间N(AT)</p><p>列空间在m维，行空间在n维</p><p>零空间在n维，左零空间在m维</p><p>列维数 + 左零维数 = m        行维数 + 零维数 = n </p><p>经典的图片：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414093802197.png" alt="image-20210414093802197" style="zoom:50%;" /><p>关键在basis 和 dimension</p><p>关键结论是：<strong>A 和 AT 的秩相同，确实同一个矩阵从不同方向看，秩不是一个有方向的属性，所以理应是不变的</strong></p><p>对列空间，一组基就是主列，维数就是r</p><p>对列空间，一组基就是主行，维数就是r</p><p>对零空间，一组基就是特殊解们，n - r 个free var 即为维数</p><p>对左零空间，一组基就是特殊解们，m - r 个free var 即为维数</p><p>又根据那个结论，所以 n - r = m - r 个锤子哟，零空间和左零空间的关系<strong>不是</strong>列和行这样作为一个矩阵的两面噢！</p><p>先看求行空间的基</p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210414094758222.png" alt="image-20210414094758222" style="zoom:50%;" /><p>这进行了行变换之后，<strong>列空间变化了！</strong>行空间没变，基发生了变化。</p><p><strong>所以基是R的前r行</strong>，因为是单位阵，所以还是<strong>最佳</strong>的基。</p><p>因为R 执行逆运算 可以得到A，所以A行确实是R行的线性组合</p><hr><p>左零</p><p>为了运用之前的方法，用A来代替AT，转置后，yT到左边去了</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414095528916.png" alt="image-20210414095528916" style="zoom: 33%;" /><p>但是老师还是习惯用 AT * y = 0来做</p><p>那怎么求它的基呢，直觉告诉。。。<strong>秘密藏在把A -&gt; R 的过程里</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414100050545.png" alt="image-20210414100050545" style="zoom:50%;" /><p>同样也是高斯 - jordan，E记录了A -&gt; R 的过程</p><p>所以相当于左边乘了一个 E  即  EA = R   EI = E ，当时(chapter2)是个方阵R = I ， 所以E是A的逆</p><p>但是现在 A 不可逆， 但 E 仍能描述很多特性，<strong>先算E</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414125257549.png" alt="image-20210414125257549" style="zoom:50%;" /><p>此处左零空间应该是一维的因为  m -r = 3 - 2 = 1</p><p>即存在一个线性组合使得A这三行结果为0，这个线性组合可以确定左零空间的基。</p><p>因此尝试着找一个能产生零行向量的行组合。此处就是E的最后一行，因为R的最后一行就是该行对A中行向量的线性组合，而结果为0，卧槽！！！所以左零的基就是这些使得R中出现0行的行，牛啊！！</p><p><strong>这样不用把矩阵转置然后从头开始计算。</strong></p><hr><p>新的向量空间：所有的 3 x 3矩阵，把每个矩阵看成一个”向量”</p><p>矩阵可以相加，数乘，也有”零向量”，所以满足向量空间的条件，暂时不考虑乘法！</p><p>用M表示所有3x3矩阵组成的矩阵空间。</p><p>则每个位置放1，其他置0，便可作为所谓的”基“，然后又有上三角和对称矩阵这俩子空间的交是对角矩阵。</p><p>反正就是这种思想，把Rn推广到Rn*n</p><h2 id="11-矩阵空间，秩一矩阵，小世界图"><a href="#11-矩阵空间，秩一矩阵，小世界图" class="headerlink" title="11.矩阵空间，秩一矩阵，小世界图"></a>11.矩阵空间，秩一矩阵，小世界图</h2><p>接着上面的问题，我们不考虑矩阵乘法，因为向量空间仅仅考虑矩阵相加和数乘</p><p>M的基就是9个不同的秩一矩阵</p><p>交集很明显，就是同属两边的向量的组合，如上三角 U 和对称矩阵 S 这俩子空间的交是对角矩阵。</p><p>而并集不是一个子空间，所以我们用 S + U 来描述他们的和而不是并集。</p><p>这代表任取S中的一个元素，再加上U中的任意一个元素，这会得到全部，也就是M的基</p><p><strong>这里 dim S + dim U = 6 + 6    dim(S+U) = 9  dim(S∪U）=3</strong></p><p><strong>前者相加 等于后者相加！</strong>画个韦恩图。。这是显然的结论，重叠了3个（类似鸽笼原理吗）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414232350750.png" alt="image-20210414232350750" style="zoom: 50%;" /><p>然后看看微分方程里的类似思想</p><p><strong>要知道线性微分方程里一个重要内容就是寻找解空间的一组基</strong></p><p>这里的基不像方向，而是函数，但是这样的线性思想是通用的。</p><hr><p>秩一矩阵都可以表示为一列乘以一行</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414233317891.png" alt="image-20210414233317891" style="zoom: 50%;" /><p>它就像积木一样</p><p>比如秩为n的矩阵，他就需要n个秩一矩阵来构建</p><p>这里提出了一个问题 M = all 5 x 17 matrics   那么一个由秩四矩阵构成的子集是子空间吗？</p><p>显然不是，因为两个秩四矩阵相加都不一定是秩四矩阵，5维里面挑四维，可能相同，也可能变成五维的空间，这里很好理解，但不好表述。。感觉像是一种排列的关系。</p><p><strong>而秩一矩阵也是这样的原理，它不是子空间。</strong></p><p>一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414234947572.png" alt="image-20210414234947572"></p><p>根据这个条件，如何描述出S的维数？首先得找到一组基</p><p>因为[1 1 1 1] [v1 v2 v3 v4]` = 0  所以这个S其实是一个零空间，然后用Ax = 0去研究四个子空间就好了</p><hr><p>小世界图：</p><p>图论和线性代数。。。Graph</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414235251527.png" alt="image-20210414235251527" style="zoom:33%;" /><p>如果用点代表一个人，线代表两者认识，那么美国1个人认识另一个人的最远距离是？</p><p>六度分离猜想，大约6步，“小世界”哈哈</p><h2 id="12-图和网络"><a href="#12-图和网络" class="headerlink" title="12.图和网络"></a>12.图和网络</h2><p>这节课专注于线代的应用</p><p>而真正需要人们处理的矩阵来源于生活中的各种问题</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414235738751.png" alt="image-20210414235738751" style="zoom:50%;" /><p>今天来探讨图，这是非常重要的应用数学概念，也是矩阵的发源之一</p><p>Nodes and Edges 节点和边</p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210414235940380.png" alt="image-20210414235940380" style="zoom:50%;" /><p>这些是有向线段来区别方向，它将用 potential电势 potential difference 电势差 currents 电流等词汇</p><p>当然这只是一个例子，图能表示各种现实意义上的，我们称这个矩阵为关联矩阵 incidence matrix</p><p>m x n 的矩阵  在第一条边上是节点1到2 所以 1号位为 -1，2号位为 1</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415000303262.png" alt="image-20210415000303262" style="zoom: 80%;" /><p>这个子图被称为loop（回路），对图来说，回路的数量和位置至关重要，回路意味着“相关”</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415000656107.png" alt="image-20210415000656107" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415000709211.png" alt="image-20210415000709211" style="zoom:50%;" /><p>现在提问题：(这是一个非常稀疏的矩阵，一行只有俩非零)</p><p>零空间是啥，这里仍研究Ax = 0</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415001052557.png" alt="image-20210415001052557" style="zoom:50%;" /><p>所以A所进行的组合相当于计算每条边上的差值。</p><p>如果把 x = x1 x2 x3 x4 作为各个节点的电势，</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415001208855.png" alt="image-20210415001208855" style="zoom:50%;" /><p>将会得到电势差，牛逼啊！！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415001316165.png" alt="image-20210415001316165" style="zoom:50%;" /><p>乘以一个常数C得C x [1 1 1 1]` 就是整个零空间，维数为1，这个零空间意味着结点电势都是由一个常数C决定。矩阵的秩为3</p><p>这样的可以任意选取，但是有意义的C在现实生活中十分广泛，比如微积分的常量C。</p><p>那么这里的Ax * C就是物理意义上的电流。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415103146096.png" alt="image-20210415103146096" style="zoom: 33%;" /><p>这个数值是电导，而不是电阻噢</p><p>再研究AT y = 0 <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415103013929.png" alt="image-20210415103013929" style="zoom:33%;" /></p><p>显然。。m - r = 2维</p><p>回到原来的。</p><p>这个时候他指出，ATy = 0是👇，也是平衡方程，守恒定律，但是并没有解释为什么。淦。我是这样理解，之前的A每列代表一个节点与各边的关系，Ax = 0 解的是<strong>节点</strong>间的关系，而这个关系体现为电势。这里A转置的列代表一条边，ATy = 0 找的是<strong>边</strong>之间的关系，这个关系体现为电流！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415103440461.png" alt="image-20210415103440461" style="zoom:33%;" /><p>列出以后，AT 对y向量(电流)的组合方程组就是基尔霍夫方程组</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415103817906.png" alt="image-20210415103817906" style="zoom: 25%;" /><p>现在回到线性代数，如何求AT的零向量(左零空间)，也就是求两个特定的y</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415104203613.png" alt="image-20210415104203613" style="zoom:33%;" /><p>他通过研究每个小回路，由回路不积累电流，一直流通的意义得到线性无关的两个y，而大回路则是这俩小回路得出的y的和</p><p>还要研究行空间（列向量代表边），r = 3 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415104424526.png" alt="image-20210415104424526" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415104453122.png" alt="image-20210415104453122" style="zoom:50%;" /><p>这些描粗的边与各主列相对应，这一小部分——没有回路。相关性均来自回路，<strong>没有回路的图叫做”树”(tree)</strong></p><p>再根据四个子空间的性质推导：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415104754834.png" alt="image-20210415104754834" style="zoom: 25%;" /><p>因为零向量必为[11111…..]`只有一维，所以r = n -1</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415104939049.png" alt="image-20210415104939049" style="zoom:50%;" /><p><strong>结点 - 边长 + 回路数 = 1  这就是欧拉公式，任何图中都具有的一种拓扑性质</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415105217496.png" alt="image-20210415105217496" style="zoom:50%;" /><p>但是这里没考虑外部电源的影响</p><p>如果加入电压源，则加入最左边那一条，电流源则ATy = f</p><p>梳理一下：</p><p>矩阵A是一切的开始，Ax得到电势差，然后再乘以一个物理常量C得CAx = y  </p><p>再用AT乘以y = f 所以 <strong>AT*C*Ax = f</strong></p><p>而AT * A总是对称的，重新理解一遍大概懂了</p><h2 id="13-复习一"><a href="#13-复习一" class="headerlink" title="13.复习一"></a>13.复习一</h2><p>算了。。忍住了跳过的欲望，反正是思修课</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415112435261.png" alt="image-20210415112435261" style="zoom:50%;" /><p>因为b和x都是3维的，所以矩阵A = 3x3 ，别忘了格式。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415113438382.png" alt="image-20210415113438382" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415113619522.png" alt="image-20210415113619522" style="zoom:33%;" /><p>B是 3x4的，N(B) ∈ R4    左矩阵可逆，这里有个结论：可逆矩阵不影响所乘的矩阵的零空间。</p><p>假设 Bx =0  A可逆  那么ABx=0</p><p>这里的秩一看就是2，所以令3，4这俩自由列分别对应的变量赋值为1，另一个为0，算出基。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415114513006.png" alt="image-20210415114513006" style="zoom:50%;" /><p>A和 -A有相同的四个子空间</p><p>如果A 和 B有相同的四个子空间，那么A是B的倍数</p><p>所有满秩方阵都可以。显然是错的</p><p>交换矩阵的两行，行空间和零空间没变，其他的变了</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415120710838.png" alt="image-20210415120710838" style="zoom:50%;" /><p>好问题！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415120818364.png" alt="image-20210415120818364" style="zoom:50%;" /><p><strong>行空间和零空间的交集只有零向量！</strong>列空间同理，他们是正交的</p><h2 id="14-正交向量与子空间"><a href="#14-正交向量与子空间" class="headerlink" title="14.正交向量与子空间"></a>14.正交向量与子空间</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415151139335.png" alt="image-20210415151139335" style="zoom:50%;" /><p>这个图的性质很明显。两组正交关系</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415151310235.png" alt="image-20210415151310235" style="zoom:50%;" /><p>正交的向量：</p><p>这意味着两个向量锤子，夹角为90°</p><p>也是用点乘来定义：👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415151457618.png" alt="image-20210415151457618" style="zoom:33%;" /><p>得到一个<strong>向量长度的平方 xT * x</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415151955142.png" alt="image-20210415151955142" style="zoom: 25%;" /><p>对于正交的向量  ||x|| 2  +   ||y||2   =  ||x+y||2</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415152111503.png" alt="image-20210415152111503" style="zoom:33%;" /><p>如果一个是0向量，另一个就任意了，结果总是0</p><hr><p>推广到正交子空间：</p><p>S和T子空间正交，意味着任何位于两者中的向量与另一者的全部向量正交。</p><p>且它们一定不会拥有某个公共的非零向量</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415154204699.png" alt="image-20210415154204699" style="zoom:50%;" /><p><strong>这个等式说明行空间的所有基底都与 x 正交</strong></p><p>很好验证，他们的线性组合，即整个行空间的所有向量，都与x正交。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415155952963.png" alt="image-20210415155952963" style="zoom:50%;" /><p>零空间包含所有垂直行空间的向量</p><hr><p><strong>如何求一个无解的Ax = b 的 “解”</strong></p><p>比如当m &gt; n时大部分情况是无解的，情景引入：</p><p>一个卫星经过，测量位置，你测量了1000次，或为体检者测量频率。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415160341547.png" alt="image-20210415160341547" style="zoom:50%;" /><p>于是Ax = b解不出来了</p><p>去掉坏数据是不现实的，根本没有判断依据。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415160501205.png" alt="image-20210415160501205"></p><p>这样会得到完整的信息。</p><hr><p><strong>至关重要的矩阵——ATA</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415160657584.png" alt="image-20210415160657584" style="zoom:50%;" /><p>当我们遇到坏矩阵时，可以通过左乘逆来处理</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415160747586.png" alt="image-20210415160747586" style="zoom:50%;" /><p>当然，上下两个x是不一样的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415160924180.png" alt="image-20210415160924180" style="zoom: 33%;" /><p><strong>ATA并不总是可逆的！</strong></p><p>当且仅当A的各列线性无关时，ATA是可逆的，下节课至关重要！</p><h2 id="15-子空间投影"><a href="#15-子空间投影" class="headerlink" title="15.子空间投影"></a>15.子空间投影</h2><p>非常重要，名留青史</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415211634652.png" alt="image-20210415211634652" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415211808092.png" alt="image-20210415211808092" style="zoom:50%;" /><p>p是b在a上的投影，e是b和p间的误差，如果引入角度，会导出很复杂的公式，p在a的子空间内，我们要找的就是那个x使得p = xa  关键是垂直a垂直于e</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415211946824.png" alt="image-20210415211946824" style="zoom:67%;" /><p>导出两个关键式子：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415212128075.png" alt="image-20210415212128075" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415212149485.png" alt="image-20210415212149485" style="zoom:80%;" /></p><p>如果b翻倍，则p翻倍，如果a翻倍无影响，因为分子和分母的倍数抵消了</p><p>这里上升到线代的高度，投影是由矩阵完成的，这个矩阵作用于b得到投影p，设为P👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415212451637.png" alt="image-20210415212451637" style="zoom:50%;" /> <p>现在研究这个矩阵的性质</p><p><strong>列空间的作用：你用任何向量b乘以这个矩阵，总会落到列空间里</strong>，b对列进行线性组合嘛。。当然</p><p>那么Pb = p，落到了这条线上，此处为a那条线，只有一维</p><p>还有这个矩阵是对称的，如果投影两次，第二次没有作用，所以P平方 = P</p><p>请记住x 和 p 和 P的三个公式</p><hr><p>why project？为什么要投影</p><p>因为Ax = b 可能无解，只能求解最接近的。而Ax总是在列空间里，但b不一定在，所以微调b成p</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415213158197.png" alt="image-20210415213158197" style="zoom:50%;" /><p>现在研究三维：</p><p>找一个向量b投影到平面的漂亮公式，设平面的一组基为  a1 a2 ，这个平面是[a1 a2] 的列空间</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415213351976.png" alt="image-20210415213351976" style="zoom:50%;" /><p>仍然引进e = b-p 垂直于平面</p><p>p = x1a1 + x2a2 写成p = Ax(帽)我们的任务是寻找合适的列组合，让误差e垂直于这个平面，也垂直于俩基</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415213719636.png" alt="image-20210415213719636" style="zoom:50%;" /><p>如果换成一个矩阵形式，</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415213838851.png" alt="image-20210415213838851" style="zoom: 33%;" /><p>这与之前的二维的方程非常像，因为之前的A是一维的，写成一个a向量而已。</p><p>由方程得出e在左零空间里，然后又由左零和列空间的正交关系得：e垂直于A的列空间</p><p>仍按当时解方程的步骤继续:</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415214223925.png" alt="image-20210415214223925" style="zoom: 33%;" /><p>当时的aTa是一个数字，现在是一个n*n的矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415214410254.png" alt="image-20210415214410254" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415214607486.png" alt="image-20210415214607486" style="zoom:25%;" /><p>hahh,好坑啊，不能直接化为 I，如果是可逆方阵，它的列空间为整个n维空间，自然</p><p>经验证，另外两个性质仍然是成立的哈哈。</p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415215717027.png" alt="image-20210415215717027" style="zoom:50%;" /><p>通过最小二乘法拟合一条直线</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415220041277.png" alt="image-20210415220041277"></p><p>3个点，产生了3处误差，列出矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415220211668.png" alt="image-20210415220211668" style="zoom:50%;" /><p>下节课求解哈哈</p><h2 id="16-投影矩阵和最小二乘"><a href="#16-投影矩阵和最小二乘" class="headerlink" title="16.投影矩阵和最小二乘"></a>16.投影矩阵和最小二乘</h2><p>当b投影到平面A的时候两个极端：</p><ol><li>b如果直接就在列空间里，Pb = b</li><li>b如果垂直于列空间，则Pb = 0</li></ol><p>那么其实Pb的作用是保留第一条的部分，去除第二条的部分（分运动呗。）</p><p>在A列空间里的b可以表现为Ax，这个结论用的很多。。也很好理解</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416151113284.png" alt="image-20210416151113284" style="zoom: 50%;" /><p>那么把b投影到列和左零空间（<strong>图一</strong>）：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416151251339.png" alt="image-20210416151251339" style="zoom:50%;" /><p>显然，由性质理解一下，也是容易证明的结论，p和e的平方等于本身</p><p>而只要有了A，就能导出P，就能得出p 和 e</p><hr><p>继续数学问题：</p><p>首先要定义并最小化“误差”的概念，然后用最小二乘（拥有最小平方和的解）</p><p>这里的“误差”是Ax - b，就是e，当然要取其长度。得了解两幅图</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416152236280.png" alt="image-20210416152236280" style="zoom:33%;" /><p>这里其实就是线性回归分析，统计学中并不对“离群值”进行处理，因为那很可能是错误的值。</p><p>而线性回归容易受到离群值的影响，当然他仍然很常用。然后用bpe来表示，<strong>图二：</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416152609502.png" alt="image-20210416152609502" style="zoom: 33%;" /><p>p是用来代替b的，它们是列的组合，是最接近的组合。那接下来解一下<strong>ATAx = ATb</strong></p><p>代入A和b，都是已知的，利用公式得到x(此处为[C D])</p><p>含C 和 D 的方程组称为正规方程组。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416162119769.png" alt="image-20210416162119769" style="zoom:33%;" /><p>没想到啊，竟然两种方法都能得到这个方程。(求偏导和线性)</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416153511992.png" alt="image-20210416153511992" style="zoom:50%;" /><p>然后就能写出新的方程最优直线y，由此解出p和e来，<strong>而且对应的p+e = b</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416153909050.png" alt="image-20210416153909050" style="zoom:33%;" /><p>当然e垂直于整个列空间，包括p在内，请记住图一和图二，C和D在图二代表那条直线，而在第一张图却并没有出现，<strong>但他们的线性组合就是p</strong></p><p>这样就完成了最小二乘法</p><hr><p>14课末尾的疑问：</p><p>当且仅当A的各列线性无关时，则ATA是可逆的，这是最小二乘法成立的大前提。</p><p>假设ATAx = 0 并且ATA是可逆的，可以推出x只有零解。这里有个我们学的诡异技巧。。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416155411342.png" alt="image-20210416155411342" style="zoom:50%;" /><p>这就证明了Ax = 0，又A列向量无关，所以x所在的零空间只有零向量，所以ATA可逆。</p><hr><p>提出一种情况：</p><p>互相垂直的向量必然线性无关，排除0向量，引入术语：正交，标准正交向量组</p><h2 id="17-正交矩阵和Gram-Schmidt正交化"><a href="#17-正交矩阵和Gram-Schmidt正交化" class="headerlink" title="17.正交矩阵和Gram-Schmidt正交化"></a>17.正交矩阵和Gram-Schmidt正交化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;为了学机器学习，重拾已经快忘干净的线代，接着上学期看的MIT，从头开始看起，没有考试的压力，单纯的探索线代世界，实在是太快乐了！而从中发现的</summary>
      
    
    
    
    <category term="math" scheme="http://example.com/categories/math/"/>
    
    
    <category term="线代" scheme="http://example.com/tags/%E7%BA%BF%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>data-analyze</title>
    <link href="http://example.com/2021/04/10/data-analyze/"/>
    <id>http://example.com/2021/04/10/data-analyze/</id>
    <published>2021-04-10T11:23:24.000Z</published>
    <updated>2021-04-10T11:26:50.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python-data" scheme="http://example.com/tags/python-data/"/>
    
  </entry>
  
  <entry>
    <title>统计</title>
    <link href="http://example.com/2021/04/10/%E7%BB%9F%E8%AE%A1/"/>
    <id>http://example.com/2021/04/10/%E7%BB%9F%E8%AE%A1/</id>
    <published>2021-04-10T09:30:55.000Z</published>
    <updated>2021-04-20T03:46:45.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述性统计"><a href="#描述性统计" class="headerlink" title="描述性统计"></a>描述性统计</h1><h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h1><p>当这门课完结的时，将会掌握对数据集进行收集，整理，计算和可视化的所需要工具</p><p>创建一个谷歌账户</p><h2 id="BBC记忆测试"><a href="#BBC记忆测试" class="headerlink" title="BBC记忆测试"></a>BBC记忆测试</h2><p>这个例子目前已经被取消了</p><p>可惜，BBC 已经不再提供人脸记忆测试了。</p><p>下面是此测试的简单描述，以帮助你跟上课程其余部分。该测试包含三个部分：</p><ol><li>在第一部分向用户展示 12 张照片。</li><li>在第二部分向用户展示另外 12 张照片。</li><li>在第三部分向用户展示 48 张照片，并询问他们是否在第一部分/第二部分见过每一张照片或在这两个部分都没见过。</li></ol><p>测试之后，用户会得到两个分数：</p><ul><li>“识别得分”，用户正确猜出某张人脸他是否见过的比例，不论用户看到的是人脸的哪个部分。</li><li>“短期记忆得分”，用户正确猜出某张人脸属于第一部分还是第二部分的比例。</li></ul><p>测试建议用户在完成第一部分，开始第二部分前休息5分钟。</p><p>BBC 是如何测量记忆的？</p><ul><li>你记住了哪些面孔？</li><li>你从第一部分和第二部分正确识别和放置的百分比？</li><li>你是否知道你是第一次还是第二次见到某个面孔？</li><li>你是否知道某个面孔已存在？</li><li>你记住的面孔数量？</li></ul><p>答案是百分比。</p><p>当选取了一种度量方法，也有了一种可操作的定义，此处为正确识别的百分比</p><p>抽象概念很难定义和度量</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410194240953.png" alt="image-20210410194240953"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410194335563.png" alt="image-20210410194335563"></p><p>我们必须仔细思考如何定义和度量“构建”</p><p>我们给出的构建的描述，让我们可以直接测量这个构建</p><p><strong>这样的描述被称为 可操作 的定义</strong></p><p>然后我们假设并分析了影响记忆的因素！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410195157781.png" alt="image-20210410195157781"></p><p>当更多的因素为常量时，我们更加相信结果</p><h2 id="思考样本"><a href="#思考样本" class="headerlink" title="思考样本"></a>思考样本</h2><p>当比较所有参与测试的人员（大样本）和其中的学生时（小样本）</p><p>总体<strong>参数</strong>（如 mu 或 \mu）是用来描述整个总体的值。</p><p>样本<strong>统计量</strong>（如 X-bar 或 \bar x<em>x</em>¯）是用来描述<strong>样本的值</strong>；我们使用统计量来估计总体参数。<strong>估计值是我们对总体参数的最佳猜测</strong>。所以，我们可以使用 X-bar 来<strong>估计</strong> mu。</p><p>而二者的区别叫做抽样误差。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410195644531.png" alt="image-20210410195644531"></p><p>样本越大越优质，越随机越优质</p><p>我们通过数据可视化（此处表格转化成图表）发现其中可能蕴藏的规律，但别忘了隐藏的因素</p><p>即使表现出了明显的规律，但我们无法确认原因</p><h2 id="金拱门理论"><a href="#金拱门理论" class="headerlink" title="金拱门理论"></a>金拱门理论</h2><p>记住：Correlation does not prove causation  （相关并不代表因果）</p><p>这是个非常重要的概念</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410200633367.png" alt="image-20210410200633367"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410200901278.png" alt="image-20210410200901278"></p><p>所以即使表现出了明显的规律，但我们无法确认原因。</p><p>如果我们想要显示因果关系，即某个特定因素导致了另一个因素，我们要开展 <strong>对照试验</strong></p><h3 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a><strong>Survey</strong></h3><ul><li>它是了解总体的最简单方式之一</li><li>相对来说成本较低</li><li>可以远程进行</li><li>任何人都可以访问并分析调查结果</li></ul><p>不足</p><ul><li>不真实的回答      –可能是心理原因或者啥</li><li>有偏见的回答        –环境，教育等因素的影响</li><li>参与者没理解问题的意思     –这得出的答案叫做<strong>应答偏差</strong></li><li>参与者拒绝回答       –某个群体因为某些原因拒绝回答，带来<strong>无应答偏差</strong></li></ul><p>还记得同一个属性有很多种衡量方法，我们在问卷里要尽量采用主观衡量的方法，</p><p>仔细斟酌调查问卷并认真措辞</p><h3 id="对照试验"><a href="#对照试验" class="headerlink" title="对照试验"></a>对照试验</h3><h4 id="单盲"><a href="#单盲" class="headerlink" title="单盲"></a>单盲</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410202316929.png" alt="image-20210410202316929"></p><p>不告诉它们情况的目的是控制主观带来的相当大的偏差，这称为blinding(盲法)</p><p>这常用于主观影响行为时，这种无效药丸叫做安慰剂</p><p>但是知情同意书会说明参与者可能会进入对照组。。不如不说</p><h4 id="双盲"><a href="#双盲" class="headerlink" title="双盲"></a>双盲</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410202949583.png" alt="image-20210410202949583"></p><p>随机性非常重要，而更大的样本更容易实现随机性</p><p>顺便附上一个<a href="https://www.kqed.org/mindshift/26079/why-sleeping-may-be-more-important-than-studying">睡眠调查</a></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410203510980.png" alt="image-20210410203510980"></p><p>答案是C</p><h2 id="基础习题"><a href="#基础习题" class="headerlink" title="基础习题"></a>基础习题</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410204407058.png" alt="image-20210410204407058"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410204413964.png" alt="image-20210410204413964"></p><p>选取样本，研究总体，呈现的特征是统计量，</p><p>简单来说，参数与总体对应在一起，统计量与样本对应在一起。参数往往是未知的，所以才要通过抽样调查的方法来估计，根据样本算出统计量。统计量就是用来估计参数的。这跟原来的意思不搭边啊。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410204850957.png" alt="image-20210410204850957"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410204858044.png" alt="image-20210410204858044"></p><p><strong>样本和总体平均值之间的差异称为抽样误差。。sampling error</strong></p><p><strong>Population differences are differences between different populations</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410205312486.png" alt="image-20210410205312486"></p><p>答案3，5，6</p><p><strong>变量是指参加研究的个体间可能不同的量。。</strong></p><p>hypothesis  假设</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410210156556.png" alt="image-20210410210156556"></p><p>答案1，2，4，5</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410210317870.png" alt="image-20210410210317870"></p><p>3，4</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410210412280.png" alt="image-20210410210412280"></p><p>4，5</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410213243525.png" alt="image-20210410213243525"></p><p><strong>1，6，7我们不能下结论，但是可以合理预测</strong></p><p>independent  自变量</p><p>dependent  因变量</p><p>lurking  潜伏变量</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410213701731.png" alt="image-20210410213701731"></p><p>答案是3，5，6</p><p>第一项错的，因为这个<strong>实验性研究</strong>不像<strong>观察性研究</strong>，已经足够缩小无关变量的影响，我们得出结论是合理的</p><p>第四项是干扰，我们得出治疗成果的操作其实是根据它们之间的差值，而不是分数</p><h2 id="进阶习题"><a href="#进阶习题" class="headerlink" title="进阶习题"></a>进阶习题</h2><p>用n代表样本大小</p><p>construct （抽象概念）是不可被直接观察和测量的变量</p><p>你每天走的距离是construct  但如果指定按米测量，它就不是</p><p>从少数样本的研究得出的现象不能说明任何问题：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410215056385.png" alt="image-20210410215056385"></p><h1 id="2-集中趋势"><a href="#2-集中趋势" class="headerlink" title="2.集中趋势"></a>2.集中趋势</h1><h2 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h2><p>绝对数量（频率）和相对频率（百分比）</p><p>通过整理数据，我们可以清晰地观察变化</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411184322489.png" alt="image-20210411184322489"></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411184838387.png" alt="image-20210411184838387"></p><p>组距 = 区间大小</p><p>percentage百分比 != porpation比例</p><p>简便性有失会牺牲一些信息</p><p>小心信息被过大的组距隐藏起来了</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411185724576.png" alt="image-20210411185724576"></p><p>直方图横坐标是同一属性的分布，可以改变组距，而且有顺序</p><p>柱状图的不同柱子是相互独立的，顺序不重要，分类或定性的</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411190847179.png" alt="image-20210411190847179"></p><p>正偏斜分布</p><p>频率低的分布在右边</p><p>Excel的一些小操作，c和s键，函数公式里，$E$2是常量E2</p><hr><p>这些都是x轴上的自变量</p><p>众数mode   直方图里用最大区间的中位数，受组距影响，与呈现数据的方式有很大关系</p><p>均匀分布没有众数，但是多峰分布由多个众数</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411194036544.png" alt="image-20210411194036544"></p><p>第一个对的</p><hr><p>中位数median</p><p>用之前要排序噢</p><p>处理高偏斜分布时中位数更可信</p><hr><p>平均数average</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210411194453701.png" alt="image-20210411194453701"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411195527966.png" alt="image-20210411195527966"></p><p>全是对的</p><p>robust 强大且稳定  符合统计的定义</p><p>使用这三个数都是中心测量方法，因为他们都描述分布中心的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411200914056.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411204640630.png" alt="image-20210411204640630"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411204952662.png" alt="image-20210411204952662"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411205002462.png" alt="image-20210411205002462"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/4938065-f641e015cbe17d86" alt="img"></p><p>平均数和中位数本来一样，但是平均数被稀少的数据拉过去了</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210411211835965.png" alt="image-20210411211835965"></p><p>所以注意自变量和因变量是谁，此处分数为自变量，人数为因变量，直方图的自变量是均匀的</p><h1 id="3-可变性"><a href="#3-可变性" class="headerlink" title="3.可变性"></a>3.可变性</h1><h2 id="IQR"><a href="#IQR" class="headerlink" title="IQR"></a>IQR</h2><p>值域提供了一个关于分布的概要信息，但是方便会牺牲一些东西</p><p>因为它参考的是最极端的数据，受到异常数据影响很大</p><p>习惯上，统计学家忽略较低和较高的各25%！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412234924656.png" alt="image-20210412234924656"></p><p>Q1  Q2  Q3   Q1和Q3间是<strong>四分位距/四分差</strong>IQR Interquartile range</p><h3 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h3><p>定义：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412235434276.png" alt="image-20210412235434276"></p><h3 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a><strong>箱线图</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210412235721975.png" alt="image-20210412235721975"></p><p>小点表示异常数据</p><p>均值不一定在IQR中</p><p><strong>不足</strong></p><p>值域和IQR无法考虑所有数据</p><p>完全不同的俩数据分布也可以有相同的IQR</p><p>因此我们需要一个数字，既能显示分布，又能考虑所有的数据</p><p>我们找的是找出每个值与数据集均值之间差的平均值</p><h2 id="平均偏差"><a href="#平均偏差" class="headerlink" title="平均偏差"></a>平均偏差</h2><p>离均差是某个数据减去平均值</p><p>平均偏差 = 离均差之合/n  = 0<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413000641459.png" alt="image-20210413000641459"></p><p>但这并不能反映甚么，问题是负值会抵消，我们不关心正负，我们只关心绝对距离！平方和取绝对值就可以处理负数。</p><p>引入绝对偏差对应离均差</p><p>平均绝对偏差对应平均偏差</p><p>平方偏差和平均平方偏差（方差）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413001254455.png" alt="image-20210413001254455"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413001417511.png" alt="image-20210413001417511"></p><p>方差可以看成那个橙色的，而标准差即为边长。</p><p>标准差是最常用的分布测量方法，小写西格玛</p><p>步骤：平均值-&gt;离均差（平均差）-&gt;每个偏差的平方值-&gt;方差-&gt;标准差</p><hr><p>思考：</p><p>为何不直接获得平均绝对偏差。</p><p>它具有重要意义，比如正态分布中，68% 和 95%是一个和两个</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413094303444.png" alt="image-20210413094303444"></p><p>所选样本的标准偏差</p><h3 id="贝塞尔矫正"><a href="#贝塞尔矫正" class="headerlink" title="贝塞尔矫正"></a>贝塞尔矫正</h3><p>通常，抽样中会低估了总体中差异性的数量</p><p>因为抽样往往是总体居于中间的值，用贝塞尔矫正系数，来矫正</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413100446583.png" alt="image-20210413100446583"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210413101551728.png" alt="image-20210413101551728"></p><p>如果用n，那就是样本的标准差</p><p>如果用n-1，那就是对真实的总体标准差更准确的估算</p><p>具体理论没讲</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h1 id="4-归一化"><a href="#4-归一化" class="headerlink" title="4.归一化"></a>4.归一化</h1><p>你已经了解了分析图表的四个值，分布，那么还有什么需要分析的呢？</p><p>象棋：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414131710341.png" alt="image-20210414131710341" style="zoom: 50%;" /><p>第一个不直观，大家不了解，第二个只知道多少人高，不知道有多少人参加</p><h2 id="绝对和相对"><a href="#绝对和相对" class="headerlink" title="绝对和相对"></a>绝对和相对</h2><p>当我们关心的是比例以及和其它元素的关系时，使用相对频率</p><p>相对频率直方图</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414131958647.png" alt="image-20210414131958647"></p><p>形状几乎一样</p><p>但对于这个图，我们无法说出190-200的比例，这些信息被隐藏起来了</p><p>可以通过减小组距来显示这些信息，看看减小组距会发生怎样的现象</p><p><video class="vjs-tech" id="vjs_video_3_html5_api" tabindex="-1" role="application" crossorigin="anonymous" src="https://s3.cn-north-1.amazonaws.com.cn/u-vid-hd/9ftDJRsfEUI.mp4"></video></p><p>如果再减小时，分布图的形状就会变得松散起来</p><p>问题出现了：</p><p><strong>组距太小，我们会丢失分布图的形状，太大会有信息被隐藏起来</strong></p><p>解决方法是采用连续分布</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414132617168.png" alt="image-20210414132617168" style="zoom:50%;" /><p>答案是1</p><h2 id="理论正态分布"><a href="#理论正态分布" class="headerlink" title="理论正态分布"></a>理论正态分布</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414132718010.png" alt="image-20210414132718010" style="zoom:33%;" /><p>而众数，中位数，平均数相等</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210414132753312.png" alt="image-20210414132753312"></p><p><strong>Z</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415130123307.png" alt="image-20210415130123307"></p><p>就可以知道小于或大于该值的百分比</p><p>确认比例不能通过数字，得通过多少z，这个视频有一步是讲两个图进行“标准化”</p><p><video class="vjs-tech" id="vjs_video_22416_html5_api" tabindex="-1" role="application" crossorigin="anonymous" src="https://s3.cn-north-1.amazonaws.com.cn/u-vid-hd/W5qXCZ-nrHM.mp4"></video></p><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415130950473.png" alt="image-20210415130950473" style="zoom:50%;" /><p>即将正态分布中的任何值转换为z值</p><p>z为负数说明x在 μ的左边，σ是标准偏差</p><p>归一化后，平均值则为0，新标准偏差为1</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415131521357.png" alt="image-20210415131521357"></p><p>对于任何正态分布：</p><ol><li>减去平均值</li><li>平移到0</li><li>除以标准偏差，使新的标准偏差为0</li></ol><p>则成为了一个<strong>标准正态分布</strong>。现在数据集中的每个值都用距离平均值的标准偏差表示</p><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><p>我们可以把任何正态分布转换为标准正态分布，然后按照任何方式拓展</p><p>它们之间的桥梁是 Z</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415132218585.png" alt="image-20210415132218585" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415132405152.png" alt="image-20210415132405152"></p><h1 id="5-正态分布"><a href="#5-正态分布" class="headerlink" title="5.正态分布"></a>5.正态分布</h1><h2 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210419230030983.png" alt="image-20210419230030983" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210419230926414.png" alt="image-20210419230926414" style="zoom: 67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210419231612242.png" alt="image-20210419231612242"></p><h2 id="Z表格"><a href="#Z表格" class="headerlink" title="Z表格"></a>Z表格</h2><p>用微积分可以计算任意处的比例，而这被做成了一张表格</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/ZTable.jpg" style="zoom:33%;" /><h1 id="6-抽样分布"><a href="#6-抽样分布" class="headerlink" title="6.抽样分布"></a>6.抽样分布</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210419235247878.png" alt="image-20210419235247878" style="zoom:50%;" /><h2 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420084731208.png" alt="image-20210420084731208" style="zoom: 33%;" /><p>抽样分布大致满足正态分布</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420084904044.png" alt="image-20210420084904044" style="zoom:33%;" /><h2 id="样本均值"><a href="#样本均值" class="headerlink" title="样本均值"></a>样本均值</h2><p>在比较均值时需要的信息：</p><p><strong>样本均值是正态分布的，所有样本均值的均值就是总体均值</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420085324314.png" alt="image-20210420085324314" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420085536447.png" alt="image-20210420085536447" style="zoom:33%;" /><p><strong>SE是样本均值分布（亦称为抽样分布）的标准偏差</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420084425804.png" alt="image-20210420084425804" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420090002918.png" alt="image-20210420090002918" style="zoom:33%;" /><p>所以SE=σ/√n￣</p><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420090746977.png" alt="image-20210420090746977" style="zoom:50%;" /><p>适用于适用于任意形体，总体可以是任意数量，然后迭代的抽取其中的n个样本并计算出均值</p><p>假设样本量足够大，则画出均值分布图（抽样分布图），是近似正态分布的</p><h2 id="投骰子"><a href="#投骰子" class="headerlink" title="投骰子"></a>投骰子</h2><p>如果只投一次，那么其实就是用原来的总体分布，样本量 = 1，画出来应该是均匀分布</p><p>但是如果每轮投两次，样本量 = 2</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420092512384.png" alt="image-20210420092512384" style="zoom:33%;" /><p>而SE可以用中心极限定理算出来</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420092945271.png" alt="image-20210420092945271" style="zoom: 33%;" /><p>随着样本量的增大，标准误差增大了，而原来默认的是1，我好像有些悟了</p><p>通常我们希望样本量更大，因为标准偏差会告诉我们总体均值更可能落在哪片区域。</p><p>当增大时，标准差变小，区域变窄，更加趋近于那个M，又因为M = μ，就更精确的找到了μ所在的区域</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420093536425.png" alt="image-20210420093536425" style="zoom:50%;" /><p>可以自己<a href="https://onlinestatbook.com/stat_sim/sampling_dist/index.html">尝试</a>一下！不过这里用了贝塞尔矫正</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420093749342.png" alt="image-20210420093749342"></p><h2 id="Klout应用"><a href="#Klout应用" class="headerlink" title="Klout应用"></a>Klout应用</h2><p>计算投掷四面体骰子，平均值至少达到3的概率。</p><p><strong>通过该定理，我们可以知道给定的任意均值会处在样本均值分布的哪个位置</strong></p><p>还可以以此判断该样本是否典型</p><p><a href="http://klout.com/corp/score">Klout</a> 是什么？它的原理是什么？</p><p><video class="vjs-tech" id="vjs_video_402492_html5_api" tabindex="-1" role="application" crossorigin="anonymous" src="https://s3.cn-north-1.amazonaws.com.cn/u-vid-hd/3q0oPuWxFpA.mp4"></video></p><p>平均分低于中位数，很标准的双峰分布</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210420101118057.png" alt="image-20210420101118057"></p><hr><h1 id="推理统计"><a href="#推理统计" class="headerlink" title="推理统计"></a>推理统计</h1><h1 id="1-评估"><a href="#1-评估" class="headerlink" title="1.评估"></a>1.评估</h1><p>Estimation</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;描述性统计&quot;&gt;&lt;a href=&quot;#描述性统计&quot; class=&quot;headerlink&quot; title=&quot;描述性统计&quot;&gt;&lt;/a&gt;描述性统计&lt;/h1&gt;&lt;h1 id=&quot;1-入门&quot;&gt;&lt;a href=&quot;#1-入门&quot; class=&quot;headerlink&quot; title=&quot;1.入门&quot;</summary>
      
    
    
    
    <category term="math" scheme="http://example.com/categories/math/"/>
    
    
    <category term="statistics" scheme="http://example.com/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>crawler</title>
    <link href="http://example.com/2021/04/10/crawler/"/>
    <id>http://example.com/2021/04/10/crawler/</id>
    <published>2021-04-10T08:34:23.000Z</published>
    <updated>2021-04-11T05:01:43.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景和配置"><a href="#背景和配置" class="headerlink" title="背景和配置"></a>背景和配置</h1><p>对大数据的获取，处理和分析，以及基于大数据的智能应用，已成为提高竞争力的关键因素</p><p>我们需要的数据大多源于各个网站，但是不同网站结构不一，布局复杂，渲染方式多样</p><p>有的网站还采取了一系列“反爬”，我们也需要针对的反制措施！</p><p>爬虫是服务机器学习和人工智能发展非常重要的技术！为其提供优质的数据</p><p>崔佬提供了多种安装python库的方式：</p><ul><li>pip/conda</li><li>wheel</li><li>去官网/github下载源码再安装</li></ul><p>爬虫可以简单分为：爬取页面，分析页面，存储数据</p><p><strong>请求库：</strong></p><ol><li><p>requests:  爬取html</p></li><li><p>Selenium  自动化测试，驱动浏览器执行某些（点击，下拉）操作，渗透JS渲染</p><p>但还要配置浏览器，此处用最好的ChromeDriver，先更新chrome</p><p>下载后直接放进环境的Scripts里面，或者单独设置环境变量</p></li><li><p>PhantomJS 无界面，可脚本编程的webkit浏览器引擎，被selenium弃用了，推荐chrome无界面模式</p></li><li><p>aiohttp  提供异步web服务，顺便安装cchardet aiodns</p></li></ol><p>下面装解析库，虽然提取信息方式多样，但写起来麻烦，不如强大的库，库还提供解析</p><p><strong>解析库：</strong></p><ol><li><p>lxml 解析HTML /XML  支持XPath解析方式，且效率非常高</p></li><li><p>beautiful soup 解析HTML /XML，可以很方便的提取数据，有强大的API和多样的解析方式</p></li><li><p>pyquery  提供了和jQuery类似的语法来解析HTML文档，还支持CSS选择器</p></li><li><p>tesserocr  通过OCR对抗验证码，是对<a href="https://github.com/UB-Mannheim/tesseract/wiki">tesseract</a>的再封装，先装后者</p><p>ps:(Optical Character Recognition 光学字符识别)扫描字符并转换成电子文本</p><p>一直失败。。。选择了替代的pytesseract</p></li></ol><p><strong>数据库</strong></p><p>关系型如SQLite  ,<strong>MySQL</strong>  ,Oracle   ,SQL Server  ,DB2     按表存储</p><p>非关系型如 <strong>MongoDB   Redis</strong>    键值对，更灵活</p><ol><li>MySQL  官网</li><li>mongodb懒得装了</li><li>redis还是装一下，还有可视化管理工具redis desktop manager</li></ol><p><strong>存储库</strong></p><p>用来和python交互，MySQL需要PyMySQL,  MongoDB需要PyMongo</p><p>我只下了PyMySQL</p><p><strong>web库</strong></p><p>搭建一些API接口供爬虫使用，比如维护一个代理池</p><ol><li>flask   轻量级web服务程序</li><li>tornado   支持异步的web框架</li></ol><p><strong>APP爬取库</strong></p><p>先不装了。。。</p><p>又是一堆。。。。还跟Android有关</p><p><strong>爬虫框架</strong></p><p>我们直接用requests , selenium等库写爬虫，当小型时很好，但写多了就有些麻烦和凌乱</p><p>上框架！这样我们只用关心爬取逻辑，而不是具体功能的实现！</p><ol><li><strong>pyspider  失败。。。</strong></li><li>Scrapy要配合splash和其python库  成功。。</li><li>scrapy-redius  成功。。</li></ol><p><strong>部署库</strong></p><ol><li><p>Docker  成功</p><p>容器技术，打包应用和环境，极大方便了应用服务的部署，</p></li><li><p>Scrapyd  部署和运行Scrapy的工具，针对linux，那没事了</p></li></ol><p>cao</p><p>没装的有：</p><p>tessorocr 图形识别码,有替代</p><p>mongodb 和配套的，。。希望别用这破玩意</p><p>app 爬取库  。。我吐了</p><p>scrapyd 部署工具。。应该用不着吧</p><p>pyspider bug  。。还早</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景和配置&quot;&gt;&lt;a href=&quot;#背景和配置&quot; class=&quot;headerlink&quot; title=&quot;背景和配置&quot;&gt;&lt;/a&gt;背景和配置&lt;/h1&gt;&lt;p&gt;对大数据的获取，处理和分析，以及基于大数据的智能应用，已成为提高竞争力的关键因素&lt;/p&gt;
&lt;p&gt;我们需要的数据大多源</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="crawler" scheme="http://example.com/tags/crawler/"/>
    
  </entry>
  
  <entry>
    <title>matlab</title>
    <link href="http://example.com/2021/04/06/Matlab/"/>
    <id>http://example.com/2021/04/06/Matlab/</id>
    <published>2021-04-06T12:00:25.000Z</published>
    <updated>2021-04-09T01:24:20.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网教程"><a href="#官网教程" class="headerlink" title="官网教程"></a>官网教程</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>无需声明</li><li>save + filename+ var 保存工作区 (或某些变量)</li><li>clear 清空工作区   clc  清除命令行窗口</li><li>load + filename + var 加载工作区(或某些变量)</li><li>加分号会不输出结果，直接输入变量名会输出变量</li><li>内置了一些常量，pi为Π，虽然显示四位，但内部用高精度存储</li><li>内置了一堆函数，如abs，eig（计算特征值）</li><li>直接转换为虚数，在运算出现时</li><li>format long 切换至高精度显示  format short 默认4位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408110030944.png" alt="image-20210408110030944"></p><p>类似jupyterbook 的模式，可以插入描述，右边可以改变输出显示模式</p><p>点击命令行，会自动高亮输出行</p><p>用section break功能分块，然后单独执行，会在输出中单独实时更改，不会影响其他块</p><p>在layout调布局，可同时使用脚本和命令行！</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>x = [1;3]  空格或逗号分隔组成行向量，用 ; 就是列向量，结合起来可以创建矩阵</p><p>numel(x)  显示x中的元素数目</p><p>用 ：创建等间距向量 ，中间那个指定间距</p><p>如果您知道向量中所需的元素数目（而不是每个元素之间的间距），则可以改用 <code>linspace</code> 函数：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">linspace</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>number_of_elements<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，请使用逗号 (<code>,</code>) 分隔 <code>linspace</code> 函数的输入。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x <span class="token operator">=</span> <span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>x <span class="token operator">=</span>     <span class="token number">0</span>    <span class="token number">0.250</span>    <span class="token number">0.500</span>    <span class="token number">0.750</span>    <span class="token number">1.000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>x’   为转置， x = x’  </p><hr><p>rand(2)  生成2*2随机数矩阵  （0-1）</p><p>rand (m,n)  生成 m*n</p><p>zeros(m,n)</p><p>size(x)  返回x的大小 是一个1x2矩阵，[m n]</p><hr><p>x(2) 索引用的是括号      x(m:n) 提取 m-n</p><p>对多行：x(m,n)提取  x(1,:) 第一行  x(:,3) 第三列</p><p>关键字：end</p><p>矩阵中的单项也允许算术运算，y = A(end-1,end-2)</p><p>如果对矩阵使用单索引，则从上至下遍历每列</p><p>可以用变量当作data的索引</p><hr><p>也可以结合使用冒号运算符</p><p>冒号运算符可以引用某个值范围。以下语法会创建一个包含矩阵 <code>A</code> 的第 1 行、第 2 行和第 3 行所有元素的矩阵。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个是1，而不是0</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>标量+数组，则数组的每一个元素都与该标量相加</p><p>等同大小的数组则可以直接相加</p><p>您可以将数组中的所有元素与某个标量相乘或相除。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">z <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>xy <span class="token operator">=</span> x<span class="token operator">/</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>max 求出最大项，接受两项则第二项为索引值<code>[vMax,ivMax] = max(v2)</code></p><p>round  四舍五入为整数</p><p>矩阵乘法 <code>*</code>   按元素相乘 <code>.*</code></p><p>如果列数为1和非1但是行数相等，也可以按元素乘，每行×对应标量</p><p>size(x)  返回x的大小 是一个1x2矩阵，[m n]，也可以分别接收<code>[dr,dc] = size(data)</code></p><p>如果只需函数的第二个输出，可以使用波浪号字符 (<code>~</code>) 忽略特定输出。[~,ivMax] = max(v2)</p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>可以直接搜索函数哟！！</p><p>每个函数都有完整的支持文档，说明了所有用法</p><p>randi函数好多用法，一次成功！</p><p>第一个参数指定随机整数值  从一到指定数字  </p><p>您也可以使用 <code>doc</code> 函数打开文档。文档名就是函数名</p><h2 id="向量图"><a href="#向量图" class="headerlink" title="向量图"></a>向量图</h2><p>plot(x,y)绘制向量图，横向量和列向量对应项对应坐标</p><p>利用<a href="https://ww2.mathworks.cn/help/matlab/ref/linespec.html">文档</a>修改线条设定，参数任意顺序哟</p><p>使用hold on 命令保留之前的plot留下的痕迹</p><p>hold on 会启用保留模式，hold off 回到默认模式</p><p>当您单独绘制一个向量时，MATLAB 会使用向量值作为 y 轴数据，并将 x 轴数据的范围设置为从 <code>1</code> 到 <code>n</code>（向量中的元素数目）。</p><p><code>Line</code> 属性控制 <code>Line</code> 对象的外观和行为。通过更改属性值，您可以修改线图的某些方面。使用圆点表示法查询和设置属性。<a href="https://ww2.mathworks.cn/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">https://ww2.mathworks.cn/help/matlab/ref/matlab.graphics.chart.primitive.line-properties.html</a></p><p><strong>MATLAB 中还有许多其他绘图函数。您可以在 <a href="https://www.mathworks.com/products/matlab/plot-gallery.html">MATLAB 图库</a>中看到一个详尽的列表。</strong></p><p>卧槽太强大了！matlab yyds</p><hr><p>title(“xx”)为现有绘图添加标签，此类函数的输入是一个字符串。MATLAB 中的字符串是用双引号 (<code>&quot;</code>) 引起来的。</p><p>字符串串联(“Sample “ + sample(3) + “ Data”)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">xlabel</span><span class="token punctuation">(</span><span class="token string">'t_&#123;seconds&#125;'</span><span class="token punctuation">)</span><span class="token function">ylabel</span><span class="token punctuation">(</span><span class="token string">'e^t'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下标和上标的写法！</p><p>您可以使用 <code>legend</code> 函数为绘图添加图例。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">legend</span><span class="token punctuation">(</span>"a"<span class="token punctuation">,</span>"b"<span class="token punctuation">,</span>"c"<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>xlim([xmin xmax])放大并查看这部分， 使用输出窗格中的数据游标查看频率位置。<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/tooltip.gif" alt="img"></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>import dat</p><p>.mat 文件工作区保存的变量将被导入</p><p>图片的话<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408232359673.png" alt="image-20210408232359673" style="zoom:67%;" /></p><p>文本文件或者电子表格</p><p>因为有很多方式导入，这时会打开导入工具(import tools)</p><p>被导入的是蓝色区域，缺失数据是橙色，将会被默认替换为NaN</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408232547731.png" alt="image-20210408232547731"></p><p>可以选择导出模式，表将导入一个变量，变量名参考文件名，标题会被识别成变量名</p><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408234720795.png" alt="image-20210408234720795"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408234728901.png" alt="image-20210408234728901"></p><p>您可以通过在实时脚本的输出窗格中点击表来与表进行交互。例如，您可以使用表的一个变量对表进行排序。<br>![img](<a href="https://matlabacademy-content.mathworks.com/4.26/R2020b/cn/content/Importing">https://matlabacademy-content.mathworks.com/4.26/R2020b/cn/content/Importing</a> Data/Importing Data as a Table/images/sorttablesmall.jpg)<br>在您对表感到满意时，您可以通过更新代码使更改永久化。<br>![img](<a href="https://matlabacademy-content.mathworks.com/4.26/R2020b/cn/content/Importing">https://matlabacademy-content.mathworks.com/4.26/R2020b/cn/content/Importing</a> Data/Importing Data as a Table/images/updatecodesmall.jpg)</p><p>这会在脚本里自动生成相应的代码</p><p>用变量和 : 提取表格，生成的变量仍是表格，<strong>即使单个，也是表格！</strong></p><h2 id="逻辑索引"><a href="#逻辑索引" class="headerlink" title="逻辑索引"></a>逻辑索引</h2><p>内置了布尔值系统，但这里类型是logical      <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210408235343375.png" alt="image-20210408235343375"></p><p>您可以使用关系运算符将某个向量或矩阵与单个标量值进行比较。结果是与原始数组相同大小的逻辑数组。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">10</span> <span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">12</span>ans <span class="token operator">=</span>     <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>您可以使用逻辑数组作为数组索引，在这种情况下，MATLAB 会提取索引为 <code>true</code> 的数组元素。以下示例将会提取 <code>v1</code> 中大于 6 的所有元素。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">v <span class="token operator">=</span> <span class="token function">v1</span><span class="token punctuation">(</span>v1 <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span>v <span class="token operator">=</span>    <span class="token number">6.6678</span>    <span class="token number">9.0698</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用逻辑索引在数组中重新赋值。例如，如果您要将数组 <code>x</code> 中等于 <code>999</code> 的所有值都替换为值 <code>1</code>，请使用以下语法。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">999</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的和和或是  <code>&amp;  |</code></p><h2 id="编程构造"><a href="#编程构造" class="headerlink" title="编程构造"></a>编程构造</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token keyword">if</span> xxxxxxxxxxxx<span class="token keyword">elseif</span> xxxxxxx<span class="token keyword">else</span>xxx<span class="token keyword">end</span>  <span class="token operator">/</span><span class="token operator">/</span>这些语言非得加个<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token keyword">for</span> 向量（有多个值）xxxxxxxxx<span class="token keyword">end</span><span class="token function">disp</span><span class="token punctuation">(</span>"done<span class="token punctuation">!</span>"<span class="token punctuation">)</span>  <span class="token operator">/</span><span class="token operator">/</span>display可还行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果只是简单的对向量进行处理，matlab提供了更简单的做法</p><p>比如点乘<code>.*</code>，比如<code>.^</code></p><p>length() 求长度 pause(second) 可以观察其生成过程，奇异值</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">基本语法示例说明x <span class="token operator">=</span> <span class="token keyword">pi</span>使用等号 <span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">)</span> 创建变量。左侧 <span class="token punctuation">(</span>x<span class="token punctuation">)</span> 是变量的名称，其值为右侧 <span class="token punctuation">(</span><span class="token keyword">pi</span><span class="token punctuation">)</span> 的值。y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>您可以使用括号提供函数的输入。 桌面管理函数示例说明savesave data<span class="token punctuation">.</span>mat将当前工作区保存到 MAT 文件中。loadload data<span class="token punctuation">.</span>mat将 MAT 文件中的变量加载到工作区。clearclear清除工作区中的所有变量。clcclc清除命令行窗口中的所有文本。formatformat long更改数值输出的显示方式。 数组类型示例说明<span class="token number">4</span>标量<span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">5</span><span class="token punctuation">]</span>行向量<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">]</span>列向量<span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span>矩阵 等间距向量示例说明<span class="token number">1</span><span class="token operator">:</span><span class="token number">4</span>使用冒号 <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> 运算符，创建一个从 <span class="token number">1</span> 到 <span class="token number">4</span>，间距为 <span class="token number">1</span> 的向量。<span class="token number">1</span><span class="token operator">:</span><span class="token number">0.5</span><span class="token operator">:</span><span class="token number">4</span>创建一个从 <span class="token number">1</span> 到 <span class="token number">4</span>，间距为 <span class="token number">0.5</span> 的向量。<span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>创建一个包含 <span class="token number">5</span> 个元素的向量。这些值从 <span class="token number">1</span> 到 <span class="token number">10</span> 均匀间隔。 创建矩阵示例说明<span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>创建一个 <span class="token number">2</span> 行 <span class="token number">2</span> 列的方阵。<span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>创建一个 <span class="token number">2</span> 行 <span class="token number">3</span> 列的矩形矩阵。 索引示例说明<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>访问最后一行的第二列中的元素。<span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>访问第二行所有元素。<span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>访问前三行的所有列。<span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">11</span>将数组中第二个元素的值更改为 <span class="token number">11</span>。 数组运算示例说明<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">]</span>ans <span class="token operator">=</span>     <span class="token number">4</span>    <span class="token number">4</span>     <span class="token number">4</span>    <span class="token number">4</span>执行矩阵乘法。<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">.*</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">]</span>ans <span class="token operator">=</span>     <span class="token number">2</span>    <span class="token number">2</span>     <span class="token number">2</span>    <span class="token number">2</span>执行按元素乘法。 多个输出示例说明<span class="token punctuation">[</span>xrow<span class="token punctuation">,</span>xcol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>将 x 中的行数和列数保存为两个不同变量。<span class="token punctuation">[</span>xMax<span class="token punctuation">,</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>计算 x 的最大值及其对应的索引值。 文档示例说明doc randi打开 randi 函数的文档页。 绘图示例说明<span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>"ro<span class="token operator">-</span>"<span class="token punctuation">,</span>"LineWidth"<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>绘制一条红色 <span class="token punctuation">(</span>r<span class="token punctuation">)</span> 虚线 <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">)</span>并使用圆圈 <span class="token punctuation">(</span>o<span class="token punctuation">)</span> 标记，线宽很大。hold on在现有绘图中新增一行。hold off为下一个绘图线条创建一个新坐标区。<span class="token function">title</span><span class="token punctuation">(</span>"My Title"<span class="token punctuation">)</span>为绘图添加标签。 使用表示例说明data<span class="token punctuation">.</span>HeightYards从表 data 中提取变量 HeightYards。data<span class="token punctuation">.</span>HeightMeters <span class="token operator">=</span> data<span class="token punctuation">.</span>HeightYards<span class="token operator">*</span><span class="token number">0.9144</span>从现有数据中派生一个表变量。 逻辑运算示例说明<span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">10</span> <span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">12</span>将向量与值 <span class="token number">12</span> 进行比较。<span class="token function">v1</span><span class="token punctuation">(</span>v1 <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span>提取 v1 中大于 <span class="token number">6</span> 的所有元素。<span class="token function">x</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">999</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>用值 <span class="token number">1</span> 替换 x 中等于 <span class="token number">999</span> 的所有值。 编程示例说明<span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0.5</span>    y <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">else</span>    y <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">end</span>如果 x 大于 <span class="token number">0.5</span>，则将 y 的值设置为 <span class="token number">3</span>。否则，将 y 的值设置为 <span class="token number">4</span>。<span class="token keyword">for</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span>    <span class="token function">disp</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">end</span>循环计数器 <span class="token punctuation">(</span>c<span class="token punctuation">)</span> 遍历值 <span class="token number">1</span><span class="token operator">:</span><span class="token number">3</span>（<span class="token number">1</span>、<span class="token number">2</span> 和 <span class="token number">3</span>）。循环体显示 c 的每个值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="大佬教程"><a href="#大佬教程" class="headerlink" title="大佬教程"></a>大佬教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409091948941.png" alt="image-20210409091948941"></p><p>先看完前五节基础必看！后面是选学</p><h2 id="基本操作和矩阵操作"><a href="#基本操作和矩阵操作" class="headerlink" title="基本操作和矩阵操作"></a>基本操作和矩阵操作</h2><p>第一步，把matlab当作基本的计算机</p><p>第二部，利用matlab进行矩阵运算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;官网教程&quot;&gt;&lt;a href=&quot;#官网教程&quot; class=&quot;headerlink&quot; title=&quot;官网教程&quot;&gt;&lt;/a&gt;官网教程&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h</summary>
      
    
    
    
    <category term="data" scheme="http://example.com/categories/data/"/>
    
    
    <category term="matlab" scheme="http://example.com/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>算法1:KMP</title>
    <link href="http://example.com/2021/04/06/%E7%AE%97%E6%B3%951%EF%BC%9ATMP/"/>
    <id>http://example.com/2021/04/06/%E7%AE%97%E6%B3%951%EF%BC%9ATMP/</id>
    <published>2021-04-06T11:13:12.000Z</published>
    <updated>2021-04-08T15:46:29.309Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="算法1：KMP"><a href="#算法1：KMP" class="headerlink" title="算法1：KMP"></a>算法1：KMP</h1><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>​    没想到我的博客竟然有朝一日也能开始记录算法感想。。大一下。。打算从开发岗转算法岗了。。感觉会有趣一百倍，而不是。。。（并没有歧视，只是个人偏好QWQ）</p><p>​    本着开源的精神，我也开始向各位大佬学习！记录一下自己学过的算法们，当然，由于博主是学生党，并不会也懒得把整个算法的过程都写下来，我会注意把自己学习时遇到的问题和难点记录下来，并总结一下思想方法的噢！</p><p>​    话说KMP也是我第一个遇到的真正需要思考的算法！终于要开始了吗！掉头发的道路！这次想了快两个小时才理解KMP，好菜QWQ，以后加油！</p><h2 id="宏观理解"><a href="#宏观理解" class="headerlink" title="宏观理解"></a>宏观理解</h2><p>KMP能够优化查询，比起暴力主要优化在两点：一是略去了目标字符串的回溯，二是优化了模式字符串的回溯效率，这都是基于前后缀表来实现的。前后缀表的实现有3种以上方法，我学的是整体右移那种，但是其实这只会导致细微的差距。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>获取前缀表：</p><p>初始化时使后缀表与前缀表错开一位（-1 和 0）</p><p>由于数学规律，在求解某项的next值时，若所有项一一对应，则k一直++，这是最顺利的情况</p><p>但是当某项不匹配时，要通过回退来试图找到稍小的字符串来与开头字符串比较。</p><p>此时把开头字符串通过next表回退一次，这时相当于是找上一个对应好的k，这个k是上一组对应好的前缀组和后缀组，此时肯定大于当前的，这里用到了递归的思想。。因为一组一组都是配好的，发生不匹配的情况时，就往已经匹配好的地方回退。</p><p>需要注意的是，不知道为啥老是想到对称上去。。他这个是前后顺序相同（感觉这样说好蠢），但就是会犯错。。和对称得出的规律差距挺大的</p><p>不管啦就这样吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;算法1：KMP&quot;&gt;&lt;a href=&quot;#算法1：KMP&quot; class=&quot;headerlink&quot; title=&quot;算法1：KMP&quot;&gt;&lt;/a&gt;算法1：KMP&lt;/h1&gt;&lt;h2 id=&quot;感想&quot;&gt;&lt;a href=&quot;#感想&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>hot key</title>
    <link href="http://example.com/2021/04/05/%E9%82%A3%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://example.com/2021/04/05/%E9%82%A3%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-04-05T02:36:09.000Z</published>
    <updated>2021-04-10T06:28:35.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><p>Fn + 左右箭头快速抵达行头行尾</p><p>Fn + shift + 左右箭头快速选中整行</p><p>C + f 搜索</p><h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>C + g  快速到达某一行</p><p>C + A + 上下  为上下行的该位置添加光标，如果为空，则尽量左移</p><p>S + A + 拖动鼠标 选中规则同上</p><p>C + c  +  C + v 快速复制一行</p><p>或者 S + A + 上下</p><hr><p>C + /  单行注释</p><p>C + S + /   多行注释（改的，原来是S + A + a）</p><p>C + ~  打开终端</p><p>C + d 快速选中相同的</p><p>C + f 搜索</p><p>C + h 替换（可以全部替换）</p><p>C + +/-  放大/缩小布局</p><p>Tab 到达下一个光标</p><p>自定义快捷键</p><p>有些快捷键，我们使用不习惯，其实我们可以自定义快捷键的。</p><p>比如js 的多行注释是 shift + alt  + a  ，我们想修改为 ctrl + shfit +  /   </p><p>设置方法：   管理按钮  —   键盘快捷方式  —  输入  shift + alt  + a  找到这个快捷键  —– 点击编辑按钮  —- 直接按下  ctrl + shift  +  /     —- 最后按下回车 修改完毕。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/070e4f32b7326196062f020bbc3a91b30c7e470c.gif" alt="img"></p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>C + S + j   开发者模式（谷歌），在火狐有些不同</p><p>C + h   历史记录</p><p>C + n  打开新窗口</p><p>C + S + n  新无痕窗口</p><p>C + 左键:打开新标签方式</p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>C + b 加粗</p><p>C + i  斜体</p><p>C + k 设为超链接</p><h1 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h1><p>A 创建新单元格above当前单元格</p><p>B 创建新单元格below当前单元格</p><p>在markdown 和 code之间进行转换</p><p>markdown -&gt; code Y</p><p>code -&gt; markdown M </p><p>L 是显示行号d</p><p>双击D 可以删除单元格，Z撤销删除</p><p>S 保存！</p><p>最强的是C + S + P</p><p>打开万能的控制栏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通用&quot;&gt;&lt;a href=&quot;#通用&quot; class=&quot;headerlink&quot; title=&quot;通用&quot;&gt;&lt;/a&gt;通用&lt;/h1&gt;&lt;p&gt;Fn + 左右箭头快速抵达行头行尾&lt;/p&gt;
&lt;p&gt;Fn + shift + 左右箭头快速选中整行&lt;/p&gt;
&lt;p&gt;C + f 搜索&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="hot key" scheme="http://example.com/tags/hot-key/"/>
    
  </entry>
  
  <entry>
    <title>plan</title>
    <link href="http://example.com/2021/03/19/plan/"/>
    <id>http://example.com/2021/03/19/plan/</id>
    <published>2021-03-19T04:06:23.000Z</published>
    <updated>2021-04-08T00:49:49.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Darren’s-Carrer"><a href="#Darren’s-Carrer" class="headerlink" title="Darren’s Carrer"></a>Darren’s Carrer</h1><p>[toc]</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>​    在经历了近半年的对计算机领域努力探索后，如今我已大致明白我们专业的处境和一些出路，现实就是如此，毕竟高考考砸了，够不着很多资源。。。只希望能如诸位前辈们般，凭借才能和热情，靠自学成为大佬，这篇博文用于记载我对未来发展方向的规划，反映了我在不同阶段的想法吧，请不要把以前的想法删掉。</p><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>2021 . 3. 19日，大一下学期第三周</p><p>统计一下现在自己的技术栈。。C语言了解基本语法，数据结构起步，linux基本操作，可以熟练安装虚拟机，git基本操作和github基本操作，python学完基本语法和部分高级语法，会使用anaconda，前端有了大致轮廓，会html，css，js基本和一些jq，通过思科课程大致了解互联网，c++学到友元，拥有一大堆计算机领域的资源和导航还有工具，ctf各方向有所了解。。。好少。。。上学期没怎么课外学习，结果现在技术栈也太拉跨了。</p><p>结合了我们学校开的课程和目前了解的信息，做出第一次计划：</p><p>大一下：</p><p>认真学习数据结构，多在leetcode上刷题（剑指offer），学完思科第一期课程：ITN，Linux，Python，学几个python库，啥数据分析，机器学习的简单一点的。</p><p>先学前端，html，css，JS（重中之重），前端工具和框架，因为比较简单</p><p>大二上：</p><p>肝JAVA，看看是继续前端还是肝一肝后端技术栈，还有web安全有没有机会。</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>哈哈，竟然才2021.4.4</p><p>最近一直在学前端呢，html啊，css啊，js啊，基本操作会用了，也知道咋做漂亮的静态页面了ヽ(✿ﾟ▽ﾟ)ノ</p><p>前端这个方向果然激励机制是非常棒呢。</p><p>去腾讯后我也好好思考了是否要继续前后端路线的问题。</p><p>怎么说呢。。前端可能确实挺有意思，但是可替代性太大了，就是。。。你懂的，谁都可以学</p><p>不知道。。。但是可能我需要一些学比较底层也有趣的知识吧。</p><p>放几张腾讯招人的图过来：</p><p><img src="../../../../Desktop/QQ%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1275972958/FileRecv/MobileFile/Screenshot_2021-03-31-15-58-03-87.jpg" alt="Screenshot_2021-03-31-15-58-03-87" style="zoom: 25%;" /><img src="../../../../Desktop/QQ%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1275972958/FileRecv/MobileFile/Screenshot_2021-03-31-16-02-46-12.jpg" alt="Screenshot_2021-03-31-16-02-46-12" style="zoom:25%;" /><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404145315607.png" alt="image-20210404145315607" style="zoom:25%;" /><img src="../../../../Desktop/QQ%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1275972958/FileRecv/MobileFile/Screenshot_2021-03-31-16-02-46-12.jpg" alt="Screenshot_2021-03-31-16-02-46-12" style="zoom:25%;" /><img src="../../../../Desktop/QQ%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1275972958/FileRecv/MobileFile/Screenshot_2021-03-31-16-04-48-25.jpg" alt="Screenshot_2021-03-31-16-04-48-25" style="zoom:25%;" /></p><p>我也确实挺喜欢机器学习的。。毕竟人工智能谁不喜欢呢。。</p><p>可能需要同时学习一些偏底层的东西，为未来转方向做准备了。。。</p><p>要不先学学后端？？？</p><h2 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h2><p>转行竟然来得如此之快！</p><p>劳资终于不用挣扎在读研和就业的泥沼里了！</p><p>我才不要一下就就业，我也不想整天处在鄙视链的底层，跟一堆没上过专科的一起工作</p><p>劳资比起应用，还是也喜欢理论。</p><p>就是数据挖掘算法工程师了。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/%E7%AE%97%E6%B3%95%E5%B2%97%E8%B7%AF%E7%BA%BF.png" alt="算法岗路线"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Darren’s-Carrer&quot;&gt;&lt;a href=&quot;#Darren’s-Carrer&quot; class=&quot;headerlink&quot; title=&quot;Darren’s Carrer&quot;&gt;&lt;/a&gt;Darren’s Carrer&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="log" scheme="http://example.com/categories/log/"/>
    
    
    <category term="plan" scheme="http://example.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>introduction-to-Network</title>
    <link href="http://example.com/2021/03/14/introduction-to-Networks/"/>
    <id>http://example.com/2021/03/14/introduction-to-Networks/</id>
    <published>2021-03-14T08:10:41.000Z</published>
    <updated>2021-04-08T12:02:40.801Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>警告：Cisco课程，不可用于商用</p><p>因为我发现学这个课老是断断续续的，每次捡起来超级麻烦，所以趁这次来个大复习，把一些该有的知识点直接记下来好了</p><h1 id="当今网络"><a href="#当今网络" class="headerlink" title="当今网络"></a>当今网络</h1><h2 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h2><p>网络有很多组件:</p><p>终端设备，中间设备，网络介质巴拉巴拉</p><p>常见表示方法：</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314161643916.png" alt="image-20210314161643916"></p><p>除了这些表示之外，还使用专门的术语来描述这些设备和介质是如何相互连接的:</p><p><img src="" alt="85163160_p0"></p><ul><li><strong>网络接口卡 (NIC)</strong> - 将设备物理连接到网络。</li><li><strong>物理端口</strong> - 网络设备上的接口或插口，介质通过它连接到终端设备或其他网络设备。</li><li><strong>接口</strong> - 网络设备上连接到独立网络的专用端口。由于路由器连接了不同的网络，路由器上的端口称为网络接口。</li></ul><p>还有物理拓扑图和逻辑拓扑图</p><p>几个类型：</p><p>内部网，外联网，Intranets and Extranets</p><p>LAN WAN</p><h2 id="常用连接技术"><a href="#常用连接技术" class="headerlink" title="常用连接技术"></a>常用连接技术</h2><p>家庭和小型办公室</p><ul><li><strong>有线电视</strong> （<strong>Cable</strong>）- 通常由有线电视服务提供商提供，互联网数据信号在输送有线电视信号的同一电缆上进行传输。它提供了高带宽、高可用性和始终在线的互联网连接。</li><li><strong>DSL</strong> - 数字用户线也可提供高带宽、高可用性和始终在线的互联网连接。DSL 通过电话线路运行。通常小型办公室和家庭办公室用户会选择使用非对称 DSL (ADSL)，这种方式的特点是下载速度高于上传速度。</li><li><strong>蜂窝网</strong>（<strong>Cellular</strong>） - 蜂窝网互联网接入使用手机网络进行连接。只要您能收到蜂窝网信号，就能获得蜂窝网互联网接入。性能会受手机功能和手机基站的限制。</li><li><strong>卫星</strong>（<strong>Satellite</strong>） - 对于根本没有互联网连接的地方来说，获得卫星互联网访问非常有用。卫星天线要求有到卫星的清晰视线。</li><li><strong>拨号电话</strong>（<strong>Dial-up Telephone</strong>） - 使用电话线和调制解调器，费用相对较低。拨号调制解调器连接提供的低带宽不足以用于大型数据传输，但对旅行过程中的移动访问非常有用。</li></ul><p><img src="" alt="background2"></p><p>企业</p><ul><li><strong>专用租用线路</strong>（<strong>Dedicated Leased Line</strong> ） - 租用线路是服务提供商网络内连接地理位置分散的办公室的保留电路，提供个人语音和/或数据网络。电路按月或按年租用。</li><li><strong>城域以太网</strong>（<strong>Metro Ethernet</strong>） -有时被称为以太网 WAN. 在本模块中，我们把它称为城域以太网。城域以太网将 LAN 访问技术扩展到 WAN 中。以太网是一种 LAN 技术，您将在后面的模块中学习。</li><li><strong>DSL</strong>（<strong>Business DSL</strong>） - 企业 DSL 提供各种格式。一种常见的选择是对称数字用户线路 (SDSL)，它类似于 DSL 的普通用户版本，但是提供相同的上传和下载速度。</li><li><strong>卫星</strong> – 当有线解决方案不可用时，卫星服务可以提供连接。</li></ul><p>今天，独立的数据、电话和视频网络融合在了一起。与专用网络不同，融合网络能够通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频。此网络基础设施采用一组相同的规则、协议和实施标准。融合数据网络在一个网络中传送多种服务。</p><h2 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h2><p>容错能力-提供冗余的多条路径</p><p>可拓展性-设计人员可以遵循广为接受的标准和协议</p><p>服务质量 (QoS)-通过各种协议和优先级</p><p>网络安全-设备安全，网络安全：</p><ul><li><p><strong>机密性</strong> - 数据机密性意味着只有预定和授权收件人可以访问并读取数据。</p></li><li><p><strong>完整性</strong> - 数据完整性表示保证信息在从源到目的地的传输过程中不会被更改。</p></li><li><p><strong>可用性</strong> - 数据可用性表示保证授权用户及时可靠地访问数据服务。</p></li><li><p><strong>病毒、蠕虫和特洛伊木马</strong> <strong>Viruses, worms, and Trojan horses</strong>- 这些包括在用户设备上运行的恶意软件或代码。</p></li><li><p><strong>间谍软件和广告软件</strong> <strong>Spyware and adware</strong>-这些是安装在用户设备上的软件类型。这些软件会秘密收集有关用户的信息。</p></li><li><p><strong>零日攻击（也称零小时攻击）****Zero-day attacks</strong> - 在出现漏洞的第一天发起的攻击。</p></li><li><p><strong>威胁发起者攻击</strong> <strong>Threat actor attacks</strong>-恶意人员攻击用户设备或网络资源。</p></li><li><p><strong>拒绝服务攻击</strong> <strong>Denial of service attacks</strong>- 使网络设备上的应用和进程减缓或崩溃的攻击。</p></li><li><p><strong>数据拦截和盗窃****Data interception and theft</strong> - 通过公司网络捕获私人信息的攻击。</p></li><li><p><strong>身份盗窃****Identity theft</strong> - 窃取用户的登录凭证来访问私人数据的攻击。</p></li></ul><h2 id="一些趋势"><a href="#一些趋势" class="headerlink" title="一些趋势"></a>一些趋势</h2><p>BYOD 意味着设备由任何使用者在任意地点使用。</p><p>云计算</p><p>智能家庭技术（物联网）</p><p>电力网：</p><p>使用标准电源适配器，只要有电源插座，设备就可以连接到 LAN。无需安装数据线，也几乎不需要额外的电力。通过使用供电的同一线路，电力线网络通过按一定频率发送数据来发送信息。</p><p>当无线接入点无法到达家里的所有设备时，电力线网络特别有用。电力线网络不会取代数据网络中的专用布线。但是，当有线数据网络或无线通信不可行时，电力线网络可以备用。</p><p>无线互联网服务提供商 (WISP) 是使用类似家庭无线局域网 (WLAN) 的无线技术</p><h1 id="配置交换机-终端"><a href="#配置交换机-终端" class="headerlink" title="配置交换机/终端"></a>配置交换机/终端</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163007230.png" alt="image-20210314163007230"></p><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>默认情况下，交换机将转发流量，无需配置即可工作。例如，连接到同一新交换机的两个已配置了的主机能够进行通信。</p><p>无论新交换机的默认特性如何，都应配置并保护所有交换机。</p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>控制台 (Console)</strong></td><td align="left">这是一种物理管理端口，可通过该端口对思科设备进行带外访问。带外访问是指通过仅用于设备维护的专用管理通道进行访问。使用控制台端口的优势在于，即使没有配置任何网络服务，也可以访问设备，例如执行初始配置时。控制台连接需要运行终端仿真软件的计算机和用于连接设备的特殊控制台电缆。</td></tr><tr><td align="left"><strong>安全外壳(SSH)</strong></td><td align="left">SSH 是一种带内且被推荐的方法，它使用虚拟接口通过网络远程建立安全的 CLI连接。不同于控制台连接，SSH 连接需要设备上具有有效的网络服务，包括配置了地址的有效接口。大部分思科 IOS 版本配备了 SSH 服务器和 SSH 客户端，可用于与其他设备建立 SSH 会话。</td></tr><tr><td align="left"><strong>Telnet</strong></td><td align="left">Telnet 使用虚拟接口通过网络远程建立 CLI 会话，这种带内方法并不安全。与 SSH 不同，Telnet 不提供安全的加密连接，只能在实验室环境中使用。用户身份验证、密码和命令通过网络以明文形式发送。最好的做法是使用 SSH 而不是 Telnet。思科 IOS 包括 Telnet 服务器和 Telnet 客户端。</td></tr></tbody></table><p><strong>注意:</strong> 某些设备，比如路由器，还可以支持传统辅助端口，这种辅助端口可使用调制解调器通过电话连接远程建立 CLI 会话。类似于控制台连接，AUX 端口也是带外连接，且不需要配置或提供网络服务。</p><h2 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h2><p>作为一项安全功能，思科 IOS 软件将管理访问分为以下两种命令模式：</p><ul><li><strong>用户 EXEC 模式</strong>（user） - 该模式功能有限，但可用于有效执行基本操作。它只允许有限数量的基本监控命令，不允许执行任何可能改变设备配置的命令。用户 EXEC 模式由采用 &gt; 符号结尾的 CLI 提示符标识。</li><li><strong>特权 EXEC 模式</strong>（privileged） - 要执行配置命令，网络管理员必须访问特权 EXEC 模式。较高级别的配置模式，比如全局配置模式，只能通过特权 EXEC 模式访问。特权 EXEC 模式由采用# 符号结尾的提示符标识。</li></ul><p>要配置设备，用户必须进入全局配置模式。</p><p>在全局配置模式下， CLI 配置所做的更改将影响整个设备的运行。全局配置模式由在设备名称之后加(config)#结尾的提示符标识，比如Switch(config)#。</p><p>访问全局配置模式之后才能访问其他具体的配置模式。在全局配置模式下，用户可以进入不同的子配置模式。其中的每种模式可以用于配置 IOS 设备的特定部分或特定功能。两个常见的子配置模式包括：</p><ul><li><strong>线路配置模式</strong> - 用于配置控制台、SSH、Telnet 或 AUX 访问。</li><li><strong>接口配置模式</strong> - 用于配置交换机端口或路由器网络接口。</li></ul><p>当使用 CLI 时，每种模式由该模式独有的命令提示符来标识。默认情况下，每个提示符都以设备名称开头。命令提示符中设备名称后的部分用于表明模式。</p><p>例如，线路配置模式的默认提示符是 <strong>Switch(config-line)#</strong> </p><p>默认的接口配置模式提示符是 **Switch(config-if)#**。</p><ul><li><strong>startup-config(启动配置文件)</strong> -存储在 NVRAM 中的配置文件。它包含在启动时或重启时用到的所有命令。当设备断电后，其中的内容不会消失。</li><li><strong>running-config(运行配置文件)</strong> -存储在随机存取存储器（RAM）中。它反映了当前的配置。修改运行配置会立即影响思科设备的运行。RAM 是易失性存储器。如果设备断电或重新启动，则它会丢失所有内容。</li></ul><h2 id="学习命令"><a href="#学习命令" class="headerlink" title="学习命令"></a>学习命令</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163957083.png" alt="image-20210314163957083"></p><table><thead><tr><th align="left"><strong>约定</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>粗体</strong></td><td align="left">粗体文本表示您需要原样输入的命令和关键字， 如显示的那样。</td></tr><tr><td align="left"><em>斜体</em></td><td align="left">斜体文本指示由您提供值的参数。</td></tr><tr><td align="left"><strong>[<strong>x</strong>]</strong></td><td align="left">方括号表示可选元素（关键字或参数）。</td></tr><tr><td align="left"><strong>{<strong>x</strong>}</strong></td><td align="left">大括号表示必需元素（关键字或参数）。</td></tr><tr><td align="left">**[**x **{**y <strong>|</strong> z <strong>}]</strong></td><td align="left">方括号中的大括号和垂直线表示 可选元素中的必填选项。空格用于清楚地描述 命令的各个部分。</td></tr></tbody></table><p>enable / disable</p><p>configure terminal / exit  (子配置—&gt;上一级)</p><p>end / Ctrl+Z (任何子配置-&gt;特权)</p><p>子配置模式间可以随意转换：</p><p><strong>line console 0</strong></p><p><strong>interface FastEthernet 0/1</strong></p><p><strong>line vty 0 15</strong></p><p>主机名字仅使用字母、数字和破折号</p><p>password ….  特定线路设置密码，如控制台</p><p>Login 启用登录，不启用就根本进不去</p><p>enable secret ….  限制特权（可能是某项命令？）</p><p><strong>service password-encryption</strong>（全局配置指令+加密所有）</p><p>show running-config /startup-config</p><p>**banner motd #<strong>当日消息</strong>#**（其实#可以换别的，向访问设备的人展示）</p><p>hostname 。。。设定主机名，</p><p>no hostname 取消</p><p>reload 清除为保存的running-config</p><p>erase start 删除启动设置，之后需重新加载设备来恢复出厂</p><p>copy 。。。 可以copy到闪存flash里面</p><p>ip address a b 设置ipv4地址和子网掩码</p><p>ipv6 address … 设置ipv6配置</p><p>ping也可在路由器特权模式下用！</p><p>no shutdown 启用虚拟接口（shutdown关闭）</p><p>show ip(ipv6) interface brief 检验接口的正确数量和标识</p><p>no ip domain-lookup 禁用DNS解析(特权模式)</p><p>show arp 交换机等设备显示MAC地址信息（特权）</p><p>show mac address-table 查看mac地址表（特权）</p><p>clear mac address-table dynamic 清除mac地址表(特权)</p><p><strong>mdix auto</strong>接口配置命令（懂得都懂）</p><p>ip route ….（远程网络地址）（网址+子网掩码）   …（下一跳路由器的IP地址）配置静态路由表</p><p>show ip route 特权模式查看路由表</p><p><strong>show ip arp</strong>查看arp表</p><p>transport input {ssh | telnet}或者俩都加上  保护远程Telnet | SSH访问</p><p>description description-text 设置接口说明</p><p><strong>ip default-gateway</strong> ip-address为交换机配置默认网关</p><p>ipv6 unicast-routing 启用 IPv6 路由</p><p>show ip（ipv6） interface brief</p><p>所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</p><p>show ip route/show ipv6 route</p><p>显示存储在 RAM 中的 IP 路由表的内容。</p><p>show interfaces （可加特定接口参数）</p><p>显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</p><p>show ip interface显示路由器上所有接口的 IPv4 统计信息。</p><p>show ipv6 interface显示路由器上所有接口的 IPv6 统计信息。</p><h3 id="主机端"><a href="#主机端" class="headerlink" title="主机端"></a>主机端</h3><p>ipconfig （/all）</p><p>arp -a </p><p>arp -d 清除 ARP 表</p><p>ping … 测试链接，一般要两遍，第一遍是自动配置arp</p><p><strong>route print</strong>或命<strong>netstat -r</strong>令可以显示主机路由表（windows主机）</p><h2 id="好多缩写"><a href="#好多缩写" class="headerlink" title="好多缩写"></a>好多缩写</h2><p>interface  = int</p><p>FastEthernet = f</p><p>running-config = run</p><p>startup-config = start</p><p>address == add</p><h2 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h2><p>？：</p><p>直接输入则显示当前模式可用</p><p>指令输入一般会显示补全可能</p><p>缺参数可以显示参数</p><p>主要Ctrl+A/E</p><p>c+s+6</p><p>c+r返回被打扰的命令行</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Tab</strong></td><td align="left">补全部分输入的命令项。</td></tr><tr><td align="left"><strong>Backspace</strong></td><td align="left">删除光标左边的字符。</td></tr><tr><td align="left"><strong>Ctrl-D</strong></td><td align="left">删除光标所在的字符。</td></tr><tr><td align="left"><strong>Ctrl-K</strong></td><td align="left">删除从光标到命令行尾的所有字符。</td></tr><tr><td align="left"><strong>Esc D</strong></td><td align="left">删除从光标到词尾的所有字符。</td></tr><tr><td align="left"><strong>Ctrl+U</strong> 或 <strong>Ctrl+X</strong></td><td align="left">删除从光标到命令行首的 所有字符。</td></tr><tr><td align="left"><strong>Ctrl-W</strong></td><td align="left">删除光标左边的单词。</td></tr><tr><td align="left"><strong>Ctrl-A</strong></td><td align="left">将光标移至行首。</td></tr><tr><td align="left"><strong>向左箭头</strong> 或 <strong>Ctrl+B</strong></td><td align="left">将光标左移一个字符。</td></tr><tr><td align="left"><strong>Esc B</strong></td><td align="left">将光标向后左移一个单词。</td></tr><tr><td align="left"><strong>Esc F</strong></td><td align="left">将光标向前右移一个单词。</td></tr><tr><td align="left"><strong>向右箭头</strong> 或 <strong>Ctrl+F</strong></td><td align="left">将光标右移一个字符。</td></tr><tr><td align="left"><strong>Ctrl-E</strong></td><td align="left">将光标移至命令行尾。</td></tr><tr><td align="left"><strong>向上箭头</strong> 或 <strong>Ctrl+P</strong></td><td align="left">调出历史记录缓冲区中的命令， 从最近输入的命令开始。</td></tr><tr><td align="left"><strong>Ctrl+R</strong> 或 <strong>Ctrl+I</strong> 或 <strong>Ctrl+L</strong></td><td align="left">收到控制台消息后重新显示系统提示符和 命令行。</td></tr></tbody></table><p><strong>注意</strong>: 虽然 <strong>Delete</strong> 键通常用于删除提示符右侧的字符，但 IOS 命令结构无法识别 Delete 键。</p><p>当命令输出产生的文本超过终端窗口中可以显示的文本时，IOS 将显示一个 <strong>“–More–”</strong> 提示。下表描述了显示此提示时可以使用的键盘输入。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>回车</strong> 键</td><td align="left">显示下一行。</td></tr><tr><td align="left"><strong>空格</strong>键</td><td align="left">显示下一屏。</td></tr><tr><td align="left">任何其他按键</td><td align="left">结束显示字符串，返回特权模式。</td></tr></tbody></table><p>此表列出了用于退出操作的命令。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl-C</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。处于设置模式下时，用于中止并返回命令 提示符。</td></tr><tr><td align="left"><strong>Ctrl-Z</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。</td></tr><tr><td align="left"><strong>Ctrl-Shift-6</strong></td><td align="left">通用中断序列用于中止 DNS lookup、traceroutes、 pings等</td></tr></tbody></table><h1 id="协议和模型"><a href="#协议和模型" class="headerlink" title="协议和模型"></a>协议和模型</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>常用的计算机协议包含以下要求：</p><ul><li>消息编码-将信息转换成可传输和解码的</li><li>消息格式和封装（encapsulation）-取决于消息类型和传递信道</li><li>消息大小</li><li>消息时序（timing）<ul><li><strong>流量控制（flow control）-</strong> 这是管理数据传输速率的过程。流量控制定义了可以发送多少信息以及传递信息的速率。例如，如果一个人讲话太快，对方就难以听清和理解。在网络通信中，源设备和目的设备使用网络协议来协商和管理信息流。</li><li><strong>响应超时</strong>(responce timeout) -如果一个人提问之后在合理的时间内没有得到回答，就会认为没有获得回答并作出相应的反应。此人可能会重复这个问题，也可能继续谈话。网络上的主机会使用网络协议来指定等待响应的时长，以及在响应超时的情况下执行什么操作。</li><li><strong>访问方法</strong> -这决定人们可以发送消息的时间。如果两个人同时讲话，就会发生信息冲突，两个人必须作出让步，重新开始的动画演示。同样，当设备想要在无线局域网上传输时，有必要使用 WLAN 网络接口卡 (NIC) 来确定无线介质是否可用。</li></ul></li><li>消息传输选项</li></ul><p>单播广播组播</p><p>网络协议定义了用于设备之间交换消息的通用格式和规则集。协议由软件、硬件或两者中的终端设备和中间设备实现。每个网络协议都有自己的功能、格式和通信规则。</p><p>该表列出了在一个或多个网络上通信所需的各种协议类型。</p><table><thead><tr><th align="left"><strong>协议类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>网络通信协议</strong></td><td align="left">这类协议使两个或多个设备能够在一个或多个 网络上通信。以太网技术家族涉及多种协议， 例如IP，传输控制协议（TCP）， 超文本传输协议（HTTP）等。</td></tr><tr><td align="left"><strong>网络安全协议</strong></td><td align="left">这类协议保护数据以提供身份验证、数据完整性和 数据加密。安全协议的示例包括安全外壳协议 (SSH)、安全套接字层协议 (SSL) 和传输层安全协议 (TLS)。</td></tr><tr><td align="left"><strong>路由（routing）协议</strong></td><td align="left">这类协议使路由器能够交换路由信息，比较路径 信息，然后选择到达目标网络的 最佳路径。路由协议的示例包括开放最短路径优先协议 (OSPF)和边界网关协议 (BGP)。</td></tr><tr><td align="left"><strong>服务发现协议。</strong></td><td align="left">这类协议用于设备或服务的自动检测。 服务发现协议的示例包括发现用于IP地址分配 服务的动态主机配置协议（DHCP）， 和用于执行域名到IP地址转换的 域名系统（DNS）。</td></tr></tbody></table><p>执行某种通信功能所需的一组内在相关协议称为协议簇。</p><p>要形象地表现协议簇中的协议如何互动，最佳方法之一就是将这种互动看成一个堆栈。协议栈展示了协议簇中的单个协议是如何实施的。<strong>协议显示为分层结构，每种上层服务都依赖于其余下层协议所定义的功能。协议栈的下层负责通过网络传输数据和向上层提供服务，而上层则负责处理发送的消息内容。</strong></p><p>当年多种协议簇，只剩下TCP/IP（互联网协议簇）和一点点OSI（开放系统互连协议）</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="*TCP/IP"></a>*TCP/IP</h2><p>免费 且 标准</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314171619114.png" alt="image-20210314171619114"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314173907739.png" alt="image-20210314173907739"></p><table><thead><tr><th><strong>4 - 应用层</strong></th><th>向用户提供数据，以及编码和对话控制。</th></tr></thead><tbody><tr><td><strong>3 - 传输层</strong></td><td>支持各种设备之间通过不同网络通信。</td></tr><tr><td><strong>2 - 互联网层</strong></td><td>确定通过网络的最佳路径。</td></tr><tr><td><strong>1 - 网络接入层</strong></td><td>控制组成网络的硬件设备和介质。</td></tr></tbody></table><p>OSI 5/6/7层供应用程序开发者参考</p><p>而底层通常使用OSI的1/2层</p><p>#应用层#(Applicaton Layer)</p><pre class="line-numbers language-none"><code class="language-none">域名系统DNS - 域名系统(Domain Name System)。将域名（例如 cisco.com）转换为 IP 地址。主机配置DHCPv4 - IPv4动态主机配置协议(Dynamic Host Configuration Protocol for IPv4)。DHCPv4 服务器在启动时动态地将 IPv4 编址信息分配给 DHCPv4 客户端，并允许在不再需要时重新使用这些地址。DHCPv6 - IPv6动态主机配置协议。DHCPv6类似于DHCPv4。SLAAC -无状态地址自动配置(Stateless Address Autoconfiguration)。一种允许设备在不使用DHCPv6服务器的情况下获得其IPv6编址信息的方法。邮件SMTP -简单邮件传输协议(Simple Mail Transfer Protocol)。使客户端能够将邮件发送到邮件服务器，并使服务器能够将邮件发送到其他服务器。POP3 -邮局协议第 3 版(Post Office Protocol version 3)。使客户端能够从邮件服务器检索电子邮件并将电子邮件下载到客户端本地邮件应用程序。IMAP -互联网消息访问协议(Internet Message Access Protocol)。使客户端能够访问存储在邮件服务器上的电子邮件，并在服务器上维护电子邮件。文件传输FTP - 文件传输协议(File Transfer Protocol)。它设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件。FTP是一种可靠、面向连接且进行确认的文件传输协议。SFTP - SSH文件传输协议(SSH...)。作为安全外壳 (SSH)协议的扩展，SFTP可用于建立安全的文件传输会话，在该会话中对文件传输进行加密。SSH 是一种安全远程登录的方法，通常用于访问设备的命令行。TFTP -简单文件传输协议(Trivial...)。这是一个简单的，无连接的文件传输协议，使用尽最大努力、无需确认的文件传输方式。它使用的开销比FTP少。Web和Web服务HTTP(Hybertext Transfer Protocol) -超文本传输协议。这是有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集。HTTPS -安全 HTTP(HTTP Secure)。这是一种安全的HTTP形式，它对在万维网上交换的数据进行加密。REST -具象状态传输协议(Representational State Transfer)。它使用应用程序编程接口 (API) 和 HTTP 请求创建 Web 应用程序的 Web 服务。前后端交接！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#传输层#(Transport layer)</p><pre class="line-numbers language-none"><code class="language-none">面向连接TCP -传输控制协议(Transmission Control Protocol)。它使运行在不同主机上的进程之间能够进行可靠的通信，并提供可靠的、需要确认的传输，以确保传输成功。无连接UDP -用户数据报协议(User Datagram Protocol)。它允许一台主机上运行的进程向另一台主机上运行的进程发送数据包。但是，UDP不会确认数据报传输是否成功。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#互联网层#(Internet Layer)</p><pre class="line-numbers language-none"><code class="language-none">Internet 协议IPv4 -互联网协议第 4 版(Internet Protocol version 4)。它接收来自传输层的消息段，将消息打包成数据包，并为通过网络进行端到端传递的数据包进行地址分配。IPv4 使用 32 位地址。IPv6 - 互联网协议第 6 版。与 IPv4 类似，但使用 128 位地址。NAT -网络地址转换(Network Address Translation)。将私有网络 IPv4 地址转换为全球唯一的公有 IPv4 地址。消息传送ICMPv4 - IPv4 互联网控制消息协议(Internet Control Message Protocol for IPv4)。目的主机针对数据包传输中出现的错误，向源主机提供反馈。ICMPv6 -用于 IPv6 的ICMP。与 ICMPv4 类似的功能，但用于 IPv6 数据包。ICMPv6 ND -IPv6 邻居发现(IPv6 Neighbor Discovery)。包括用于地址解析和重复地址检测的四个协议消息。路由协议OSPF -开放最短路径优先协议(Open Shortest Path First)。它使用基于区域的分层设计的链路状态路由协议。OSPF是一种开放式标准内部路由协议。EIGRP — 增强型内部网关路由协议(Enhanced Interior Gateway Routing Protocol)这是一种思科开发的开放标准路由协议，使用基于带宽、延迟、负载和可靠性的复合度量。BGP -边界网关协议(Border Gateway Protocol)。这是一种开放标准的外部网关路由协议，用于互联网服务提供商(ISP)之间。BGP 还通常用于 ISP 与其大型私有客户端之间来交换路由信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#网络接入层#(Network Access Layer)</p><pre class="line-numbers language-none"><code class="language-none">地址解析ARP -地址解析协议(Address Resolution Protocol)。提供 IPv4 地址与硬件地址之间的动态地址映射。注意：您可能会看到其他文档声明 ARP 在互联网层（OSI 第 3 层）运行。但是，在本课程中，我们声明 ARP 在网络接入层（OSI 第 2 层）运行，因为它的主要目的是发现目标的 MAC 地址。MAC 地址是第 2 层地址。数据链路协议Ethernet -为网络接入层的布线和信令标准定义规则。WLAN -无线局域网(Wirelee Local Area Network)。定义 2.4 GHz 和 5 GHz 无线电频率的无线信号规则。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314174259989.png" alt="image-20210314174259989"></p><p>PDU协议数据单元</p><p>Data 数据 </p><p>Segment 段  Datagram 报</p><p>Packet 包</p><p>Frame 帧</p><p>Bits 位</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>网络接口卡 (NIC) 将设备连接到网络。以太网网卡用于有线连接（如图所示），而无线局域网（WLAN）网卡用于无线连接。最终用户设备可能包括一种或两种类型的网卡。</p><p>在连接网络时，所有物理连接的性能水平并不是相等的。</p><p>OSI 物理层通过网络介质传输构成数据链路层帧的比特（位）。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。帧由经过编码的比特（位）构成，这些位可以被终端设备或中间设备接收。</p><h2 id="物理层标准"><a href="#物理层标准" class="headerlink" title="物理层标准"></a>物理层标准</h2><p>由以下组织定义和管理：</p><ul><li>国际标准化组织 (ISO)</li><li>电信工业协会/电子工业协会 (TIA/EIA)</li><li>国际电信联盟 (ITU)</li><li>美国国家标准学会 (ANSI)</li><li>电气电子工程师协会 (IEEE)</li><li>国家级电信管理局包括美国联邦通信委员会 (FCC) 和欧洲电信标准协会 (ETSI)。</li></ul><p>除了这些组织之外，通常还有地方性布线标准组织，例如 CSA（加拿大标准协会）、CENELEC（欧洲电工标准化委员会）和 JSA/JIS（日本标准协会），开发本地规范。（放在这里谨表敬意，绝对不记！！）</p><p>物理层标准管理三个功能区：</p><ul><li>物理组件 - 电子硬件设备、介质和其他连接器</li><li>编码 - 将数据位流转换为预先定义“代码”的方法，这些代码就是位的编组，用于提供一种可预测模式，以便发送者和接收者均能识别。换句话说，编码是用于表示数字信息的方法或模式。（比如曼切斯特）</li><li>信令 - 表示位的方法称为信令方法，在介质上生成代表“1”和“0”的电信号、光信号或无线信号，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。长脉冲可能代表 1，而短脉冲可能代表 0。</li></ul><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>用来衡量带宽质量的术语包括:</p><p><strong>延迟</strong></p><p>延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。</p><p>在拥有多个网段的网际网络或网络中，吞吐量不能超过从源到目的地之间路径的最低链路。纵使这些网段全部或多数具备高速带宽，它也只使用那段低速率路径的吞吐量，这就会造成整个网络的吞吐量瓶颈。</p><p><strong>吞吐量</strong></p><p>吞吐量是给定时段内通过介质传输的位的量度。</p><p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符。吞吐量通常低于带宽。影响吞吐量的因素</p><ul><li>流量大小</li><li>流量类型</li><li>从源通往目的地的过程中遇到的网络设备数量所造成的延时。</li></ul><p><strong>实际吞吐量</strong></p><p>用于评估可用数据传输的第三个测量标准称为实际吞吐量。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。实际吞吐量就是吞吐量减去建立会话、确认、封装和重传所产生的流量开销。实际吞吐量总是低于吞吐量，而吞吐量通常低于带宽。</p><h2 id="铜缆"><a href="#铜缆" class="headerlink" title="铜缆"></a>铜缆</h2><p>有三种不同类型的铜缆布线，每一种都用于特定的情况。</p><p>价格低廉、易于安装、对电流的电阻低。但是，铜介质受到距离和信号干扰的限制。</p><p>信号传输的距离越远，信号下降就越多。这称为信号衰减。</p><ul><li>**电磁干扰 (EMI) 或射频干扰 (RFI) - EMI 和 RFI 干扰信号会扭曲和损坏通过铜介质承载的数据信号。EMI 和 RFI 的潜在来源包括无线电波和电磁设备（如荧光灯或电动机）。</li><li>**串扰 - 串扰是一根电线中信号的电场或磁场对邻近电线中的信号造成的干扰。在电话线上，串扰会由相邻电路中另一语音会话的接听部分引起。具体而言，当电流流经电线时，会在电线周围产生一个较小的环形磁场，而相邻电线可能接收到该磁场。</li></ul><p>为了应对 EMI 和 RFI 的负面影响，某些类型的铜缆会用金属屏蔽套包裹，并要求适当的接地连接。</p><p>为了应对串扰的负面影响，某些类型的铜缆将相反电路线对绞合在一起以有效消除串扰。</p><p>使用以下建议也可以限制电子噪音对铜缆的影响：</p><ul><li>选择的电缆类型或类别要适合特定的网络环境。</li><li>设计电缆基础设施时应规避建筑结构中已知和潜在的干扰源。</li><li>使用包括正确处理和端接电缆的布线技术。</li></ul><p>UTP非屏蔽双绞线 Unshielded twisted-pair </p><p>最常用的网络介质。通过 RJ-45 连接器端接的 UTP 布线用于<strong>网络主机与中间网络设备的互连</strong>，例如交换机和路由器。四对用颜色标记的电线组成</p><p>STP屏蔽双绞线 Shielded twisted-pair</p><p>比 UTP 布线提供更好的噪声防护。但是，与 UTP 电缆相比，STP 电缆更加昂贵而且不易安装。和 UTP 相同，STP 也使用 RJ-45 连接器。为了充分利用屏蔽的优势，STP 电缆使用特殊屏蔽 STP 数据连接器进行端接。如果电缆接地不正确，屏蔽就相当于一个天线，会接听多余信号。</p><p>多了金属编制和金属箔</p><p>Coaxial cable</p><p>同轴电缆，或简称同轴，由于它的两根导线共享同一个中轴而得名</p><p>同轴电缆使用许多不同类型的连接器</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314182735686.png" alt="image-20210314182735686"></p><p>虽然 UTP 电缆在现代以太网安装中最终取代了同轴电缆，但在以下情形中仍采用同轴电缆设计：</p><ul><li><strong>无线安装</strong> - 用同轴电缆将<strong>天线连接到无线设备</strong>。同轴电缆可传送天线和无线电设备之间的射频 (RF) 能量。</li><li><strong>有线电视互联网安装</strong> - 有线电视服务提供商为其客户提供互联网连接，他们会使用光缆替换同轴电缆和支撑放大元件部分。但是，<strong>客户所在地的布线</strong>仍采用同轴电缆。</li></ul><h2 id="UTP布线"><a href="#UTP布线" class="headerlink" title="UTP布线"></a>UTP布线</h2><p>标准规定了一些要素</p><ul><li>电缆类型</li><li>电缆长度</li><li>连接器</li><li>电缆端接</li><li>测试电缆的方法</li></ul><p>IEEE 按照它的性能对 UTP 布线划分等级。电缆分类的依据是它们承载更高速率带宽的能力。例如，5类电缆通常用于 100BASE-TX 快速以太网安装。其他类别包括增强型 5类电缆、6类电缆 和 6a 类电缆。</p><p>为了支持更高的数据传输速率，人们设计和构造了更高类别的电缆。随着新的千兆位以太网技术的开发和运用，如今已经很少采用 5e 类电缆，新建筑安装推荐使用 6 类电缆。</p><p>-3 类电缆最初用于语音线路的语音通信，但后来用于数据传输。 -5 类和5e 类电缆用于数据传输。5类电缆支持 100Mbps，5e 类电缆支持 1000 Mbps -6类电缆在每对线之间增加了一个分隔器以支持更高的速度。 6类电缆支持高达 10 Gbps。 -7类电缆也支持 10 Gbps。 -8类电缆支持 40 Gbps。</p><p>UTP 电缆的端头通常为 RJ-45 连接器。TIA/EIA-568 标准描述为以太网电缆进行引脚分配（引出线）的电线颜色标记。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200028243.png" alt="image-20210314200028243"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200013783.png" alt="image-20210314200013783"></p><p>直通和交通</p><ul><li><strong>以太网直通电缆</strong> -最常见的网络电缆类型。它通常用于主机到交换机和交换机到路由器的互连。</li><li><strong>以太网交叉电缆</strong> -用于互连相似设备的电缆。例如，交换机到交换机、主机到主机或路由器到路由器的连接。但是，由于网卡使用介质相关接口交叉（auto-MDIX）来自动检测电缆类型并进行内部连接，因此现在已将交叉电缆视为传统电缆。</li><li>但是主机链接路由器竟然也是用交叉线！</li></ul><p><strong>注意</strong>: 另一种类型的电缆是思科专有的全反电缆。它用于连接路由器或交换机的控制台端口。</p><p>在设备间错误使用交叉电缆或直通电缆不会损坏设备，但也无法连通设备并进行通信</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200350348.png" alt="image-20210314200350348"></p><table><thead><tr><th align="left">电缆类型</th><th align="left">标准</th><th align="left">应用</th></tr></thead><tbody><tr><td align="left">以太网直通线</td><td align="left">两端均为 T568A 或两端均为 T568B</td><td align="left">将网络主机连接到交换机或集线器之类的网络设备</td></tr><tr><td align="left">以太网交叉线</td><td align="left">一端为 T568A，另一端为 T568B</td><td align="left">连接两个网络主机或连接两台网络中间设备 （交换机到交换机或路由器到路由器）</td></tr><tr><td align="left">全反电缆</td><td align="left">思科专有</td><td align="left">使用适配器连接工作站串行端口与路由器 控制台端口。</td></tr></tbody></table><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><ul><li>单模光纤 (SMF) Single-mode fiber</li><li>多模光纤 (MMF) Mulitimode fiber</li></ul><p>单模光纤包含一个极小的芯，使用昂贵的激光技术来发送单束光，如图所示。单模光纤在跨越数百公里的长距离传输情况下很受欢迎，例如应用于长途电话和有线电视中的光纤。</p><p>多模光纤包含一个稍大的芯，使用 LED 发射器发送光脉冲。具体而言，LED 发出的光从不同角度进入多模光纤，t有多条光路，普遍用于 LAN 中，因为它们可以由低成本的 LED 提供支持。它可以通过长达 550 米的链路提供高达 10 Gb/s 的带宽。</p><p>多模和单模光纤之间的主要区别之一就是色散的数量。色散是指光脉冲在时间上的分布。色散增加意味着信号强度损失增加。多模光纤具有比单模光纤更大的色散。这就是为什么多模光纤在信号丢失之前只能传播 500 米。</p><ul><li><strong>企业网络</strong> - 用于主干布线和基础设施设备互连。</li><li><strong>光纤到户 (FTTH)</strong> - 用于为家庭和小型企业提供不间断宽带服务。</li><li><strong>长距离传输网络</strong> - 由服务提供商用于连接国家/地区与城市。</li><li><strong>水下有线网络</strong> - 用于提供可靠高速、高容量的网络解决方案，使其在深度与横跨海洋的距离相当的严酷海下环境中仍能生存。在互联网上搜索“海底电缆电信地理地图”，以在线查看各种地图。</li></ul><p>连接器：</p><p>直通式ST Straight-tip</p><p>用户连接器SC Subscriber Connector</p><p>朗讯连接器LC单工 Lucent Connector Simplex Connectors</p><p>双工多模LC连接器 Duplex Multimode</p><p>直到最近，光还只能在光纤上沿一个方向传播。因此，需要两根光纤来支持全双工操作。因此，光纤跳线是将两根光纤线缆捆绑在一起，并通过一对标准的单光纤接头端接。有些光纤连接器可以在单个连接器上同时传送和接收光纤，称为双工连接器，其实就是连接了俩线</p><p>需要使用光纤接插线（即光纤跳线）互连基础设施设备。人们使用不同颜色来区分单模和多模接插线。黄色表皮的是单模光缆，橙色（或浅绿色）的是多模光缆。</p><p>有SC-SC多模  LC-LC 单模 ST-LC多模 SC-ST单模 。。。</p><h2 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h2><p>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。</p><p>以下是无线网络的一些局限性:</p><ul><li><strong>覆盖面积</strong> - 无线数据通信技术非常适合开放环境。但是，在楼宇和建筑物中使用的某些建筑材料以及当地地形将会限制它的有效覆盖。</li><li><strong>干扰</strong> - 无线电易受干扰，可能会受到家庭无绳电话、某些类型的荧光灯、微波炉和其他无线通信装置等常见设备的干扰。</li><li><strong>安全性</strong> - 无线通信覆盖无需进行介质的物理接线。因此，未获得网络访问授权的设备和用户可以访问传输。所以网络安全是无线网络管理的重要组成部分。</li><li><strong>共享介质</strong> - WLAN 以半双工模式运行，意味着一台设备一次只能发送或接收。无线介质由所有无线用户共享。许多用户同时访问WLAN会导致每个用户的带宽减少。</li></ul><p>标准规定了：</p><ul><li>数据到无线电信号编码</li></ul><ul><li>传输频率和功率</li><li>信号接收和解码要求</li><li>天线的设计和施工</li></ul><p>这些是无线标准：</p><ul><li><strong>Wi-Fi (IEEE 802.11)</strong> - 无线 LAN (WLAN) 技术，通常称为 Wi-Fi。WLAN 使用一种称为“载波侦听多路访问/冲突避免 (CSMA/CA)”的争用协议。无线 NIC 在传输数据之前必须先侦听，以确定无线信道是否空闲。如果其他无线设备正在传输，则 NIC 必须等待信道空闲。Wi-Fi 是 Wi-Fi 联盟的标记。Wi-Fi 与基于 IEEE 802.11 标准的认证 WLAN 设备结合使用。</li><li><strong>蓝牙 (IEEE 802.15)</strong> - 这是一个无线个人局域网 (WPAN) 标准，通常称为 “蓝牙”。它采用设备配对过程进行通信，距离为 1 到 100 米。</li><li><strong>WiMAX (IEEE 802:16)</strong> - 通常称为微波接入全球互通 (WiMAX)，这个无线标准采用点到多点拓扑结构，提供无线带宽接入。</li><li><strong>Zigbee (IEEE 802.15.4)</strong> - Zigbee是一种用于低数据速率、低功耗通信的规范。它适用于需要短距离、低数据速率和长电池寿命的应用。Zigbee 通常用于工业和物联网 (IoT) 环境，如无线照明开关和医疗设备数据采集。</li></ul><p>WLAN 要求具备下列网络设备：</p><ul><li><strong>无线接入点 (AP) Wireless Access Point</strong> - 集中用户的无线信号，并连接到现有基于铜介质的网络基础设施，如以太网。如图所示，家庭和小型企业无线路由器将路由器、交换机和接入点的功能整合到了一起。</li><li><strong>无线网卡适配器Wireless NIC adapters</strong> - 能够为每台网络主机提供无线通信</li></ul><p>以太网网卡用于有线连接，而 WLAN（无线局域网）网卡用于无线连接。</p><h1 id="数制系统"><a href="#数制系统" class="headerlink" title="数制系统"></a>数制系统</h1><p>IPV4每一个地址包含一串 32 位字符串，并分为四个部分，称为二进制八位组。每一个二进制八位组包含 8 位（或 1 个字节），用句点分隔。IPv4 地址通常表达为点分十进制记法</p><p>十六进制数制系统在网络中用于表示以太网 MAC 地址和 IP V6 地址。</p><p>IPv6地址长度为128位，每 4 位以一个十六进制数字表示，共 8组32 个十六进制值。IPv6 地址不区分大小写，可用大写或小写书写。首选格式为<code> x:x:x:x:x:x:x:x</code>，</p><p>每个“x”称为一个十六进制数，包括四个十六进制值</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>与 TCP/IP 的上层协议不同，数据链路层协议通常不是由征求意见 (RFC) 文档定义的。互联网工程任务组 (IETF) 虽然维护着 TCP/IP 协议簇上层的工作协议和服务，但它没有定义TCP/IP模型的网络接入层的功能和操作。</p><p>定义适用于网络接入层（即，OSI的物理和数据链路层）的开放标准和协议的工程组织包括：</p><ul><li>电气电子工程师协会 (IEEE)</li><li>国际电信联盟 (ITU)</li><li>国际标准化组织 (ISO)</li><li>美国国家标准学会 (ANSI)</li></ul><p>OSI模型的数据链路层(第2层)为物理网络准备网络数据。数据链路层负责网络接口卡 (NIC) 到网络接口卡的通信。数据链路层执行以下操作：</p><ul><li>允许上层访问介质。上层协议完全不知道用于转发数据的介质类型。</li><li>接受数据，通常是第 3 层数据包（即 IPv4 或 IPv6），并将它们封装到第 2 层帧中。</li><li>控制数据在介质上的放置和接收方式，</li><li>通过网络介质在终端之间交换帧。</li><li>接收封装的数据，通常是第 3 层数据包，并将它们定向到适当的上层协议。</li><li>执行错误检测并拒绝任何损坏的帧。</li></ul><p>如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。此外，每当开发出一种新的网络技术或介质时，IP 必须做出相应调整。而这些交给数据链路层来考虑，IP只需考虑更加抽象的架构</p><h2 id="IEEE-802-LAN-MAN"><a href="#IEEE-802-LAN-MAN" class="headerlink" title="IEEE 802 LAN/MAN"></a>IEEE 802 LAN/MAN</h2><p>IEEE 802 LAN/MAN 标准专用于以太网局域网、无线局域网 (WLAN)、无线个人区域网 (WPAN) 和其他类型的局域网和城域网。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：</p><ul><li><strong>逻辑链路控制 (LLC)</strong> - 这个 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。<strong>它放入帧中的信息用于确定帧所使用的网络层协议</strong>。此信息<strong>允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</strong>不必让每个协议自己研究这些</li><li><strong>介质访问控制 (MAC)</strong> - 在硬件上实现这个子层（IEEE 802.3、802.11 或 802.15）。它负责数据<strong>封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</strong></li></ul><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314205917487.png" alt="image-20210314205917487"></p><p>LLC 子层获取网络协议数据（通常是 IPv4 或 IPv6数据包）并加入第2层控制信息，帮助将数据包传送到目的节点。 </p><p>MAC子层控制网卡和负责在有线或无线LAN/MAN介质上发送和接收数据的其他硬件。</p><p>MAC 子层提供数据封装：</p><ul><li><strong>帧定界</strong> - 在成帧过程中提供重要的定界符，用来标识帧中的字段。这些定界符位可以在发送节点与接收节点之间提供同步。</li><li><strong>编址</strong> - 提供源和目的编址，用于在同一共享介质上的设备之间传输第 2 层帧。</li><li><strong>错误检测</strong> - 包含一个帧尾，用于检测传输错误。</li></ul><p>MAC 子层还提供介质访问控制，允许多个设备通过共享（半双工）介质进行通信。全双工通信不需要访问控制。</p><h2 id="介质访问"><a href="#介质访问" class="headerlink" title="介质访问"></a>介质访问</h2><p>在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。例如，以太网 LAN 通常由许多争用网络介质访问的主机组成。MAC 子层解决了这个问题。对于串行链路，访问方法可能只包括两个设备之间的直接连接，通常是两个路由器。因此，它们不需要 IEEE 802 MAC 子层所使用的技术。</p><p>路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p><p>在路径上的每一跳，路由器都执行以下第 2 层功能：</p><ol><li>从介质接受帧</li><li>解封帧</li><li>将数据包重新封装到新帧中</li><li>从适合该物理网络网段的介质转发新帧</li></ol><h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><ul><li><strong>物理拓扑</strong> - 标识物理连接，以及终端设备和中间设备（即，路由器、交换机和无线接入点）如何互连。这个拓扑还可能包括特定的设备位置，如房间号和设备机架上的位置。物理拓扑通常是点对点拓扑或星型拓扑。</li><li><strong>逻辑拓扑</strong> - 是指网络将帧从一个节点传输到另一节点的方法。此拓扑使用<strong>设备接口和<em>第 3 层</em> IP 寻址方案识别虚拟连接。</strong></li></ul><p>在控制对介质的数据访问时，数据链路层“看见”的是网络的逻辑拓扑。正是逻辑拓扑在影响网络成帧和介质访问控制的类型。</p><p><strong>WAN拓扑</strong></p><p>点对点：在这种布局中，两个节点无需与其他主机共享介质。此外，当使用串行通信协议，如点对点协议(PPP)时，节点无需判定收到的帧是指向它还是指向另一节点。因此，逻辑数据链路协议将非常简单，因为介质中的所有帧都只去往或来自这两个节点。节点将帧放置到一端的介质上，然后点对点线路另一端的节点从介质取走帧。<br><strong>在网络中使用物理设备并不会影响逻辑拓扑</strong></p><p>中心辐射：这是星型拓扑的 WAN 版本，在该拓扑中一个中心站点使用点对点链路互连分支机构站点。如果不经过中心站点，分支站点就不能与其他分支站点交换数据。</p><p>网状：该拓扑可用性高，但要求每个终端系统都与其他各个系统互连。因此管理成本和物理成本都会非常高。每条链路实质上是另一节点的点对点链路。</p><p>混合拓扑（任意拓扑的变体和组合）</p><p><strong>LAN拓扑</strong></p><p>在多路访问局域网中，终端设备（即节点）使用星型或扩展星型拓扑相互连接，如图所示。在这种类型的拓扑中，终端设备连接到一个中央中间设备，在本例中是一个以太网交换机。扩展星型（<strong>扩展星型</strong>）通过连接多个以太网交换机来扩展此拓扑。星型和扩展星型拓扑安装简单、扩展性好（易于添加和删除终端设备），而且故障排除容易。早期的星型拓扑使用以太网集线器互连终端设备。</p><p><strong>传统LAN拓扑</strong></p><p>早期的以太网和传统令牌环局域网技术包括另外两种拓扑结构:</p><ul><li><strong>总线</strong> - 所有终端系统都相互连接，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。传统的以太网络中会使用采用同轴电缆的总线拓扑，因为它价格低廉而且安装简易。</li><li><strong>环</strong> - 终端系统与其各自的邻居相连，形成一个环状。与总线拓扑不同，环拓扑不需要端接。传统的光纤分布式数据接口 (FDDI) 和令牌环网络使用环拓扑。</li></ul><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314211820357.png" alt="image-20210314211820357"></p><p><strong>半双工</strong></p><p>两台设备都可以通过该介质发送和接收，但无法同时执行这两个操作。WLAN和带有以太网集线器的传统总线拓扑使用半双工模式。</p><p><strong>全双工</strong></p><p>两台设备都可以在共享介质上同时发送和接收，现代Ethernet</p><p>双工不匹配会导致效率严重下降！重要错误</p><h2 id="访问控制方法"><a href="#访问控制方法" class="headerlink" title="访问控制方法"></a>访问控制方法</h2><p>多路访问网络是指可能有两个或多个终端设备同时试图访问网络的网络。</p><p>以太网 LAN 和 WLAN 都是多路访问网络的示例</p><p>对于共享介质，有两种基本的访问控制方法：</p><ul><li>基于竞争的访问</li><li>受控访问</li></ul><p><strong>受控访问</strong></p><p>在基于控制的多路访问网络中，每个节点都有自己的时间来使用介质。这种确定性的传统网络类型效率很低，因为设备必须等到轮到自己才能访问介质。使用受控访问的多路访问网络的示例包括：</p><ul><li>传统令牌环</li><li>传统ARCNET</li></ul><p><strong>基于竞争的访问</strong></p><p>在基于竞争的多路访问网络中，所有节点都工作在半双工方式，争夺介质的使用。然而，一次只有一台设备能够发送。因此，当多台设备同时传输时，会使用一个处理过程。基于竞争的访问方法示例如下：</p><ul><li>在<strong>传统总线拓扑/使用集线器的以太网局域网</strong>上使用载波侦听多路访问/冲突检测(CSMA/CD)</li><li>在<strong>无线局域网</strong>上使用载波侦听多路访问/冲突避免(CSMA/CA)</li></ul><p><em>基于竞争的系统在介质使用率高的情况下都无法很好地扩展。</em></p><p><strong>CSMA/CD</strong></p><p>如果两台设备同时传输，则会发生冲突。对于传统以太网局域网，两台设备将会检测到网络上的冲突。这就是 CSMA/CD 的冲突检测 (CD) 部分。网卡通过比较传输的数据与接收的数据，或通过识别介质中的信号振幅是否高于正常状况来实现。两台设备发送的数据会损坏且需重新发送。</p><p>集线器例子：</p><p>在没有载波信号时，假定网络可用，A发送给B，帧首先到集线器，然后从所有端口发送，由于帧拥有 PC3 的目的数据链路地址，只有该设备会接受并被全帧复制。所有其他设备的网卡都将忽略该帧</p><p>它还提供了一种回退重传算法。</p><p><strong>CSMA/CA</strong></p><p>在无线环境中，设备可能无法检测到冲突。CMSA/CA 不检测冲突，但会通过在传输之前等待来尝试避免冲突。每台设备发送时都会包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有久不可用。</p><p><em><strong>注意: 使用交换机的以太网 LAN 不使用基于竞争的系统，因为交换机和主机网卡在全双工模式下运行</strong></em></p><h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><p>附加到帧的信息由正在使用的协议决定。</p><p>数据链路协议负责同一网络中的网卡间通信。虽然有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有三个基本组成部分：</p><ul><li>帧头</li><li>数据</li><li>帧尾</li></ul><p>没有一种帧结构能满足通过所有类型介质的全部数据传输需求。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。例如，WLAN帧必须包含避免冲突的过程，因此与以太网帧相比需要额外的控制信息。在脆弱的环境下，需要更多控制才能确保送达。由于所需控制信息较多，因此帧头和帧尾字段都较大。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213324158.png" alt="image-20210314213324158"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213352540.png" alt="image-20210314213352540"></p><p><em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p><p>在 TCP/IP 网络中，所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用。但是，所用的第 2 层协议取决于逻辑拓扑和物理介质。</p><p>每个协议执行指定第 2 层逻辑拓扑的介质访问控制。这意味着在执行这些协议时，有很多种不同的网络设备都可以充当运行在数据链路层上的节点。这些设备包括计算机上的网卡以及路由器和第 2 层交换机上的接口。</p><p>用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。所使用的技术取决于网络规模（根据主机数量和地理范围判断）以及通过网络提供的服务。</p><p>带宽差异常会导致 LAN 和 WAN 使用不同的协议。</p><p>数据链路层协议包括：</p><ul><li>以太网</li><li>802.11 无线</li><li>点对点协议 (PPP)</li><li>高级数据链路控制 (HDLC) High-Level Data Link Control</li><li>帧中继 Frame Relay</li></ul><h1 id="以太网交换"><a href="#以太网交换" class="headerlink" title="以太网交换"></a>以太网交换</h1><p>以太网是如今广泛使用的两种局域网技术之一，另一种是无线局域网（WLAN）。它使用有线通信，包括双绞线、光纤链路和同轴电缆。</p><p>以太网在数据链路层和物理层运行，是 IEEE 802.2 和 802.3 标准中定义的一系列网络技术。（无线是802.11）</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214332628.png" alt="image-20210314214332628"></p><p>以太网也使用802 LAN/MAN协议的俩子层</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214654631.png" alt="image-20210314214654631"></p><h2 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h2><p>MAC 子层负责数据封装和访问介质。</p><p><strong>数据封装</strong></p><p>IEEE 802.3 数据封装包括以下内容：</p><ul><li><strong>以太网帧</strong> - 这是以太网帧的内部结构。</li><li><strong>以太网寻址</strong> - 以太网帧中包含源和目的MAC 地址，用于将该以太网帧从以太网网卡传送到<strong>同一LAN</strong>上的以太网网卡。</li><li><strong>以太网错误检测</strong> - 以太网帧中包含用于错误检测的帧校验序列 (FCS) 帧尾。</li></ul><p>它也负责使用CSMA/CD and CSMA/CA技术</p><h2 id="以太网帧字段"><a href="#以太网帧字段" class="headerlink" title="以太网帧字段"></a>以太网帧字段</h2><p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。在描述帧的大小时，不包含“前导码”字段。</p><p>任何长度小于 64 个字节的帧都被接收站点视为“冲突碎片”或“残帧”而自动丢弃。超过 1500 个字节的数据帧被视为“巨帧”或“小型巨型帧”。</p><p>如果发送的帧小于最小值或者大于最大值，接收设备将会丢弃该帧。帧之所以被丢弃，可能是因为冲突或其他多余信号。它们被视为无效。大多数快速以太网和千兆以太网交换机和网卡通常都支持巨帧。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214944369.png" alt="image-20210314214944369"></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">前导码和帧首定界符字段</td><td align="left">前导码（Preamble）（7 字节）和帧首定界符(Start Frame Delimiter)（SFD），也称为 帧首（1 字节），该字段用于发送设备 与接收设备之间的同步。帧开头的八个字节 用于引起接收节点的注意。基本上，前几个字节的 作用是告诉接收方准备接收新帧。</td></tr><tr><td align="left">目的 MAC 地址字段</td><td align="left">该 6 字节字段是预期接收方的标识符。读者应该还记得， 此地址被第2层用来协助设备 确定帧是否发送到目的地。帧中的地址将会与设备中的 MAC 地址进行比对。如果匹配， 设备就接受该帧。可以是单播、组播或广播 地址。</td></tr><tr><td align="left">源 MAC 地址字段</td><td align="left">该 6 字节字段标识发出帧的网卡 或接口。</td></tr><tr><td align="left">类型/长度</td><td align="left">该字段包含两个字节，<strong>标识封装于以太网帧中的 上层协议</strong>。常见值为十六进制，0x800 用于 IPv4， 0x86DD 用于 IPv6，0x806 用于 ARP。 <strong>注意</strong>：您也可能会看到此字段称为 EtherType、类型或长度。</td></tr><tr><td align="left">数据字段</td><td align="left">该字段（46-1500 字节）包含来自 较高层的封装数据，一般是第3层PDU。最常见是IPv4 数据包。所有帧至少必须有 64 个字节。<strong>如果封装的是小数据包， 则使用填充位将帧增大到最小值</strong>。</td></tr><tr><td align="left">帧校验序列字段</td><td align="left">“帧校验序列 (Frame Check Sequence)(FCS)”字段（4 个字节）用于检测帧中 的错误。它使用循环冗余校验 (CRC)。发送设备 在帧的 FCS 字段中包含 CRC 的结果。接收设备 接收帧并生成 CRC 以查找 错误。如果计算匹配，就不会发生错误。计算 不匹配则表明数据已经改变。因此， 帧会被丢弃。数据的变化可能是 由于代表比特位的电信号受到干扰所致。</td></tr></tbody></table><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>在以太网中，每台网络设备都连接到同一个共享介质。MAC 地址用于标识本地网段上的物理源和目的设备。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。</p><p>以太网 MAC 地址是使用 <strong>12个十六进制数字</strong>表示的 48 位地址，因为一个字节等于 8 位，我们也可以说 一个MAC 地址长度为 6 个字节。</p><p>所有 MAC 地址对于以太网设备或以太网接口必须是唯一的。<br>为了确保这一点，所有销售以太网设备的供应商必须向 IEEE 注册才能获得唯一的 6个十六进制（即 24 位或 3 字节）代码，称为组织唯一标识符 (OUI)。（Organization unique identifier）</p><p>当供应商为设备或以太网接口分配 MAC 地址时，供应商必须执行以下操作：</p><ul><li>使用其分配的 OUI 作为前 6 个十六进制数字。</li><li>为后 6 个十六进制数字分配唯一值。</li></ul><p>OUI查询网址：<a href="http://standards-oui.ieee.org/oui/oui.txt">http://standards-oui.ieee.org/oui/oui.txt</a></p><p>供应商有责任确保其设备不被分配相同的 MAC 地址。但是，由于制造过程中出现的错误、某些虚拟机部署方式中的错误或使用多种软件工具之一进行的修改，可能存在重复的 MAC 地址。若出现以上任一情况，必须在新网卡或软件中修改 MAC 地址。</p><p>MAC 地址通常称为烧录地址(Built-in Address) (BIA)，因为传统上该地址被烧录到网卡的只读存储器（ROM）中。这意味着该地址会永久编码到 ROM 芯片中。</p><p><strong>注意</strong>: 在现代 PC 操作系统和网卡中，可以在软件中更改MAC 地址。当试图访问基于 BIA 进行过滤的网络时，这一点非常有用。因此，根据 MAC 地址来过滤或控制流量就不再安全了。</p><p>当计算机启动时，网卡将 MAC 地址从 ROM 复制到 RAM 中</p><p>收到以太网帧时，网卡会查看帧中的目的 MAC 地址是否与设备 RAM 中存储的物理 MAC 地址匹配。如果不匹配，设备就会丢弃帧。如果与帧中的目的 MAC 匹配，则网卡会将帧向上传送到 OSI 层进行解封处理。</p><p><em><strong>单播，广播，组播MAC地址</strong></em></p><p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p><p>以太网单播 MAC 地址是帧从一台发送设备去往一台目的设备时使用的唯一地址</p><p>源主机用来确定目的IPv4地址所对应的目的 MAC 地址的流程称为**地址解析协议 (ARP)<strong>。源主机用来确定目的IPv6地址所对应的目的 MAC 地址的流程称为</strong>邻居发现 (ND)**。（参看TCP/IP）</p><p>以太网广播帧由以太网LAN上的每个设备接收和处理。以太网广播的功能如下：</p><ul><li>它有一个十六进制（在二进制中是 48 个 1）FF-FF-FF-FF-FF-FF的<strong>目的 MAC</strong> 地址。</li><li>它向除输入端口以外的所有以太网交换机端口泛洪。</li><li><strong>路由器不会转发该帧</strong>。</li></ul><p>IPv4 的 DHCP 是使用以太网和 IPv4 广播地址的一个协议示例。</p><p>以太网组播帧由属于同一组多播组的以太网LAN上的一组设备接收和处理。以太网组播的功能如下：</p><ul><li>当封装数据为IPv4组播包时，目的MAC地址为01-00-5E;<br>当封装数据为IPv6组播包时，目的MAC地址为33-33。</li><li>当封装的数据不是IP时，还有其他预留的组播目的MAC地址，<br>如生成树协议Spanning Tree Protocol(STP)和链路层发现协议Link Layer Discovery Protocol(LLDP)。</li><li>除非交换机被配置为用于组播窥探multicast snooping，否则它将向除传入端口之外的所有以太网交换机端口泛洪flooded out。</li><li>它不会由路由器转发，除非路由器配置为路由组播数据包。</li></ul><p>如果封装的数据是一个IP组播包，则属于组播组的设备都分配有该组播组IP地址。IPv4 组播地址的范围为 224.0.0.0 到 239.255.255.255。IPv6 组播地址的范围以 ff00::/8 开头。由于组播地址代表一组地址（有时称为主机组），因此只能用作数据包的目的地址。源地址始终应为单播地址。</p><h2 id="MAC地址表"><a href="#MAC地址表" class="headerlink" title="MAC地址表"></a>MAC地址表</h2><p>现在就该讨论交换机如何使用这些地址将帧转发(或丢弃)到网络上的其他设备。如果交换机只是转发出它接收到的每一帧到所有端口，您的网络将会非常拥挤，以至于它可能会完全停止工作。</p><p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，交换机仅根据第 2 层以太网 MAC 地址做出转发决策。这才实现了真正的分工和可复用</p><p>一个以太网交换机检查它的<strong>MAC地址表</strong>，为每个帧做出一个<strong>转发决策</strong>，不像传统的以太网集线器，向除了传入端口以外的所有端口重复发出比特位。</p><p><strong>注意</strong>: MAC 地址表有时也称为内容可寻址内存Content-addressable-memory (CAM) 表。虽然 CAM 表这一术语相当常见，但在本课程中，我们将称其为 MAC 地址表。</p><p><strong>学习Learn</strong></p><p>进入交换机的每个帧被检查，以确定其中是否有可被学习的新信息。它是通过检查帧的源 MAC 地址和帧进入交换机的端口号来完成这一步的。如果源 MAC 地址在该网络不存在（就是来自另一局域网），会将其和传入端口号一并添加到表中。如果源 MAC 地址已存在表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</p><p><strong>注意</strong>: 如果源 MAC 地址已经保存在表中，但是对应的是不同的端口，那么交换机会将其视为一个新的条目。使用相同的 MAC 地址和最新的端口号来<strong>替换</strong>该条目。</p><p><strong>转发Forward</strong></p><p>如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。如果表中存在该目的MAC地址，交换机会从指定端口转发帧。如果表中不存在该目的MAC地址，交换机会从除传入端口外的所有端口转发帧。这称为未知单播。</p><p><strong>注意</strong>: 如果目的 MAC 地址为广播或组播，该帧也将被泛洪到除传入端口外的所有端口。</p><p>交换机是从不同的设备接收帧，因此它可以通过检查每个帧的源 MAC 地址来填充它的 MAC 地址表。如果MAC 地址表包含目的MAC 地址，则交换机将“滤过”该帧并将其从单个端口转发出去。</p><h2 id="交换机速率-转发方法"><a href="#交换机速率-转发方法" class="headerlink" title="交换机速率/转发方法"></a>交换机速率/转发方法</h2><p>对于思科交换机，实际上有两种帧转发的方法，根据具体情况，有充分的理由使用其中一种来代替另一种。</p><p>在过去，交换机使用下面的两种转发方法之一来进行网络端口间的数据交换：</p><ul><li><strong>存储转发交换</strong> - 这个帧转发的方法接收整个帧并计算CRC。CRC 根据帧中的比特位为 1 的位数量，使用数学公式来确定收到的帧是否有错。如果 CRC 有效，则交换机查找目的地址，目的地址决定了转发接口。帧然后从正确的端口转发出去。</li></ul><p>ps：<em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p><ul><li><strong>直通交换</strong> - 这种帧转发的方法在收到整个帧之前即转发帧。在可以转发帧之前，至少必须读取帧的目的地址。</li></ul><p><strong>存储转发交换</strong>的一大优点是，它可以在传播帧之前确定帧是否有错误。当在帧中检测到错误时，交换机丢弃该帧。丢弃有错的帧可减少损坏的数据所耗用的带宽量。存储转发交换对于融合网络中的服务质量 (QoS) 分析是必需的，在融合网络中，必须对帧进行分类以划分流量优先级。如 IP 语音数据流的优先级需要高于 Web 浏览流量。</p><p><strong>直通交换</strong>中，交换机在收到数据时立即处理数据，即使传输尚未完成。交换机只缓冲帧的一部分，缓冲的量仅足以读取目的 MAC 地址，以便确定转发数据时应使用的端口。目的 MAC 地址位于帧中前导码后面的前 6 个字节。交换机在其交换表中查找目的 MAC 地址，确定转发端口，然后通过指定的交换机端口将帧转发到其目的地。交换机对该帧不执行任何错误检查。</p><ul><li><strong>快速转发交换 -</strong> 快速转发交换提供最低程度的延时。快速转发交换在读取目的地址之后立即转发数据包。由于快速转发交换在收到整个数据包之前就开始转发，因此有时候中继数据包时会出错。这种情况并不经常发生，而且目的网络适配器在收到含错数据包时会将其丢弃。在快速转发模式下，延时是指从收到第一个位到传出第一个位之间的时间差。快速转发交换是典型的直通交换方法。<strong>Fast-forward switching</strong></li><li><strong>免分片交换 -</strong> 在免分片交换中，交换机在转发之前存储帧的前 64 个字节，原因是，大部分网络错误和冲突都发生在前 64 个字节。免分片交换在转发帧之前对帧的前 64 个字节执行小错误检查以确保没有发生过冲突，并且尝试通过这种方法来增强快速转发交换功能。免分片交换是存储转发交换的高延时和高完整性与快速转发交换的<strong>低延时和弱完整性之间的折衷</strong>。<strong>Fragment-free switching</strong></li></ul><p>某些交换机可配置为按端口执行直通交换，当达到用户定义的错误阈值时，这些端口自动切换为存储转发。当错误率低于该阈值时，端口自动恢复到直通切换。（牛啊！）</p><p>以太网交换机在转发帧之前，可以使用<strong>缓冲技术</strong>存储帧。当目的端口由于拥塞而繁忙时，也可以使用缓冲。交换机将帧存储起来，直到可以传输。</p><p>有两种内存缓冲方法：</p><table><thead><tr><th align="left">方法(………)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>基于端口的内存</strong></td><td align="left">帧存储在链接到特定传入端口和传出 端口的队列中。只有当队列前面的所有帧都成功传输后， 才会将帧传输到传出端口。由于目地端口繁忙， 单个帧可能会造成内存中所有帧的传输延迟。即使其他帧可以传送到开放的目的端口， 这种延迟仍然会发生。</td></tr><tr><td align="left"><strong>共享内存</strong></td><td align="left">将所有帧存储到由所有交换端口共享的公共内存缓冲区中， 并且动态分配一个端口所需的 缓冲区内存量。缓冲区中的帧动态地链接到目的端口， 允许在一个端口上接收数据包，然后 在另一个端口上发送，而无需移动到另一个队列。</td></tr></tbody></table><p>而且<strong>共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少</strong>。这对于非对称交换非常重要，因为它允许在不同端口上使用<strong>不同的数据速率</strong>，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p><p>交换机上最基本的两个设置是带宽(有时称为“速率”)和每个交换机端口的双工设置。交换机端口和连接的设备（例如计算机或另一台交换机）的双工设置和带宽设置必须匹配。</p><p>自动协商是大多数以太网交换机和网卡的一项可选功能。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。</p><p><strong>注意</strong>: 大多数思科交换机和以太网网卡默认采用自动协商功能，以提高速率和实现双工。千兆以太网端口仅以全双工模式运行。</p><p>当链路上的一个或两个端口被重置时，会发生双工不匹配，自动协调过程并不会使链路上的两个端口的配置相同。当用户重新配置链路的一端而忘记重新配置另一端时，也会出现这样的情况。链路的两端均应都使用或都不使用自动协商。最佳实践是将两个以太网交换端口都配置为全双工。</p><h2 id="Auto-MDIX"><a href="#Auto-MDIX" class="headerlink" title="Auto-MDIX"></a>Auto-MDIX</h2><p>现在，大多数交换机设备都支持自动介质相关接口交叉 (auto-MDIX) 功能。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。因此，如果要连接到交换机上的铜缆 10/100/1000 端口，您既可以使用交叉线，也可以使用直通线，而无需考虑连接另一端的设备类型。</p><p>在运行思科 IOS Release 12.2(18)SE 或更高版本的交换机上，默认启用 auto-MDIX 功能。当然，该功能可以被禁用。因此，您应始终使用正确的线缆类型，而不是依赖auto-MDIX 功能。Auto-MDIX 可以使用接口配置命令 <strong>mdix auto</strong> 重新启用。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>要向不在本地网络上的任何人发送电子邮件（视频或文件等），您必须能够访问路由器。要访问路由器，您必须使用网络层协议。</p><h2 id="网络层特征"><a href="#网络层特征" class="headerlink" title="网络层特征"></a>网络层特征</h2><p>网络层即 OSI 第 3 层，提供能够<em><strong>让终端设备跨整个网络交换数据的服务</strong></em></p><p>IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括路由协议，如开放式最短路径优先协议(OSPF)，和消息传递协议，如Internet控制消息协议(ICMP)。</p><p>为了实现跨网络边界的端到端通信，网络层协议执行四个基本操作:</p><ul><li>**终端设备编址 - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li><li>**封装 - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</li><li>**路由 - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是<strong>为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由</strong>。数据包可能需要经过很多路由器才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</li><li>**解封 - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</li></ul><p>传输层（OSI 第 4 层）负责管理每台主机上的运行进程之间的数据传输，而网络层通信协议（即，IPv4和IPv6）则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。网络层工作时<strong>无需考虑每个数据包中所携带的数据</strong>，这使其能够为多台主机之间的多种类型的通信传送数据包</p><p><strong>逐层封装数据的流程使我们可以开发和扩展位于不同层的服务而不影响其他层</strong>。这意味着传输层数据段可以随时通过 IPv4 或 IPv6 进行封装，或使用未来可能开发出的任何新协议进行封装。</p><p>从数据包离开源主机到达目的主机之前，IP编址信息保持不变，除非是由为IPv4执行网络地址转换(NAT)的设备进行转换。</p><p><em><strong>IP的基本特征</strong></em></p><p>IP 被设计为一种<strong>低开销</strong>协议。它只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。并不负责跟踪和管理数据包的流动。这些功能（如果需要）将由其他层的其他协议（主要是第 4 层的 TCP）执行。</p><p>IP的基本特征：</p><ul><li><strong>无连接</strong> - 发送数据包前不与目的地建立连接。IP 在转发数据包前，并不需要初步交换控制信息来创建端到端连接。</li><li><strong>尽力而为</strong> - IP本质上是<strong>不可靠</strong>的，因为不保证数据包交付。IP 也不需要报头中包含其他字段来维持建立的连接。此过程显著降低了 IP 的开销。但是，由于没有预先建立端到端连接，发送数据包时，发送方不知道目的地是否存在和正常运行，同时发送数据包时，也不会知道目的地是否接收数据包，或者，目的设备是否可以访问并读取数据包。确认由其他协议负责</li><li><strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。如果数据包顺序错乱或丢失，则使用数据或上层服务的应用程序必须解决这些问题。这让 IP 可以非常有效地发挥作用。在 TCP/IP 协议簇中，可靠性是TCP协议在传输层的功能。IP 数据包既可以作为电信号通过铜缆传送，也可以作为光信号通过光纤传送或作为无线电信号无线传送。</li></ul><p>但是，网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (MTU)。数据链路层和网络层之间的部分控制通信就是确定数据包的最大尺寸<strong>。数据链路层将 MTU 值向上传送到网络层</strong>。网络层会由此确定可以传送的数据包的大小。</p><p>有时，中间设备（通常是路由器），在将IPv4数据包从一个介质转发到具有更小 MTU 的介质时，必须分割数据包。此过程称为数据包分片或分片。<strong>分片会导致延迟。IPv6 数据包不能被路由器分片。</strong></p><p>OSI传输层发送被封装在IPv4或IPv6包中的数据段</p><p>OSI数据链路层负责接收数据包并准备数据包以在通信介质上传输</p><h2 id="IPv4数据包"><a href="#IPv4数据包" class="headerlink" title="IPv4数据包"></a>IPv4数据包</h2><p>IPv4 是主要网络层通信协议之一。IPv4 数据包报头用于确保此数据包在到达目的地终端设备的路上被传递到其下一站。</p><p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233828847.png" alt="image-20210314233828847"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233849824.png" alt="image-20210314233849824"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314234312571.png" alt="image-20210314234312571"></p><p>其他字段用于重新排列分段的数据包。具体而言，IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段。路由器从一种介质向具有较小 MTU 的另一种介质转发IPv4数据包时必须将它分片。</p><p>注意：选项和填充字段很少使用，因此不在本模块的介绍范围之内。</p><p><em><strong>8.2.3的视频描述wireshark中检测IPv4报头非常好！</strong></em></p><h2 id="IPv6数据包"><a href="#IPv6数据包" class="headerlink" title="*IPv6数据包"></a>*IPv6数据包</h2><p>IPv6它最终将取代 IPv4</p><p>多年来，为应对新的挑战，已经制定了附加议定书和规程。但是，尽管经历了多次变更，IPv4 仍然有三个重要问题：</p><ul><li><strong>IPv4地址耗尽 -</strong> IPv4 的可用唯一公有地址数量有限。尽管有大约 40 亿的 IPv4 地址，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li><li><strong>缺乏端到端连接 -</strong> 网络地址转换 (NAT) 是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li><li><strong>增加的网络复杂性</strong> - 虽然NAT延长了IPv4的寿命，但它只是作为一种过渡到IPv6的机制。NAT在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。</li></ul><p>IPv6 的功能提升包括以下：</p><ul><li><strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li><li><strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</li><li><strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</li></ul><p>32 位的 IPv4 地址空间提供大约 4,294,967,296 个地址。IPv6 地址空间提供 340,282,366,920,938,463,463,374,607,431,768,211,456 个或 340 涧（10 的 36 次方）个地址。这大致相当于地球上的每一粒沙子。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314235834424.png" alt="image-20210314235834424"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000426978.png" alt="image-20210315000426978"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000511899.png" alt="image-20210315000511899"><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000554634.png" alt="image-20210315000554634"></p><p>共40个八位组，8个报头字段</p><h2 id="主机路由方式"><a href="#主机路由方式" class="headerlink" title="主机路由方式"></a>主机路由方式</h2><p>对于IPv4和IPv6，数据包总是在源主机上创建。源主机必须能够将数据包定向到目的主机。为此，主机终端设备将创建自己的路由表。本主题讨论终端设备如何使用路由表。</p><p>网络层的另一个作用是在主机之间转发数据包。主机可以将数据包发送至如下：</p><ul><li><strong>主机自己</strong> - 主机可以通过向特定的地址发送数据包来向自己发起ping测试，这个特定的地址是：IPv4地址127.0.0.1，或者IPv6地址 ::1，它被称为<strong>环回接口</strong>。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</li><li><strong>本地主机</strong> - 目的主机与发送主机位于同一本地网络。源和目的主机共享同一个网络地址。</li><li><strong>远程主机</strong> - 这是位于远程网络上的目的主机。源和目的主机不共享同一个网络地址。</li></ul><p>数据包是要发送到本地主机还是远程主机是由源端设备决定的。源端设备确定目的 IP 地址是否与源设备本身所在的网络相同。确定方法因 IP 版本不同而异：</p><ul><li><strong>在 IPv4 中</strong> -源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址来进行此判断。</li><li><strong>在 IPv6 中</strong> -本地路由器将本地网络地址（前缀）通告给网络上的所有设备</li></ul><p>在家庭或企业网络中，您可能有若干通过中间设备（LAN 交换机和/或无线接入点 (WAP) 等）互联的有线和无线设备。这种中间设备在本地网络上的本地主机之间提供互联服务。本地主机可以互相访问和共享信息，无需任何附加设备。如果主机要将数据包发送到与本主机在同一 IP 网络中的设备，<strong>则数据包仅是被转发出主机接口，然后经过中间设备即可直接到达目的设备（不必经手路由器）。</strong></p><p>当然，在大多数情况下我们希望我们的设备不仅仅能够连接本地网段，还能连接其他家庭、企业和互联网。位于本地网段外的设备称为远程主机。如果源设备发送数据包到远程目的设备，则需要借助路由器和路由。路由是确定到达目的地之最佳路径的过程。<strong>连接到本地网段的路由器称为默认网关Defalut Gateway。</strong></p><p><strong>默认网关</strong>Default Gateway是可以将流量路由到其他网络的网络设备(即，路由器或第3层交换机)。如果把一个网络比作一个房间，那么默认网关就好比是门口。如果要去另一个房间或网络，您就需要找到门口。</p><p>在网络上，默认网关通常是具有以下功能的路由器：</p><ul><li>它拥有与本地网络其他主机位于相同地址范围的本地 IP 地址。</li><li>它可以接受数据到本地网络，并将数据转发出本地网络。</li><li>它向其他网络路由流量。</li></ul><p>需要使用默认网关来发送本地网络之外的流量。如果没有默认网关、未配置默认网关地址或默认网关关闭，则无法将流量转发到本地网络之外。</p><p>主机的路由表通常包括默认网关。在IPv4中，主机通过动态主机配置协议 (DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以在主机上手动配置。</p><p><strong>配置默认网关会在 PC 的路由表中创建一个默认路由</strong>。默认路由是计算机尝试联系远程网络时所用的路由或路径。</p><h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><p>当数据包到达路由器接口时会发生什么?</p><p>路由器会检查数据包的目的 IP 地址并搜索其路由表以确定将数据包转发到何处。路由表包含所有<strong>已知网络地址（前缀）以及数据包转发位置</strong>的列表。这些条目称为路由条目或路由。路由器将使用最佳（最长）匹配的路由条目转发数据包。</p><p>路由表存储三种类型的路由条目：</p><ul><li><strong>直连网络-</strong> 这些网络路由条目是活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。每个路由器接口均连接到一个不同的网段。在图中，R1 IPv4路由表中的直连网络为192.168.10.0/24和209.165.200.224/30。</li><li><strong>远程网络</strong> - 这些网络路由条目连接到其他路由器。路由器通过由管理员明确配置或使用动态路由协议交换路由信息来学习远程网络。在图中，R1 IPv4路由表中的远程网络为10.1.1 /24。</li><li><strong>默认路由</strong> -像主机一样，大多数路由器还包含默认路由条目，即默认网关。当IP路由表中没有更好(更长)的匹配时，将使用默认路由。在图中，R1 IPv4路由表很可能包含一个将所有数据包转发到路由器R2的默认路由。</li></ul><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315124026095.png" alt="image-20210315124026095"></p><p>路由器可通过两种方式获知远程网络：</p><ul><li><strong>手动</strong> - 使用静态路由将远程网络手动输入到路由表中。</li><li><strong>动态</strong> - 使用动态路由协议自动学习远程路由。</li></ul><p><em><strong>静态路由</strong></em></p><p>手动配置的路由条目</p><p>静态路由包括远程网络地址和下一跳路由器的IP地址。</p><p>ip route 远程网络地址 下一跳路由器的IP地址</p><p>如果网络拓扑改变，静态路由不会自动更新，必须手动重新配置静态路由</p><p>静态路由具有以下特征：</p><ul><li>必须手动配置静态路由。</li><li>如果拓扑发生变化，且静态路由不再可用，则管理员需要重新配置静态路由。</li><li>静态路由适用于小型网络且当冗余链路很少或没有冗余链路的情况。</li><li>静态路由通常与动态路由协议一起用于配置默认路由。</li></ul><p><em><strong>动态路由</strong></em></p><p>动态路由协议可让路由器从其他路由器那里自动学习远程网络，包括默认路由。如果使用动态路由协议，则路由器无需网络管理员的参与，即可自动与其它路由器共享路由信息并对拓扑结构的变化作出反应。如果网络拓扑发生变化，路由器将使用动态路由协议共享此信息，并自动更新路由表。</p><p>动态路由协议包括OSPF（开放最短路径优先协议）和增强型内部网关路由协议 (EIGRP)</p><p>基本配置只需要网络管理员在动态路由协议中启用直连网络。动态路由协议将自动执行如下操作：</p><ul><li>发现远程网络</li><li>维护最新路由信息</li><li>选择通往目的网络的最佳路径</li><li>当前路径无法再使用时尝试找出新的最佳路径</li></ul><p>当使用静态路由手动配置路由器或使用动态路由协议动态学习远程网络时，远程网络地址和下一跳地址将被输入到IP路由表中。如图所示，如果网络拓扑发生变化，路由器将自动调整并尝试找到新的最佳路径。（R1,2,3正在使用动态路由协议OSPF）</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315124816720.png" alt="image-20210315124816720"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315125544736.png" alt="image-20210315125544736"></p><p><em><strong>8.5.5大致介绍挺好的</strong></em></p><p>每个路由表条目的开头都有一个代码，用于标识路由的类型或路由的学习方式。常见路由源（代码）包括以下内容：</p><ul><li><strong>L</strong> - 该网络所直连的它的本地接口的 IP 地址</li><li><strong>C</strong> - 直连网络</li><li><strong>S</strong> - 静态路由由管理员手动配置</li><li><strong>O</strong> - OSPF</li><li><strong>D</strong> - EIGRP</li></ul><p>默认路由具有全都是零的网络地址。例如，IPv4 网络地址为 0.0.0.0。路由表中的静态路由条目以 S\ * 的代码开头</p><h1 id="地址解析！"><a href="#地址解析！" class="headerlink" title="地址解析！"></a>地址解析！</h1><p>主机和路由器都创建路由表，以确保它们可以跨网络发送和接收数据。那么这些信息是如何在路由表中被创建的呢? 作为网络管理员，您可以手动输入这些 MAC 和 IP 地址。但这将花费大量时间，而且犯一些错误的可能性很大。您是否认为一定有某种方式，由主机和路由器可以自动完成? 当然，您是对的！即使它是自动的，您仍然必须要了解它是如何工作的，因为您可能会需要排除一些故障，或更糟的是，您的网络可能会受到威胁发起者的攻击。</p><h2 id="MAC-and-IP"><a href="#MAC-and-IP" class="headerlink" title="MAC and IP"></a>MAC and IP</h2><p>（复习）以太网 LAN 上的设备都配有两个主要地址：</p><ul><li><strong>物理地址（MAC 地址）</strong> – 用于同一网络上的以太网网卡之间的通信。</li><li><strong>逻辑地址（IP地址）</strong> – 用于将数据包从源设备发送到目的设备。目的IP地址可能与源地址在同一个IP网络上，也可能在远程网络上。</li></ul><p>第二层物理地址(即以太网MAC地址)用于将数据链路层帧从同一网络中一个网卡发送到另一个网卡， IP 数据包就封装在帧中。<br>如果目的IP地址在同一网络上，则目的MAC地址将是目的设备的MAC地址。<br>当目的 IP 地址(IPv4或IPv6)处于远程网络中时，则目的 MAC 地址为主机的默认网关的地址(即路由器接口)</p><p>数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过地址解析协议 (ARP) 过程来完成。对于IPv6数据包，这个过程是ICMPv6邻居发现(ND)。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>IPv4当将帧发送到另一个远程网络时，只知道IP地址，要获得MAC地址得使用ARP帮助</p><p>ARP 提供两个基本功能：</p><ul><li>将 IPv4 地址<strong>解析</strong>为 MAC 地址</li><li><strong>维护IPv4到MAC地址映射表</strong></li></ul><p>当数据包发送到要封装入以太网帧的数据链路层时，设备将参照其<strong>内存中的表来</strong>查找映射至 IPv4 地址的 MAC 地址。此表临时存储在<strong>RAM</strong>内存中，称为 ARP 表或 ARP 缓存。</p><p>发送设备会在自己的 ARP 表中搜索目的 IPv4 地址和相应的 MAC 地址。</p><ul><li>如果数据包的目的 IPv4 地址与源 IPv4 地址处于同一个网络，则设备会在 ARP 表中搜索目的 IPv4 地址。</li><li>如果目的 IPv4 地址与源 IPv4 地址不在同一个网络中，则设备会在 ARP 表中搜索默认网关的 IPv4 地址。</li></ul><p>这两种情况都是搜索设备的 IPv4 地址和与其相对应的 MAC 地址。</p><p>ARP 表中的每一条（或每行）将一个 IPv4 地址与一个 MAC 地址绑定。我们把两个值之间的关系称为<strong>映射</strong>。这意味着您可以在表中查找 IPv4 地址并发现相应的 MAC 地址。ARP 表暂时保存（缓存）LAN 上设备的映射。</p><p><em><strong>ARP 请求。</strong></em></p><p>当设备需要确定与 IPv4 地址关联的 MAC 地址，而它的 ARP 表中没有该 IPv4 地址条目时，会发送一个 ARP 请求。</p><p><strong>ARP 消息直接封装到以太网帧中。没有 IPv4 报头</strong>。ARP 请求使用以下帧头信息封装在以太网帧中：</p><ul><li><strong>目的 MAC 地址</strong> – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的<strong>广播地址FF-FF-FF-FF-FF-FF</strong>。</li><li><strong>源 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li><li><strong>类型</strong> - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</li></ul><p>因为 ARP 请求属于广播，交换机会将其泛洪到除接收端口外的其他所有端口。局域网上的所有以太网网卡都会处理广播，并且必须将ARP请求发送到其操作系统进行处理。每台设备必须处理 ARP 请求，以检查目的 IPv4 地址是否与其自己的地址相匹配。<strong>路由器不会将广播转发到其他接口。</strong>不会干扰别人家的局域网</p><p><em><strong>ARP应答</strong></em></p><p>LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应答。</p><p>只有具有与ARP请求相应的目的IPv4地址的设备才会以ARP应答做出响应。ARP 应答使用以下帧头信息封装在以太网帧中：</p><ul><li><p><strong>目的 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</p></li><li><p><strong>源 MAC 地址</strong> – 这是ARP应答发送方的MAC地址。</p></li><li><p><strong>类型</strong> – ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</p><p> 只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。该 IPv4 地址的数据包现在便可使用其相应的 MAC 地址封装在帧中。</p><p> 如果没有设备响应 ARP 请求，就无法创建帧，那么这个数据包会被丢弃。</p></li></ul><p>ARP 表中的条目具有时间戳。如果在时间戳到期前没有从特定设备收到帧，此设备的条目将会从 ARP 表中删除。</p><p><em>此外，也可以在 ARP 表中输入静态映射条目，但这种情况很少见。静态 ARP 表条目没有到期时间，必须手动删除。</em></p><p>默认网关的 IPv4 地址存储在主机的 IPv4 配置中。当主机创建通往某台目的主机的数据包时，会将目的 IPv4 地址与其自己的 IPv4 地址进行比较，以确定两个 IPv4 地址是否位于相同的第 3 层网络上。如果目的主机不在同一网络上，<strong>源主机将从 ARP 表中查找默认网关的 IPv4 地址条目。如果没有该条目，源主机将使用 ARP 流程来确定默认网关的 MAC 地址。</strong>不会连默认网关都没存吧。。</p><p>对于每台设备，ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目。时间根据设备的操作系统不同而不同。例如，较新的 Windows 操作系统将 ARP 表条目<strong>存储 15 秒到 45 秒</strong>之间</p><p>也可以使用命令来手动删除 ARP 表中的部分或全部条目。当条目被删除之后，要想在 ARP 表中输入映射，必须重复一次发送 ARP 请求和接收 ARP 回复的过程。</p><p>作为<strong>广播帧（IPv6是组播）</strong>，本地网络上的每台设备都会收到并处理 ARP 请求。在一般的商业网络中，这些广播对网络性能的影响可能微不足道。但是，如图所示，如果大量设备都已启动，并且同时开始使用网络服务，网络性能可能会有短时间的下降。在设备发出初始 ARP 广播并获取必要的 MAC 地址之后，网络受到的影响将会降至最小。</p><p>有时，使用 ARP 可能会造成潜在的安全风险。威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。如图所示，威胁发起者使用这种技术来应答属于另一台设备（例如默认网关）的 IPv4 地址的 ARP 请求。威胁发起者会发送一个带有自己 MAC 地址的 ARP 应答。ARP 应答的接收方会将错误的 MAC 地址添加到其 ARP 表中，并将这些数据包发送给威胁发起者。 企业级的交换机包含称为动态 ARP 检查 (DAI) 的缓解技术。DAI 不在本课程的讨论范围之内。</p><h2 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h2><p>IPv6 邻居发现协议有时被称为 ND 或 NDP。在本课程中，我们称它为 ND。ND使用ICMPv6为IPv6提供地址解析、路由器发现和重定向服务。ICMPv6 ND 使用五种 ICMPv6 消息来执行这些服务：</p><ul><li>邻居请求消息</li><li>邻居通告消息</li><li>路由器请求消息</li><li>路由器通告消息</li><li>重定向消息</li></ul><p>邻居请求和邻居通告消息用于<strong>设备到设备</strong>的消息传递，例如地址解析（类似于 IPv4 的 ARP）。设备包括主机计算机和路由器。，一个不同点是，IPv4仅使用MAC来匹配，不涉及IP协议，邻居发现会使用ICMPv6把消息封装在IPv6报头中，再封入以太网头尾，目标IPv6会映射到特殊的IPv6目标组播地址，再映射成目标MAC组播地址，该过程会包含目的IPv6地址的很大一部分，反正最后就是不会有太多主机收到信息，比较节省，接受的设备将优先在以太网层匹配该组播地址，再向上检测IPv6层和ICMPv6</p><p>路由器请求和路由器通告消息用于设备和路由器之间的消息传递。通常，路由器发现用于<em><strong>动态地址分配和无状态地址自动配置 (SLAAC)。</strong></em></p><p><strong>注意</strong>: 第五个 ICMPv6 ND 消息是一个重定向消息，用于更好的下一跳选择。这不在本课程的讨论范围之内。</p><p>IPv6 ND 是在 IETF RFC 4861 中定义的。</p><p>ICMPv6 邻居请求和邻居通告消息用于MAC地址解析。这类似于ARP用于IPv4的ARP请求和ARP应答</p><p><strong>ICMPv6邻居请求消息使用特定的以太网和IPv6 组播 而不是广播地址发送。这允许接收设备的以太网卡确定邻居请求消息是否属于它自己，而不必将它发送到操作系统进行处理。</strong></p><h1 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在路由器上配置初始设置时，应完成以下任务。</p><ol><li>配置设备名称。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# hostname hostname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>\2. 保护特权模式。</p><pre class="line-numbers language-none"><code class="language-none">Router(config)# enable secret password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>\3. 保护用户模式</p><pre class="line-numbers language-none"><code class="language-none">Router(config)# line console 0Router(config-line)# password passwordRouter(config-line)# login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>\4. 保护远程 Telnet / SSH 访问</p><pre class="line-numbers language-none"><code class="language-none">Router(config-line)# line vty 0 4Router(config-line)# password passwordRouter(config-line)# loginRouter(config-line)# transport input &#123;ssh | telnet&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>\5. 保护配置文件中的所有密码。</p><pre class="line-numbers language-none"><code class="language-none">Router(config-line)# exitRouter(config)# service password-encryption<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>\6. 提供法律通知。</p><p>法律通知警告用户只能由允许用户访问该设备。法律通知配置如下。</p><pre class="line-numbers language-none"><code class="language-none">R1(config)# banner motd #Enter TEXT message. End with a new line and the #*********************************************** WARNING: Unauthorized access is prohibited!***********************************************#R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>\7. 保存配置。</p><pre class="line-numbers language-none"><code class="language-none">Router(config)# endRouter# copy running-config startup-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="接口配置"><a href="#接口配置" class="headerlink" title="接口配置"></a>接口配置</h2><p>配置路由器接口的任务与交换机上管理 SVI 非常相似。具体来说，它包括发出以下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router(config)# interface type-and-numberRouter(config-if)# description description-textRouter(config-if)# ip address ipv4-address subnet-maskRouter(config-if)# ipv6 address ipv6-address&#x2F;prefix-lengthRouter(config-if)# no shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此表总结了用于验证接口配置的更常用 <strong>show</strong> 命令。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>**show ip interface brief****show ipv6 interface brief**</code></td><td align="left">所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</td></tr><tr><td align="left"><code>**show ip route****show ipv6 route**</code></td><td align="left">显示存储在 RAM 中的 IP 路由表的内容。</td></tr><tr><td align="left"><code>**show interfaces**</code></td><td align="left">显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</td></tr><tr><td align="left"><code>**show ip interface**</code></td><td align="left">显示路由器上所有接口的 IPv4 统计信息。</td></tr><tr><td align="left"><code>**show ipv6 interface**</code></td><td align="left">显示路由器上所有接口的 IPv6 统计信息。</td></tr></tbody></table><h2 id="配置默认网关"><a href="#配置默认网关" class="headerlink" title="配置默认网关"></a>配置默认网关</h2><p>如果您的本地网络只有一个路由器，它就将是网关路由器，并且必须使用此信息配置网络上的所有主机和交换机。如果您的本地网络有多个路由器，则必须选择其中一个作为默认网关路由器</p><p>连接客户端计算机的交换机通常是第 2 层设备。因此，第 2 层交换机不需要使用 IP 地址就能正常工作。但是，可以在交换机上配置 IP 配置，以便管理员能够远程访问交换机。</p><p>要通过本地 IP 网络连接和管理交换机，必须配置交换机虚拟接口 (SVI)。SVI 配置了本地局域网上的 IPv4 地址和子网掩码。要从远端网络管理交换机，必须给交换机配置一个默认网关。</p><p><strong>在会通过本地网络之外的方式通信的所有设备上，一般都会配置默认网关地址。</strong></p><p>要为交换机配置默认网关，请使用<strong>ip default-gateway</strong> ip-address 全局配置命令。配置的 IP 地址是连接到交换机的本地路由器接口的 IP 地址。</p><p>也可以使用 SVI 上的 IPv6 地址配置工作组交换机。但是，<strong>交换机不需要手动配置默认网关的 IPv6 地址。</strong>交换机将自动接收来自路由器的 ICMPv6 路由器公告消息的默认网关。</p><h2 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h2><p>您将使用的故障排除方法包含以下步骤：</p><p>a. 验证网络文档，并使用测试来查明问题。 </p><p>b. 为查明的问题确定一个适当的解决方案。 </p><p>c. 实施解决方案。 </p><p>d. 进行测试以验证问题是否已解决。</p><p> e. 记录解决方案。</p><p>在整个 CCNA 学习过程中，您会遇到不同的 故障排除方法，以及测试 并记录问题和解决方案的不同方法。这是有意设计的。故障排除没有固定的 标准或模板。每个组织都制定了独特的 流程和文档标准（有时候，一个组织的流程就是“我们没有 固定流程”）。但是，所有有效的故障排除方法通常都包括 上述步骤。</p><p>注意：通常不止一个解决方案。但是，排除故障的最佳做法是每次实施和验证一个解决方案。在更复杂的 情形中，实施多个解决方案会导致其他问题。</p><h1 id="遗漏知识"><a href="#遗漏知识" class="headerlink" title="*遗漏知识"></a>*遗漏知识</h1><h2 id="2-1-5终端仿真程序"><a href="#2-1-5终端仿真程序" class="headerlink" title="2.1.5终端仿真程序"></a>2.1.5终端仿真程序</h2><h2 id="2-3-8用Tera-Term连接控制台"><a href="#2-3-8用Tera-Term连接控制台" class="headerlink" title="2.3.8用Tera Term连接控制台"></a>2.3.8用Tera Term连接控制台</h2><h2 id="2-5-4捕获配置到文本中"><a href="#2-5-4捕获配置到文本中" class="headerlink" title="2.5.4捕获配置到文本中"></a>2.5.4捕获配置到文本中</h2><h1 id="真-命令集"><a href="#真-命令集" class="headerlink" title="真*命令集"></a>真*命令集</h1><p><strong>转载自：<a href="https://blog.csdn.net/qq_42833924/article/details/89790004">https://blog.csdn.net/qq_42833924/article/details/89790004</a><br>为自己学习方便故转载，如果大家觉得有帮助，请为原文点赞。</strong></p><p>1.基本配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token operator">></span> enable   从用户模式进入特权模式<span class="token class-name">R</span># disable  从特权模式退到用户模式<span class="token class-name">R</span># logout <span class="token punctuation">(</span>或exit<span class="token punctuation">)</span>   退出<span class="token class-name">Cisco</span>设备<span class="token class-name">R</span># show history 查看先前输入的命令（默认<span class="token number">10</span>个）<span class="token class-name">R</span># terminal history size #_of_commands  改变历史缓存的大小（最大<span class="token number">256</span>）<span class="token class-name">R</span># terminal no editing  禁用编辑特性（移去no参数为启用）<span class="token class-name">R</span># configure terminal   进入配置模式（退出为end或CTRL<span class="token operator">-</span><span class="token class-name">Z</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># hostname name    改变路由器的名称<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># banner motd delimiting_character banner_character delimiting_character   设置登录横幅<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># exec<span class="token operator">-</span>timeout minutes_# seconds_#    更改休止超时（默认<span class="token number">10</span>分钟）<span class="token class-name">R</span># show hosts   查看路由器解析表中的静态和动态DNS条目<span class="token class-name">R</span><span class="token operator">></span> show version 查看路由器综合信息<span class="token class-name">R</span># show line    验证线路的配置<span class="token class-name">R</span># show processes   查看设备的各个进程的CPU使用率<span class="token class-name">R</span># show users   查看登录到这台设备上的所有用户<span class="token class-name">R</span># show sessions    查看当前挂起的已经打开的telnet会话<span class="token class-name">R</span># term ip netmask<span class="token operator">-</span>format bit<span class="token operator">-</span>count<span class="token operator">|</span>decimal<span class="token operator">|</span>hexadecimal 改变子网掩码显示方式（在当前登录会话期间有效，在子线路模式下即可保存）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip host name_of_host <span class="token punctuation">[</span><span class="token class-name">TCP_port_</span>#<span class="token punctuation">]</span> <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span> 创建主机静态解析表（可指定多达<span class="token number">8</span>个IP地址）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip name<span class="token operator">-</span>server <span class="token class-name">IP_address_of_DNS_server</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>  配置通过访问DNS服务器动态解析主机（可指定多达<span class="token number">6</span>个DNS服务器）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># no ip domain<span class="token operator">-</span>lookup  禁用DNS查询<span class="token class-name">R</span><span class="token operator">></span> ping destination_IP_address_or_host_name 查看与目的主机的连通性<span class="token class-name">R</span><span class="token operator">></span> traceroute destination_IP_address_or_host_name   查看与目的主机间的路由器<span class="token class-name">R</span># <span class="token punctuation">[</span>telnet<span class="token operator">|</span>connect<span class="token punctuation">]</span> name_of_the_destination<span class="token operator">|</span>destination_IP_address  打开telnet会话<span class="token class-name">R</span># resume connection_#  恢复一个特定的会话<span class="token class-name">R</span># disconnect connection_#  结束一已挂起的telnet会话无须恢复它并随后从中退出<span class="token class-name">R</span># clear line line_#    结束某人的会话<span class="token class-name">R</span># no debug all <span class="token punctuation">(</span>或undebug all<span class="token punctuation">)</span>  禁用debug<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># service timestamps debug datetime msec   在debug输出中显示时间戳<span class="token class-name">R</span># terminal monitor 从VTY或辅助线路端口登录执行，路由器将在屏幕上显示报告消息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># logging synchronous在该线路上报告信息后路由器在新提示符后重新显示未打完的命令<span class="token number">123456789101112131415161718192021222324252627282930</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.文件操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span># show running<span class="token operator">-</span>config  查看正在运行（当前）的配置文件<span class="token class-name">R</span># show startup<span class="token operator">-</span>config  查看NVRAM中的配置文件<span class="token class-name">R</span># copy running<span class="token operator">-</span>config<span class="token operator">|</span>startup<span class="token operator">-</span>config tftp  将配置备份到TFTP服务器<span class="token class-name">R</span># copy tftp startup<span class="token operator">-</span>config<span class="token operator">|</span>running<span class="token operator">-</span>config  从TFTP服务器将配置恢复到路由器<span class="token class-name">R</span># copy startup<span class="token operator">-</span>config running<span class="token operator">-</span>config   从NVRAM中将配置恢复到RAM中<span class="token class-name">R</span># copy running<span class="token operator">-</span>config startup<span class="token operator">-</span>config   将RAM中的配置文件保存到NVRAM<span class="token class-name">R</span># erase startup<span class="token operator">-</span>config 删除NVRAM中的配置文件<span class="token class-name">R</span># copy flash tftp  备份IOS镜像到TFTP服务器<span class="token class-name">R</span># show flash   查看闪存中的文件<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.启动配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span># setup    运行系统配置会话<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system flash name_of_IOS_file_in_flash  启动时加载闪存中的指定IOS文件<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system tftp <span class="token class-name">IOS_image_name</span> <span class="token class-name">IP_address_of_server</span> 启动时加载TFTP服务器里的IOS文件<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system rom  启动时加载ROM中的迷你IOS文件（启动与这三个命令的顺序有关）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># config<span class="token operator">-</span>register <span class="token number">0</span>x hexadecimal_value 改变寄存器的值rommon <span class="token number">5</span><span class="token operator">></span> confreg <span class="token number">0x2142</span>    <span class="token number">2600</span>、<span class="token number">3600</span>系列启动后按CTRL<span class="token operator">-</span>BREAK进入ROMMON模式，改变寄存器的值<span class="token class-name">R</span><span class="token operator">></span> o<span class="token operator">/</span>r <span class="token number">0x2142</span>   其他系列路由器改变寄存器的值的方法<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.密码设置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line console <span class="token number">0</span>   进入控制台接口配置模式<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password console_password   配置控制台口令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line vty <span class="token number">0</span> <span class="token number">4</span> 进入虚拟终端线路配置模式（根据路由器及IOS最少<span class="token number">5</span>个直到很多）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># login   接上条命令，允许进行<span class="token class-name">Telnet</span>访问<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password telnet_password    接上条命令，配置<span class="token class-name">Telnet</span>口令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line aux <span class="token number">0</span>   进入辅助端口配置模式<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password console_password   接上条命令，配置辅助端口口令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># enable password privileged_password  配置特权EXEC口令（不加密）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># enable secret privileged_password    配置特权EXEC口令（加密）<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.接口配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  进入接口子配置模式<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># description interface_description 添加接口描述<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># no shutdown   启用该接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> loopback port_#    创建环回接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># media<span class="token operator">-</span>type aui<span class="token operator">|</span><span class="token number">10</span>baset<span class="token operator">|</span><span class="token number">100</span>baset<span class="token operator">|</span>mii   指定该接口连接的介质类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># speed <span class="token number">10</span><span class="token operator">|</span><span class="token number">100</span><span class="token operator">|</span>auto 指定该接口速率<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> half<span class="token operator">-</span>duplex  指定该接口双工模式<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># clock rate rate_in_bits_per_second    指定该DCE串行接口速率<span class="token class-name">R</span><span class="token operator">></span> show controller serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  验证该接口是DCE还是DTE，注意空格<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># bandwidth rate_in_Kbps    改变该接口的带宽值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address <span class="token class-name">IP_address</span> subnet_mask 配置该接口IP地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip subnet<span class="token operator">-</span>zero   IOS12<span class="token punctuation">.</span><span class="token number">0</span>前默认禁用<span class="token number">0</span>子网，此命令为启用<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip directed<span class="token operator">-</span>broadcast IOS12<span class="token punctuation">.</span><span class="token number">0</span>后默认禁用定向广播，此命令为启用<span class="token class-name">R</span># show interfaces <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span>  验证接口配置<span class="token class-name">R</span># show ip interfaces <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span> <span class="token punctuation">[</span>brief<span class="token punctuation">]</span>   验证接口IP配置<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.CDP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> cdp run 启用<span class="token operator">/</span>禁用CDP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> cdp enable   基于接口启用<span class="token operator">/</span>禁用CDP<span class="token class-name">R</span># show cdp 查看CDP状态<span class="token class-name">R</span># show cdp <span class="token keyword">interface</span>   查看基于接口的CDP配置<span class="token class-name">R</span># show cdp neighbors <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>  查看与用户<span class="token class-name">Cisco</span>设备相连的CDP邻居的摘要<span class="token operator">/</span>详细清单<span class="token class-name">R</span># show cdp entry neighbor's_name   查看一个指定邻居的详细信息<span class="token class-name">R</span># show cdp traffic 查看CDP通信量的统计信息<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.路由</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route destination_network_# <span class="token punctuation">[</span>subnet_mask<span class="token punctuation">]</span> <span class="token class-name">IP_address_of_next_hop_neighbor</span><span class="token operator">|</span>interface_to_exit <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span> <span class="token punctuation">[</span>permanent<span class="token punctuation">]</span> 配置IP静态路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span> <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span> <span class="token class-name">IP_address_of_next_hop_neighbor</span><span class="token operator">|</span>interface_to_exit <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span> <span class="token punctuation">[</span>permanent<span class="token punctuation">]</span> 配置默认路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip classless 使有类协议接受非一致性子网掩码或不连续子网<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">.</span> subinterface_# <span class="token punctuation">[</span>point<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>point<span class="token operator">|</span>multipoint<span class="token punctuation">]</span>  创建子接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>subif<span class="token punctuation">)</span># encapsulation isl<span class="token operator">|</span>dotlq VLAN_# 指定子接口中继类型和相关的VLAN<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router name_of_the_IP_routing_protocol   进入路由选择协议的配置模式<span class="token class-name">R</span># show ip route    查看IP路由表<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.RIP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router rip   配置IP RIP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  指定哪些接口参与路由选择进程<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># version <span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span>   只接受和发送RIP版本<span class="token number">1</span>或<span class="token number">2</span>（默认只产生<span class="token class-name">RIPv1</span>更新，而两个版本的更新都接收）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># ip rip send<span class="token operator">|</span>receive version <span class="token number">1</span> <span class="token operator">|</span> version <span class="token number">2</span> <span class="token operator">|</span> version <span class="token number">1</span> <span class="token number">2</span>   在特定接口上控制在发送或接收RIP更新时使用哪个版本的RIP<span class="token class-name">R</span># show ip protocols    查看在路由器上已配置并运行的所有IP路由选择协议<span class="token class-name">R</span># show ip route <span class="token punctuation">[</span>name_of_the_IP_routing_protocol<span class="token punctuation">]</span>  查看路由选择表<span class="token class-name">R</span># debug ip rip 帮助进行故障排除<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>9.IGRP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router igrp AS_# 配置IP IGRP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  通告网络号<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span>   配置单播更新<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># passive<span class="token operator">-</span><span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#   允许该接口在IGRP中通告但它不监听或发送IGRP更新<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># traffic<span class="token operator">-</span>share min across<span class="token operator">-</span>interfaces   使路由器只使用最佳路径但又在路由选择表中放入替代路径<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># timers basic update_# invalid_# holddown_# flush_# <span class="token punctuation">[</span>sleeptime_#<span class="token punctuation">]</span>  调整定时器（默认时，update<span class="token operator">=</span><span class="token number">90</span>，invalid<span class="token operator">=</span><span class="token number">270</span>，holddown<span class="token operator">=</span><span class="token number">280</span>，flush<span class="token operator">=</span><span class="token number">630</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no metric holddown    关闭压制定时器（默认）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distance administrative_distance_#    调整管理距离（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">255</span>，默认为<span class="token number">100</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>metric bandwidth_# delay_# reliability_# load_# MTU_# 调整度量值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># metric weights tos_# K1_# K2_# K3_# K4_# K5_# 调整度量权重值（默认时，<span class="token function">K1</span><span class="token punctuation">(</span>带宽<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K3</span><span class="token punctuation">(</span>可靠性<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span>，<span class="token function">K2</span><span class="token punctuation">(</span>延迟<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K4</span><span class="token punctuation">(</span>负载<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K5</span><span class="token punctuation">(</span>MTU<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># variance multiplier_# 启用IGRP非同等成本路径（变化因子值<span class="token number">1</span><span class="token operator">-</span><span class="token number">128</span>默认为<span class="token number">1</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># traffic<span class="token operator">-</span>share balanced    配置负载均衡<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># maximum<span class="token operator">-</span>paths paths_# 配置负载均衡的路径条数（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">6</span>）<span class="token class-name">R</span># debug ip igrp events 提供路由器和邻居间发生的每一步操作信息<span class="token class-name">R</span># debug ip igrp transactions   提供有关包含在路由更新中路由的详细信息<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10.EIGRP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router eigrp AS_#    配置EIGRP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  通告网络号<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip bandwidth<span class="token operator">-</span>percent eigrp AS_# percent_# 设置pacing（调速）占给定接口带宽的百分数（默认为<span class="token number">50</span><span class="token operator">%</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distance administrative_distance_#    调整管理距离（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">255</span>，默认对于内部路由是<span class="token number">90</span>而外部是<span class="token number">170</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>metric bandwidth_# delay_# reliability_# load_# MTU_# 调整度量值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># metric weights tos_# K1_# K2_# K3_# K4_# K5_# 调整度量权重值（默认时，<span class="token function">K1</span><span class="token punctuation">(</span>带宽<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K3</span><span class="token punctuation">(</span>可靠性<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span>，<span class="token function">K2</span><span class="token punctuation">(</span>延迟<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K4</span><span class="token punctuation">(</span>负载<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K5</span><span class="token punctuation">(</span>MTU<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip hello<span class="token operator">-</span>interval eigrp AS_# seconds_#    在给定接口上设置<span class="token class-name">Hello</span>间隔（默认对于低速的NBMA网络是<span class="token number">60</span>秒，其他是<span class="token number">5</span>秒）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip hold<span class="token operator">-</span>time eigrp AS_# seconds_# 在给定接口上设置<span class="token class-name">Hello</span>保持定时器（默认是<span class="token number">3</span>倍的<span class="token class-name">Hello</span>间隔）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># passive<span class="token operator">-</span><span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#   允许该接口在EIGRP中通告但它不监听或发送EIGRP更新<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no auto<span class="token operator">-</span>summary   取消对路由的自动汇总<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip summary<span class="token operator">-</span>address eigrp AS_# network_address network_mask    创建不在有类边界上的汇总地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># eigrp log<span class="token operator">-</span>neighbor<span class="token operator">-</span>changes   记录在某个邻居上发生的变化<span class="token class-name">R</span># show ip route eigrp  查看被EIGRP学习到的路由<span class="token class-name">R</span># show ip route network_address    查看指定目的地的路由信息<span class="token class-name">R</span># show ip eigrp topology   查看EIGRP的拓扑表<span class="token class-name">R</span># show ip eigrp interfaces     查看加入到EIGRP路由器所有接口的概述<span class="token class-name">R</span># show ip eigrp neighbor <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>  显示和本路由器已形成邻居关系的所有路由器<span class="token class-name">R</span># show ip eigrp traffic    显示每个包类型的发出和接收的数量<span class="token class-name">R</span># show ip eigrp events 查看每个EIGRP事件的日志<span class="token class-name">R</span># debug ip eigrp   提供路由器和它的邻居之间发生的每一步操作<span class="token class-name">R</span># debug eigrp packets  查看在该路由器和它的邻居之间发送的数据包类型<span class="token class-name">R</span># debug eigrp neighbors    查看邻居的信息<span class="token number">12345678910111213141516171819202122</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>11.OSPF</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router ospf process_ID   配置OSPF<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_address</span> wildcard_mask area area_#  指定接口进入OSPF区域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip ospf cost cost_value   给接口指定成本（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">65535</span>）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span>   手动配置邻居<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span> priority value    指定邻居的优先级（取值范围是<span class="token number">0</span><span class="token operator">-</span><span class="token number">255</span>，<span class="token number">255</span>为DR，<span class="token number">0</span>为不可能成为DR）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip ospf network non<span class="token operator">-</span>broadcast 手工配置非广播网络类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id stub 允许创建存根区域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id stub no<span class="token operator">-</span>summary  允许创建完全存根区域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id nssa 允许创建次存根区域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id virtual<span class="token operator">-</span>link router_id   连接不连续区域为骨干区域<span class="token number">0</span><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id range network_address network_mask   在区域边界路由器上汇总在给定区域中的路由器使用的IP地址空间到其他的区域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># summary<span class="token operator">-</span>address network_address network_mask  在自治系统边界路由器上汇总外部路由<span class="token class-name">R</span># show ip ospf 概述所有OSPF相关的信息<span class="token class-name">R</span># show ip ospf process<span class="token operator">-</span>id  与上相同，而不仅仅是指定的进程<span class="token class-name">R</span># show ip ospf border<span class="token operator">-</span>routers  显示在此自治系统中所有ABR和ASBR的路由器ID<span class="token class-name">R</span># show ip ospf database    显示链路状态数据库<span class="token class-name">R</span># show ip ospf <span class="token keyword">interface</span>   显示接口的OSPF参数和其他的指定到此接口上的OSPF信息<span class="token class-name">R</span># show ip ospf neighbor <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>   显示每个OSPF邻居和邻接状态<span class="token class-name">R</span># debug ip ospf adj    报告路由器建立到其他路由器的邻接关系进程<span class="token class-name">R</span># debug ip ospf events 报告路由器上的OSPF事件<span class="token class-name">R</span># debug ip ospf packet 报告OSPF LSA分组的内容<span class="token number">123456789101112131415161718192021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>12.ACL</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># access<span class="token operator">-</span>list <span class="token number">1</span><span class="token operator">-</span><span class="token number">99</span><span class="token operator">|</span><span class="token number">1300</span><span class="token operator">-</span><span class="token number">1999</span> permit<span class="token operator">|</span>deny source_IP_address <span class="token punctuation">[</span>wildcard_mask<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span>    创建标准编号IP ACL<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip access<span class="token operator">-</span>group ACL_# in<span class="token operator">|</span>out  在指定接口上启动ACL<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># access<span class="token operator">-</span><span class="token keyword">class</span> standard_ACL_# in<span class="token operator">|</span>out  在指定若干线路上启动ACL以限制对路由器的<span class="token class-name">Telnet</span>访问<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># access<span class="token operator">-</span>list <span class="token number">100</span><span class="token operator">-</span><span class="token number">199</span><span class="token operator">|</span><span class="token number">2000</span><span class="token operator">-</span><span class="token number">2699</span> permit<span class="token operator">|</span>deny <span class="token class-name">IP_protocol</span> source_address source_wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> destination_address destination_wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span>  创建扩展编号IP ACL<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip access<span class="token operator">-</span>list standard <span class="token class-name">ACL_name</span> 创建标准命名ACL（从IOS11<span class="token punctuation">.</span><span class="token number">2</span>开始支持）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>std<span class="token operator">-</span>acl<span class="token punctuation">)</span># permit<span class="token operator">|</span>deny source_IP_address <span class="token punctuation">[</span>wildcard_mask<span class="token punctuation">]</span>    输入标准ACL命令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip access<span class="token operator">-</span>list extended <span class="token class-name">ACL_name</span> 创建扩展命名ACL（从IOS11<span class="token punctuation">.</span><span class="token number">2</span>开始支持）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>ext<span class="token operator">-</span>acl<span class="token punctuation">)</span># permit<span class="token operator">|</span>deny <span class="token class-name">IP_protocol</span> source_IP_address wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> destination_IP_address wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span> 输入扩展ACL命令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip access_group <span class="token class-name">ACL_name</span> in<span class="token operator">|</span>out   启动命名ACL<span class="token class-name">R</span># show ip interfaces   验证访问列表<span class="token class-name">R</span># show access<span class="token operator">-</span>lists <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>    显示ACL中的语句<span class="token class-name">R</span># show ip access<span class="token operator">-</span>list <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>  显示IP ACL中的语句<span class="token class-name">R</span># clear access<span class="token operator">-</span>list counters <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>   对指定ACL中的匹配计数器清零<span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>13.NAT PAT 配置负载分发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source <span class="token keyword">static</span> inside_local_source_IP_address inside_global_source_IP_address   定义NAT静态转换<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat outside source <span class="token keyword">static</span> outside_global_destination_IP_address outside_local_destination_IP_address  定义NAT静态转换<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip nat inside<span class="token operator">|</span>outside 指定路由器上哪些接口在内部，哪些在外部<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat outside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span>  为重叠地址转换配置NAT<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span>   定义动态NAT，指定转换哪些内部设备的源地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat pool <span class="token class-name">NAT_pool_name</span> beginning_inside_global_IP_address ending_inside_global_IP_address netmask subnet_mask_of_addresses<span class="token operator">|</span>prefix<span class="token operator">-</span>length length   创建源内部全局IP地址池<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span> overload  定义PAT，指定哪台内部设备会转换其源地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat pool pool_name beginning_inside_local_IP_address ending_inside_local_IP_address prefix<span class="token operator">-</span>length subnet_mask_bits type rotary    指定提供服务的设备上配置的内部IP地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside destination list standard_ACL_# pool pool_name 指定外部设备用来访问内部资源的全局IP地址<span class="token class-name">R</span># show ip nat translations <span class="token punctuation">[</span>verbose<span class="token punctuation">]</span>   查看路由器上的（详细）地址转换信息<span class="token class-name">R</span># show ip nat statistics   查看路由器上的地址转换的统计信息<span class="token class-name">R</span># clear ip nat translation <span class="token operator">*</span>   清除所有NAT表项<span class="token class-name">R</span># clear ip nat translation inside<span class="token operator">|</span>outside global_IP_address<span class="token operator">|</span>local_IP_address   清除转换表中的指定动态条目<span class="token class-name">R</span># clear ip nat translation protocol inside global_IP_address global_port local_IP_address local_port   清除转换表中的指定动态条目<span class="token class-name">R</span># debug ip nat 提供IOS对每个已转换分组所做的转换<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>14.DHCP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> service dhcp    启用<span class="token operator">/</span>禁用DHCP（默认启用）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp pool pool_name   创建地址池<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># network network_number <span class="token punctuation">[</span>subnet_mask<span class="token operator">|</span><span class="token operator">/</span>prefix_length<span class="token punctuation">]</span> 指定分配给客户的IP地址范围<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># domain<span class="token operator">-</span>name domain_name 向客户分配域名<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># dns<span class="token operator">-</span>server <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>   指定最多<span class="token number">8</span>台DNS服务器分配给客户<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># netbios<span class="token operator">-</span>name<span class="token operator">-</span>server <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>  指定最多<span class="token number">8</span>台WINS服务器分配给客户<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># netbios<span class="token operator">-</span>node<span class="token operator">-</span>type node_type 向微软客户分配节点类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>router <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>   指定最多<span class="token number">8</span>条默认路由给客户用于该地址范围<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># lease days <span class="token punctuation">[</span>hours<span class="token punctuation">]</span> <span class="token punctuation">[</span>minutes<span class="token punctuation">]</span> <span class="token operator">|</span>infinite  指定租约的期限（默认一天）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp ping timeout milliseconds    指定测试服务器地址池中的可用地址是否正在使用时服务器应等待时间<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp excluded<span class="token operator">-</span>address beginning_IP_address <span class="token punctuation">[</span>ending_IP_address<span class="token punctuation">]</span>    排除一些地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address dhcp   在路由器上建立DHCP客户<span class="token class-name">R</span># show ip dhcp binding <span class="token punctuation">[</span>client_address<span class="token punctuation">]</span>    查看分配给客户的地址<span class="token class-name">R</span># clear ip dhcp binding client_address<span class="token operator">|</span><span class="token operator">*</span>   清除分配给客户的指定<span class="token operator">/</span>所有地址<span class="token class-name">R</span># debug ip dhcp server events<span class="token operator">|</span>packet<span class="token operator">|</span>linkage   查看DHCP服务器相关信息<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>15.HDLC</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation hdlc    封装同步串行接口为HDLC（默认）<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>16.PPP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation ppp 在WAN接口上使用PPP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp pap sent<span class="token operator">-</span>username your_hostname password password 指定PAP用于认证并且提供在服务端用于执行认证的用户名和口令（此为客户端配置）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># hostname your_router's_hostname  为路由器指定惟一主机名（以下三个为服务端配置）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># username remote_hostname password matching_password  指定认证路由器时所使用的远端主机名称和口令<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication pap    指定PAP认证<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication chap<span class="token operator">|</span>pap<span class="token operator">|</span>chap pap<span class="token operator">|</span>pap chap 批定PPP认证类型<span class="token class-name">R</span># debug ppp negotiation    查看LCP协商时的信息<span class="token class-name">R</span># debug ppp authentication 查看PPP认证情况<span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>17.FR</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation frame<span class="token operator">-</span>relay <span class="token punctuation">[</span>cisco<span class="token operator">|</span>ietf<span class="token punctuation">]</span>    指定封装类型为帧中继<span class="token punctuation">(</span>默认cisco）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># frame<span class="token operator">-</span>relay lmi<span class="token operator">-</span>type ansi<span class="token operator">|</span>cisco<span class="token operator">|</span>q933a 给该串行接口指定LMI类型<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay lmi 查看详细的LMI统计信息<span class="token class-name">R</span># debug frame<span class="token operator">-</span>relay lmi    报告路由器正在发送与接收的实际LMI信息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># frame<span class="token operator">-</span>relay map protocol_name destination_address local_dlci_# <span class="token punctuation">[</span>broadcast<span class="token punctuation">]</span> <span class="token punctuation">[</span>ietf<span class="token operator">|</span>cisco<span class="token punctuation">]</span>   将远端第<span class="token number">3</span>层地址手动映射到本地DLCI号<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> frame<span class="token operator">-</span>relay inverse<span class="token operator">-</span>arp <span class="token punctuation">[</span>protocol_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>DLCI_#<span class="token punctuation">]</span> 启用<span class="token operator">/</span>禁用逆向<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>18.ARP（默认启用）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span> clear frame<span class="token operator">-</span>relay<span class="token operator">-</span>inarp    清除逆向ARP解析表<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay traffic 查看逆向ARP统计<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay pvc <span class="token punctuation">[</span>DLCI_#<span class="token punctuation">]</span>    查看终止于路由器的所有（指定）帧中继PVC及其统计信息<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay map 查看将第<span class="token number">3</span>层地址映射成本地DLCI号的虚电路解析表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">.</span> subinterface_# <span class="token punctuation">[</span>point<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>point<span class="token operator">|</span>multipoint<span class="token punctuation">]</span>  创建子接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>subif<span class="token punctuation">)</span># frame<span class="token operator">-</span>relay <span class="token keyword">interface</span><span class="token operator">-</span>dlci local_DLCI_#    配置子接口的帧中继<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>19.ISDN</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">]</span><span class="token punctuation">)</span># isdn <span class="token keyword">switch</span><span class="token operator">-</span>type <span class="token class-name">ISDN_switch_type</span>   在全局或接口配置模式下配置交换机类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isdn spid1 spid_#__for_1st_BRI local_dial_#   为第一个<span class="token class-name">B</span>信道配置SPID<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isdn spid2 spid_#__for_2st_BRI local_dial_#   为第二个<span class="token class-name">B</span>信道配置SPID<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># controller t1<span class="token operator">|</span>e1 <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    以下<span class="token number">6</span>个命令为控制卡配置<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># framing esf<span class="token operator">|</span>sf<span class="token operator">|</span>crc4<span class="token operator">|</span>nocrc4    在T1或E1上使用物理成帧<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># linecode ami<span class="token operator">|</span>b8zs<span class="token operator">|</span>hdb3    线路编码，定义<span class="token number">1</span>与<span class="token number">0</span>如何在线路上物理表示<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># clock source line primary<span class="token operator">|</span>secondary<span class="token operator">|</span>internal  定义路由器如何获得其时钟以用于同步数字连接<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># pri<span class="token operator">-</span>group timeslots <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">24</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">]</span>   指定路由器哪个或哪些时隙用于ISDN连接<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> shutdown 启用<span class="token operator">/</span>禁用控制器<span class="token class-name">R</span># show controllers t1<span class="token operator">|</span>e1 <span class="token punctuation">[</span>slot_#<span class="token operator">/</span>port_#<span class="token punctuation">]</span>   验证控制器卡配置<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token operator">:</span><span class="token number">23</span> 设置逻辑串口（T1使用）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token operator">:</span><span class="token number">15</span> 设置逻辑串口（E1使用）<span class="token class-name">R</span># show <span class="token keyword">interface</span> bri <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>    验证ISDN连接的状态（查看<span class="token class-name">B</span>信道）<span class="token class-name">R</span># show isdn status 查看ISDN详细的物理层和数据链路层信息<span class="token class-name">R</span># debug isdn q921  报告ISDN数据链路层详细信息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route <span class="token class-name">IP_network_</span># subnet_mask remote_router's_IP_address<span class="token operator">|</span>router_interface <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span>  配置静态路由。以下<span class="token number">7</span>个命令配置传统DDR<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># dialer<span class="token operator">-</span>list list_# protocol protocol_name permit<span class="token operator">|</span>deny <span class="token punctuation">[</span>access<span class="token operator">-</span>list ACL_#<span class="token punctuation">]</span>    定义敏感流量<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer<span class="token operator">-</span>group dialer_list_#    激活拨号列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer map protocol_name address_of_destination_router <span class="token punctuation">[</span>name remote_router_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>speed <span class="token number">56</span><span class="token operator">|</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>broadcast<span class="token punctuation">]</span> destination_phone_number   表明利用传统DDR进行电话呼叫<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer idle<span class="token operator">-</span>timeout #_of_seconds  定义空闲超时周期<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer fast<span class="token operator">-</span>idle #_of_seconds 定义快速空闲计时器<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer load<span class="token operator">-</span>threshold load either<span class="token operator">|</span>inbound<span class="token operator">|</span>outbound    通过BRI的两条<span class="token class-name">B</span>信道执行负载均衡（分配带宽）<span class="token class-name">R</span># show dialer  查看哪个DDR接口进行了电话呼叫及其状态<span class="token class-name">R</span># show isdn active 查看激活的ISDN呼叫<span class="token class-name">R</span># show isdn history    查看路由器发出的呼叫或以前接收的呼叫<span class="token class-name">R</span># debug dialer 显示建立或拆除一个连接的DDR过程<span class="token class-name">R</span># debug isdn q931  显示ISDN电话连接建立及挂断的详细信息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> dialer port_#  创建逻辑拨号接口。以下全为配置拨号配置文件。以下<span class="token number">8</span>个为拨号接口配置<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation ppp 指定封装类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication pap<span class="token operator">|</span>chap<span class="token operator">|</span>chap pap<span class="token operator">|</span>pap chap 指定认证类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address <span class="token class-name">IP_address</span> subnet_mask 指定接口IP地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer remote<span class="token operator">-</span>name name   指定远端路由器的名称<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer string phone_# <span class="token punctuation">[</span><span class="token keyword">class</span> map_name<span class="token punctuation">]</span>    指定映射类名称<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer pool pool_#    指定拨号接口能使用哪组物理接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer<span class="token operator">-</span>group dialer_list_#    激活拨号列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer pool<span class="token operator">-</span>member pool_# <span class="token punctuation">[</span>priority priority_#<span class="token punctuation">]</span> <span class="token punctuation">[</span>min<span class="token operator">-</span>link #_of_B_channels<span class="token punctuation">]</span> <span class="token punctuation">[</span>max<span class="token operator">-</span>link #_of_B_channels<span class="token punctuation">]</span> 指定哪些拨号接能使用物理接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># map<span class="token operator">-</span><span class="token keyword">class</span> dialer map_name    进入映射子配置模式。以下<span class="token number">4</span>个为创建映射类<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer isdn speed <span class="token number">56</span> 指定ISDN中的<span class="token class-name">B</span>信道的速度（默认<span class="token number">64</span>kbps）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer idle<span class="token operator">-</span>timeout #_of_seconds 定义空闲超时周期<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer fast<span class="token operator">-</span>idle #_of_seconds    定义快速空闲计时器<span class="token class-name">R</span># show dialer <span class="token keyword">interface</span> bri<span class="token operator">|</span><span class="token punctuation">&#123;</span>serial<span class="token operator">:</span><span class="token number">23</span><span class="token operator">|</span><span class="token number">15</span><span class="token punctuation">&#125;</span> <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span>port_# 显示与拨号接口关联的物理接口的进入和离开呼叫的DDR统计信息<span class="token number">1234567891011121314151617181920212223242526272829303132333435363738394041</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>20.IS-IS</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router isis  启动IS<span class="token operator">-</span>IS<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># net areaID<span class="token punctuation">.</span>systemID<span class="token punctuation">.</span>SEL   配置NET<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># is<span class="token operator">-</span>type level_of_router   配置路由器的层次<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip router isis    在接口上启动IS<span class="token operator">-</span>IS<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isis priority value level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span>   手动配置第一层或第二层路由器的优先级<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># clns router isis  为无连接网络服务启动IS<span class="token operator">-</span>IS<span class="token class-name">R</span># show ip route isis   查看通过IS<span class="token operator">-</span>IS学习到的路由<span class="token class-name">R</span># show isis database <span class="token punctuation">[</span>detail level_of_router<span class="token punctuation">]</span>  查看IS<span class="token operator">-</span>IS链路状态数据库中的所有（某层）LSP信息<span class="token class-name">R</span># show clns protocol   显示IS<span class="token operator">-</span>IS详细配置信息<span class="token class-name">R</span># show clns <span class="token keyword">interface</span>  显示配置为IS<span class="token operator">-</span>IS接口的相关信息<span class="token class-name">R</span># show clns is<span class="token operator">-</span>neighbors   查看路由器的邻居<span class="token class-name">R</span># show isis spf<span class="token operator">-</span>log    查看SPF计算情况<span class="token class-name">R</span># debug isis adj<span class="token operator">-</span>packets   查看路由器发送和接收<span class="token class-name">Hello</span> PDU的情况<span class="token class-name">R</span># debug isis update<span class="token operator">-</span>packets    提供路由器发送和接收的所有LSP详细内容及SNP信息<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>events    查看写入路由表的IS<span class="token operator">-</span>IS路由<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>triggers  查看触发SPF计算的原因<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>statistics    查看执行SPF计算所用的时间<span class="token number">1234567891011121314151617</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>21.BGP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router bgp AS_#  启动BGP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> remote<span class="token operator">-</span>as AS_#_remote_device    指定远端路由器作为对等体<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no synchronization    关闭BGP与IGP同步（默认启用）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> update<span class="token operator">-</span>source loopback #    使用环回接口作为对等体<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> ebgp<span class="token operator">-</span>multihop <span class="token punctuation">[</span>ttl<span class="token punctuation">]</span> 配置eBGP多跳（允许BGP邻居可以不在直连网络上）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> route<span class="token operator">-</span>reflector<span class="token operator">-</span>client  配置邻居为路由反射器客户<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network network_address mask subnet_mask  向对等体通告路由（手动向BGP注入路由）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute protocol process_ID  将路由重新分配到BGP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute connected    将直连接口地址重新分配到BGP<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp cluster<span class="token operator">-</span>id cluster_ID 分配簇ID<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp confederation identifier confederation_ID 配置联邦ID<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp confederation peers AS_#  配置联邦的对等自治系统成员<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> distribute<span class="token operator">-</span>list access_list_# <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>  过滤到或来自邻居的更新信息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip prefix<span class="token operator">-</span>list list_name <span class="token punctuation">[</span>seq seq_value<span class="token punctuation">]</span> permit<span class="token operator">|</span>deny network_address<span class="token operator">/</span>length <span class="token punctuation">[</span>ge ge_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>le le_value<span class="token punctuation">]</span>  配置前缀列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> prefix<span class="token operator">-</span>list list_name <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>  应用从邻居输入的前缀列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># route<span class="token operator">-</span>map route_map_name permit<span class="token operator">|</span>deny <span class="token punctuation">[</span>sequence_number<span class="token punctuation">]</span>   创建路由映射序列<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match as<span class="token operator">-</span>path <span class="token class-name">AS_path_accesslist_</span># 匹配BGP自治系统路径访问列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match community<span class="token operator">-</span>list community_list_#  匹配BGP团体<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  发布任何下一跳是指定接口的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip address access_list_#<span class="token operator">|</span>prefix_list_name    匹配任何目的网络地址被指定的标准访问列表、扩展访问列表或前缀列表允许的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip next<span class="token operator">-</span>hop access_list_#<span class="token operator">|</span>prefix_list_name   匹配任何下一跳地址被指定的标准访问列表、扩展访问列表或前缀列表允许的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip route<span class="token operator">-</span>source access_list_#<span class="token operator">|</span>prefix_list_name   匹配任何由被指定的标准访问列表、扩展访问列表或前缀列表允许的地址通告的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match metric value 匹配任何具有指定的度量值的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match route<span class="token operator">-</span>type type_of_route 匹配任何具有指定类型的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match tag value    匹配任何具有指定标识的路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set as<span class="token operator">-</span>path prepend AS_#   向AS_PATH属性添加自治系统号<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set as<span class="token operator">-</span>path tag    设置作为AS_PATH属性的标记<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set automatic<span class="token operator">-</span>tag  自动计算标记值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set community number<span class="token operator">|</span>aa<span class="token operator">:</span>nn<span class="token operator">|</span>additive<span class="token operator">|</span>local<span class="token operator">-</span>as<span class="token operator">|</span>no<span class="token operator">-</span>advertise<span class="token operator">|</span>no<span class="token operator">-</span>export<span class="token operator">|</span>none   设置BGP COMMUNITIES属性<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set dampening half_life start_reusing start_suppressing duration_to_suppress   设置BGP路由冷落参数<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set <span class="token keyword">default</span> <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    设置默认的输出接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    设置输出接口<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip <span class="token keyword">default</span> next<span class="token operator">-</span>hop <span class="token class-name">IP_address</span> 设置路径的默认下一跳地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip next<span class="token operator">-</span>hop <span class="token class-name">IP_address</span> 设置下一跳地址<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip precedence <span class="token punctuation">[</span>precedence<span class="token punctuation">]</span> 设置“IP <span class="token class-name">Precedence</span>”字段<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip tos type_of_service 设置“IP服务类型”字段<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set level level    设置导入路由的位置<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set local<span class="token operator">-</span>preference value 设置BGP LOCAL_PREF路径属性<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set metric value   设置目标路由协议的度量值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set metric<span class="token operator">-</span>type type_of_route  设置目标路由协议的度量类型<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set origin origin_code 设置BGP源代码<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set tag value  设置目标路由协议的标记值<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set weight value   设置路由表的BGP权重<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> route<span class="token operator">-</span>map route_map_name <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>   应用从邻居输入的路由映射<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> send<span class="token operator">-</span>community  向该邻居发送COMMUNITY属性<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip community<span class="token operator">-</span>list community_list_# <span class="token punctuation">[</span>permit<span class="token operator">|</span>deny<span class="token punctuation">]</span> community_list_#    创建团体列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor peer_group_name peer<span class="token operator">-</span>group   创建对等组<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor peer_group_name option_to_use_in_update_policy   给对等组分配选项<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> peer<span class="token operator">-</span>group peer_group_name  给对等组分配对等体<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no auto<span class="token operator">-</span>summary   取消BGP的自动路由汇总功能<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># aggregate<span class="token operator">-</span>address <span class="token class-name">IP_address</span> mask <span class="token punctuation">[</span>summary<span class="token operator">-</span>only<span class="token punctuation">]</span>  创建汇聚地址（禁止通告其他特定路由）<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># aggregate<span class="token operator">-</span>address <span class="token class-name">IP_address</span> mask as<span class="token operator">-</span>set  创建汇聚地址，在AS_PATH中添加AS_SET类型<span class="token class-name">R</span># clear ip bgp peer_address    重设特定BGP对等会话<span class="token class-name">R</span># clear ip bgp AS_#    重设指定自治系统的所有对等体的BGP会话<span class="token class-name">R</span># clear ip bgp <span class="token operator">*</span>   重设路由器上所有BGP会话<span class="token class-name">R</span># show ip bgp  查看路由器从BGP学习到的所有路由<span class="token class-name">R</span># show ip bgp summary  提供和路由器具有对等关系的所有路由器汇总<span class="token class-name">R</span># show ip bgp neighbors    查看对等体连接详细信息<span class="token class-name">R</span># debug ip bgp 查看在本地路由器与试图和其建立对等关系的路由器之间所发送和接收的OPEN信息<span class="token class-name">R</span># debug ip bgp updates 提供路由器发送和接收所有UPDATE消息的信息<span class="token class-name">R</span># debug ip bgp peer_address upadtes    提供关于BGP对等体之间发送的UPDATE消息<span class="token class-name">R</span># debug ip bgp dampening   显示关于被冷落路由的信息<span class="token class-name">R</span># debug ip bgp events  提供关于尝试成为BGP对等体的路由器的状态转换信息<span class="token class-name">R</span># debug ip bgp keepalives  提供关于路由器发送和接收KEEPALIVE消息的信息<span class="token number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>22.路由优化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distribute<span class="token operator">-</span>list ACL_#<span class="token operator">|</span>prefix prefix_list_name in<span class="token operator">|</span>out <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span>   配置分配列表<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip policy route<span class="token operator">-</span>map map_tag   识别一个接口上基于策略的路由选择使用的路由映射<span class="token class-name">R</span># show ip policy   列出所有配置为基于策略的路由选择的接口及它们相关的路由映射<span class="token class-name">R</span># show route<span class="token operator">-</span>map   查看所有路由映射<span class="token class-name">R</span># debug ip policy  提供在该路由器上执行的路由策略的信息<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>information originate 重新分配默认路由到OSPF和IS<span class="token operator">-</span>IS<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>information originate always  引起一个默认路由到OSPF不管路由表中是否有一个默认路由<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute protocol <span class="token punctuation">[</span>process<span class="token operator">-</span>ID<span class="token punctuation">]</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span> <span class="token punctuation">[</span>metric metric_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>metric<span class="token operator">-</span>type type_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>match internal<span class="token operator">|</span>external <span class="token number">1</span><span class="token operator">|</span>external <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>tag tag_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>route<span class="token operator">-</span>map map_tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>weight weight_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>subnets<span class="token punctuation">]</span>    重新分配路由选择信息从一个路由选择域到另一个路由选择域<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># summary<span class="token operator">-</span>address network_address network_mask <span class="token punctuation">[</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>  为起源于和重新分配到IS<span class="token operator">-</span>IS的路由创建一个汇总地址<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>23.异步连接</p><pre class="line-numbers language-none"><code class="language-none">R# line number  进入线路配置模式R(config-line)# login   允许一个连接R(config-line)# password password   提供线路上使用的口令R(config-line)# flowcontrol hardware|software   选择硬件流控制或软件流控制R(config-line)# speed number    指定调制解调器和访问服务器或路由器之间使用的最大速度（单位：bps）R(config-line)# transport input lat|mop|nasi|pad|rlogin|telnet|v120|all 定义反向Telnet连接使用的协议R(config-line)# stopbits 1|1.5|2    定义每个字节的结束R(config-line)# modem autoconfigure type modem_type 指示路由器使用modemcap数据库中的命令按照指定的类型对连接到一个端口上的调制解调器进行自动配置R# show modemcap    显示modemcap数据库R(config-line)# modem edit modem_profile_name   向modemcap数据库增加条目R(config-line)# modemcap edit new_profile_name template existing_profile_name   创建名为new_profile_name的条目并从existing_profile_name中拷贝所有的配置R(config-line)# modem autoconfigure discovery   发现和自动配置连接到一个端口上的调制解调器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/25.jpg" alt="25"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;警告：Cisco课程，不可用于商用&lt;/p&gt;
&lt;p&gt;因为我发现学这个课老是断断续续的，每次捡起来超级麻烦，所以趁这次来个大复习，把一些该有的知识点直接记下来好了&lt;/p&gt;
&lt;h1 id=&quot;当今网络&quot;&gt;&lt;a href=&quot;#当今网络&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="cisco" scheme="http://example.com/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>Linux(basic)</title>
    <link href="http://example.com/2021/03/13/Linux/"/>
    <id>http://example.com/2021/03/13/Linux/</id>
    <published>2021-03-13T12:57:21.000Z</published>
    <updated>2021-04-08T12:03:09.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>一个操作系统是一种软件，在计算设备上运行和管理硬件和软件组件，使一个功能性计算系统。</p><p>现代操作系统不仅管理硬件和软件资源，还计划将程序以多任务方式运行（共享处理器，以便显然可以同时发生多个任务），提供允许用户和程序请求发生某些事情的标准服务。 （例如打印作业），并在正确请求的情况下，操作系统将接受该请求并执行所需的功能。</p><p>桌面和服务器操作系统本质上比在诸如防火墙或移动电话之类的专用设备上运行的操作系统更为复杂。从提供电缆菜单菜单界面的简单机顶盒到超级计算机和大规模并行计算集群，通用术语“操作系统”用于描述在该设备上启动和运行的任何软件。</p><p>如今，计算机用户主要在以下三种主要操作系统之间进行选择：<strong>Microsoft Windows</strong>，<strong>Apple macOS</strong>和<strong>Linux</strong>。</p><p>在列出的三个主要操作系统中，只有Microsoft Windows在其基础代码中是唯一的。苹果的macOS是基于BSD Unix（直到1995年才发行的操作系统）的完全合格的UNIX发行版，并辅以大量的专有代码。它在经过专门优化以与Apple软件配合使用的硬件上运行。Linux可以是数百种针对任何任务而设计或优化的分发软件包中的任何一种。仅Microsoft Windows基于不基于UNIX或Linux的专有代码库。</p><p>用户可以通过日常工作任务指向并单击自己的方式来轻松地与任何这些系统进行交互，而无论底层操作系统如何，这些任务的行为都相似。除了主要通过GUI管理的Windows外，大多数系统管理任务都是使用终端中的键入命令来执行的。熟悉UNIX的管理员通常可以在Linux系统上执行任务，反之亦然。许多Linux命令行功能还具有Microsoft等效项，管理员可以使用这些等效项来有效地完成工作。</p><p>决定你需要什么操作系统前，需要考虑很多因素：</p><p>角色，功能，生命周期</p><p>稳定性，兼容性，成本，界面</p><p><strong>Microsoft</strong>根据计算机的角色提供不同的操作系统：台式机还是服务器？Windows的桌面版本经历了各种命名方案，当前版本（在撰写本文时）仅为<strong>Windows 10</strong>。此操作系统的新版本每3-5年发布一次，并且往往会得到很多年的支持。向后兼容性是Microsoft的首要任务，甚至可以捆绑虚拟机技术，使用户可以运行较早的软件。</p><p><strong>Windows Server</strong>当前（截至撰写本文时）的版本为<strong>2019，</strong>以指示发布日期。该服务器可以运行GUI，但是最近，Microsoft（主要是对Linux的竞争）在通过PowerShell的命令行脚本功能方面取得了不可思议的进步。还有一个可选的Desktop Experience软件包，它模仿了标准的生产率计算机。微软还积极鼓励企业客户整合其Azure云服务。</p><p><strong>苹果公司</strong>生产的<strong>macOS</strong>操作系统部分基于FreeBSD项目中的软件，并且已经过UNIX认证。macOS以“易于使用”而著称，因此继续受到访问学校和小型企业等IT资源有限的用户的青睐。由于其强大的UNIX基础，它在程序员中也非常受欢迎。</p><p>在服务器方面，<strong>macOS Server</strong>主要针对较小的组织。macOS桌面的这种低成本添加使用户可以进行协作，而管理员可以控制对共享资源的访问。它还提供与iPhone和iPad等iOS设备的集成。</p><p>一些大型公司的IT部门允许用户选择macOS，因为与标准的Microsoft生产力部署相比，用户所需的支持通常更少。macOS的持续流行确保了软件供应商的健康支持。macOS在图形和视频制作等创意产业中也很受欢迎。对于许多这样的用户，应用程序的选择决定了操作系统的决定。与操作系统紧密集成的Apple硬件及其在应用程序编程中坚持遵守标准的能力，为这些富有创造力的专业人士提供了一个稳定的平台，可以执行许多具有计算能力的功能，而对兼容性的顾虑则很少。</p><p>Linux用户通常通过<strong>下载发行版</strong>来获得操作系统。Linux发行版是一包软件，通常包含Linux内核，实用程序，管理工具，甚至包括一些应用程序软件，它们都包含在软件包中，该软件包还包括更新核心软件和安装其他应用程序的方法。</p><p><strong>该发行版负责设置存储，构建内核和安装硬件驱动程序，以及安装应用程序和实用程序以构成功能齐全的计算机系统。创建发行版的组织还包括用于管理系统的工具，用于添加和删除软件的程序包管理器以及用于提供安全性和功能补丁的更新程序。</strong></p><p>Linux发行版的可用数量达数百种，因此一开始的选择似乎令人生畏。但是，决策点与选择操作系统时突出显示的决策点基本相同。</p><p><strong>强烈建议自己看一下LINUX第二章背景知识<a href="https://lms-cn.netacad.com/course/view.php?id=12987">戳我</a></strong></p><h2 id="各种发行版"><a href="#各种发行版" class="headerlink" title="各种发行版"></a>各种发行版</h2><h3 id="Red-Hat"><a href="#Red-Hat" class="headerlink" title="Red Hat"></a><strong>Red Hat</strong></h3><p> Over time, Red Hat started to focus more on the server applications, such as web- and file-serving and released <strong>Red Hat Enterprise Linux (RHEL)</strong>, which was a paid service on a long release cycle.</p><p><strong>Scientific Linux</strong> </p><p>is an example of a specific-use distribution based on Red Hat，The project is a Fermilab-sponsored distribution designed to enable scientific computing.</p><p><strong>Centos</strong></p><p>Because everything in Red Hat Enterprise Linux is open source, a project called <strong>CentOS</strong> came to be， It recompiled all the RHEL packages，and gave them away for free.</p><h3 id="SUSE"><a href="#SUSE" class="headerlink" title="SUSE"></a><strong>SUSE</strong></h3><p>originally derived from <strong>Slackware</strong>, </p><p>While SUSE Linux Enterprise contains proprietary code and is sold as a server product, <strong>openSUSE</strong> is a completely open, free version with multiple desktop packages similar to CentOS and Linux Min</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a><strong>Debian</strong></h3><p>is more of a community effort, and as such, also promotes the use of open source software and adherence to standards，Debian came up with its own package management system based on the <code>.deb</code> file format. While Red Hat leaves non-Intel and AMD platform support to derivative projects, Debian supports many of these platforms directly. respect！！</p><p><strong>Ubuntu</strong> </p><p>is the most popular Debian-derived distribution. It is the creation of <strong>Canonical</strong>，They also offer an LTS version that is kept up-to-date for 3 years on desktops and 5 years on servers, which gives developers and the companies they work for confidence to build solutions based on a stable distribution.</p><p><strong>‌⁠⁠Linux Mint</strong> </p><p>was started as a fork of Ubuntu Linux, while still relying upon the Ubuntu repositories. There are various versions, all free of cost, but some include proprietary codecs, which cannot be distributed without license restrictions in certain countries.</p><p><em>Linux is a kernel, and many of the commands covered in this course are actually part of the GNU package. That is why some people insist on using the term <strong>GNU/Linux</strong> instead of Linux alone. Linux仅仅是一个内核，他的功能都是由开源项目GNU实现的，他们（开源）被我们和Linux系统视为一体，我们要对这些开源的先驱充满敬意！</em></p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p><strong>Android</strong>, sponsored by Google, is the world’s most popular Linux distribution. It is fundamentally different from its counterparts. Android uses the <strong>Dalvik</strong> virtual machine with Linux, providing a robust platform for mobile devices such as phones and tablets. However, lacking the traditional packages that are often distributed with Linux (such as GNU and Xorg), Android is generally incompatible with desktop Linux distributions.</p><p>use <strong>BusyBox</strong> with Android to enable most commands to work.</p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p><strong>Raspbian</strong> is a specialized Linux distribution optimized to run on <strong>Raspberry Pi</strong> hardware， Its low cost and ease of use have made it a favorite of educators worldwide, and many add-on devices are available to extend its capabilities into the physical world.</p><p><strong>Linux From Scratch (LFS)</strong> is more of a learning tool than a working distribution。This project consists of an online book, and source code, with “step-by-step instructions” for building a custom Linux distribution from the source code up. This “distribution” embodies the true spirit of Linux whereby users can modify any aspect of the operating system and learn how all the pieces work together. It’s also a good starting point for anyone who needs specialized functionality or an ultra-compact build for an embedded system project.</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210316171316621.png" alt="image-20210316171316621"></p><h2 id="Linux嵌入无处不在！"><a href="#Linux嵌入无处不在！" class="headerlink" title="Linux嵌入无处不在！"></a>Linux嵌入无处不在！</h2><p>Linux最初只能在Linus Torvald的计算机上运行：具有特定硬盘驱动器控制器的Intel 386 PC，但是由于任何人都可以添加或更改Linux，人们开始构建对其他硬件的支持。最终，Linux开始支持其他注重小尺寸和低功耗的芯片。</p><p>由于这种灵活性，许多设备制造商已将Linux用作其硬件产品的操作系统。今天，我们将这些嵌入式系统称为“嵌入式系统”，是因为它们被设计为仅针对此目的在经过优化的硬件上执行特定任务。这些系统涵盖了当今使用的各种设备，从手机到智能电视和家电，再到用于管道和工厂的远程监控系统。</p><p>随着Linux的发展，专门为消费类和工业设备开发了专用处理器芯片，以利用其功能。对Linux的支持已经变得无处不在，因此可以使用现成的组件来进行原型设计并将新设备推向市场。像Raspberry Pi这样的廉价，小型，适应性强的单板计算机的兴起，为实验人员和企业家提供了各种工具，可以快速构建基于Linux的自定义解决方案，而几年前，专门团队需要花费数月的时间。</p><p>尽管消费者熟悉嵌入式Linux娱乐设备，如数字录像机（DVR）和“智能电视”，但嵌入式Linux的真正影响才刚刚开始意识到。在物联网（IOT）只是斜了便宜，部署在一切从油井到太阳能发电场无处不在的设备。这些智能传感器和控制器网络使工程师能够实时调整关键过程，同时监视并报告给中央控制站。随着越来越多的流程被监视以及更多的数据与机器学习和人工智能（AI）集成，我们可以预期效率，安全性和生产率的提高仅是前几代人梦dream以求的。</p><h1 id="使用Linux工作"><a href="#使用Linux工作" class="headerlink" title="使用Linux工作"></a>使用Linux工作</h1><h2 id="主要应用"><a href="#主要应用" class="headerlink" title="主要应用"></a>主要应用</h2><p>Linux内核可以在许多硬件平台上运行各种软件。计算机可以充当服务器，这意味着它主要代表他人处理数据，也可以充当台式机，这意味着用户直接与计算机进行交互。该计算机可以运行软件，也可以在创建软件的过程中用作开发计算机。一台机器甚至可以扮演多个角色，<strong>因为Linux没有区别。这仅是配置运行哪些应用程序的问题。</strong></p><p>由此带来的一个优势是，Linux可以模拟生产环境的几乎所有方面，从开发到测试，再到按比例缩小的硬件进行验证，从而节省了成本和时间。Linux管理员可以在台式机或大型互联网服务提供商运行的廉价虚拟服务器上运行相同的服务器应用程序。当然，台式机将无法处理与主要提供商相同的卷，但是几乎可以模拟任何配置，而无需强大的硬件或服务器许可。</p><p>Linux软件通常分为以下三类之一：</p><ul><li><p>服务器应用</p><p>与运行机器的显示器和键盘没有直接交互作用的软件。其目的是将信息提供给称为客户端的其他计算机。有时服务器应用程序可能不与其他计算机通信，而只能坐在那里处理数据。</p></li><li><p>桌面应用</p><p>用户直接与之交互的Web浏览器，文本编辑器，音乐播放器或其他应用程序。在许多情况下，例如Web浏览器，应用程序正在与另一端的服务器通信并解释数据。这是客户端/服务器应用程序的“客户端”端。</p></li><li><p>工具</p><p>存在的松散类别的软件，可以更轻松地管理计算机系统。工具可以帮助配置显示，提供用户输入命令的Linux shell或什至是更复杂的工具（称为编译器），这些工具可以将源代码转换为计算机可以执行的应用程序。</p></li></ul><p>封闭源代码和开放源代码软件世界之间存在几个显着差异，一个是将其他项目作为项目或程序包的组件包含在内。在封闭源代码世界中，<strong>Microsoft Exchange</strong>主要作为包含以下内容的软件包/套件提供：所有必需的或已批准的组件，均来自Microsoft，因此几乎没有（如果有的话）进行单独选择的选项。在开源世界中，很多选项都可以模块化地包含在组件中或换成组件组件，实际上，某些软件包或套件只是一组包装良好的组件，否则各个组件都可以和谐地协同工作。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>Linux由于其可靠性和效率而擅长于运行服务器应用程序。利用仅需的组件来优化服务器操作系统的能力使管理员可以用更少的钱做更多的事情，这是初创企业和大型企业都喜欢的功能。</p><p><strong>Web服务器</strong></p><p><strong>Apache</strong>是当今使用的主要<strong>Web服务器</strong>。Apache最初是一个独立的项目，但此后成立了<strong>Apache Software Foundation，</strong>并维护了一百多个开源软件项目。<strong>Apache HTTPD</strong>是守护程序或服务器应用程序，用于“服务”网页请求。</p><p>另一个Web服务器是<strong>NGINX</strong>，它位于俄罗斯之外。它通过使用更现代的UNIX内核来专注于性能，并且仅提供Apache可以执行的工作的一部分。超过65％的网站由NGINX或Apache提供支持。</p><p><strong>私有云服务器软件</strong></p><p>随着个人，组织和公司开始将其数据移动到云中，对可以在内部部署和管理的<strong>私有云服务器软件</strong>的需求日益增长。</p><p>该<strong>ownCloud</strong>项目于2010年推出由弗兰克·卡利切从私有云服务器提供软件来存储，同步和共享数据。它有标准的开源GNU AGPLv3许可证和带有商业许可证的企业版。</p><p>该<strong>Nextcloud</strong>项目从ownCloud在2016年由Karlitschek分叉，从那时起一直稳步增长。它是在GNU AGPLv3下提供的，旨在“开放，透明的开发过程”。</p><p>这两个项目都致力于提供满足大型和小型组织需求的私有云软件，这些组织需要安全性，隐私和法规遵从性。尽管其他几个项目旨在为相同的用户提供服务，但就部署和项目成员而言，这两个是迄今为止最大的项目。</p><p><strong>数据库服务器</strong></p><p>MariaDB是<strong>MySQL</strong>关系数据库管理系统的社区开发分支。它只是用于Web开发的许多数据库服务器之一，因为不同的要求决定了执行所需任务的最佳应用程序。</p><p>数据库存储信息，并且还允许轻松检索和查询。其他一些流行的数据库是<strong>Firebird</strong>和<strong>PostgreSQL</strong>。您可以将原始销售数据输入数据库，然后使用称为<strong>结构化查询语言（SQL）的语言</strong>按产品和日期汇总销售以生成报告。</p><p><strong>电子邮件服务器</strong></p><p><strong>Dovecot</strong>由于其易用性和低维护性而成为流行的POP / IMAP服务器。<strong>赛勒斯IMAP</strong>是另一种选择</p><p><strong>文件共享</strong></p><p>对于以Windows为中心的文件共享，<strong>Samba</strong>无疑是赢家。Samba允许Linux机器的外观和行为类似于Windows机器，以便它可以共享文件并参与Windows域。Samba实现服务器组件，例如使文件可用于共享和某些Windows服务器角色，并实现客户端，以便Linux机器可以使用Windows文件共享。</p><p><strong>Netatalk</strong>项目可让Linux机器成为苹果Macintosh文件服务器执行。UNIX / Linux的本机文件共享协议称为<strong>网络文件系统（NFS）</strong>。NFS通常是内核的一部分，这意味着可以像安装常规磁盘一样安装（可访问）远程文件系统，从而使文件访问对其他应用程序透明。</p><p>DNS主要集中在计算机名称和IP地址上，不易搜索。出现了其他目录来存储信息，例如用户帐户和安全角色。在<strong>轻量级目录访问协议（LDAP）</strong>是一个共同的目录系统，同样支持微软的Active Directory。在LDAP中，对象存储在树中，并且该对象在树上的位置可用于派生有关该对象及其存储内容的信息。例如，Linux管理员可以存储在名为“ IT Department”的树的分支中，该分支位于名为“ Operations”的分支之下。因此，通过在“ IT部门”分支下进行搜索，可以找到所有技术人员。<strong>OpenLDAP</strong>是Linux基础结构中使用的主要程序。</p><h3 id="桌面应用"><a href="#桌面应用" class="headerlink" title="桌面应用"></a>桌面应用</h3><p><strong>电子邮件</strong></p><p>Mozilla基金会推出了功能齐全的桌面电子邮件客户端<strong>Thunderbird</strong>。Thunderbird连接到POP或IMAP服务器，在本地显示电子邮件，并通过外部SMTP服务器发送电子邮件。</p><p>其他值得注意的电子邮件客户端是<strong>Evolution</strong>和<strong>KMail</strong>，它们是GNOME和KDE项目的电子邮件客户端。通过POP和IMAP以及本地电子邮件格式进行标准化意味着可以轻松地在电子邮件客户端之间进行切换而不会丢失数据。</p><p><strong>创意</strong></p><p>有<strong>Blender</strong>，<strong>GIMP（GNU图像处理程序）</strong>和<strong>Audacity</strong>分别处理3D电影创建，2D图像处理和音频编辑。Audacity是免费的开源音频编辑工具，可在多个操作系统上使用。（甚至ctf都用）</p><p><strong>生产力</strong></p><p>在演示文稿和项目中<strong>使用通用的开源应用程序</strong>是增强Linux技能的一种方法。基本的生产力应用程序（例如文字处理器，电子表格和演示文稿包）是宝贵的资产。总的来说，它们被称为办公套件，这主要是由于市场上占主导地位的Microsoft Office所致。</p><p><strong>LibreOffice</strong>是<strong>OpenOffice</strong>（有时称为<strong>OpenOffice.org</strong>）应用程序套件的分支。两者都提供完整的办公套件，包括力求在功能和文件格式上与Microsoft Office兼容的工具。</p><p>LibreOffice还可以使用其他文件格式，例如Microsoft Office或<strong>Adobe可移植文档格式（PDF）</strong>文件。此外，通过使用扩展，可以使LibreOffice与Wiki软件集成，从而为您提供功能强大的Intranet解决方案。</p><p><strong>Web浏览器</strong></p><p>Linux是<strong>Mozilla Firefox</strong>和<strong>Google Chrome</strong>浏览器的一等公民。两者都是开源的Web浏览器，它们快速，功能丰富，并且对Web开发人员具有出色的支持</p><h3 id="控制台工具"><a href="#控制台工具" class="headerlink" title="控制台工具"></a>控制台工具</h3><p>从历史上看，UNIX的开发表明软件开发和系统管理的技能之间存在相当多的重叠。用于管理系统的工具具有诸如循环（允许重复执行命令）之类的计算机语言功能，并且某些计算机编程语言已广泛用于自动化系统管理任务。因此，应该认为这些技能是互补的，并且主管系统管理员至少需要对编程有基本的了解。</p><p><em><strong>Shell</strong></em></p><p>Shell的工作是接受命令，例如文件操作和启动应用程序，并将这些命令传递给Linux内核以执行。shell⁠ ⁠Linux外壳提供了丰富的语言来遍历文件和自定义环境，而这一切都无需离开外壳。</p><p>Linux提供了多种外壳供您选择，它们的主要区别在于如何自定义方式和自定义内容以及内置脚本语言的语法。两个主要的族是<strong>Bourne壳</strong>和<strong>C壳</strong>。Bourne外壳以其创建者Bell Labs的Stephen Bourne命名。之所以如此命名C外壳，是因为其语法是从C语言大量借用的。由于这两种外壳都是在1970年代发明的，因此出现了更多现代版本，包括<strong>Bourne Again Shell（Bash）</strong>和<strong>tcsh</strong>（发音为tee-cee-shell）。Bash是大多数系统上的默认Shell，尽管通常也可以使用tcsh。</p><p>程序员从Bash和tcsh获得了喜欢的功能，并制作了其他shell，例如<strong>Korn shell（ksh）</strong>和<strong>Z shell（zsh）</strong>。壳的选择主要是个人的。熟悉Bash的用户可以在大多数Linux系统上有效运行。其他外壳可能会提供可在特定使用情况下提高生产率的功能。</p><p><strong>文本编辑</strong></p><p><strong>Vi</strong>（或者更现代的<strong>Vim</strong>）和<strong>Emacs</strong>是两个主要的应用程序。两者都是编辑文本文件的强大工具。它们在命令格式以及为它们编写插件的方式方面有所不同，Vi和Emacs都很复杂，学习曲线也很陡，这对于简单编辑小文本文件没有帮助。</p><p>因此<strong>Pico</strong>和<strong>Nano</strong>提供非常基本的文本编辑</p><p>不过，管理员应该努力使自己对Vi有一些基本的了解，因为它几乎可以在现有的每个Linux系统上使用。通过在发行版的恢复模式下运行来恢复已损坏的Linux系统时，Vi可能是至关重要的工具</p><h3 id="包管理器！！"><a href="#包管理器！！" class="headerlink" title="包管理器！！"></a>包管理器！！</h3><p>每个Linux系统都需要添加，删除和更新软件。在过去，这意味着需要下载源代码，进行设置，编译以及将文件复制到需要更新的每个系统上。值得庆幸的是，现代发行版使用的包是压缩文件，这些文件将应用程序及其依赖项（或所需文件）捆绑在一起，通过创建正确的目录，将适当的文件复制到其中以及创建诸如符号链接之类的所需项来大大简化安装过程</p><p>包管理器负责跟踪的哪些文件属于哪个包，甚至从存储库下载更新，通常是远程服务器共享出去分配相应的更新。在Linux中，有许多不同的软件包管理系统，但是最受欢迎的两个是Debian和Red Hat的软件包。</p><p><strong>Debian</strong></p><p>Debian软件包管理的核心是软件包，这些软件包以<code>.deb</code>扩展名结尾的文件的形式分发。</p><p>用于管理这些文件的最底层工具是<code>dpkg</code>命令。该命令可能难倒新手Linux用户，所以<strong>先进的包装工具</strong>，<code>apt-get</code>（<code>dpkg</code>工具的前端程序），使封装的管理更加容易。用作<code>dpkg</code>前端的其他命令行工具包括<code>aptitude</code>和<strong>Synaptic</strong>和<strong>Software Center之</strong>类的GUI前端。</p><p><strong>RPM</strong></p><p>在<strong>Linux标准基础</strong>，这是<strong>Linux基金会</strong>的项目，旨在指定（通过共识）的一套标准增加符合Linux系统之间的兼容性。根据Linux Standards Base，标准软件包管理系统是RPM。</p><p>RPM<code>.rpm</code>为每个软件包使用一个文件。这个系统是从Red Hat（包括Centos和Fedora）派生的发行版用于管理软件的。不是Red Hat派生的其他几个发行版，例如SUSE，OpenSUSE和Arch，也使用RPM。</p><p>与Debian系统一样，RPM软件包管理系统跟踪软件包之间的依赖关系。跟踪相关性可确保在安装软件包时，系统还会安装该软件包正常运行所需的所有软件包。依赖关系还确保正确执行软件更新和删除。</p><p>该<code>rpm</code>命令最常用于RPM软件包管理的后端工具。虽然<code>rpm</code>命令可以安装，更新，查询和删除软件包，但命令行的前端工具，如<code>yum</code>和<code>up2date</code>使得解决依赖问题的过程自动化</p><p>还有一些基于GUI的前端工具，例如<strong>Yumex</strong>和<strong>Gnome PackageKit</strong>，它们也使RPM软件包管理更加容易</p><h2 id="云与LINUX"><a href="#云与LINUX" class="headerlink" title="云与LINUX"></a>云与LINUX</h2><p>从物理上讲，云可以描述为来自一个或多个异地数据中心的计算资源，这些资源可以通过Internet进行访问。云基于数据中心的优势，并为需要存储和处理数据的组织提供计算解决方案，并允许他们将IT基础架构的管理委派给第三方。组织存储在云中的数据和资源可以包括数据，服务器，存储，应用程序托管，分析和众多其他服务。</p><p>云部署模型为如何构建，管理和访问云基础架构提供了基础。有四种主要的云部署模型：</p><ul><li><strong>公共云</strong>：公共云是提供商所部署的云基础结构，用于通过Internet向公众和组织提供云服务。在公共云模型中，可能有多个租户（消费者）共享公共云资源。我们中的许多人很可能在某些时候通过诸如Amazon，Google和其他流行的公共云提供商之类的提供商访问了公共云资源。</li><li><strong>私有云</strong>：私有云是专门为特定组织而建立的云基础架构。与公共云相比，私有云为组织提供了更高程度的隐私，并可以控制云基础架构，应用程序和数据。它可以托管在使用它的公司管理的服务器上，也可以托管在托管的私有云提供商（例如Rackspace或IBM）中。</li><li><strong>社区云</strong>：社区云是一种云基础结构，由一组具有共同目标或要求的组织专用。参与社区的组织通常分担社区云服务的成本。此选项可能比公共云贵。但是，与公共云相比，它可以提供更高级别的控制和防御外部威胁。</li><li><strong>混合云</strong>：混合云由两个或多个单独的云组成，每个云可以是私有云，社区云或公共云。随着组件云的加入和离开，混合云可能会随时间而变化。使用这种技术可以实现数据和应用程序的可移植性。它还允许公司利用外部资源，同时保留对敏感资源的控制权。</li></ul><p>Linux在云计算中起着举足轻重的作用。它为90％的公共云工作负载提供动力，大多数虚拟服务器基于Linux内核的某个版本，并且Linux通常用于承载云计算服务背后的应用程序。那么，什么使Linux特别适合实现云计算呢？</p><p><strong>灵活性</strong></p><p>Linux在这里脱颖而出，因为它具有高度的适应性。对于初学者来说，Linux是设计上模块化的，并且在庞大的开源应用程序生态系统的中心，提供了无休止的配置选项以适合各种系统和用例。最重要的是，Linux可以高效地扩展，从而可以运行从微小的远程传感器到整个服务器场的所有内容。</p><p><strong>辅助功能</strong></p><p>在传统环境中，可从专用设备（例如台式机或笔记本电脑）访问IT资源。在云计算中，应用程序和数据驻留在中央，并且可以通过网络从任何设备（例如台式机，移动设备或瘦客户端）从网络上的任何位置进行访问，并且这些设备中的每一个都有一个Linux版本。</p><p><strong>具有成本效益</strong></p><p>云计算之所以具有吸引力，是因为它具有降低消费者IT成本的潜力。在云计算中，消费者可以单方面自动扩展IT资源以满足工作负载需求，从而消除未充分利用资源的开销。此外，减少了与IT配置，管理，占地面积，电源和冷却相关的费用。</p><p>云提供商承担了这些基础架构成本，但必须保持低成本的替代方案。选择Linux是提供商可以部署的最具成本效益的解决方案之一。Linux是最省电的操作系统之一，Linux内核以及许多相关的应用程序，实用程序和其他软件组件都是完全免费的。</p><p>企业和政府组织可以选择购买商业支持的发行版，与经许可的竞争对手相比，这种发行版更具成本效益。对于许多组织来说，支持云计算的非商业发行版也是一个可行的选择。</p><p>供应商不仅可以将这些节省的资金转嫁给客户，而且提供基于Linux的解决方案对于客户来说可以更便宜地实现。在自己的系统上安装Linux可以消除与竞争性操作系统相关的昂贵的用户许可费用。</p><p><strong>可管理性</strong></p><p>尽管Linux最初只是一个小众的操作系统，但它在IT行业中的广泛存在使Linux的使用和管理成为IT专业人员的必备技能。云供应商和消费者变得越来越容易获得必要的人才或重新分配现有的团队成员。</p><p>建立在C编程语言上的Linux的性质也使其适用于自动化管理工具。在云中运行的Linux服务器的很大一部分是由自动化管理程序而不是人工操作人员创建和管理的。此过程使管理员可以腾出时间来监视计算操作，而不必手动配置和更新系统。</p><p><strong>安全</strong></p><p>当使用云解决方案时，尤其是公共云，组织可能会担心与隐私，外部威胁以及对IT资源和数据的控制不足有关。</p><p>Linux可帮助抵消这些问题，因为它是可用的最安全和可靠的操作系统之一。Linux是开源的，这意味着其源代码可供任何人获取，查看和修改。这也意味着可以检查该代码中的漏洞和兼容性问题，从而导致社区进行了广泛的工作来纠正这些问题并维护Linux的良好声誉。</p><p><em><strong>虚拟化</strong></em></p><p>虚拟化是促成计算支持云的最重要进步之一。</p><p>Linux是一个多用户操作系统，这意味着许多不同的用户可以同时在同一个系统上工作，并且在大多数情况下不能做损害其他用户的事情。但是，这确实有局限性–用户可能会占用磁盘空间或占用过多的内存或CPU资源，并使每个人的系统运行缓慢。在多用户模式下共享系统还要求每个人都以非特权用户身份运行，因此，例如，让每个用户运行自己的Web服务器都是一项挑战。</p><p>虚拟化是一个过程，其中一台称为主机的物理计算机运行一个操作系统的多个副本，每个副本称为guest虚拟机。可以为特定功能预先配置这些来宾映像，以在需要时允许自动快速部署。<strong>主机系统运行称为Hypervisor的软件，该软件可在各种来宾之间切换资源</strong>，就像Linux内核对单个进程所做的一样。使用裸机管理程序，管理程序直接在计算机硬件上运行，而不是在操作系统之上运行，从而释放了更多的资源用于来宾映像。</p><p>虚拟化之所以有效，是因为服务器将大部分时间都花在了闲置时间上，并且不需要诸如显示器和键盘之类的物理资源。借助来自<strong>VMWare</strong>和<strong>Openbox之</strong>类的公司的软件，您现在可以使用功能强大的CPU，并通过使用它运行多个虚拟机，管理员可以优化物理资源的使用并大大降低以前的单机，单操作系统数据中心模型的成本。主要限制通常是内存，但是，随着虚拟机监控程序技术和CPU的发展，可以在一台主机上放置比以往更多的虚拟机。</p><p>在虚拟化环境中，一台主机可以运行许多来宾操作系统，并且在CPU本身的支持下，来宾甚至都不知道它们在虚拟机上运行。每个来宾都拥有自己的虚拟资源，并与自己的网络进行通信。甚至没有必要在所有客户机上运行相同的操作系统，这进一步减少了所需的物理服务器的数量。</p><p>虚拟化为企业提供了一种方法，可以通过等效的物理服务器群来降低能耗并减少数据中心空间。来宾现在仅是软件配置，因此很容易启动新机器进行测试，并在其有用性过去时将其销毁。</p><p>由于可以在一台物理计算机上运行一个操作系统的多个实例并通过网络连接到它，因此计算机的位置无关紧要。云计算采用这种方法，并允许管理员在另一家公司拥有的远程数据中心中拥有虚拟机，并且仅需为使用的资源付费。云计算供应商可以利用经济规模来以比运营现场数据中心低得多的价格提供计算资源。</p><p><strong>集装箱和裸机部署</strong></p><p>随着诸如<strong>Docker</strong>和<strong>Kubernetes之</strong>类的容器化技术的兴起，如今正在编写可在无服务器环境中运行的应用程序软件。本质上，程序员正在创建一种软件，该软件执行在容器中运行的系统的一项功能（例如数据库处理或存储）。这些容器组织在节点内运行的Pod中，可以相互通信，并且可以根据需要与外界通信。节点又由主节点组织和控制为结构中的每个组件提供服务。通过这种方式构建应用程序，可以使每个组件彼此分离，并避免运行OS的开销。由于难题的每个部分都可以由主节点自动销毁并重新创建，因此不再需要像在OS顶部运行的软件那样强大。尽管这些新的编程体系结构在许多方面都绕过了对传统OS的需求，但使它们起作用的底层技术仍然是Linux。因此，在Linux中工作的开发团队将越来越多地利用编程，数据库设计，网络和系统管理的学科来创建未来的系统。？？？？看不懂。。</p><h1 id="开源项目和许可"><a href="#开源项目和许可" class="headerlink" title="开源项目和许可"></a>开源项目和许可</h1><p>Software projects take the form of source code, which is a human-readable set of computer instructions. Since source code is not understood directly by the computer, it must be compiled into machine instructions by a compiler. The compiler is a special program that gathers all of the source code files and generates instructions that can be run on the computer, such as by the Linux kernel.</p><p>（个人强烈建议在学习Linux前查看GNU宣言及相关历史）</p><p>在谈论购买软件时，有三个不同的组件：</p><ul><li><strong>所有权</strong>–谁拥有该软件背后的知识产权？</li><li><strong>汇款</strong>–<strong>资金</strong>如何转手（如果有的话）？</li><li><strong>许可</strong>–您会得到什么？您可以使用该软件做什么？您只能在一台计算机上使用它吗？你能把它给别人吗？</li><li>Linux由Linus Torvalds拥有。他已将代码置于称为<strong>GNU通用公共许可证版本2（GPLv2）的许可证下</strong>。该许可证除其他外，规定必须向任何提出要求的人提供源代码，并且允许任何人进行更改。一个警告是，如果有人进行更改并将其分发，则他们必须将更改置于相同的许可下，以便其他人可以从中受益。GPLv2还说，除分发源代码的实际成本（例如将其复制到可移动媒体）外，任何人都不得收取分发源代码的费用。</li></ul><p>通常，当某人创建某物时，他们也有权决定如何使用和分发它。<strong>自由和开源软件（FOSS）</strong>是指已放弃此权利的软件；任何人都可以查看源代码并重新分发。Linus Torvalds使用Linux做到了这一点–即使他创建了Linux，但他也不能禁止某人在其计算机上使用它，因为他已经通过GPLv2许可证放弃了该权利。</p><h2 id="开源计划"><a href="#开源计划" class="headerlink" title="开源计划"></a>开源计划</h2><p>The <strong>Open Source Initiative (OSI)</strong> was founded in 1998 by Bruce Perens and Eric Raymond. They believed that the Free Software Foundation was too politically charged and that less extreme licenses were necessary, particularly around the copyleft aspects of FSF licenses. OSI believes that not only should the source be freely available, but also that no restrictions should be placed on the use of the software, no matter what the intended use. Unlike the FSF, the OSI does not have its own set of licenses. Instead, the OSI has a set of principles and adds licenses to that list if they meet those principles, called open source licenses. Software that conforms to an Open Source license is, therefore, open source software.</p><p>One type of Open Source license is the <strong>BSD (Berkeley Software Distribution)</strong> and its derivatives, which are much simpler than GPL. There are currently two actual “BSD” licenses approved by OSI, a 2-Clause and a 3-Clause. These licenses state that you may redistribute the source and binaries as long as you maintain copyright notices and don’t imply that the original creator endorses your version. In other words “do what you want with this software, just don’t say you wrote it.” According to FSF, the original BSD license had a serious flaw in that it required developers to add a clause acknowledging the University of California, Berkeley in every advertisement for software licensed this way. As others copied this simple license, they included acknowledgment for their own institutions which led to over 75 such acknowledgments in some cases.</p><p>FSF licenses, such as GPLv2, are also open source licenses. However, many open source licenses such as BSD and MIT do not contain the copyleft provisions and are thus not acceptable to the FSF. These licenses are called permissive free software licenses because they are permissive in how you can redistribute the software. You can take BSD licensed software and include it in a closed software product as long as you give proper attribution.</p><p>Rather than dwell over the finer points of Open Source and Free Software, the community has started referring to them collectively as <strong>Free and Open Source Software (FOSS)</strong>. The English word “free” can mean “free as in lunch” (as in no cost) or “free as in speech” (as in no restrictions). This ambiguity led to the inclusion of the word “libre” to refer to the latter definition. Thus, we end up with <strong>Free/Libre/Open Source Software (FLOSS)</strong>.</p><p>The <strong>Creative Commons (CC)</strong> organization has created the Creative Commons Licenses which try to address the intentions behind FOSS licenses for non-software entities. CC licenses can also be used to restrict commercial use if that is the desire of the copyright holder. The CC licenses are made up of the following set of conditions the creator can apply to their work:</p><p>These conditions are then combined to create the six main licenses offered by Creative Commons:</p><ul><li><strong>Attribution (CC BY)</strong> – Much like the BSD license, you can use CC BY content for any use but must credit the copyright holder.</li><li><strong>Attribution ShareAlike (CC BY-SA)</strong> – A copyleft version of the Attribution license. Derived works must be shared under the same license, much like in the Free Software ideals.</li><li><strong>Attribution NoDerivs (CC BY-ND)</strong> – You may redistribute the content under the same conditions as CC-BY but may not change it.</li><li><strong>Attribution-NonCommercial (CC BY-NC)</strong> – Just like CC BY, but you may not use it for commercial purposes.</li><li><strong>Attribution-NonCommercial-ShareAlike (CC BY-NC-SA)</strong> – Builds on the CC BY-NC license but requires that your changes be shared under the same license.</li><li><strong>Attribution-NonCommercial-NoDerivs (CC BY-NC-ND)</strong> – You are sharing the content to be used for non-commercial purposes, but people may not change the content.</li><li><strong>No Rights Reserved (CC0)</strong> – This is the Creative Commons version of public domain.</li></ul><h2 id="开源业务模型"><a href="#开源业务模型" class="headerlink" title="开源业务模型"></a>开源业务模型</h2><p>如果所有这些软件都是免费的，那么谁能从中赚钱呢？</p><p>首先，您必须了解GPL中没有禁止销售软件的任何内容。实际上，销售软件的权利是GPL许可的一部分。同样，请记住，“自由”一词是指自由，而不是价格。鼓励为这些免费程序增加价值的公司赚取尽可能多的钱，并将这些利润重新投入到开发更多更好的软件中。</p><p>赚钱的最简单方法之一是在软件周围出售支持或保修。诸如Canonical，Ubuntu的开发者和Redhat之类的公司已经通过创建Linux发行版和工具来发展为大型企业，这些发行版和工具使商业用户能够管理其企业并为他们的客户提供产品和服务。</p><p>许多其他开源项目也已扩展为大量业务。在1990年代，Gerald Combs在一家互联网服务提供商处工作，并开始编写自己的网络分析工具，因为当时的类似工具价格昂贵。现在有600多人为这个名为Wireshark的项目做出了贡献。现在，它通常被认为比商业产品更好，并导致成立了一家销售产品和支持的公司。与许多其他公司一样，该公司被一家支持其持续发展的大型企业收购。</p><p>像Tivo这样的公司已经打包了硬件或添加了额外的封闭源代码软件，以与免费软件一起出售。使用Linux的设备和嵌入式系统是一项价值数十亿美元的业务，涵盖了从家用DVR到安全摄像机和可穿戴健身设备的所有内容。许多消费者防火墙和娱乐设备都遵循此模型。</p><p>如今，大型和小型雇主都有个人，有时甚至整个团体都致力于开源项目。科技公司争夺机会来影响将改变其行业未来的项目。其他公司则将资源专用于内部使用所需的项目。随着在云资源上完成更多的业务，开源程序员的机会将继续扩大。</p><p>‌⁠</p><hr><p>我吐了</p><h1 id="命令行之始"><a href="#命令行之始" class="headerlink" title="命令行之始"></a>命令行之始</h1><ol><li><p><strong>用户名：</strong></p><pre class="line-numbers language-none"><code class="language-none">sysadmin @localhost：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>系统名称：</strong></p><pre class="line-numbers language-none"><code class="language-none">sysadmin @本地主机：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>当前目录：</strong></p><pre class="line-numbers language-none"><code class="language-none">sysadmin @ localhost：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>该<code>~</code>符号用作用户主目录的简写。通常，用户的主目录位于该<code>/home</code>目录下，并以用户帐户名命名；例如，<code>/home/sysadmin</code>。</p><p>命令的典型格式如下：</p><pre class="line-numbers language-none"><code class="language-none">命令[选项] [参数]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项用于修改命令的核心行为，而参数用于提供其他信息</p><p>请记住，Linux区分大小写。命令，选项，参数，变量和文件名必须完全按照所示输入。</p><p>组合选项的顺序并不重要。所有这些示例的输出将是相同的：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -l -r ls -rl ls -lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选项通常是单个字母；但是，有时它们也是单词或短语。通常，较旧的命令使用单个字母，而较新的命令使用完整的单词作为选项。<code>-</code>像该<code>-h</code>选项一样，单字母选项前面带有一个破折号。全字选项前面有两个破折号<code>--</code>。该<code>-h</code>选项还具有等效的全字形式；该<code>--human-readable</code>选项。</p><p>Bash shell中使用了两种类型的变量：local和environment。</p><p>Bash在解释命令和执行任务时使用的所有shell中，环境变量（也称为全局变量）在系统范围内可用。当打开新的外壳程序时，系统会自动重新创建环境变量</p><p>要理解的最重要的Bash shell变量之一是<code>PATH</code>变量。它包含一个列表，该列表定义了外壳程序在哪些目录中查找命令。如果输入了有效命令，并且外壳程序返回“找不到命令”错误，那是因为Bash Shell无法在路径中包含的任何目录中以该名称找到命令</p><p>列表中的每个目录都用冒号分隔<code>:</code>。根据前面的输出，该路径包含以下目录。Shell将按照列出的顺序检查目录：</p><p>更新<code>PATH</code>变量时，<strong>请始终包含当前路径</strong>，以免失去对这些目录中命令的访问权限。这可以通过<code>$PATH</code>在赋值表达式中附加值来实现。回想一下，以美元符号开头的变量名称表示该变量的值。<strong>而且最后那个分隔符冒号是要自己加的！</strong><code>$ PATH = / usr / bin / custom：$ PATH  </code></p><h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><p>There are several different sources of commands within the shell of your CLI including internal commands, external commands, aliases, and functions.内部命令，外部命令，别名，函数</p><p>一个别名可以用于映射到更短的按键序列长的命令。当外壳程序看到别名正在执行时，它将替换较长的序列，然后继续解释命令。</p><p>例如，该命令<code>ls -l</code>通常别名为<code>l</code>或<code>ll</code>。由于这些较小的命令更易于键入，因此运行<code>ls -l</code>命令行的速度会更快。</p><p>也可以使用现有命令来构建函数，以创建新命令，或覆盖Shell内置命令或存储在文件中的命令。通常在外壳程序首次启动时从初始化文件中加载别名和函数。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="quoting引号"><a href="#quoting引号" class="headerlink" title="quoting引号"></a>quoting引号</h3><p>double “  single ‘  back  `</p><p>双引号阻止外壳程序解释某些元字符（特殊字符），包括全局字符。</p><p>Glob字符，也称为通配符（wild cards），是对shell具有特殊含义的符号；<em><strong>它们会在尝试运行任何命令之前由外壳程序本身解释</strong></em>。球形字符包括星号<code>*</code>，<code>?</code>问号字符和方括号<code>[ ]</code>等。</p><p>稍后将在本课程中更详细地介绍globbing。</p><p>双引号仍然允许命令替换，变量替换（$），并允许一些尚未讨论的其他shell元字符</p><p>单引号可防止外壳对特殊字符进行任何解释，包括glob，变量，命令替换和其他尚未讨论的元字符。</p><p>反引号，或反引号，用于指定一个命令内的命令时，<strong>这个过程被称为命令替换</strong>。这允许强大而复杂的命令使用</p><p>echo data 和 echo back data back</p><h3 id="Control-Statement"><a href="#Control-Statement" class="headerlink" title="Control Statement"></a>Control Statement</h3><p>控制语句允许您一次使用多个命令或运行其他命令，具体取决于上一个命令的成功。通常，这些控制语句在脚本内使用，但是它们也可以在命令行上使用。</p><p>分号；依次执行，彼此独立。</p><p>双“＆”号<code>&amp;&amp;</code>充当逻辑“与”；如果第一个命令成功执行，则第二个命令也将运行。如果第一个命令失败，则第二个命令将不会运行。</p><p>使用双管道，如果第一个命令成功运行，则第二个命令将被跳过；如果第一个命令失败，则运行第二个命令。换句话说，您实际上是在告诉Shell，“要么运行第一个命令，要么运行第二个命令”。 </p><h1 id="内置帮助"><a href="#内置帮助" class="headerlink" title="内置帮助"></a>内置帮助</h1><h2 id="Man-Pages"><a href="#Man-Pages" class="headerlink" title="Man Pages"></a>Man Pages</h2><p>man + 命令</p><p>The <code>man</code> command uses a pager to display documents. Usually, <strong>this pager is the <code>less</code> command</strong>, but on some distributions, it may be the <code>more</code> command. Both are very similar in how they perform.</p><p>To view the various movement commands that are available, use the <em><strong>H key</strong></em> while viewing a man page. This displays a help page.</p><p>man手册使用less命令，less和more是查看文件的方法命令，less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。那些操作都是less命令提供的，用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Commands marked with * may be preceded by a number, N.        Notes in parentheses indicate the behavior if N is given.           A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>请注意，手册页现在可能对您来说还是个谜，但是随着您对Linux的更多了解，您会发现它们是非常有价值的资源</p><p><strong>Name</strong></p><p><strong>SYNOPSIS</strong></p><p>好像是使用类似正则表达式规则，[bda]表示b,d,a都可用，均为可选</p><p>可能会显示多组用法，参数各自独立  <code>a|b</code>表示或，a和b等价</p><p><strong>DESCRIPTION</strong></p><p><strong>OPTIONS</strong></p><p><strong>FILES</strong></p><p>Lists the files that are associated with the command as well as a description of how they are used. These files may be used to configure the command’s more advanced features. Often this information is found in the <code>DESCRIPTION</code> section and not in a separate <code>FILES</code> section.（description装不下就单独文件）</p><p><strong>AUTHOR</strong></p><p><strong>REPORTING BUGS</strong></p><p><strong>COPYRIGHT</strong></p><p><strong>SEE ALSO</strong></p><p>Provides you with an idea of where you can find additional information. This often includes other commands that are related to this command.</p><p>By default, there are nine sections of man pages:</p><ol><li>General Commands</li><li>System Calls</li><li>Library Calls</li><li>Special Files</li><li>File Formats and Conventions</li><li>Games</li><li>Miscellaneous</li><li>System Administration Commands</li><li>Kernel Routines</li></ol><p>不同的手册页由“部分”区分。默认情况下，手册页有九个部分：</p><ul><li>可执行程序或外壳命令</li><li>系统调用（内核提供的功能）</li><li>库调用（程序库中的函数）</li><li>特殊文件（通常在中找到<code>/dev</code>）</li><li>文件格式和约定，例如 <code>/etc/passwd</code></li><li>游戏类</li><li>其他（包括宏包和约定），例如<code>man(7)&gt;</code>，<code>groff(7)</code></li><li>系统管理命令（通常仅用于root用户）</li><li>内核例程</li></ul><p>搜索指令时依次搜索</p><p>默认输出第一个找到的手册页</p><p>该<code>whereis</code>命令专门用于<strong>查找命令和手册页</strong>。尽管这很有用，但通常需要查找文件或目录，而不仅仅是查找命令或手册页文件。</p><p>要查找任何文件或目录，请使用<code>locate</code>命令。创建数据库时，此命令将搜索系统中所有文件和目录的数据库。通常，生成该数据库的命令每晚运行一次。</p><h2 id="INFO文档"><a href="#INFO文档" class="headerlink" title="INFO文档"></a>INFO文档</h2><p>手册页是很好的信息来源，但是它们确实有一些缺点。一个示例是，每个手册页都是单独的文档，与任何其他手册页都不相关。尽管某些手册页的某个<code>SEE ALSO</code>部分可能引用其他手册页，但它们往往是独立的文档来源。</p><p>该<code>info</code>命令还提供有关操作系统命令和功能的文档。目标与手册页略有不同：提供一个文档资源，该文档资源给出了合理的组织结构，使阅读文档更加容易。</p><p>所有文档都合并到一个代表所有可用文档的“书”中。在信息文档中，信息分为几类，其工作方式与书中的目录非常相似。为页面提供超链接，其中包含有关特定命令或功能的各个主题的信息。</p><p>信息相对于手册页的另一个优点是，信息文档的写作风格通常更有利于学习主题。手册页更多地是参考资源，而信息文档更多地是学习指南。</p><p>首行显示了索引信息，下一章/上一章</p><p>尾行显示了当前节点</p><p>菜单列出了相关话题的超链接，选择+enter可选择</p><p>请注意，进入有关排序的节点会将线索带入原始节点的子节点。要返回上一个节点，请使用<strong>U</strong>键。当<strong>U</strong>导致上一级节点的开始时，<strong>L</strong>键返回到与进入排序节点之前相同的位置。U是上级，L是来回</p><p>shift+H是移动命令列表</p><p>L返回当前文档，Q退出info</p><p><strong>与其使用信息文档来查找有关特定命令或功能的信息，不如考虑通过阅读信息文档来探索Linux的功能。执行<code>info</code>不带任何参数的命令，将其带入文档的顶层。这是探索许多功能的一个很好的起点：</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Many commands will provide basic information, very similar to the <code>SYNOPSIS</code> found in man pages, by simply using the <code>--help</code> option to the command. This option is useful to learn the basic usage of a command quickly而且不用离开终端</p><p>在大多数系统上，存在一个目录，在该目录中可以找到其他文档（例如，第三方软件供应商存储的文档文件）。</p><p>这些文档文件通常称为自述文件，因为这些文件通常具有诸如<code>README</code>或的名称<code>readme.txt</code>。这些文件的位置可能会有所不同，具体取决于您所使用的分发。典型的位置包括<code>/usr/share/doc</code>和<code>/usr/doc</code>。</p><p>通常，此目录是系统管理员用来学习如何设置更复杂的软件服务的目录。但是，有时普通用户也会发现此文档很有用。</p><h1 id="文件系统导航"><a href="#文件系统导航" class="headerlink" title="文件系统导航"></a>文件系统导航</h1><p>在Linux中，所有内容均视为文件。文件用于存储文本，图形和程序等数据。目录是一种用于存储其他文件的文件；Windows和Mac OS X用户通常将它们称为文件夹。在任何情况下，目录都用于提供分层的组织结构。但是，此结构可能会有所不同，具体取决于使用的系统类型。</p><p>与Windows一样，Linux目录结构（通常称为文件系统）也具有顶层。但是，它而不是“我的电脑”被称为根目录，**并且用斜杠符号表示<code>/</code>**。此外，Linux中没有驱动器。每个物理设备都可在目录（而不是驱动器号）下访问。</p><p>请注意，有许多目录具有描述性名称，包括<code>/boot</code>，其中包含用于引导计算机的文件。</p><p>主目录（home directory）一词通常会使新的Linux用户感到困惑。首先，在大多数Linux发行版中<code>home</code>，根<code>/</code>目录下有一个目录。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/LEv2_7_4.png" alt="根目录中有一个名为home的目录。"></p><p>在此<code>/home</code>目录下，为系统上的每个用户提供一个目录。目录名与用户名相同，因此名为的用户<code>sysadmin</code>将具有一个名为<code>/home/sysadmin</code>的主目录</p><p><img src="https://ndg-content-dev.s3.amazonaws.com/media/images/linux-essentials-v2/LEv2_7_5.png" alt="用户的主目录位于/ home目录中，该目录又位于/字符表示的根目录中。 例如，sysadmin用户在/ home目录中有一个主目录（也称为sysadmin）。">首先，当用户打开shell程序时，应将其自动放置在其主目录中，因为通常这是他们执行大部分工作的地方。</p><p>此外，主目录是用户可以完全控制创建和删除其他文件和目录的少数目录之一。在大多数Linux发行版中，唯一可以访问主目录中文件的用户是系统的所有者和管理员。Linux文件系统中的大多数其他目录受文件权限保护。</p><p>主目录的特殊符号是 <code>~</code></p><p>父目录<code>..</code> 当前目录<code>.</code></p><p>~username 可以引用别的用户的主目录</p><p>pwd    </p><p>cd 如果不加参数，则回到主目录</p><p>绝对路径·总是从根目录开始 /   相对路径则从现在的目录开始</p><h2 id="powerful-ls"><a href="#powerful-ls" class="headerlink" title="powerful ls"></a>powerful ls</h2><p>在许多Linux发行版中，包括在我们的虚拟机中使用的发行版，该<code>ls</code>命令使用颜色按文件类型进行区分。例如，目录可以显示为蓝色，可执行文件可以显示为绿色，符号链接可以显示为青色。</p><p>彩色输出不是<code>ls</code>命令的默认行为，而是该<code>--color</code>选项的效果。在<code>ls</code>似乎因为对于一个别名来自动执行此着色<code>ls</code>指令，因此它与运行<code>--color</code>选项。</p><p>ls -l属性</p><p>每行的第一个字符表示文件的类型。文件类型为：</p><table><thead><tr><th align="left">象征</th><th align="left">文件类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>d</code></td><td align="left">目录</td><td align="left">用于存储其他文件的文件。</td></tr><tr><td align="left"><code>-</code></td><td align="left">常规文件</td><td align="left">包括可读文件，图像文件，二进制文件和压缩文件。</td></tr><tr><td align="left"><code>l</code></td><td align="left">符号链接</td><td align="left">指向另一个文件。</td></tr><tr><td align="left"><code>s</code></td><td align="left">插座socket</td><td align="left">允许进程之间的通信。</td></tr><tr><td align="left"><code>p</code></td><td align="left">管道pipe</td><td align="left">允许进程之间的通信。</td></tr><tr><td align="left"><code>b</code></td><td align="left">block文件</td><td align="left">用于与硬件通信。</td></tr><tr><td align="left"><code>c</code></td><td align="left">字符文件</td><td align="left">用于与硬件通信。</td></tr></tbody></table><p>随后是权限，硬连接数，用户所有者，小组所有者，文件大小，时间戳，文档名称</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-rw-r--r-- 1 root   root  35330 May 26  2018 bootstrap.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于符号链接，将显示链接名称以及箭头和原始文件的路径名。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lrwxrwxrwx。1 root root 2018年11月22日&#x2F;etc&#x2F;grub.conf- &gt; ..&#x2F;boot&#x2F;grub&#x2F;grub.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用该<code>-d</code>选项时，它引用的是当前目录，而不是其中的内容。如果没有其他选择，那就毫无意义。</p><pre class="line-numbers language-none"><code class="language-none">sysadmin@localhost:~$ ls -ld                                           drwxr-xr-x 1 sysadmin sysadmin 224 Nov  7 17:07 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>详细的看命令集[]</p><p>颜色指示该项目是什么类型。下表描述了一些较常见的颜色：</p><table><thead><tr><th align="left">颜色</th><th align="left">档案类型</th></tr></thead><tbody><tr><td align="left">黑或白</td><td align="left">常规文件</td></tr><tr><td align="left">蓝色</td><td align="left">目录文件</td></tr><tr><td align="left">青色</td><td align="left">符号链接文件（指向另一个文件的文件）</td></tr><tr><td align="left">绿色的</td><td align="left">可执行文件（程序）</td></tr></tbody></table><h1 id="管理文件和目录"><a href="#管理文件和目录" class="headerlink" title="管理文件和目录"></a>管理文件和目录</h1><p>Linux中的所有内容都区分大小写</p><p>Glob字符 are often referred to as wild cards（通配符）.</p><p>Globs功能强大，因为它们允许您指定与目录中的文件名匹配的模式。因此，您可以轻松地执行影响多个文件的命令，而不必一次处理一个文件。例如，通过使用全局字符，可以处理具有特定扩展名或特定文件名长度的所有文件。</p><p>与shell运行的命令或shell传递给命令的选项和参数不同，<strong>glob字符在尝试运行任何命令之前由shell本身解释</strong>。结果，全局字符可以与任何命令一起使用。</p><p>*  匹配任意个字符（包括0个）</p><p>？ 匹配单个字符</p><p>*+n？搭配表示匹配至少n个字符</p><p>[ ]匹配一系列，也可以[ ]*,这不就是正则表达式吗</p><p>但是取反是[!xx]而不是 ^</p><p>请记住，是将shell（而不是<code>echo</code>or<code>ls</code>命令）将全局模式扩展为相应的文件名。换句话说，如果<code>echo /etc/a*</code>执行了该命令，则在执行echo命令之前，外壳程序将<code>a*</code>用<code>/etc</code>与该模式匹配的目录中的所有文件和目录替换。</p><p><strong>ls 在使用通配符时你可能不知道他到底显示的是哪里的文件夹，可以用 -d来显示路径而不是内容</strong></p><p><strong>cp</strong>是复制 cp sour des  </p><pre class="line-numbers language-none"><code class="language-none">sysadmin @ localhost：〜 $ cp -v &#x2F; etc &#x2F; hosts〜                              &#96;&#x2F; etc &#x2F; hosts&#39;-&gt;&#96;&#x2F; home &#x2F; sysadmin &#x2F; hosts&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认同名，新名字可以加在路径里，<strong>默认覆盖重名文件！</strong></p><p>-v可以显示具体操作</p><p>-i会提供交互式警戒，确认后才会覆盖  -n选项则代表 no clobber（没有破坏力）不会覆盖！</p><p><strong>默认不能复制目录</strong>，-r可以递归复制整个目录，-p保留时间戳</p><p><strong>mv</strong> 语法类似 cp用于移动</p><p>还可以用来重命名，mv former newer如果在相同目录，就是<strong>重命名</strong></p><p>-i  -n  -v作用类似，但没有-r因为<strong>默认可以移动目录</strong>，-p保留时间戳</p><p>创建文件touch</p><p>rm命令，小心使用</p><p><strong>警告：</strong>文件将被永久删除。没有取消删除文件的命令，也没有从中恢复已删除文件的垃圾桶。</p><p>在删除搭配通配符时还是最好使用-i   </p><p>rm -r删除目录 最好-i</p><p>rmdir删除空目录，mkdir创建空目录</p><h1 id="存档和压缩"><a href="#存档和压缩" class="headerlink" title="存档和压缩"></a>存档和压缩</h1><p>archiving and compression</p><ul><li>归档：将多个文件合并为一个，从而消除了单个文件的开销，并使文件更易于传输。</li><li>压缩：通过删除冗余信息来缩小文件的大小。</li><li>Files can be compressed individually, or multiple files can be combined into a single archive and then subsequently compressed. The latter is still referred to as archiving.</li></ul><p>即使磁盘空间相对便宜，归档和压缩仍然有价值：</p><ul><li>当提供大量文件（例如应用程序的源代码或文档集合）时，与单独下载文件相比，人们下载压缩的存档要容易得多。</li><li>日志文件有填充磁盘的习惯，因此按日期拆分日志并压缩较旧的版本很有帮助。</li><li>备份目录时，将其全部保存在一个存档中比对每个文件进行版本控制（更新）要容易得多。</li><li>如果您发送的是数据流而不是单个文件，则某些流式传输设备（例如磁带）的性能会更好。</li><li>通常，在将文件发送到磁带驱动器或通过较慢的网络进行压缩之前，在另一端进行压缩比在不压缩的情况下进行压缩通常会更快。</li></ul><p>压缩算法是一个计算机使用来编码原始文件的过程，并且作为结果，使其变小。计算机科学家研究了这些算法，并提出了更好的算法，它们可以更快地工作或使输入文件更小。</p><p>在谈论压缩时，有两种类型：</p><ul><li>无损：不会从文件中删除任何信息。压缩文件并解压缩后，会留下与原始文件相同的内容。</li><li>有损：信息可能已从文件中删除。它的压缩方式是，解压缩文件将导致文件与原始文件略有不同。例如，可以通过将这两个阴影视为相同来缩小具有两个略微不同的绿色阴影的图像。通常，眼睛总是无法分辨出差异。</li></ul><p>压缩已经压缩的文件不会使其变小。当涉及到图像时，通常会忘记这一事实，因为它们已经以压缩格式存储。使用无损压缩，这种多重压缩不是问题，但是，如果使用有损算法多次压缩和解压缩文件，最终将导致无法识别的内容。</p><h2 id="压缩工具"><a href="#压缩工具" class="headerlink" title="压缩工具"></a>压缩工具</h2><p>Linux提供了几种工具来压缩文件。最常见的是<code>gzip</code>。</p><p>gzip xxx 将压缩xxx并加上.gz后缀  </p><p> -l 选项将提供压缩信息，压缩前/后大小，压缩率</p><p>gunzip 或 gzip -d 是解压缩</p><p>The <code>gunzip</code> command is just a script that calls <code>gzip</code> with the right parameters.</p><p>使用<strong>Lempel-Ziv</strong>数据压缩算法，</p><p>bzip2  bunzip2     它们具有<code>.bz</code>或<code>.bz2</code>扩展名,  <code>bzip</code>实用程序使用另一种称为<strong>Burrows-Wheeler</strong>块排序的压缩算法，该算法可以<strong>压缩较小</strong>的文件，而不用<code>gzip</code>花费那么多多的CPU时间。</p><p>xz unxz   .xz拓展名   <strong>Lempel-Ziv-Markov (LZMA)</strong> chain algorithm，</p><p>同时拥有比gzip快的时间和比bzip2快的压缩率</p><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><p><code>tar</code>命令接收多个文件，并创建一个输出文件，该文件可在传输的另一端再次拆分为原始文件。</p><p>该<code>tar</code>命令具有三种有助于熟悉的模式：</p><ul><li>创建c：从一系列文件中创建一个新的存档。</li><li>提取x：从存档中提取一个或多个文件。</li><li>列表t：显示存档的内容而不进行提取。</li></ul><p>记住模式是弄清执行所需操作所需的命令行选项的关键。除了该模式外，还请记住在何处指定档案名称，因为您可能会在命令行上输入多个文件名。</p><p>虽然文件扩展名不会影响文件的处理方式，但约定是将其<code>.tar</code>用于tarball</p><p><code>.tar.gz</code>或<code>.tgz</code>称呼用gzip压缩的tarball。</p><p><code>.tar.bz2</code>，<code>.tbz</code>或者<code>.tbz2</code>称呼用bzip2压缩的tarball</p><p><code>tar</code> stands for <strong>Tape ARchive</strong></p><p><strong>将<code>–f</code>标志保留在末尾很重要，因为<code>tar</code>假定此选项后的所有内容均为文件名。如果放错了位置，导致<code>tar</code>将该命令解释为对名为的文件的操作，该文件<code>v</code>不存在</strong>。</p><h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>-c</code></td><td align="left">创建一个档案。</td></tr><tr><td align="left"><code>-f ARCHIVE</code></td><td align="left">使用存档文件。参数<code>ARCHIVE</code>将是生成的存档文件的名称。</td></tr><tr><td align="left"><code>-z</code></td><td align="left">使用<code>gzip</code>命令压缩（或解压缩）归档文件。</td></tr><tr><td align="left"><code>-j</code></td><td align="left">使用<code>bzip2</code>命令压缩（或解压缩）归档文件。</td></tr></tbody></table><h3 id="列表模式"><a href="#列表模式" class="headerlink" title="列表模式"></a>列表模式</h3><p>给定一个<code>tar</code>压缩的或未压缩的存档，您可以使用该<code>-t</code>选项查看其中的内容。下一个示例使用三个选项：</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>-t</code></td><td align="left">列出档案中的文件。</td></tr><tr><td align="left"><code>-j</code></td><td align="left">用<code>bzip2</code>命令解压缩。</td></tr><tr><td align="left"><code>-f ARCHIVE</code></td><td align="left">在给定的存档上进行操作。</td></tr></tbody></table><p><strong>默认使用递归查看子目录</strong></p><h3 id="提取模式"><a href="#提取模式" class="headerlink" title="提取模式"></a>提取模式</h3><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>-x</code></td><td align="left">从存档中提取文件。</td></tr><tr><td align="left"><code>-j</code></td><td align="left">使用<code>bzip2</code>命令解压缩。</td></tr><tr><td align="left"><code>-f ARCHIVE</code></td><td align="left">在给定的存档上进行操作。</td></tr><tr><td align="left"><code>-v</code></td><td align="left">详细列出已处理的文件。</td></tr></tbody></table><p>提取时原始文件未更改，并创建了新目录。目录内是原始目录和文件</p><p>如果后面加了完全正确的路径名，则可以提取单个文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -xjvf folders.tbz School&#x2F;Art&#x2F;linux.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ZIP文件"><a href="#ZIP文件" class="headerlink" title="ZIP文件"></a>ZIP文件</h2><p>Microsoft中的事实上的归档实用程序是ZIP文件。ZIP在Linux中并不普遍，但是<code>zip</code>and<code>unzip</code>命令很好地支持ZIP 。尽管和<code>tar</code>和<code>gzip</code>/<code>gunzip</code>相同的命令和选项可以互换使用来进行创建和提取，但是并非如此<code>zip</code>。对于两个不同的命令，相同的选项具有不同的含义。</p><p><code>zip</code>的默认模式是将文件添加到存档并进行压缩。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">zip [OPTIONS] [zipfile [file…]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应当注意的是，<code>tar</code>需要使用<code>–f</code>选项来指示正在传递文件名，而需要<code>zip</code>并<code>unzip</code>使用文件名，因此不需要您通知命令正在传递文件名。</p><p><code>zip</code>默认情况下，该命令不会递归到子目录中，这与<code>tar</code>命令的行为不同。也就是说，仅添加<code>School</code>将仅添加空目录，而不添加其下的文件。如果您想要<code>tar</code>类似的行为，则必须使用该<code>–r</code>选项指示要使用递归：</p><p>unzip的 -l选项是列出文件</p><p>提取文件就像创建存档一样，因为<code>unzip</code>命令的默认操作是提取。如果解压缩文件会覆盖现有文件，它将提供几个选项：</p><p>也可以加上具体路径提取具体的</p><h1 id="使用文本"><a href="#使用文本" class="headerlink" title="使用文本"></a>使用文本</h1><p>典型文件系统中的大量文件是文本文件(text files)。文本文件仅包含文本，不包含您可能在文字处理文件中看到的额外增加的格式。</p><p>因为在典型的Linux系统上有许多这样的文件，所以存在大量命令来帮助用户操纵文本文件。有用于以各种方式查看和修改这些文件的命令。</p><p>此外，外壳程序还提供一些功能来控制命令的输出，因此可以将输出重定向到另一个文件或另一个命令中，而不是将输出放置在终端窗口中。这些重定向功能为用户提供了更加灵活和强大的工作环境。</p><p><code>cat</code>命令是concatenate的缩写，是一个简单但有用的命令，其功能包括创建和显示文本文件，以及合并文本文件的副本。最受欢迎的用途之一<code>cat</code>是显示文本文件的内容。要使用<code>cat</code>命令在标准输出中显示文件，请键入命令，然后输入文件名</p><p>尽管终端是此命令的默认输出，但是该<code>cat</code>命令也可以用于将文件内容重定向到其他文件，或者通过使用重定向字符输入另一个命令。</p><h2 id="Pager"><a href="#Pager" class="headerlink" title="Pager"></a>Pager</h2><p>尽管使用<code>cat</code>命令查看小文件没有问题，但对于大文件而言，这不是理想的选择。<code>cat</code>命令没有提供任何简单的方法来暂停和重新开始显示，因此整个文件内容都转储到了屏幕上。</p><p>对于较大的文件，请使用Pager命令来查看内容。分页器pager命令一次显示一页数据，允许您使用移动键在文件中前后移动。</p><p>有两种常用的Pager命令：</p><ul><li><code>less</code>命令提供了非常高级的分页功能。它通常是命令（例如<code>man</code>命令）使用的默认Pager。</li><li><code>more</code>自UNIX成立以来，该命令就已存在。尽管它的功能少于<code>less</code>命令，但是该<code>less</code>命令并不包含在所有Linux发行版中。该<code>more</code>命令始终可用。Use the <code>more</code> command to display the entire contents of the <code>/etc/passwd</code> file:</li></ul><p><code>more</code>和<code>less</code>命令允许用户使用按键命令文件走动。因为开发人员基于<code>less</code>命令的功能来使用<code>more</code>命令，所以该命令中可用的所有击键命令<code>more</code>也可以在<code>less</code>命令中使用。</p><p>我们内容的重点是更高级的<code>less</code>命令。在<code>more</code>命令<code>less</code>不可用时，该命令对于记住该命令仍然很有用。请记住，大多数击键命令都可用于这两个命令!</p><p>less filename</p><p>use the <strong>H</strong> key or <strong>Shift</strong>+<strong>H</strong> to display a help screen:</p><p>最常用的几个：</p><table><thead><tr><th align="left">Key</th><th align="left">Movement</th></tr></thead><tbody><tr><td align="left"><strong>Spacebar</strong></td><td align="left">Window forward</td></tr><tr><td align="left"><strong>B</strong></td><td align="left">Window backward</td></tr><tr><td align="left"><strong>Enter</strong></td><td align="left">Line forward</td></tr><tr><td align="left"><strong>Q</strong></td><td align="left">Exit</td></tr><tr><td align="left"><strong>H</strong></td><td align="left">Help</td></tr></tbody></table><p>/从头开始找  ？从现在位置开始找  n下一个  shift+n 上一个</p><p>head和tail用来显示文件头尾，默认10行</p><table><thead><tr><th>command</th><th>head</th><th>tail</th></tr></thead><tbody><tr><td>-number</td><td>显示前n行</td><td>显示后n行</td></tr><tr><td>-n  -3</td><td>从头到倒数第三行（负值期权）</td><td>显示后3行</td></tr><tr><td>-n  (+)3</td><td>显示前3行</td><td>从第三行显示到结尾（正值期权）</td></tr></tbody></table><p>加上-f 选项则变成可以实时观测更改。。可以用来检查日志啥的</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>pipe <code>|</code>字符可以被用于将一个命令的输出发送到另一个。通常，当命令有输出或产生错误时，输出将显示在屏幕上。但是，并非必须如此。一条命令的输出而不是打印到屏幕上，而成为下一条命令的输入。该工具功能强大，尤其是在查找特定数据时；管道通常用于优化初始命令的结果。</p><p>例如<code>ls | head</code> 查看当前目录的前十个</p><p>可以连续使用多个管道将多个命令链接在一起。依次传输</p><p>nl 会将输入按行编号并显示在屏幕上</p><p>输出</p><p>STDIN STDOUT STDEER</p><p>I/O redirection allows the user to redirect STDIN so that <strong>data comes from a file</strong> and STDOUT/STDERR so that <strong>output goes to a file.</strong> Redirection is achieved by using the arrow <code>&lt;</code> <code>&gt;</code> characters.</p><p>但是<code>1&gt; 或 &gt;</code>重定向到文件会覆盖原内容，&gt;&gt;是附加</p><p>而STDEER的重定向是<code>2&gt;</code>，虽然它和STDOUT都默认显示在屏幕上，但是流是不一样的</p><p>而<code>&amp;&gt;</code>将两者同时重定向.，下面这种诡异的写法也可以定向到同一个文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F;etc -name hosts &gt; find.out 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以分开放，如下所示：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">~$ ls &#x2F;fake &#x2F;etc&#x2F;ppp &gt; example.txt 2&gt; error.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><p>重定向STDIN的概念很困难，因为很难理解为什么要重定向STDIN。使用STDOUT和STDERR，它们的目的很简单。有时将输出存储到文件中以备将来使用会很有帮助。</p><p>对于某些命令，如果您未指定文件名作为参数，则它们将恢复为使用STDIN来获取数据。例如，cat</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ cathellohellohow are you?how are you?ctrl+c终止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tr 接受一个字符集并将它们转化为另一个字符集<code>tr &#39;a-z&#39; &#39;A-Z&#39;</code>该命令不支持跟文件</p><p>只能<code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt;file &gt;save</code> 可对文件进行处理</p><p>Most commands do accept file names as arguments, so this use case is relatively rare. </p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><em><strong>sort</strong></em></p><p>The <code>sort</code> command can rearrange the output based on the contents of one or more fields. Fields are determined by a field delimiter contained on each line.</p><p>-t 指定分界符<em>delimiter</em>（默认空格）比如按照 : 分界，就 -t:</p><p>-kn 指定根据哪一项排序，项间以分界符隔开</p><p>-n 指定排序类型为数字的</p><p>-r 反向排序</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ sort -t: -n -k3 mypasswdroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashdaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用逗号可以依次指定多次排序</p><p>To sort first by the operating system (field #2) and then year (field #1) and then by last name (field #3), use the following command:</p><pre class="line-numbers language-none"><code class="language-none">sysadmin@localhost:~$ sort -t, -k2 -k1n -k3 os.csv1991,Linux,Torvalds1987,Minix,Tanenbaum1970,Unix,Richie1970,Unix,Thompson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>wc</strong></p><p>分别打印行数，单词数，字符数和文件名</p><p>如果提供了多个文件还会打印一行总的</p><p>-l 只显示行数   -w单词数  -c字节数</p><p><strong>cut</strong></p><p><code>cut</code>命令可以从文件或标准输入中提取文本列。它主要用于处理带分隔符的数据库文件。同样，定界文件(delimited flies)是包含由定界符分隔的列的文件。这些文件在Linux系统上非常常见。</p><p>-d 也是指定分界符（默认tab）</p><p>-f 指定范围</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ cut -d: -f1,5-7 mypasswdroot:root:&#x2F;root:&#x2F;bin&#x2F;bashdaemon:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:sync:&#x2F;bin:&#x2F;bin&#x2F;sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-c 选项根据字符位置提取文本列-在使用固定宽度的数据库文件或命令输出时很有用。</p><p>The following will display just the file type (character 1), permissions (characters 2-10), a space (character 11), and filename (characters 50+):</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ ls -l | cut -c1-11,50-total 44drwxr-xr-x Desktopdrwxr-xr-x Documentsdrwxr-xr-x Downloadsdrwxr-xr-x Musicdrwxr-xr-x Picturesdrwxr-xr-x Publicdrwxr-xr-x Templatesdrwxr-xr-x Videos-rw-rw-r-- all.txt-rw-rw-r-- example.txt-rw-rw-r-- mypasswd-rw-rw-r-- new.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>grep</strong></p><p><code>grep</code>命令可用于过滤文件中的行或与指定模式匹配的另一个命令的输出。该模式可以与您要匹配的确切文本一样简单，也可以通过使用正则表达式来使其更加先进。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ grep bash &#x2F;etc&#x2F;passwdroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashsysadmin:x:1001:1001:System Administrator,,,,:&#x2F;home&#x2F;sysadmin:&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>–color 会用红色高亮匹配到的项，上文中的bash就会变成红色</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323185628820.png" alt="image-20210323185628820"></p><p>-c 会显示匹配的行数而不会输出内容</p><p>-n会在每行前面加上原始行号</p><p><code>-v</code>选项反转匹配，输出不包含模式的所有行</p><p>-i 将忽略大小写</p><p>-w 会显示完全匹配该单词的，比如are只匹配are 不然会匹配ware</p><p><strong>可以使用基本的正则表达式，但是多了一个  <code>.</code>表示匹配单个字符！</strong></p><p>请注意<code>grep</code>，默认情况下该命令不会将管道识别为交替运算符。该<code>grep</code>命令实际上是将管道作为普通字符包含在要匹配的模式中。使用<code>grep -E</code>或<code>egrep</code>允许使用扩展的正则表达式，包括交替。像{3}这种东西也是需要拓展模式使用。。</p><h1 id="基本脚本"><a href="#基本脚本" class="headerlink" title="基本脚本"></a>基本脚本</h1><p>一个shell脚本是已被存储在一个文本文件，可执行命令的文件。运行文件时，将执行每个命令。Shell脚本可以访问Shell的所有命令，包括逻辑。因此，脚本可以测试文件的存在或寻找特定的输出并相应地更改其行为。您可以构建脚本来自动化重复的工作，这可以节省您的时间并确保每次使用脚本时的一致性。例如，如果您每天运行相同的五个命令，则可以将它们转换为shell脚本，从而将您的工作减少为一个命令</p><p>脚本后缀名.sh 两种运行方法：</p><p>1.命令 sh 文件名  2. 直接输入路径（因为很少会有脚本文件放到PATH里，所以直接引用相对路径./）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ sh test.shHello, World!sysadmin@localhost:~$ .&#x2F;test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为很多shell都有他们各自的语法，因此很多复杂的脚本会<em><strong>指定特定的shell</strong></em>来执行本文件，他们会在第一行首先添加绝对路径，并加上前缀<code>#!</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;sh  也可以#!&#x2F;bin&#x2F;bashecho &quot;Hello, World!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The two characters <code>#!</code> are traditionally called the hash and the bang respectively, which leads to the shortened form of “shebang” when they’re used at the beginning of a script.</p><p>顺便说一句，shebang（或crunchbang）用于传统的shell脚本和其他基于文本的语言，如Perl，Ruby和Python。只要直接运行脚本，任何标记为可执行文件的文本文件都将在第一行中指定的解释器下运行。如果直接将脚本作为解释器的参数, 例如<code>sh script</code>或调用<code>bash script</code>，则无论shebang行中的内容如何，都将使用给定的shell。</p><h2 id="编辑shell脚本"><a href="#编辑shell脚本" class="headerlink" title="编辑shell脚本"></a>编辑shell脚本</h2><p>LPI Essentials教学大纲中特别提到了两个：GNU nano编辑器是一个非常简单的编辑器，非常适合编辑小文本文件。可视编辑器（<code>vi</code>或更高版本，VI改进（<code>vim</code>））是一种功能强大的编辑器，但学习曲线陡峭。我们将专注于<code>nano</code>。</p><p>nano filename</p><p><code>nano</code>编辑器的功能很少，可以助您一臂之力。您只需使用键盘输入内容，即可使用<strong>箭头键</strong>四处移动，并使用<strong>Delete</strong> / <strong>Backspace</strong>按钮删除文本。在屏幕底部，您可以看到一些可用的命令，这些命令是上下文相关的，并且会根据您的操作进行更改。如果您直接在Linux机器上，而不是通过网络进行连接，则还可以使用鼠标移动光标并突出显示文本。</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>Ctrl</strong> + <strong>W</strong></td><td align="left">搜索文件</td></tr><tr><td align="left"><strong>Ctrl</strong> + <strong>W</strong>，然后按<strong>Control</strong> + <strong>R</strong></td><td align="left">搜索并替换</td></tr><tr><td align="left"><strong>Ctrl</strong> + <strong>G</strong></td><td align="left">显示所有可能的命令</td></tr><tr><td align="left"><strong>Ctrl</strong> + <strong>Y</strong> / <strong>V</strong></td><td align="left">向上/向下翻页</td></tr><tr><td align="left"><strong>Ctrl</strong> + <strong>C</strong></td><td align="left">显示文件中的当前位置和文件的大小</td></tr><tr><td align="left">Ctrl+ X</td><td align="left">退出</td></tr><tr><td align="left">Ctrl + O</td><td align="left">不退出的情况下保存</td></tr><tr><td align="left">Ctrl + K   +U</td><td align="left">剪贴本行，释放剪贴板</td></tr></tbody></table><p>除了运行命令之外，您还必须熟悉3个主题：</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>variable_name=value   <strong>不准有空格在 = 两边！！</strong></p><p>$variable_name调用</p><p>read命令从STDIN接受一个参数，当然也可以重定向</p><p>程序运行后（无论是二进制程序还是脚本程序），它将返回退出代码，该退出代码是0到255之间的整数。您可以通过<code>$?</code>变量进行测试，以查看前一个命令是否成功完成。</p><p><code>grep</code>命令用于在带有<code>–q</code>标志的文件中查找字符串，这意味着“安静”的<code>grep</code>，而在安静模式下运行，如果字符串被发现则返回<code>0</code>如果是<code>1</code>代表其他情况。此信息可以在条件中用于根据另一个命令的输出执行操作。</p><p>注释是#，保持一行，可以手动exit number 来设定退出代码</p><p>按照惯例，退出代码的<code>0</code>意思是“一切都OK”。任何大于该退出代码的代码<code>0</code>均表示发生了某种错误，这是该程序所特有的</p><p>$number表示传给脚本的第n个参数,$0是脚本名，这和c命令行argv一样，传的是字符串</p><h2 id="判断和分支"><a href="#判断和分支" class="headerlink" title="判断和分支"></a>判断和分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if grep -q root &#x2F;etc&#x2F;passwd; then  echo root is in the password fileelse  echo root is missing from the password filefi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法有点诡异，要用fi闭合</p><p><code>test</code>命令使您可以轻松访问比较和文件测试运算符。例如：</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>test –f /dev/ttyS0</code></td><td align="left"><code>0</code> 如果文件存在</td></tr><tr><td align="left"><code>test ! –f /dev/ttyS0</code></td><td align="left"><code>0</code> 如果文件不存在</td></tr><tr><td align="left"><code>test –d /tmp</code></td><td align="left"><code>0</code> 如果目录存在</td></tr><tr><td align="left"><code>test –x </code> ‘ which ls’</td><td align="left">查看命令ls并判断能否被用户执行</td></tr><tr><td align="left"><code>test 1 –eq 1</code></td><td align="left"><code>0</code> 如果数值比较成功</td></tr><tr><td align="left"><code>test ! 1 –eq 1</code></td><td align="left"><code>NOT – 0</code> 如果比较失败</td></tr><tr><td align="left"><code>test 1 –ne 1</code></td><td align="left">同上，不相同返回0，其实是OP</td></tr><tr><td align="left"><code>test “a” = “a”</code></td><td align="left"><code>0</code> 如果字符串比较成功</td></tr><tr><td align="left"><code>test “a” != “a”</code></td><td align="left"><code>0</code> 如果字符串不同</td></tr><tr><td align="left"><code>test 1 –eq 1 –o 2 –eq 2</code></td><td align="left"><code>-o</code> 是OR：可以相同</td></tr><tr><td align="left"><code>test 1 –eq 1 –a 2 –eq 2</code></td><td align="left"><code>-a</code> 是AND：两者必须相同</td></tr></tbody></table><p><em><strong>OP是 -eq，-ne，-lt，-le，-gt，-ge的一个，分别代表</strong></em></p><p><em><strong>相等，不等, 小于，小于等于，大于，大于等于</strong></em></p><p><code>test</code> is fairly verbose for a command that gets used so frequently, so there is an alias for it called <code>[</code> (left square bracket). If you enclose your conditions in square brackets, it’s the same as running <code>test</code>. So, these statements are identical.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if test –f &#x2F;tmp&#x2F;foo; thenif [ -f &#x2F;tmp&#x2F;foo]; then<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em><strong>Important</strong></em></p><p><em><strong>There must be spaces around the square brackets. <code>[$age -lt 16]</code> would fail, but <code>[ $age -lt 16 ]</code> would work.</strong></em></p><p>The <code>if</code> statement has a final form that lets you do multiple comparisons at one time using <code>elif</code> (short for <code>else</code> <code>if</code>).</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashif [ &quot;$1&quot; &#x3D; &quot;hello&quot; ]; then  echo &quot;hello yourself&quot;elif [ &quot;$1&quot; &#x3D; &quot;goodbye&quot; ]; then  echo &quot;nice to have met you&quot;  echo &quot;I hope to see you again&quot;else  echo &quot;I didn&#39;t understand that&quot;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有诡异的case语法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashcase &quot;$1&quot; inhello|hi)  echo &quot;hello yourself&quot;  ;;goodbye)  echo &quot;nice to have met you&quot;  echo &quot;I hope to see you again&quot;  ;;*)  echo &quot;I didn&#39;t understand that&quot;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>for循环</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashfor NAME in Sean Jon Isaac David; do  echo &quot;Hello $NAME&quot;donefor S in *; do  echo &quot;Doing something to $S&quot;done&#x2F;&#x2F;Shell将*其扩展到当前目录中的所有文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>while循环</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashi&#x3D;0while [ $i -lt 10 ]; do  echo $i  i&#x3D;$(( $i + 1))doneecho “Done counting”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以直接在命令行使用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ for name in &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;hosts &#x2F;etc&#x2F;group           &gt; do                                                                          &gt;     wc $name                                                                &gt; done                                                                          24   30 1001 &#x2F;etc&#x2F;passwd                                                      7  15 161 &#x2F;etc&#x2F;hosts                                                          46  46 561 &#x2F;etc&#x2F;group                                                        sysadmin@localhost:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>seq用来生成列表。。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for num in &#96;seq 1 12&#96;do          touch test$numdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vi基本"><a href="#vi基本" class="headerlink" title="vi基本"></a>vi基本</h2><p><code>vi</code>编辑器有两种模式：插入和命令。在插入模式下，您将文本添加到文档中。在命令模式下，可以执行导航，搜索，保存和退出编辑器之类的操作。</p><p>vi filename 创建或开始处理一个文本文件</p><p>Insert modes include: <code>i</code>, <code>I</code>, <code>a</code>, <code>A</code>, <code>o</code>, and <code>O</code>.</p><p>i 直接进入插入模式，a光标右移一格进入，<code>I</code>从本行首进入插入模式，A在行尾进入</p><p><code>o</code>  在当前行的下一行开始新的一行并进入输入模式</p><p>cw进入替换模式，将依次替换该单词内的字符，完成后进入普通插入</p><p><em><strong>大写字母既可以用大写，也可以用shift+小写代替</strong></em></p><p>搜索/ 和 ？ n/N用法和less一致</p><table><thead><tr><th align="left">Key</th><th align="left">Function</th></tr></thead><tbody><tr><td align="left"><code>j</code></td><td align="left">到下一行</td></tr><tr><td align="left"><code>k</code></td><td align="left">上一行</td></tr><tr><td align="left"><code>l</code></td><td align="left">后移字符</td></tr><tr><td align="left"><code>h</code></td><td align="left">前移字符</td></tr><tr><td align="left"><code>w</code></td><td align="left">下n个单词的开头</td></tr><tr><td align="left"><code>e</code></td><td align="left">单词的结尾</td></tr><tr><td align="left"><code>b</code></td><td align="left">前n个单词开头</td></tr><tr><td align="left"><code>$</code></td><td align="left">当前行尾</td></tr><tr><td align="left"><code>0</code> (zero)</td><td align="left">当前行首</td></tr><tr><td align="left"><code>3G</code></td><td align="left">Jumps to third line (<code>nG</code> jumps to the nth line)(要大写G)</td></tr><tr><td align="left"><strong>Shift</strong>+<strong>G</strong></td><td align="left">Jumps to the last line</td></tr><tr><td align="left"><code>3dw</code></td><td align="left">删除该光标后的第三个单词，不完整则删掉下个空格前，不加数字默认1</td></tr><tr><td align="left"><code>4u</code></td><td align="left">取消4次操作，同时该4u命令将成为上一个命令</td></tr><tr><td align="left"><code>14x</code></td><td align="left">同delete，删除，而backspace是向前移动一位</td></tr><tr><td align="left"><code>5X</code></td><td align="left">删除前面的</td></tr><tr><td align="left"><code>2dd</code></td><td align="left">删除两行</td></tr><tr><td align="left"><code>p P</code></td><td align="left">凡是最后删除或复制的都被加到黏贴栏，用u可以黏贴 P为插在光标前</td></tr><tr><td align="left"><code>D/d$</code></td><td align="left">删除从光标到行末</td></tr><tr><td align="left"><code>J</code></td><td align="left">将下一行合并到本行尾</td></tr><tr><td align="left"><code>yw</code></td><td align="left">复制当前单词</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>5~</code></td><td align="left">转换大小写</td></tr></tbody></table><p>还有保存的：</p><table><thead><tr><th align="left">命令</th><th align="left">功能/按键</th></tr></thead><tbody><tr><td align="left"><code>:x</code></td><td align="left">将保存并关闭文件。</td></tr><tr><td align="left"><code>:wq</code></td><td align="left">将写入文件并退出。</td></tr><tr><td align="left"><code>:wq!</code></td><td align="left">如果可能，将写入一个只读文件，然后退出。</td></tr><tr><td align="left"><code>ZZ</code></td><td align="left">将保存并关闭。请注意，<code>:</code>在这种情况下不使用冒号。</td></tr><tr><td align="left"><code>:q!</code></td><td align="left">退出而不保存更改</td></tr><tr><td align="left"><code>:e!</code></td><td align="left">放弃更改并重新加载文件</td></tr><tr><td align="left"><code>:w!</code></td><td align="left">如果可能，写为只读。</td></tr></tbody></table><h1 id="操作集？"><a href="#操作集？" class="headerlink" title="操作集？"></a>操作集？</h1><ol><li><p>variable = value创建局部变量，引用时前面加$</p></li><li><p>info里用less命令shift+H或H是移动命令列表</p><p>L返回当前文档，Q退出info</p><p>/从头开始找  ？从现在位置开始找  n下一个  shift+n 上一个</p></li><li></li></ol><h1 id="命令集"><a href="#命令集" class="headerlink" title="命令集"></a>命令集</h1><ol><li><p>ls 可加多个参数则依次打印</p><p>-l详细模式  -r 反顺序打印（默认字母顺序）ls -a 打印包括隐藏文件</p><p>-h == –human-readable   该<code>-h</code>选项必须与该<code>-l</code>选项一起使用。</p><p>-d引用当前目录 -r 递归</p><p>ls 在使用通配符时你可能不知道他到底显示的是哪里的文件夹，可以用 -d来显示路径而不是内容</p><p>-s按文件大小排序 -t按时间，大的/新的放前面</p><p><code>--full-time</code>选项显示完整的时间戳（包括小时，分钟，秒）。它将自动采用<code>-l</code>选项：</p><p>仅为创建较早的文件提供</p><p>ls也可查看文件信息，最好跟着 -l不然没啥用</p></li><li><p>history+5 显示最后5个指令</p><p>感叹号!+数字（负号倒数）来选择历史命令</p><p>！！执行最新</p><p>！+命令 为特定命令的最新迭代</p></li><li><p>echo  ascii</p></li><li><p>data / env /whoami </p></li><li><p>uname（系统名）uname -n/–nodename 显示network node hostname</p></li><li><p>clear</p></li><li><p>export / unset 设置/删除导出变量（全局）</p></li><li><p>which 查看命令路径   whereis command查看手册页位置</p></li><li><p>type </p></li></ol><p>   shell builtin(internal commands)</p><p>   路径（external commands）</p><p>   a is aliased to “b”(alias)</p><p>   -a 输出所有（因为有时会有多种）</p><ol start="11"><li><p>alias 显示所有别名</p><p>alias a = “b” 设置别名</p><p>/+别名可以使别名失效</p></li><li><p>man +command</p><p>man -f command 显示所有包含该命令的手册(==whatis)</p><p>man 5 password 在5部分查看该命令</p><p>man -k key-words在手册页的名称和描述中搜索关键字!(==apropos)</p></li><li><p>locate 查找所有文件和目录</p><p>updatedb更新数据库，免得晚上才更新</p><p>不加参数则匹配包含字符串的，输出一堆</p><p>-c  显示有多少匹配</p><p>locate -b仅匹配包含基本名,不然目录里面的杂项都会出来</p><p>如果 locate -b “\….”加上破折号就是完全匹配，连后缀都没有那种</p></li><li><p>find是搜索实时文件系统，而不是静态数据库</p></li><li><p>info command    </p></li><li><p>less/more filename</p></li><li><p>cat</p></li><li><p>head和tail用来显示文件头尾，默认10行</p><table><thead><tr><th>command</th><th>head</th><th>tail</th></tr></thead><tbody><tr><td>-n</td><td>显示前n行</td><td>显示后n行</td></tr><tr><td>-n  -3</td><td>从头到倒数第三行（负值期权）</td><td>显示后3行</td></tr><tr><td>-n  (+)3</td><td>显示前3行</td><td>从第三行显示到结尾（正值期权）</td></tr></tbody></table><p>加上-f 选项则变成可以实时观测更改。。可以用来检查日志啥的</p></li><li><p>nl 会将输入按行编号并显示在屏幕上</p></li><li><p>tr 接受一个字符集并将它们转化为另一个字符集<code>tr &#39;a-z&#39; &#39;A-Z&#39;该命令不支持跟文件</code>只能重定向</p><p>只能<code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt;file &gt;save</code> 可对文件进行处理</p></li><li><p>sort 排序（ASCII？？）详细在使用文本-&gt;重定向那里</p></li><li><p><strong>wc</strong></p><p>分别打印行数，单词数，字符数和文件名</p><p>如果提供了多个文件还会打印一行总的</p><p>-l 只显示行数   -w单词数  -c字节数</p></li></ol><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="cisco" scheme="http://example.com/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础</title>
    <link href="http://example.com/2021/03/13/http/"/>
    <id>http://example.com/2021/03/13/http/</id>
    <published>2021-03-13T12:51:18.000Z</published>
    <updated>2021-04-08T12:02:53.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>[toc]</p><h2 id="几个知识"><a href="#几个知识" class="headerlink" title="几个知识"></a>几个知识</h2><p>http2已经越来越普及：</p><p>二进制编码报文，仍采用TCP，分为若干个帧，来加快传输</p><p>HPACK算法压缩大量重复的http头</p><p>用服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间</p><p>http-&gt;SPDY-&gt;舍弃-&gt;http2.0-&gt;http2</p><p>HTTPS完全在TLS之上搭载HTTP，因此可以对整个基础HTTP协议进行加密</p><p>有大致相同的语法，</p><p><strong>MDN Web Docs</strong>，以前是<strong>Mozilla开发人员网络</strong>，以前是<strong>Mozilla开发人员中心</strong>，是<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>，<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft</a>，<a href="https://en.wikipedia.org/wiki/Google">Google</a>和<a href="https://en.wikipedia.org/wiki/Samsung">Samsung</a>使用的Web开发人员的文档资料库和学习资源。该项目由<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>于2005年启动[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-MitchellBlog-2">2]</a>，是有关开放式Web标准，Mozilla自己的项目和开发人员指南的统一场所。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-3">3]</a>在2017年，微软，谷歌和三星宣布将关闭自己的文档项目，并将所有文档移至MDN Web Docs。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-:0-4">4]</a></p><p>MDN Web文档的内容由Mozilla和Google的员工和志愿者（开发人员和技术作家的社区）维护。主题包括<a href="https://en.wikipedia.org/wiki/HTML5">HTML5</a>，<a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>，<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>，<a href="https://en.wikipedia.org/wiki/Web_API">Web API</a>，<a href="https://en.wikipedia.org/wiki/Django_(web_framework)">Django</a>，<a href="https://en.wikipedia.org/wiki/Node.js">Node.js</a>，<a href="https://en.wikipedia.org/wiki/WebExtension">WebExtensions</a>，<a href="https://en.wikipedia.org/wiki/MathML">MathML</a>等。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-5">5]</a></p><p>TCP是<a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">面向连接的</a>，并且可以在发送数据之前在客户端和服务器之间建立连接。建立连接之前，服务器必须正在侦听（被动打开）来自客户端的连接请求。三向握手（主动打开），<a href="https://en.wikipedia.org/wiki/Retransmission_(data_networks)">重传</a>和错误检测可增加可靠性，但会延长<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">等待时间</a>。不需要可靠<a href="https://en.wikipedia.org/wiki/Data_stream">数据流</a>服务的应用程序可以使用<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">用户数据报协议</a>（UDP），该<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">协议</a>提供无<a href="https://en.wikipedia.org/wiki/Connectionless_communication">连接</a> <a href="https://en.wikipedia.org/wiki/Datagram">数据报</a>服务，该服务优先考虑时间而不是可靠性。TCP采用<a href="https://en.wikipedia.org/wiki/TCP_congestion_control">避免网络拥塞的方法</a>。但是，TCP存在一些漏洞，包括<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">拒绝服务</a>，<a href="https://en.wikipedia.org/wiki/TCP_sequence_prediction_attack">连接劫持</a>，TCP否决权和<a href="https://en.wikipedia.org/wiki/TCP_reset_attack">重置攻击</a>。</p><p><strong>握手</strong>是在通信电路建立之后，信息传输开始之前。 握手用于达成参数，如信息传输率，字母表，奇偶校验， 中断过程，和其他协议特性。TCP三握手：</p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN—SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=i+j)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN—RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包．向服务器发送确认包ACK(ack=k+1)．此包发送完毕．客户端和服务器进入ESTABI．ISHED状态。完成三次握手。完成三次握手．客户端与服务器开始传送数据 [1]</p><h2 id="标识互联网内容"><a href="#标识互联网内容" class="headerlink" title="标识互联网内容"></a>标识互联网内容</h2><p>每个资源都由一个 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URI">URI</a>) 来进行标识。</p><p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p><p>URI 的最常见形式是统一资源定位符 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">URL</a>)，它也被称为 <em>Web 地址</em>。</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">https:</span>//developer.mozilla.org<span class="token header-name keyword">https:</span>//developer.mozilla.org/en-US/docs/Learn/<span class="token header-name keyword">https:</span>//developer.mozilla.org/en-US/search?q=URL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">urn:</span><span class="token header-name keyword">isbn:</span>9780141036144<span class="token header-name keyword">urn:</span><span class="token header-name keyword">ietf:</span><span class="token header-name keyword">rfc:</span>7230<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="URI语法"><a href="#URI语法" class="headerlink" title="URI语法"></a>URI语法</h3><ol><li><p>“://“前是方案或协议</p><p><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">websocket协议</a>全双工的兼容http的协议</p><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">data</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URIs</a></td></tr><tr><td align="left">file</td><td align="left">指定主机上文件的名称</td></tr><tr><td align="left">ftp</td><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/FTP">文件传输协议</a></td></tr><tr><td align="left">http/https</td><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">超文本传输协议／安全的超文本传输协议</a></td></tr><tr><td align="left">mailto</td><td align="left">电子邮件地址</td></tr><tr><td align="left">ssh</td><td align="left">安全 shell</td></tr><tr><td align="left">tel</td><td align="left">电话</td></tr><tr><td align="left">urn</td><td align="left">统一资源名称</td></tr><tr><td align="left">view-source</td><td align="left">资源的源代码</td></tr><tr><td align="left">ws/wss</td><td align="left">（加密的） <a href="https://developer.mozilla.org/zh-CN/docs/WebSockets">WebSocket</a> 连接</td></tr></tbody></table></li><li><p>“//到:之间的域名”</p><p>这既是域名，也代表管理域名的机构，指示了一台主机</p></li><li><p>”：xx“是端口</p><p>它表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p></li><li><p>后面跟着一串路径</p></li><li><p>查询字符串</p><p><code>?key1=value1&amp;key2=value2</code> 是提供给 Web 服务器的额外参数。这些参数是用 &amp; 符号分隔的键/值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。</p></li><li><p>片段</p><p><code>#SomewhereInTheDocument</code> 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p></li></ol><h3 id="Data-URLs"><a href="#Data-URLs" class="headerlink" title="Data URLs"></a>Data URLs</h3><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、如果非文本则为可选的<code>base64</code>标记、数据本身：</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">data:</span>[&lt;mediatype>][;base64],&lt;data>mediatype `是个 MIME 类型的字符串，例如 "`image/jpeg`" 表示 JPEG 图像文件。如果被省略，则默认值为 `text/plain;charset=US-ASCII<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有很多问题：</p><ol><li>语法容易出错</li><li>html代码若转化成base64可能有问题</li><li>长度限制</li><li>缺乏错误处理</li><li>不支持查询字符串</li></ol><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><p><strong>媒体类型</strong>（通常称为 <strong>Multipurpose Internet Mail Extensions</strong> 或 <strong>MIME</strong> 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在<a href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>中进行了定义和标准化。</p><p>互联网号码分配机构（<a href="https://www.iana.org/">IANA</a>）是负责跟踪所有官方MIME类型的官方机构，您可以在<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">媒体类型</a>页面中找到最新的完整列表。</p><p><strong>重要：</strong>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><p>type/subtype  </p><p>独立（离散）类型/子类型</p><ul><li><p><code>application</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#application">在IANA上列出</a></p><p>没有明确属于其他类型之一的任何类型的二进制数据；或者将以某种方式执行或解释的数据，或者需要特定应用程序或应用程序类别使用的二进制数据。通用二进制数据（或真实类型未知的二进制数据）为<code>application/octet-stream</code>。其他常见的例子包括<code>application/pdf</code>， <code>application/pkcs8</code>，和<code>application/zip</code>。</p></li><li><p><code>audio</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio">在IANA上列出</a></p><p>音频或音乐数据。例子包括<code>audio/mpeg</code>， <code>audio/vorbis</code>。</p></li><li><p><code>example</code></p><p>保留用作展示如何使用MIME类型的示例中的占位符。这些代码绝对不能在示例代码清单和文档之外使用。 <code>example</code>也可以用作子类型；例如，在一个与在Web上处理音频有关的示例中，MIME类型<code>audio/example</code>可用于指示该类型是占位符，并且在现实世界中使用代码时应使用适当的占位符替换。</p></li><li><p><code>font</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#font">在IANA上列出</a></p><p>字体/字体数据。常见的例子包括<code>font/woff</code>， <code>font/ttf</code>，和<code>font/otf</code>。</p></li><li><p><code>image</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#image">在IANA上列出</a></p><p>图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本，例如动画<a href="https://developer.mozilla.org/en-US/docs/Glossary/gif">GIF</a>或APNG。常见的例子是<code>image/jpeg</code>，<code>image/png</code>和 <code>image/svg+xml</code>。</p></li><li><p><code>model</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#model">在IANA上列出</a></p><p>3D对象或场景的模型数据。示例包括<code>model/3mf</code>和 <code>model/vml</code>。</p></li><li><p><code>text</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#text">在IANA上列出</a></p><p>纯文本数据，包括任何人类可读的内容，源代码或文本数据，例如逗号分隔值（CSV）格式的数据。实例包括 <code>text/plain</code>，<code>text/csv</code>，和<code>text/html</code>。</p></li><li><p><code>video</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video">在IANA上列出</a></p><p>视频数据或文件，例如MP4电影（<code>video/mp4</code>）。</p></li></ul><p>对于没有特定子类型的文本文档，<code>text/plain</code>应使用。同样，对于没有特定或已知子类型的二进制文件， <code>application/octet-stream</code>应使用。</p><p><strong>多部分</strong>类型表示文档的分类，通常分为不同的MIME类型。它们也可以用来表示多个独立的文件，尤其是在电子邮件场景中，这些文件都是同一笔交易的一部分。它们代表一个<strong>复合文档</strong>。</p><p>除了<code>multipart/form-data</code>用于 <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML Forms</a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST"><code>POST</code></a>方法中的和用于发送文档的一部分外，HTTP不会以特殊方式处理多部分文档：消息会传输到浏览器（可能会显示“另存为”窗口（如果它不知道如何显示文档）。<code>multipart/byteranges</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> <code>Partial Content</code></p><p>有两种多部分类型：</p><ul><li><p><code>message</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">在IANA上列出</a></p><p>包含其他消息的消息。例如，它可以用来表示包含转发的消息作为其数据一部分的电子邮件，或者允许以块的形式发送非常大的消息，就像它是多条消息一样。示例包括<code>message/rfc822</code>（用于转发或回复的消息引用），并 <code>message/partial</code>允许将大消息分解为较小的消息，以便收件人自动进行重组。</p></li><li><p><code>multipart</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">在IANA上列出</a></p><p>由多个组件组成的数据，这些组件可能分别具有不同的MIME类型。示例包括<code>multipart/form-data</code>（对于使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a>API生成的数据）和<code>multipart/byteranges</code>（在<a href="https://tools.ietf.org/html/rfc7233">RFC 7233：5.4.1中</a>定义 ），并与<a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> “部分内容”响应一起使用，当获取的数据仅是内容的一部分（例如使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"><code>Range</code></a>标头传递的内容）时返回）。</p></li></ul><p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#%E9%87%8D%E8%A6%81%E7%9A%84mime%E7%B1%BB%E5%9E%8B">常用的</a></strong></em>*</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">常见MIME类型列表</a></p><p>很多web服务器使用默认的 <code>application/octet-stream</code> 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，导致用户必须存储到本地以使用。常见的导致服务器配置错误的文件类型如下所示：</p><ul><li>RAR编码文件。在这种情况，理想状态是，设置真实的编码文件类型；但这通常不可能（可能是服务器所未知的类型或者这个文件包含许多其他的不同的文件类型）。这这种情况服务器将发送 <code>application/x-rar-compressed</code> 作为MIME类型，用户不会将其定义为有用的默认操作。</li><li>音频或视频文件。只有正确设置了MIME类型的文件才能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">``</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">``</a> 识别和播放。 可参照  <a href="https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements">use the correct type for audio and video</a>。</li><li>专有文件类型。是专有文件时需要特别注意。使用 <code>application/octet-stream</code> 作为特殊处理是不被允许的：对于一般的MIME类型浏览器不允许定义默认行为（比如“在Word中打开”）</li></ul><p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 来设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> 以阻止MIME嗅探。</p><p>MIME类型不是传达文档类型信息的唯一方式：</p><ul><li>有时会使用名称后缀，特别是在Microsoft Windows系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是Linux和Mac OS），并且像外部MIME类型一样，不能保证它们是正确的。</li><li>魔术数字。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个GIF文件以47 49 46 38十六进制值[GIF89]或89 50 4E 47 [.PNG]的PNG文件开头。 并非所有类型的文件都有幻数，所以这也不是100％可靠的方式。</li></ul><h3 id="选择www吗"><a href="#选择www吗" class="headerlink" title="选择www吗"></a>选择www吗</h3><p>一个服务器不一定是一个独立的物理机：几台服务器可以驻留在同一台物理机器上，或者一台服务器可以通过几台机器进行处理，协作处理并响应或负载均衡它们之间的请求。关键点在于语义上<strong>一个域名代表一个单独的服务器</strong>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Choosing_between_www_and_non-www_URLs">两种设定非官方网站的方法</a>：HTTP301 和&lt;link rel =”canonical”</p><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>![概念图](<a href="https://mdn.mozillademos.org/files/13673/HTTP">https://mdn.mozillademos.org/files/13673/HTTP</a> &amp; layers.png)</p><p>ps:TLS是传输层安全协议，建立在TCP之上</p><p>HTTP被设计于20世纪90年代初期，是一种可扩展的协议。它是应用层的协议，通过<a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP">TCP</a>，或者是<a href="https://developer.mozilla.org/en-US/docs/Glossary/TLS">TLS</a>－加密的TCP连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。</p><p>实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 …）发起请求来获取部分或全部资源。</p><p>Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a>头部中，它们甚至可以共享同一个IP地址。</p><h3 id="代理（Proxies）（这是思科学的东西吧）"><a href="#代理（Proxies）（这是思科学的东西吧）" class="headerlink" title="代理（Proxies）（这是思科学的东西吧）"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#%E4%BB%A3%E7%90%86%EF%BC%88proxies%EF%BC%89">代理（Proxies）（这是思科学的东西吧）</a></h3><p>在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为<strong>代理（Proxies）</strong>。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用：</p><ul><li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li><li>过滤（像反病毒扫描，家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（对不同资源进行权限管理）</li><li>日志记录（允许存储历史信息）</li></ul><p>http简单，可扩展，无状态有会话</p><h3 id="HTTP-是无状态，有会话的"><a href="#HTTP-是无状态，有会话的" class="headerlink" title="HTTP 是无状态，有会话的"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84">HTTP 是无状态，有会话的</a></h3><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p><p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p><p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误），HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p><p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议<em><a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>。</em></p><h3 id="HTTP-能控制什么"><a href="#HTTP-能控制什么" class="headerlink" title="HTTP 能控制什么"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E8%83%BD%E6%8E%A7%E5%88%B6%E4%BB%80%E4%B9%88">HTTP 能控制什么</a></h3><p>多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。</p><p>以下是可以被HTTP控制的常见特性。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">缓存 </a><br>文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。</li><li><em>开放同源限制</em><br>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于<strong>相同来源</strong>的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。</li><li><em>认证</em><br>一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authenticate"><code>Authenticate</code></a>相似的头部即可，或用HTTP Cookies来设置指定的会话。</li><li><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling">代理和隧道</a></em><br>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。</li><li><em>会话</em><br>使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。</li></ul><p>当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的 <strong>帧 </strong>所取代。</p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。</p><p>即使HTTP/2为了提高性能将HTTP报文嵌入到帧中这一举措增加了复杂度，但是从Web应用的角度看，报文的基本结构没有变化，从HTTP/1.0发布起就是这样的结构。会话流依旧简单，通过一个简单的 <a href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">HTTP message monitor</a>就可以查看和纠错。</p><p>请求由以下元素组成：</p><ul><li>一个HTTP的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">method</a>，经常是由一个动词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 或者一个名词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML form</a>表单值（POST方法），虽然在一些情况下也会有其他操作。</li><li>要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有<a href="https://developer.mozilla.org/en-US/docs/Glossary/Protocol">protocol</a> （<code>http://</code>），<a href="https://developer.mozilla.org/en-US/docs/Glossary/Domain">domain</a>（<code>developer.mozilla.org</code>），或是TCP的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port</a>（HTTP一般在80端口）。</li><li>HTTP协议版本号。</li><li>为服务端表达其他信息的可选头部<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>。</li><li>对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。</li></ul><p>响应报文包含了下面的元素：</p><ul><li>HTTP协议版本号。</li><li>一个状态码（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li><li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li><li>HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>，与请求头部类似。</li><li>可选项，比起请求报文，响应报文中更常见地包含获取的资源body。</li></ul><h3 id="基于HTTP的APIs"><a href="#基于HTTP的APIs" class="headerlink" title="基于HTTP的APIs"></a>基于HTTP的APIs</h3><p>基于HTTP的最常用API是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API，可用于在<a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent">user agent</a>和服务器之间交换数据。 现代<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API"><code>Fetch API</code></a>提供相同的功能，具有更强大和灵活的功能集。双工</p><p>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a>接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a>对象，并将它们传递给专门处理这类<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/type"><code>type</code></a>事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage"><code>onmessage</code> (en-US)</a>事件处理程序处理</p><h2 id="HTTP信息"><a href="#HTTP信息" class="headerlink" title="HTTP信息"></a>HTTP信息</h2><p>HTTP消息由采用ASCII编码的多行文本构成。在HTTP/1.1及早期版本中，这些消息通过连接公开地发送。在HTTP/2中，为了优化和性能方面的改进，曾经可人工阅读的消息被分到多个HTTP帧中。</p><p>Web 开发人员或网站管理员，很少自己手工创建这些原始的HTTP消息︰ 由软件、浏览器、 代理或服务器完成。他们通过配置文件（用于代理服务器或服务器），API （用于浏览器）或其他接口提供HTTP消息</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsg2.png" alt="From a user-, script-, or server- generated event, an HTTP/1.x msg is generated, and if HTTP/2 is in use, it is binary framed into an HTTP/2 stream, then sent."></p><p>HTTP/2二进制框架机制被设计为不需要改动任何API或配置文件即可应用︰ 它大体上对用户是透明的。</p><p>HTTP 请求和响应具有相似的结构，由以下部分组成︰</p><ol><li>一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</li><li>一个可选的HTTP头集合指明请求或描述消息正文。</li><li>一个空行指示所有关于请求的元数据已经发送完毕。</li><li>一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。</li></ol><p>起始行和 HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsgStructure2.png" alt="Requests and responses share a common structure in HTTP"></p><p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages#http_%E8%AF%B7%E6%B1%82">HTTP请求详细在这里</a></strong></em></p><p>HTTP/1.x 报文有一些性能上的缺点：</p><ul><li>Header 不像 body，它不会被压缩。</li><li>两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。</li><li>无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。</li></ul><p>HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 <em>多路复用 (multiplexing)</em> 的过程，它允许更有效的底层 TCP 连接。</p><p>热连接就是活跃的连接，冷连接应该是指新连接的意思。因为 TCP 接连建立需要一定的耗时，还要握手，所以 HTTP 应用保持长连接的话，就可以在多个请求之间复用一个 TCP 连接，这样只需要一次连接和握手，从而大幅度提高资源的加载速度。</p><p>从 HTTP1.1 开始，长连接和多路复用就就已经被主流浏览器支持，但是某些网站或者不标准的客户端，还是会在一次请求完成之后关闭连接，变成短连接，从而造成资源的浪费。一般来说，请求头或者响应头字段 Connection: keep-alive 用来告诉另一方自己希望保持连接，并持续复用，直到服务器设定的超时限制达到，或者客户端认为所有资源已经加载完成并主动断开连接。</p><p>HTTP2 则在原有长连接和多路复用的基础上，实现了头部压缩和封包发送，以及无序请求-响应模型。HTTP1 的多路复用必须等待前一个请求完成才发送下一个请求，这造成了同步阻塞的问题，而 HTTP2 解决了这个问题，客户端给每一个请求打上序号发给服务器，服务器响应时返回这个序号，客户端就知道这个响应属于那个请求，从而实现了无序异步的多路复用，大大提高了客户端的并发能力并加快了资源的加载。同时 HTTP1 客户端还会在检测当前连接拥塞（被前一个连接长时占用）时开新连接加载其他资源。而HTTP2因为无需等待，则可以永远复用一个连接，减少了连接资源的消耗。–A-yon知乎</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/Binary_framing2.png" alt="HTTP/2 modify the HTTP message to divide them in frames (part of a single stream), allowing for more optimization."></p><h2 id="HTTTP-1-x-连接管理"><a href="#HTTTP-1-x-连接管理" class="headerlink" title="HTTTP/1.x 连接管理"></a>HTTTP/1.x 连接管理</h2><p><em>短连接</em>, <em>长连接</em>, 和 <em>HTTP 流水线。</em></p><p>都有很多问题，还有莫名诡异的域名分片</p><p>好像http2中解决了很多很多的问题</p><p>自己看吧</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</a></p><h2 id="HTTP内容协商"><a href="#HTTP内容协商" class="headerlink" title="HTTP内容协商"></a>HTTP内容协商</h2><p>在 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a> 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如，文档使用的自然语言，图片的格式，或者内容编码形式）。</p><p>注意：HTTP内容协商的一些不好的地方在这篇文章中有介绍<a href="https://wiki.whatwg.org/wiki/Why_not_conneg">a wiki page from WHATWG</a>，HTML5提供其他的选择来进行内容协商，如<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source">source&gt; element</a>。</p><p>这个功能好复杂，知道有就好了。。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation</a></p><h2 id="HTTP发展"><a href="#HTTP发展" class="headerlink" title="HTTP发展"></a>HTTP发展</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></p><h2 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h2><p>非常方便的，可由服务器端或者客户端发起的协议升级</p><p>不要看他下面的中文翻译。。。错得离谱</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism</a></p><h2 id="MDN暂时没有"><a href="#MDN暂时没有" class="headerlink" title="MDN暂时没有"></a>MDN暂时没有</h2><p>http会话流程</p><p>HTTP/2中的帧结构</p><p>HTTP/2连接管理</p><p>商定http版本</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;几个知识&quot;&gt;&lt;a href=&quot;#几个知识&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="web-back-end" scheme="http://example.com/categories/web-back-end/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2021/03/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/03/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-03-10T05:15:54.000Z</published>
    <updated>2021-04-06T08:42:27.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>来自菜鸟教程</p><h2 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ol><li><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p></li><li><p>非打印字符</p><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table></li><li><p>特别字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。比如限定符</p></li><li><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>以下正则表达式匹配一个正整数，**[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]*** 表示任意多个数字：</p></li><li><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table></li><li><p>选择</p><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)</p><p>但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 <strong>?:</strong> 放在第一个选项前来消除这种副作用</p></li><li><p>先/后行断言</p><p>个人感觉这是一种修饰，不会有括号那种缓冲的副作用</p><p>**exp1(?=exp2)**：查找 exp2 前面的 exp1</p><p><strong>(?&lt;=exp2)exp1</strong>：查找 exp2 后面的 exp1。</p><p>**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。</p><p><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</p></li><li><p>修饰符：(置于表达式之后)</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table></li></ol><h3 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h3><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td align="left">(?=pattern)</td><td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?!pattern)</td><td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?&lt;=pattern)</td><td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td align="left">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">\nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">\un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h2 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h2><p>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p><pre class="line-numbers language-none"><code class="language-none">^once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p><pre class="line-numbers language-none"><code class="language-none">bucket$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 <strong>^</strong> 和 <strong>$</strong> 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p><pre class="line-numbers language-none"><code class="language-none">^bucket$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p><pre class="line-numbers language-none"><code class="language-none">once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与字符串</p><pre class="line-numbers language-none"><code class="language-none">There once was a man from NewYorkWho kept all of his cash in a bucket.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是匹配的。</p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:<strong>、</strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><pre class="line-numbers language-none"><code class="language-none">Is is the cost of of gasoline going up up?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Is is the cost of of gasoline going up up"</span><span class="token punctuation">;</span><span class="token keyword">var</span> patt1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\b([a-z]+) \1\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>patt1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="小ps："><a href="#小ps：" class="headerlink" title="小ps："></a>小ps：</h2><ol><li><em>*<em>*</em>** 和 *</em>+** 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。**</li></ol><h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><p>转自<a href="https://oddfar.com/archives/35/">https://oddfar.com/archives/35/</a></p><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><pre class="line-numbers language-none"><code class="language-none">1、数字：^[0-9]*$2、n位的数字：^\d&#123;n&#125;$3、至少n位的数字：^\d&#123;n,&#125;$4、m-n位的数字：^\d&#123;m,n&#125;$5、零和非零开头的数字：^(0|[1-9][0-9]*)$6、非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7、带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$8、正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$9、有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10、有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11、非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12、非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$13、非负整数：^\d+$ 或 ^[1-9]\d*|0$14、非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15、非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16、非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17、正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18、负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19、浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><pre class="line-numbers language-none"><code class="language-none">-  1、汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$-  2、英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$-  3、长度为3-20的所有字符：^.&#123;3,20&#125;$-  4、由26个英文字母组成的字符串：^[A-Za-z]+$-  5、由26个大写英文字母组成的字符串：^[A-Z]+$-  6、由26个小写英文字母组成的字符串：^[a-z]+$-  7、由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$-  8、由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$-  9、中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$- 10、中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$- 11、可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+- 12、禁止输入含有~的字符：[^~\x22]+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><pre class="line-numbers language-none"><code class="language-none">-  1、Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$-  2、域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?-  3、InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$-  4、手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$-  5、电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ -  6、国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;-  7、身份证号码(数字、字母x结尾)：^(\d&#123;15&#125;$|^\d&#123;18&#125;$|^\d&#123;17&#125;(\d|X|x))$-  9、帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$- 10、密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$- 11、强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  - 12、日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><pre class="line-numbers language-none"><code class="language-none">- 1、  中文字符的正则表达式：[\u4e00-\u9fa5]- 2、  双字节字符：  [^\x00-\xff](包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))- 3、 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)- 4、 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)- 5、 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)  (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)- 6、 腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)- 7、 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)- 8、 IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)- 9、 匹配所有字符：(.*?)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;来自菜鸟教程&lt;/p&gt;
&lt;h2 id=&quot;为什么使用正则表达式？&quot;&gt;&lt;a href=&quot;#为什么使用正则表达式？&quot; class=&quot;</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="Regular expression" scheme="http://example.com/tags/Regular-expression/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://example.com/2021/03/08/python/"/>
    <id>http://example.com/2021/03/08/python/</id>
    <published>2021-03-08T06:28:04.000Z</published>
    <updated>2021-04-18T00:25:04.787Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="廖雪峰"><a href="#廖雪峰" class="headerlink" title="廖雪峰"></a>廖雪峰</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。</p></li><li><p>可变对象和不可变对象：可变指存在某项操作可以改变本身如list</p></li><li><p>set里都是key，set可以做&amp;和|操作</p></li><li><p>tuple里的不变指“指向对象不变”，指向的对象自身可以变（如list）</p></li><li><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p></li><li><p>占位符pass什么都不做</p></li><li><p>函数可以同时返回多个值，但其实就是一个tuple，多个变量可以同时接收一个tuple，按位置赋给对应的值</p></li><li><p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！如果指向可变对象如一个list，默认参数则指向这个list，且内容会被记住，每次调用都有继承，通过妙用不变对象来规避</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_end</span><span class="token punctuation">(</span>L<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> L <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> L<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    因为Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p></li><li><p>参数前加*可以接受list和tuple并组装成tuple，加**则自动组装成dict，不过此时的key不用加引号</p><ol start="11"><li><p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p></li><li><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li><li><p>函数参数规则：</p><ol><li><em><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></em></li><li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</li><li><strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li></ol></li><li><p>```python<br> a, b = b, a + b #这个挺诡异的，记录了初始值</p><pre class="line-numbers language-none"><code class="language-none">15. 切片可用于str，list，tuple16. 判断一个对象是可迭代对象：通过collections模块的Iterable类型判断    &#96;&#96;&#96;python    &gt;&gt;&gt; from collections import Iterable    &gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>列表解析：</p><ol><li>可以使用两层循环，可以生成全排列：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>m <span class="token operator">+</span> n <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token string">'ABC'</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token string">'XYZ'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'AX'</span><span class="token punctuation">,</span> <span class="token string">'AY'</span><span class="token punctuation">,</span> <span class="token string">'AZ'</span><span class="token punctuation">,</span> <span class="token string">'BX'</span><span class="token punctuation">,</span> <span class="token string">'BY'</span><span class="token punctuation">,</span> <span class="token string">'BZ'</span><span class="token punctuation">,</span> <span class="token string">'CX'</span><span class="token punctuation">,</span> <span class="token string">'CY'</span><span class="token punctuation">,</span> <span class="token string">'CZ'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>for后面的<code>if</code>是一个筛选条件，不能带<code>else</code></p></li><li><p>for前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果，必须加上else，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>生成器generator：</p><ol><li><p>第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code></p></li><li><p>二：如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator</p><p>​    变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p></li><li><p>generator函数的“调用”实际返回一个generator对象：</p></li><li><p>但是用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> g <span class="token operator">=</span> fib<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         x <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'g:'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Generator return value:'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p></li><li><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为不同地方都指向同一个对象，多处修改</p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" title="来自廖雪峰的装饰器详解">装饰器详解</a>functools.wraps(func)</p></li><li><p>偏函数：</p><p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。其实也可以传入其他值，会自动加到左侧</p><pre class="line-numbers language-none"><code class="language-none">max2 &#x3D; functools.partial(max, 10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">max2<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li><p>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>__name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p></li><li><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p></li><li><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是 <em><strong>多态真正的威力</strong></em>：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p></li><li><p>动态语言的“鸭子类型”，它并不要求严格的继承体系,只要同样能进行操作，并不会检查它的类型，即使你要求的参数是animal类</p></li><li><p>千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p></li><li><p>可以给实例动态绑定属性（直接）</p><p>A是类，a=A()  </p><p> a.name=’darren’  del(a.name)可以直接操作</p><p>print(a.attribute)要是没有特殊的，就打印A的</p><p>还可以动态绑定方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">set_age</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#定义一个函数作为实例方法</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     self<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> types <span class="token keyword">import</span> MethodType<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>set_age <span class="token operator">=</span> MethodType<span class="token punctuation">(</span>set_age<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment"># 给实例绑定一个方法</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>set_age<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token comment"># 调用实例方法</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>age <span class="token comment"># 测试结果</span><span class="token number">25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以直接给类动态绑定方法</p><p>A.set_age=set_age</p><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字</p></li><li><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span> <span class="token comment"># 用tuple定义允许绑定的属性名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p><p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p><p>（怪怪的）</p></li><li><p>@property   @method_name.setter将方法变成类</p></li><li><p><em><strong>定制类</strong></em>:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span><span class="token builtin">len</span>函数自动调用的计算长度工具<span class="token operator">-</span><span class="token operator">-</span>name<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>获得当前函数的名族<span class="token punctuation">(</span>functions<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">str</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回用户信息<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">repr</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回开发者信息<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">iter</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回迭代对象，使一个类可以被<span class="token keyword">for</span> <span class="token keyword">in</span>使用<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">next</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>迭代将调用<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">next</span><span class="token operator">-</span><span class="token operator">-</span>方法<span class="token operator">-</span><span class="token operator">-</span>getitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>实现下标访问<span class="token punctuation">[</span><span class="token punctuation">]</span>（切片要分类。。。不懂）<span class="token operator">-</span><span class="token operator">-</span>setitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>把对象视作<span class="token builtin">list</span><span class="token operator">/</span><span class="token builtin">dict</span>来赋值<span class="token operator">-</span><span class="token operator">-</span>delitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>删除某元素<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">getattr</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>在没有找到属性<span class="token operator">/</span>方法时返回定义好的，可实现动态调用！<span class="token operator">-</span><span class="token operator">-</span>call<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>直接对实例进行调用！可调用对象是CallablePython的官方文档<span class="token punctuation">:</span>  https<span class="token punctuation">:</span><span class="token operator">//</span>docs<span class="token punctuation">.</span>python<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token number">3</span><span class="token operator">/</span>reference<span class="token operator">/</span>datamodel<span class="token punctuation">.</span>html<span class="token comment">#special-method-names</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum，uniqueMonth <span class="token operator">=</span> Enum<span class="token punctuation">(</span><span class="token string">'Month'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Jan'</span><span class="token punctuation">,</span> <span class="token string">'Feb'</span><span class="token punctuation">,</span> <span class="token string">'Mar'</span><span class="token punctuation">,</span> <span class="token string">'Apr'</span><span class="token punctuation">,</span> <span class="token string">'May'</span><span class="token punctuation">,</span> <span class="token string">'Jun'</span><span class="token punctuation">,</span> <span class="token string">'Jul'</span><span class="token punctuation">,</span> <span class="token string">'Aug'</span><span class="token punctuation">,</span> <span class="token string">'Sep'</span><span class="token punctuation">,</span> <span class="token string">'Oct'</span><span class="token punctuation">,</span> <span class="token string">'Nov'</span><span class="token punctuation">,</span> <span class="token string">'Dec'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>value默认从1开始！！！！</em></p><p>用@unique精确控制Enum衍生</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@unique</span><span class="token keyword">class</span> <span class="token class-name">Weekday</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    Sun <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># Sun的value被设定为0</span>    Mon <span class="token operator">=</span> <span class="token number">1</span>    Tue <span class="token operator">=</span> <span class="token number">2</span>    Wed <span class="token operator">=</span> <span class="token number">3</span>    Thu <span class="token operator">=</span> <span class="token number">4</span>    Fri <span class="token operator">=</span> <span class="token number">5</span>    Sat <span class="token operator">=</span> <span class="token number">6</span>    day1<span class="token operator">=</span>Weekday<span class="token punctuation">.</span>Mon    day1<span class="token operator">==</span>Weekday<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    day1<span class="token punctuation">.</span>value<span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用.value获得对应的值</p></li><li><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数，所以类的类型是‘type’。</p></li><li><p>object是python的默认类，有很多的方法，python种默认的list,str,dict等等都是继承了object类的方法，继承了object的类属于新式类 ，没有继承属于经典类，在python3种默认都是新式类，也即是所有的自定义类，基类都会继承object类！</p></li><li><p>type也可创建新类</p><ol><li>class的名称；</li><li>继承的父类集合</li><li>class的方法名称与函数绑定，</li></ol></li><li><p>先定义metaclass，就可以创建类，最后创建实例。</p><p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”，它可以改变类创建时的行为。</p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。。。</p><p>按照默认习惯，metaclass的类名总是以Metaclass结尾</p><p>（写法着实奇怪。。不放了。。希望这辈子碰不到！听说ORM要用。。）</p><p>url：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072#0">使用元类 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p></li></ol><h3 id="错误-amp-异常"><a href="#错误-amp-异常" class="headerlink" title="错误&amp;异常"></a>错误&amp;异常</h3><ol><li><p>错误衍生：</p><p>The class hierarchy for built-in exceptions is:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">BaseException <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemExit <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyboardInterrupt <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> GeneratorExit <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Exception      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopIteration      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopAsyncIteration      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ArithmeticError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FloatingPointError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OverflowError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ZeroDivisionError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AssertionError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AttributeError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BufferError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> EOFError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ModuleNotFoundError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> LookupError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndexError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> MemoryError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NameError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnboundLocalError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OSError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BlockingIOError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ChildProcessError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionError      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BrokenPipeError      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionAbortedError      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionRefusedError      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionResetError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileExistsError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileNotFoundError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> InterruptedError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IsADirectoryError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotADirectoryError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PermissionError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ProcessLookupError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TimeoutError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ReferenceError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotImplementedError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RecursionError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndentationError      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TabError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TypeError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ValueError      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeError      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeDecodeError      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeEncodeError      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeTranslateError      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Warning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> DeprecationWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PendingDeprecationWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UserWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FutureWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BytesWarning           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ResourceWarning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>try .. except.. excepy…else…finally</p><p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>bar()</code>，<code>bar()</code>调用<code>foo()</code>，结果<code>foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理</p></li><li><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出.</p><p>顺着错误信息一路向下就可以找到根源</p></li><li><p>logging可以记录错误信息，要配置。。。<a href="https://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程 -</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> logging<span class="token keyword">try</span><span class="token punctuation">:</span><span class="token operator">//</span><span class="token keyword">except</span><span class="token punctuation">:</span> Excerption <span class="token keyword">as</span> e<span class="token punctuation">:</span>    logging<span class="token punctuation">.</span>excerption<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，在抛出错误信息后继续运行</p><p>当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理，raise不带参数则原样抛出</p></li><li><p>assert … , ‘decleration’可以在解释时<code>python -O file.py</code>来终止调用assert</p><p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看</p></li><li><p>logging.info()输出一段文本</p><p>在import logging后加<code>logging.basicConfig(level=logging.INFO)</code>指定记录信息的级别</p><p>error&gt;warning&gt;info&gt;debug，上面规定INFO后，logging.debug就失效了</p></li><li><p>PDB我不想学。。不如IDE自带</p></li><li><p>测试unittest参见《入门》</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">$ python <span class="token operator">-</span>m unittest mydict_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以直接启用测试，常用的assetRaises,Equal,NotEqual,True,False,In,NotIn</p><p>在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行</p></li><li><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> doctest    doctest<span class="token punctuation">.</span>testmod<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ol><li><p>异步的理解</p><p>read(size)读取size</p><p>readline()读一行</p><p>readlines()一次读取并按行返回list</p><p>清理每行结尾自动加的\n</p></li><li><p>有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行</p><p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲</p></li><li><p>open（url,encoding=’gbk’,errors=’igone’）默认编码UTF-8，在出现非法字符时，由errors决定解决方式，直接‘igone’。。。</p></li><li><p>StringIO在内存中读写str</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> io <span class="token keyword">import</span> StringIOf<span class="token operator">=</span> StringIO<span class="token punctuation">(</span><span class="token string">'initial'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getvalue()获得写入后的str</p><p>BytesIO操作的是二进制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'中文'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">6</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">b'\xe4\xb8\xad\xe6\x96\x87'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写入的是utf-8编码的bytes，也可以初始化，其他读取方式和文件一样</p></li><li><p>操作文件和目录</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> osos<span class="token punctuation">.</span>name  posix  ntos<span class="token punctuation">.</span>uname<span class="token punctuation">(</span><span class="token punctuation">)</span>不适用于windowsos<span class="token punctuation">.</span>environos<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token comment">#查看绝对路径</span><span class="token string">'/Users/michael'</span><span class="token comment">#创建目录</span><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'/Users/michael'</span><span class="token punctuation">,</span> <span class="token string">'testdir'</span><span class="token punctuation">)</span><span class="token string">'/Users/michael/testdir'</span><span class="token comment"># 然后创建一个目录:</span><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">'/Users/michael/testdir'</span><span class="token punctuation">)</span><span class="token comment"># 删掉一个目录:</span><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span><span class="token string">'/Users/michael/testdir'</span><span class="token punctuation">)</span><span class="token comment">#合成路径不要拼接字符串，才能正确处理不同操作系统的路径分隔符</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span><span class="token punctuation">)</span>可以直接让你得到文件扩展名os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token punctuation">)</span>重命名os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span>删除shutil模块提供了copyfile<span class="token punctuation">(</span><span class="token punctuation">)</span>的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os<span class="token punctuation">.</span>path模块中。还有很多操作，需要用到时去找os库吧！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化指把变量从内存中变成可存储或传输的过程称之为序列化 pickling</p><p>比起pickle库，json库更好，更通用</p><table><thead><tr><th>JSON类型</th><th>Python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int或float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><p>Python内置的<code>json</code>模块提</p><p>json.dump()   json.dumps(d,f)</p><p>json.load()   json.loads(f)</p><p>加了s是序列化和反序列化,没加则是操作文件同时序列化和反序列化。UTF-8</p><p>很多时候json不够智能，需要我们加上很多自定义参数来辅助，default是dumps用的，object_hook是loads用的，json好复杂啊</p><p><a href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p><p><a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ol><li><p>强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了</p></li><li><p>```python<br>import re<br>test = ‘用户输入的字符串’<br>if re.match(r’正则表达式’, test):</p><pre><code>print(&#39;ok&#39;)</code></pre><p>else:</p><pre><code>print(&#39;failed&#39;)</code></pre><pre class="line-numbers language-none"><code class="language-none">3. 可用于切分字符串   &#96;&#96;&#96;python   &gt;&gt;&gt; re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)   [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>提取字串！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">m<span class="token operator">=</span>re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">r'正则表达式'</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">=</span>stringm<span class="token punctuation">.</span>group<span class="token punctuation">(</span>n<span class="token punctuation">)</span>是第n个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re<span class="token comment"># 编译:</span><span class="token operator">>></span><span class="token operator">></span> re_telephone <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span><span class="token punctuation">)</span><span class="token comment"># 使用：</span><span class="token operator">>></span><span class="token operator">></span> re_telephone<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'010-12345'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'010'</span><span class="token punctuation">,</span> <span class="token string">'12345'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> re_telephone<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'010-8086'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'010'</span><span class="token punctuation">,</span> <span class="token string">'8086'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li></li></ol><h2 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h2><ol><li><p><code>str.replace(&#39;a&#39;,&#39;A&#39;) 把字符串里的a替换成A</code></p></li><li><p>abs（）绝对值，max（）返回最大值</p></li><li><p>help(function_name)放到print里克查看帮助信息</p></li><li><p>int，float，str，bool 内置数据类型转换</p></li><li><p>hex（）函数把一个整数转换成十六进制表示的字符串</p></li><li><p>内置函数<code>isinstance()</code>用于数据类型检查，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">isinstance</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p></li><li><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">reduce</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">[</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span> x4<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">(</span>f<span class="token punctuation">(</span>f<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> x3<span class="token punctuation">)</span><span class="token punctuation">,</span> x4<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>filter()</code>接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素，并返回的是一个<code>Iterator</code></p></li><li><p>sorted（列表，映射函数，reverse=True）</p><p>比较对每一项使用映射函数后的新列表！</p></li><li><p>基本类型都可以用<code>type()</code>判断，返回相应class</p><p>可以使用<code>types</code>模块中定义的常量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> types<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>FunctionType<span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>BuiltinFunctionType<span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>LambdaType<span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>GeneratorType<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>dir()</code>函数，它返回一个包含字符串的list获得一个对象的所有属性和方法</p></li><li><p>```python<br>getattr()<code>、</code>setattr()<code>以及</code>hasattr()</p><pre class="line-numbers language-none"><code class="language-none">可以分别验证，设置，得到某个instance的属性和方法如果试图获取不存在的属性，会抛出AttributeError的错误：&#96;&#96;&#96;python&gt;&gt;&gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以传入一个default参数，如果属性不存在，就返回默认值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token comment"># 获取属性'z'，如果不存在，返回默认值404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>```python<br> raise ValueError(‘score must be an integer!’)</p><pre class="line-numbers language-none"><code class="language-none">15. eval()解析字符串为指令## 常用内建模块还是看廖雪峰吧1. datetime----datetime里有个datetime包！   &#96;datetime.now()&#96;返回当前日期和时间，其类型是&#96;datetime&#96;。   &#96;&#96;&#96;python   from datetime import datetime   &gt;&gt;&gt; dt &#x3D; datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime   &gt;&gt;&gt; print(dt)   2015-04-19 12:20:00   dt.timestamp() # 把datetime转换为timestamp   1429417200.0   datetime.(时区如utc)fromtimestamp(dt)   &gt;&gt;&gt;2015-04-19 12:20:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>   <u>我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</u>对应的北京时间是：</p>   <pre class="line-numbers language-python" data-language="python"><code class="language-python">timestamp <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1970</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   str转换为datetime用datetime.strptime(‘time’,’格式参数’)具体参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python文档</a>此处得到的datetime无时区信息</p><p>   datetime转str用strftime</p><h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>   对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>   <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timedelta<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nowdatetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">-</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>参考PEP8    </p><ol><li><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p></li><li><p>运算符的空格要看出运算顺序，<code>x = 3*4 + 5</code>  <code>y = 3 + 5</code></p></li><li><p>每行代码应该不超过 <strong>80</strong> 个字符，虽然在某些使用情况下，<strong>99</strong> 个字符也可以</p></li></ol><h2 id="以后再学"><a href="#以后再学" class="headerlink" title="以后再学"></a>以后再学</h2><ol><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904" title="廖雪峰">定制类</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376">进程和线程</a></li></ol><h1 id="思科补充"><a href="#思科补充" class="headerlink" title="思科补充"></a>思科补充</h1><p>print(“..”,end=”分隔符”)分隔符用于指示结尾，默认为换行、</p><p>print(“a”,”b”,sep=”在句号间的分割标志”)</p><p><code>None</code>可以安全使用的情况只有两种：</p><ul><li>当您<strong>将其分配给变量</strong>（或将其作为<strong>函数的结果</strong>返回）时</li><li>当您<strong>将其与变量</strong>进行<strong>比较</strong>以诊断其内部状态时。</li></ul><p>它<strong>不能参与任何表达式</strong>。</p><p>列表和元组可以用*操作符“繁殖”</p><p>python3函数先定义再调用</p><h1 id="Udacity"><a href="#Udacity" class="headerlink" title="Udacity"></a>Udacity</h1><p>任何专业人士都无法记住所有方法，因此知道如何通过文档查询答案非常重要。掌握扎实的编程基础使你能够利用这些基础知识查询文档，并且构建的程序比死记硬背所有 python 可用函数的人士构建的程序强大得多。</p><p>区分函数和方法的概念</p><p>下图显示了任何字符串都可以使用的方法。</p><p><a href="https://www.w3school.com.cn/python/python_ref_string.asp">https://www.w3school.com.cn/python/python_ref_string.asp</a></p><p><strong><a href="https://docs.python.org/3/library/stdtypes.html#string-methods">文档是最宝贵的资料</a></strong></p><p>还有Udacity的<a href="https://anandology.com/python-practice-book/getting-started.html">文档教材</a></p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><hr><p>mutability 可变性</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409100005524.png" alt="image-20210409100005524"></p><p>包含可变对象和不可变对象的变量行为不同</p><p>把字符串赋给另一个变量就是复制一份，但如果是列表就类似引用</p><hr><p>orderd 有序性</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409100027234.png" alt="image-20210409100027234"></p><p>有序性的容器可以使用索引，在 python 中，所有有序容器（例如列表，字符串）的起始索引都是 0。</p><p>还可以使用切片</p><hr><h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a><strong>列表函数</strong></h3><p>max等函数在比较不能比的类型时，并不会自动转换！直接出错</p><p>支持 in</p><p>min  len   sorted（小心字符串没有列表的len方法，要用len(string)）</p><p>join字符串函数，注意python的字符串字面量间如果不加分隔符，会被视为连在一起</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_str <span class="token operator">=</span> <span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"fore"</span><span class="token punctuation">,</span> <span class="token string">"aft"</span><span class="token punctuation">,</span> <span class="token string">"starboard"</span><span class="token punctuation">,</span> <span class="token string">"port"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>new_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出:</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">foreaftstarboardport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数同样在遇到非字符串类型时直接出错</p><p>小心一些方法或者函数没有返回值，比如append，这时默认返回None</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>这下有定义了，元组是 <strong>不可变</strong> 的 <strong>有序</strong> 数据结构</p><p>所以不能更改，但可以使用索引和切片，元组适合确定后不变的数据们，可以用来表示始终不变的对应数据</p><p>元组还可以用来以紧凑的方式为多个变量赋值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dimensions <span class="token operator">=</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height <span class="token operator">=</span> dimensions<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The dimensions are &#123;&#125; x &#123;&#125; x &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在定义元组时，小括号是<strong>可选</strong>的，如果小括号并没有对解释代码有影响，程序员经常会忽略小括号。</p><p>在第二行，我们根据元组 dimensions 的内容为三个变量赋了值。这叫做<strong>元组解包</strong>。你可以通过元组解包将元组中的信息赋值给多个变量，而不用逐个访问这些信息，并创建多个赋值语句。</p><p>如果我们不需要直接使用 <code>dimensions</code>，可以将这两行代码简写为一行，一次性为三个变量赋值！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The dimensions are &#123;&#125; x &#123;&#125; x &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>{1,2,3}</p><p>无序，所以不存在最后一个元素这一说，pop方法如果无参数则会随机弹出</p><p>可变，支持in</p><p>但是不能使用append，要使用add方法</p><p><strong>不能往无序的里面使用某些带有有序意义的方法如append，</strong></p><p>对set可以进行数学上集合的操作，union()  intersection() difference(),并且与其他容器相比，速度快了很多。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是无序的！</p><p>字典的键可以是任何<strong>不可变</strong>类型！一个字典的每个键也并非必须具有相同的类型</p><p>get()用来查找值！默认返回None，也可以自定义，如果可能出错，就使用get方法而不是方括号，免得崩溃</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> elements<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'kryptonite'</span><span class="token punctuation">,</span> <span class="token string">'There\'s no such element!'</span><span class="token punctuation">)</span><span class="token string">"There's no such element!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>恒等运算符is 和 is not  与 == 和 != 是有区别的</p><p>首先要知道Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。</p><p>== 比较的是值   is比较的是id      可以用id()查看id</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">只有数值型和字符串型的情况下，a <span class="token keyword">is</span> b才为<span class="token boolean">True</span>，当a和b是<span class="token builtin">tuple</span>，<span class="token builtin">list</span>，<span class="token builtin">dict</span>或<span class="token builtin">set</span>型时，a <span class="token keyword">is</span> b为<span class="token boolean">False</span>。小整数导致的bug<span class="token operator">**</span>大家自己试试看a<span class="token operator">=</span><span class="token number">257</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">257</span>时它们的<span class="token builtin">id</span>还是否会相等。事实上Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。而Python 对小整数的定义是 <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">257</span><span class="token punctuation">)</span>，只有数字在<span class="token operator">-</span><span class="token number">5</span>到<span class="token number">256</span>之间它们的<span class="token builtin">id</span>才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。<span class="token operator">**</span> <span class="token operator">**</span>总的来说，只有数值型和字符串型，并且在通用对象池中的情况下，a <span class="token keyword">is</span> b才为<span class="token boolean">True</span>，否则当a和b是<span class="token builtin">int</span>，<span class="token builtin">str</span>，<span class="token builtin">tuple</span>，<span class="token builtin">list</span>，<span class="token builtin">dict</span>或<span class="token builtin">set</span>型时，a <span class="token keyword">is</span> b均为<span class="token boolean">False</span>。<span class="token operator">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推荐样式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> population <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Shanghai'</span><span class="token punctuation">:</span> <span class="token number">17.8</span><span class="token punctuation">,</span>              <span class="token string">'Istanbul'</span><span class="token punctuation">:</span> <span class="token number">13.3</span><span class="token punctuation">,</span>              <span class="token string">'Karachi'</span><span class="token punctuation">:</span> <span class="token number">13.0</span><span class="token punctuation">,</span>              <span class="token string">'Mumbai'</span><span class="token punctuation">:</span> <span class="token number">12.5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复合结构</strong></p><p>我们可以在其他容器中包含容器，以创建复合数据结构。例如，下面的字典将键映射到也是字典的值！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">elements <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hydrogen"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>                         <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">1.00794</span><span class="token punctuation">,</span>                         <span class="token string">"symbol"</span><span class="token punctuation">:</span> <span class="token string">"H"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>              <span class="token string">"helium"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>                         <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">4.002602</span><span class="token punctuation">,</span>                         <span class="token string">"symbol"</span><span class="token punctuation">:</span> <span class="token string">"He"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以如下所示地访问这个嵌套字典中的元素。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">helium <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token string">"helium"</span><span class="token punctuation">]</span>  <span class="token comment"># get the helium dictionary</span>hydrogen_weight <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token string">"hydrogen"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"weight"</span><span class="token punctuation">]</span>  <span class="token comment"># get hydrogen's weight</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="*逻辑"></a>*逻辑</h2><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><ul><li>逻辑运算符 <code>and</code>、<code>or</code> 和 <code>not</code> 具有特定的含义，与字面英文意思不太一样。确保布尔表达式的结果和你预期的一样。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Bad example</span><span class="token keyword">if</span> weather <span class="token operator">==</span> <span class="token string">"snow"</span> <span class="token keyword">or</span> <span class="token string">"rain"</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Wear boots!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码在 Python 中是有效的，但不是布尔表达式，虽然读起来像。原因是 <code>or</code> 运算符右侧的表达式 <code>&quot;rain&quot;</code> 不是布尔表达式，它是一个字符串。稍后我们将讨论当你使用非布尔型对象替换布尔表达式时，会发生什么。</p><ul><li>请勿使用 <code>== True</code> 或 <code>== False</code> 比较布尔变量</li></ul><p><strong>以下是在 Python 中被视为 False 的大多数内置对象：</strong></p><ul><li>定义为 false 的常量：<code>None</code> 和 <code>False</code></li><li>任何数字类型的零：<code>0</code>、<code>0.0</code>、<code>0j</code>、<code>Decimal(0)</code>、<code>Fraction(0, 1)</code></li><li>空序列和空集合：<code>””</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>、<code>set()</code>、<code>range(0)</code></li></ul><p>在Python中and的优先级是大于or的，而且and和or都是会返回值的并且不转换为True和False。当not和and及or在一起运算时，优先级为是not&gt;and&gt;or</p><hr><h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p><strong>短路求值</strong></p><p>如果<code>a = False</code>，对于<code>a and b</code>求值时，将直接得到结果为<code>False</code>，不会再对<code>b</code>的值做考核，不论它是<code>True</code>或<code>False</code>。</p><p>如果<code>a = True</code>，对于<code>a or b</code>求值时，将直接得到结果为<code>True</code>，不会再对<code>b</code>的值做考核，不论它是<code>True</code>或<code>False</code>。</p><p>python的if这些语句会提取表达式的真假，但并不是把表达式改了值！</p><hr><p><strong>短路输出</strong></p><p><strong>记住，所有被短路的表达式均不会被输出</strong></p><p><strong>短路规则如下</strong></p><ul><li><p>表达式从左至右运算，若 or 的左侧逻辑值为 True ，则短路 or 后所有的表达式（不管是 and 还是 or），直接输出 or 左侧表达式 。 // 若 or 的左侧逻辑值为 False ，则输出or右侧的表达式，不论其后表达式是真是假，整个表达式结果即为其后表达式的结果</p></li><li><p>表达式从左至右运算，若 and 的左侧逻辑值为 False ，则短路其后所有 and 表达式，直到有 or 出现，输出 and 左侧表达式到 or 的左侧，参与接下来的逻辑运算。  // 若 and 的左侧逻辑值为 True,则输出其后的表达式，不论其后表达式是真是假，整个表达式结果即为其后表达式的结果</p></li><li><p>若 or 的左侧为 False ，或者 and 的左侧为 True 则不能使用短路逻辑。</p></li></ul><p><a href="https://www.cnblogs.com/an9wer/p/5475551.html">有例子的大佬详解</a></p><p><strong>三元运算操作符</strong></p><p>　　在python2.5 之前，python 是没有三元操作符的，Guido Van Rossum 认为它并不能帮助 python 更加简洁，但是那些习惯了 c 、 c++ 和 java 编程的程序员却尝试着用 and 或者 or 来模拟出三元操作符，而这利用的就是python的短路逻辑。</p><p>　　三元运算操作符 bool ? a : b ，若 bool 为真则 a ，否则为 b 。</p><p>　　转化为 python 语言为：</p><blockquote><p>　　　　　　　　**bool and a or b **</p></blockquote><p>　　如何理解呢？ 首先 a ， b 都为真，这是默认的。如果 bool 为真， 则 bool and a 为真，输出 a ，短路 b 。如果 bool 为假，短路 a，直接 bool or b ，输出 b 。</p><p>　　换一种更简单的写法：</p><blockquote><p>　　　　　　　　<strong>return a if bool else b</strong></p></blockquote><h3 id="for和迭代"><a href="#for和迭代" class="headerlink" title="for和迭代"></a>for和迭代</h3><p><strong>iterable</strong> 也是一个很重要的属性！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409115901777.png" alt="image-20210409115901777"></p><p>字符串，列表，元组等序列结构，</p><p>字典，文件等非序列类型</p><p>iter()方法定义对象，使其为可迭代</p><p><strong>for用于可迭代对象</strong>！！！！！习惯用单复数分别作为迭代变量名，和迭代对象名</p><p>range(star,stop,step) 默认start -0 step-1  只能是整数,小心stop表示到xx停止，所以不会包含</p><p>漂亮用法👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409120515316.png" alt="image-20210409120515316"></p><p>只会返回一个可迭代的range对象。。得用list转化或for遍历</p><hr><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><code>For</code> 循环是一种“有限迭代”，意味着循环主体将运行预定义的次数。这与“无限迭代”循环不同，无限迭代循环是指循环重复未知次数，并在满足某个条件时结束，<code>while</code> 循环正是这种情况</p><p>break和continue</p><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">ps<span class="token punctuation">:</span> 格式化字符串函数<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token operator">>></span><span class="token operator">></span><span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>    <span class="token comment"># 不设置指定位置，按默认顺序</span><span class="token string">'hello world'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"&#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment"># 设置指定位置</span><span class="token string">'hello world'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment"># 设置指定位置</span><span class="token string">'world hello world'</span>也可以设置参数：<span class="token comment"># 关键字参数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> url<span class="token operator">=</span><span class="token string">"www.runoob.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 通过字典设置参数</span>site <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"www.runoob.com"</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token operator">**</span>site<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 通过列表索引设置参数</span>my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>my_list<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># "0" 是必须的</span><span class="token comment"># 仅列表</span><span class="token keyword">for</span> point <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>labels<span class="token punctuation">,</span> x_coord<span class="token punctuation">,</span> y_coord<span class="token punctuation">,</span> z_coord<span class="token punctuation">)</span><span class="token punctuation">:</span>    points<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&#123;&#125;: &#123;&#125;, &#123;&#125;, &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">)</span>    此外我们可以使用大括号 <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> 来转义大括号<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"runoob"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>runoob 对应的位置是 <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span>数字则在前面加上<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">数字</th><th align="left">格式</th><th align="left">输出</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">3.1415926</td><td align="left">{:.2f}</td><td align="left">3.14</td><td align="left">保留小数点后两位</td></tr><tr><td align="left">3.1415926</td><td align="left">{:+.2f}</td><td align="left">+3.14</td><td align="left">带符号保留小数点后两位</td></tr><tr><td align="left">-1</td><td align="left">{:+.2f}</td><td align="left">-1.00</td><td align="left">带符号保留小数点后两位</td></tr><tr><td align="left">2.71828</td><td align="left">{:.0f}</td><td align="left">3</td><td align="left">不带小数</td></tr><tr><td align="left">5</td><td align="left">{:0&gt;2d}</td><td align="left">05</td><td align="left">数字补零 (填充左边, 宽度为2)</td></tr><tr><td align="left">5</td><td align="left">{:x&lt;4d}</td><td align="left">5xxx</td><td align="left">数字补x (填充右边, 宽度为4)</td></tr><tr><td align="left">10</td><td align="left">{:x&lt;4d}（顺着读：在x左边）</td><td align="left">10xx</td><td align="left">数字补x (填充右边, 宽度为4)</td></tr><tr><td align="left">1000000</td><td align="left">{:,}</td><td align="left">1,000,000</td><td align="left">以逗号分隔的数字格式</td></tr><tr><td align="left">0.25</td><td align="left">{:.2%}</td><td align="left">25.00%</td><td align="left">百分比格式</td></tr><tr><td align="left">1000000000</td><td align="left">{:.2e}</td><td align="left">1.00e+09</td><td align="left">指数记法</td></tr><tr><td align="left">13</td><td align="left">{:&gt;10d}（没写用啥补，就是空的）</td><td align="left">13</td><td align="left">右对齐 (默认, 宽度为10)</td></tr><tr><td align="left">13</td><td align="left">{:&lt;10d}</td><td align="left">13</td><td align="left">左对齐 (宽度为10)</td></tr><tr><td align="left">13</td><td align="left">{:^10d}</td><td align="left">13</td><td align="left">中间对齐 (宽度为10)</td></tr><tr><td align="left">11</td><td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td><td align="left"><code>1011 11 13 b 0xb 0XB</code></td><td align="left">进制</td></tr></tbody></table><hr><h3 id="Zip-amp-Enumerate"><a href="#Zip-amp-Enumerate" class="headerlink" title="Zip &amp;Enumerate"></a>Zip &amp;Enumerate</h3><p><code>zip</code> 返回一个将多个可迭代对象组合成一个元组序列的迭代器。每个元组都包含所有可迭代对象中该位置的元素。例如，</p><p><code>list(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]))</code> 将输出 <code>[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</code>.</p><p>正如 <code>range()</code> 一样，我们需要将其转换为列表或使用循环进行遍历以查看其中的元素。</p><p>你可以如下所示地用 <code>for</code> 循环拆分每个元组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">for</span> letter<span class="token punctuation">,</span> num <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>letters<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>letter<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span>这个是两个参数依次匹配，字典的items是用了这个原理<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>items原理（转化为一个元组列表）：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194823598.png" alt="image-20210409194823598"></p><p>除了可以将两个列表组合到一起之外，还可以使用星号拆分列表。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">some_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>letters<span class="token punctuation">,</span> nums <span class="token operator">=</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>some_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样可以创建正如之前看到的相同 <code>letters</code> 和 <code>nums</code> 列表，巧妙👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409190913313.png" alt="image-20210409190913313"></p><hr><p><code>enumerate</code> 是一个会返回元组迭代器的内置函数，这些元组包含列表的索引和值。当你需要在循环中获取可迭代对象的每个元素及其索引时，将经常用到该函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> letter <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>letters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> letter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码将输出：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">0 a1 b2 c3 d4 e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409191815484.png" alt="image-20210409191815484"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409191831742.png" alt="image-20210409191831742"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409192428071.png" alt="image-20210409192428071"></p><p>这个技巧很诡异，tuple可以将列表，区间，字符串，zip等（可迭代对象？）等转换为元组</p><p>但在转化字典时，只会保留键。这边就是把zip迭代对象转化为元组，</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409193651985.png" alt="image-20210409193651985"></p><p>这样就直接可以使用索引了！</p><h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3><p>终于知道SyntaxError原来是语法错误</p><p>你还可以向列表推导式添加条件语句。在可迭代对象之后，你可以使用关键字 <code>if</code> 检查每次迭代中的条件。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述代码将 <code>squares</code> 设为等于列表 [0, 4, 16, 36, 64]，因为仅在 x 为偶数时才评估 x 的 2 次幂。如果你想添加 <code>else</code>，将遇到语法错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你要添加 <code>else</code>，则需要将条件语句移到列表推导式的开头，直接放在表达式后面，如下所示。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> x <span class="token operator">+</span> <span class="token number">3</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列表推导式并没有在其他语言中出现，但是在 python 中很常见。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194302935.png" alt="image-20210409194302935"></p><p>这个课程总有一些奇怪的知识藏在题解里面卧槽，split是个很重要的工具</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194648954.png" alt="image-20210409194648954"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>仅在函数名称中使用普通字母、数字和下划线。不能有空格，需要以字母或下划线开头。</li><li><strong>不能使用在 Python 中具有重要作用的保留字或内置标识符</strong>，我们将在这门课程中学习这方面的知识。要了解 python 保留字列表，请参阅<a href="https://pentangle.net/python/handbook/node52.html">此处</a>。</li><li>尝试使用可以帮助读者了解函数作用的描述性名称</li></ol><h3 id="python变量"><a href="#python变量" class="headerlink" title="python变量"></a>python变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409234143765.png" alt="image-20210409234143765"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409234153818.png" alt="image-20210409234153818"></p><p><em><strong>你发现在函数内，我们可以成功地输出外部变量的值。因为我们只是访问该变量的值。当我们尝试将此变量的值更改或重新赋值为另一个值时，我们将遇到错误。Python 不允许函数修改不在函数作用域内的变量。</strong></em></p><p><em><strong>但是上面的原则仅适用于整数和字符串，列表、字典、集合、类中可以在子程序（子函数）中通过修改局部变量达到修改全局变量的目的。</strong></em></p><h3 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h3><p>通用写法是*arg  **kwargs</p><p>*args就是就是传递一个可变参数列表给函数实参，这个参数列表的数目未知，甚至长度可以为0。</p><p>打包后成为元组tuple</p><p>**kwargs则是将一个可变的关键字参数的字典传给函数实参，同样参数列表长度可以为0或为其他值</p><p>打包后是一个字典</p><p>args 必须放在 kwargs 前面</p><p>打包就是zip</p><p>解包可以是之前介绍的写法，一个变量对应一项，对应不上就报错</p><p>可以用*var 代替任意项<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410111047193.png" alt="image-20210410111047193"></p><p><strong>函数定义时</strong>，我们用的*和**其实也是压包解包过程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">myfun</span><span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> myfun<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数用<code>*num</code>表示，<code>num</code>变量就可以当成元组调用了。</p><p>其实这个过程相当于<code>*num, = 1,2,5,6</code></p><p>但是在<strong>传递参数</strong>时，是解包过程<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410111344033.png" alt="image-20210410111344033"></p><p>这个应用牛啊</p><p>可以看看<a href="https://zhuanlan.zhihu.com/p/33896402">原文</a></p><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>docstrings，文档字符串是一种注释，用于解释函数的作用以及使用方式。</p><p>文档字符串用三个引号引起来，第一行简要解释了<strong>函数的作用</strong>。如果你觉得信息已经足够了，可以在文档字符串中只提供这么多的信息；</p><p>如果你觉得需要更长的句子来解释函数，可以在一行摘要后面添加更多信息</p><p>对函数的参数进行了解释，描述了每个参数的作用和类型。我们经常还会对函数输出进行说明</p><p><a href="https://www.python.org/dev/peps/pep-0257/">这里是惯例</a></p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>你可以使用 Lambda 表达式创建匿名函数，即没有名称的函数。lambda 表达式非常适合快速创建<strong>在代码中以后不会用到</strong>的函数。尤其<strong>对高阶函数或将其他函数作为参数的函数</strong>来说，非常实用。</p><p><strong>Lambda 函数的组成部分</strong></p><ol><li>关键字 <code>lambda</code> 表示这是一个 lambda 表达式。</li><li><code>lambda</code> 之后是该匿名函数的一个或多个参数（用英文逗号分隔），然后是一个英文冒号 <code>:</code>。和函数相似，lambda 表达式中的参数名称是随意的。</li><li>最后一部分是被评估并在该函数中返回的表达式，和你可能会在函数中看到的 return 语句很像。</li></ol><p>鉴于这种结构，lambda 表达式不太适合复杂的函数，但是非常适合简短的函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409235417795.png" alt="image-20210409235417795"></p><h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><p>Iterator   and   generator </p><p><strong>迭代器</strong>是每次可以返回一个对象元素的对象，例如返回一个列表。我们到目前为止使用的很多内置函数（例如 enumerate）都会返回一个迭代器。</p><p><strong>迭代器</strong>是一种表示数据流的对象。这与列表不同，列表是可迭代对象，但不是迭代器，因为它不是数据流。</p><p>第一种方法很简单，只要把一个列表解析式的<code>[]</code>改成<code>()</code></p><p><strong>生成器</strong>是使用函数创建迭代器的简单方式。也可以使用<strong>类</strong>定义迭代器，更多详情请参阅<a href="https://docs.python.org/3/tutorial/classes.html#iterators">此处</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">my_range</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>        <span class="token keyword">yield</span> i        i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，该函数使用了 yield 而不是关键字 return。这样使函数能够一次返回一个值，并且每次被调用时都从停下的位置继续。关键字 yield 是将生成器与普通函数区分开来的依据。调用该函数返回一个迭代器</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410003534992.png" alt="image-20210410003534992"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410003603746.png" alt="image-20210410003603746"></p><p>妙啊！用size指定间距，用切片进行范围切取</p><p><strong>python和c的思维方式是不一样的！</strong></p><p>C要利用有限的工具进行微操，而python要巧妙利用已有的强大工具进行组合！</p><p>这些工具组合起来太巧妙了</p><p>tuple,list,dict,zip,enumerate,压包解包,列表解析,lambda,range,iterator还有封装好的函数</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>Python 是一种“脚本语言”。脚本，对应的英文是：script。一般人看到script这个英文单词，或许想到的更多的是：电影的剧本，就是一段段的脚本，所组成的。电影剧本的脚本，决定了电影中的人和物，都做哪些事情，怎么做。而计算机中的脚本，决定了：计算机中的操作系统和各种软件工具，要做哪些事情，以及具体怎么做。</p><p>学完更全面的Anaconda和Jupyter Notebook  我们继续脚本</p><p>运行python文件得先输入python（理解为执行python命令，毕竟python没有c那么底层）</p><p>输入python进入环境，C + Z退出，或者exit()</p><p>input(‘xx’) 注意返回的是字符串</p><p>内置函数 <code>eval</code> 将用户输入解析为 Python 表达式，感觉非常危险！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter an expression: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果用户输入 <code>2 * 3</code>，输出为 <code>6</code>。</p><p>ps:</p><p>split </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"Line1-abcdef \nLine2-abc \nLine4-abcd"</span><span class="token punctuation">;</span> <span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment"># 以空格为分隔符，包含 \n </span><span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 以空格为分隔符，分隔成两个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上实例输出结果如下：</p><pre class="line-numbers language-none"><code class="language-none">[&#39;Line1-abcdef&#39;, &#39;Line2-abc&#39;, &#39;Line4-abcd&#39;][&#39;Line1-abcdef&#39;, &#39;\nLine2-abc \nLine4-abcd&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面看一个神奇的例子</p><hr><pre class="line-numbers language-python" data-language="python"><code class="language-python">names <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter names separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>assignments <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter assignment counts separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>grades <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter grades separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>message <span class="token operator">=</span> "Hi <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>\n\nThis <span class="token keyword">is</span> a reminder that you have <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> assignments left to \submit before you can graduate<span class="token punctuation">.</span> You're current grade <span class="token keyword">is</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">and</span> can increase \to <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">if</span> you submit <span class="token builtin">all</span> assignments before the due date<span class="token punctuation">.</span>\n\n"<span class="token keyword">for</span> name<span class="token punctuation">,</span> assignment<span class="token punctuation">,</span> grade <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> assignments<span class="token punctuation">,</span> grades<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> assignment<span class="token punctuation">,</span> grade<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>assignment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h3><p>SyntaxError  语法异常</p><p>Exception就是语法正常但是出错</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410145517500.png" alt="image-20210410145517500"></p><p>Try 语句</p><p>我们可以使用 try 语句处理异常。你可以使用 4 个子句（除了视频中显示的子句之外还有一个子句）。</p><ul><li><p><code>try</code>：这是 <code>try</code> 语句中的唯一必需子句。该块中的代码是 Python 在 <code>try</code> 语句中首先运行的代码。</p></li><li><p><code>except</code>：如果 Python 在运行 <code>try</code> 块时遇到异常，它将跳到处理该异常的 <code>except</code> 块。</p><p>可以明确指明异常种类 except ValueError:   话说竟然C+C是KeyboardInterrupt异常</p><p>也可以用逗号分割来指定多种（实质是转化成一个元组，也可以直接写一个元组上去）</p><p>或者写多条except语句来分别不同情况</p></li><li><p><code>else</code>：如果 Python 在运行 <code>try</code> 块时没有遇到异常，它将在运行 <code>try</code> 块后运行该块中的代码。</p></li><li><p><code>finally</code>：在 Python 离开此 <code>try</code> 语句之前，在任何情形下它都将运行此 <code>finally</code> 块中的代码，即使要结束程序，例如：如果 Python 在运行 <code>except</code> 或 <code>else</code> 块中的代码时遇到错误，在停止程序之前，依然会执行此<code>finally</code> 块。</p></li></ul><p><a href="https://stackoverflow.com/questions/11551996/why-do-we-need-the-finally-clause-in-python">为何在 Python 中需要 <code>finally</code> 子句？</a></p><p>可用于清理代码比如关闭文件之类的👆</p><p>注意一下顺序</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410145940469.png" alt="image-20210410145940469"></p><p><strong>在这里，当执行了x = xx 时，抛出异常，直接到except里面，而不是执行break！</strong></p><p><strong>访问错误信息</strong></p><p>在处理异常时，依然可以如下所示地访问其错误消息：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment"># some code</span><span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>   <span class="token comment"># some code</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ZeroDivisionError occurred: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该会输出如下所示的结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ZeroDivisionError occurred: division by zero<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此依然可以访问错误消息，即使已经处理异常以防止程序崩溃！</p><p>如果没有要处理的具体错误，依然可以如下所示地访问消息：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment"># some code</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>   <span class="token comment"># some code</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception occurred: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>Exception</code> 是所有内置异常的基础类</strong>。你可以在<a href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions">此处</a>详细了解 Python 的异常。</p><hr><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件其实是一堆数字符号编码</p><p>其他的文件打开应用其实就是解读特定的编码并显示出来的GUI</p><p>在python中打开文件会出现一个公用程序接口</p><p>文件对象时python与文件交互的接口，智能按顺序一次查看一个字符</p><p>open打开，参数w，a，r之类的，write（返回输入的字符数）</p><p>read会从当前位置读取所有字符放进一个字符串，一定要close噢！小心耗尽文件句柄</p><p>如果向 <code>.read()</code> 传入整型参数，它将读取长度是这么多字符的内容，输出所有内容，并使 ‘window’ 保持在该位置以准备继续读取。</p><p>Python 提供了一个特殊的语法with，该语法会在你使用完文件后自动关闭该文件。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'my_path/my_file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    file_data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该 <code>with</code> 关键字使你能够打开文件，对文件执行操作，并在缩进代码（在此示例中是读取文件）执行之后自动关闭文件。现在，我们不需要调用 f.close() 了！你只能在此缩进块中访问文件对象 f。</p><p>实质是利用作用域</p><p>请参阅 <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files">Python 文档的相关部分</a></p><p>readline() 会读取一行</p><p><code>f.tell()</code> returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode.</p><p>鬼知道这个不透明数字是个啥玩意</p><p>To change the file object’s position, use <code>f.seek(offset, whence)</code>. The position is computed from adding <em>offset</em> to a reference point; the reference point is selected by the <em>whence</em> argument. A <em>whence</em> value of 0 measures from the beginning of the file, <strong>1 uses the current file position, and 2 uses the end of the file as the reference point</strong>. <em>whence</em> can be omitted and <strong>defaults to 0</strong>, using the beginning of the file as the reference point.</p><p>在文本文件中（那些<code>b</code>在模式字符串中不带a开头的文件），<strong>仅允许相对于文件开头的查找</strong>（查找到以结尾的文件末尾为例外），并且唯一有效的<em>偏移</em>值是从零返回的<em>偏移</em>量值。。任何其他<em>偏移</em>值都会<strong>产生不确定</strong>的行为。<code>seek(0, 2)``f.tell()</code>  这个和c语言一样</p><p>很方便的是，Python 将使用语法 <code>for line in file</code> 循环访问文件中的各行内容。 我可以使用该语法创建列表中的行列表。因为<strong>每行依然包含换行符</strong>，因此我使用 <code>.strip()</code> 删掉换行符。也可以rstrip()</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">camelot_lines <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"camelot.txt"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        camelot_lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>camelot_lines<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[&quot;We&#39;re the knights of the round table&quot;, &quot;We dance whenever we&#39;re able&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如提取每行的信息，前提是你知道怎么分离的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_cast_list</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>    cast_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># use with to open the file filename</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment"># use the for loop syntax to process each line        </span>    <span class="token comment"># and add the actor name to cast_list</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>            line_data <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>            cast_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> cast_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>只能在导入语句之后使用相应python代码，所以习惯放在顶部</p><p><strong>模块是具有python定义和语句的文件</strong></p><p>import  xxx as xx</p><p>还有python里面的<strong>main函数</strong> if __name__ ==  “__main__“</p><p>这样的结构不错：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># useful_functions.py</span><span class="token keyword">def</span> <span class="token function">mean</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add_five</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">5</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> num_list<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Testing mean function"</span><span class="token punctuation">)</span>    n_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">]</span>    correct_mean <span class="token operator">=</span> <span class="token number">30.5</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>mean<span class="token punctuation">(</span>n_list<span class="token punctuation">)</span> <span class="token operator">==</span> correct_mean<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Testing add_five function"</span><span class="token punctuation">)</span>    correct_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">]</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>add_five<span class="token punctuation">(</span>n_list<span class="token punctuation">)</span> <span class="token operator">==</span> correct_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"All tests passed!"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<a href="https://pymotw.com/3/">python标准库里查看并引用需要的module</a></p><p>datetime 用来处理日期和时间</p><p>os可以用来处理操作系统相关的，还有当前目录</p><p><strong>直接导入</strong></p><p>from module_name import object_name   </p><p>from module_name import object_name,object_name2</p><p>只获取所需要的对象，所以说函数其实也是一个对象</p><p>廖雪峰教材里确实有提到：函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p><p>总结：</p><ol><li><p>要从模块中导入单个函数或类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> object_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>要从模块中导入多个单个对象：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> first_object<span class="token punctuation">,</span> second_object<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>要重命名模块：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> module_name <span class="token keyword">as</span> new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>要从模块中导入对象并重命名：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> object_name <span class="token keyword">as</span> new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>要从模块中单个地导入所有对象（请勿这么做）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> <span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果你真的想使用模块中的所有对象，请使用标准导入 module_name 语句并使用点记法访问每个对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> module_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><hr><p>为了更好地管理代码，Standard 标准库中的模块被拆分成了子模块并包含在软件包中。<strong>软件包</strong>是一个包含子模块的模块。子模块使用普通的点记法指定。</p><p>子模块的指定方式是软件包名称、点，然后是子模块名称。你可以如下所示地导入子模块。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> package_name<span class="token punctuation">.</span>submodule_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>python的标准库非常庞大，但即使这样，仍有成千上万的第三方库</p><p>pip和conda下载这些库的的软件包，这样你可以使用与导入标准库相同的语法来导入第三方软件包</p><p><strong>conda据说专门针对数据科学！</strong>pip是内置，也是一般情况</p><p>按照规范，最好把第三方库放在导入标准库的语句后面</p><p><strong>使用 <code>requirements.txt</code> 文件</strong></p><p>大型 Python 程序可能依赖于十几个第三方软件包。为了更轻松地分享这些程序，程序员经常会在叫做 requirements.txt 的文件中列出项目的依赖项。下面是一个 requirements.txt 文件示例。</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">beautifulsoup4&#x3D;&#x3D;4.5.1bs4&#x3D;&#x3D;0.0.1pytz&#x3D;&#x3D;2016.7requests&#x3D;&#x3D;2.11.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该文件的每行包含软件包名称和版本号。版本号是可选项，但是通常都会包含。不同版本的库之间可能变化不大，可能截然不同，因此有必要使用程序作者在写程序时用到的库版本。</p><p>你可以使用 pip 一次性安装项目的所有依赖项，方法是在命令行中输入 <code>pip install -r requirements.txt</code>。</p><h3 id="实用的第三方软件包"><a href="#实用的第三方软件包" class="headerlink" title="实用的第三方软件包"></a>实用的第三方软件包</h3><p>能够安装并导入第三方库很有用，但是要成为优秀的程序员，还需要知道有哪些库可以使用。大家通常通过在线推荐或同事介绍了解实用的新库。如果你是一名 Python 编程新手，可能没有很多同事，因此为了帮助你了解入门信息，下面是优达学城工程师很喜欢使用的软件包列表。（可能部分网站在国内网络中无法打开）</p><ul><li><a href="https://ipython.org/">IPython</a> - 更好的交互式 Python 解释器</li><li><a href="http://docs.python-requests.org/">requests</a> - 提供易于使用的方法来发出网络请求。适用于访问网络 API。</li><li><a href="http://flask.pocoo.org/">Flask</a> - 一个小型框架，用于构建网络应用和 API。</li><li><a href="https://www.djangoproject.com/">Django</a> - 一个功能更丰富的网络应用构建框架。Django 尤其适合设计复杂、内容丰富的网络应用。</li><li><a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> - 用于解析 HTML 并从中提取信息。适合网页数据抽取。</li><li><a href="http://doc.pytest.org/">pytest</a> - 扩展了 Python 的内置断言，并且是最具单元性的模块。</li><li><a href="http://pyyaml.org/wiki/PyYAML">PyYAML</a> - 用于读写 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件。</li><li><a href="http://www.numpy.org/">NumPy</a> - 用于使用 Python 进行科学计算的最基本软件包。它包含一个强大的 N 维数组对象和实用的线性代数功能等。</li><li><a href="http://pandas.pydata.org/">pandas</a> - 包含高性能、数据结构和数据分析工具的库。尤其是，pandas 提供 dataframe！</li><li><a href="http://matplotlib.org/">matplotlib</a> - 二维绘制库，会生成达到发布标准的高品质图片，并且采用各种硬拷贝格式和交互式环境。</li><li><a href="http://ggplot.yhathq.com/">ggplot</a> - 另一种二维绘制库，基于 R’s ggplot2 库。</li><li><a href="https://python-pillow.org/">Pillow</a> - Python 图片库可以向你的 Python 解释器添加图片处理功能。</li><li><a href="http://www.pyglet.org/">pyglet</a> - 专门面向游戏开发的跨平台应用框架。</li><li><a href="http://www.pygame.org/">Pygame</a> - 用于编写游戏的一系列 Python 模块。</li><li><a href="http://pytz.sourceforge.net/">pytz</a> - Python 的世界时区定义。</li></ul><h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>通过在终端里输入 <code>python</code> 启动 python 交互式解释器。你可以接着输入内容，直接与 Python 交互。这是每次实验和尝试一段 Python 代码的很棒工具。只需输入 Python 代码，输出将出现在下一行。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; type(5.23)&lt;class &#39;float&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在解释器中，提示符窗口中最后一行的值将自动输出。如果有多行代码需要输出值，依然需要使用 print。</p><p>如果你开始定义函数，你将在提示符窗口中看到变化，表示这是可以继续的行。在定义函数时，你需要自己添加缩进。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def cylinder_volume(height, radius):...         pi &#x3D; 3.14159...         return height * pi * radius ** 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解释器的不足之处是修改代码比较麻烦。如果你在输入该函数时出现了拼写错误，或者忘记缩进函数的主体部分，无法使用鼠标将光标点到要点击的位置。需要使用箭头键在代码行中来回移动。有必要了解一些实用的快捷方式，例如移到一行的开头或结尾。</p><p>注意，我可以引用我在解释器中之前定义的任何对象！</p><p>实际上有一个代替默认 python 交互式解释器的强大解释器 IPython，它具有很多其他功能。</p><p>在命令行输入ipython就可以打开</p><ul><li>Tab 键补充完整</li><li><code>?</code>：关于对象的详细信息</li><li><code>!</code>：执行系统 shell 命令</li><li>语法突出显示</li></ul><p>你可以在<a href="https://ipython.org/ipython-doc/3/interactive/tutorial.html">此处</a>查看更多其他功能！</p><h3 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询"></a>快速查询</h3><p>要想成为熟练的程序员，需要掌握大量知识。需要了解库、记住语法以及其他细节。此外，让这一切更具挑战的是，技术在不断革新，因为新的技巧和工具会不断出现。</p><p>对于编程新手来说，学习所有这些细节并及时获悉新的发展动态似乎是一项不可能完成的任务。的确是这样！具有多年经验的编程专业人士实际上并不是在脑中记下百科全书一样的知识，而是掌握了快速查找信息的技巧。</p><p>下面是高效网络搜索的一些技巧：</p><ul><li>在查询时，尝试使用 Python 或要使用的库的名称作为第一个字词。这样会告诉搜索引擎优先显示与你要使用的工具明确相关的结果。</li><li>创建良好的搜索查询需要多次尝试。如果第一次尝试时没有找到有用的结果，再试一遍。</li><li>尝试使用在一开始搜索时发现的网页上发现的关键字，使搜索引擎在后续搜索中转到更好的资源。</li><li>复制粘贴错误消息作为搜索字词。这样会出现错误解释性信息和潜在原因。错误消息可能包括你所写的特定行号引用。只在搜索中包含这些信息之前的错误消息部分。</li><li>如果找不到问题答案，自己提出问题！StackOverflow 等社区有一些行为规则，如果你要加入该社区，必须了解这些规则，但是别因为这些规则而不愿意使用这些资源。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410161009668.png" alt="image-20210410161009668"></p><p>虽然有很多关于编程的在线资源，但是并非所有资源都是同等水平的。下面的资源列表按照大致的可靠性顺序排序。</p><ol><li><strong><a href="https://docs.python.org/3/tutorial/">Python 教程</a></strong> - 这部分官方文档给出了 Python 的语法和标准库。它会举例讲解，并且采用的语言比主要文档的要浅显易懂。确保阅读该文档的 Python 3 版本！</li><li><strong><a href="https://docs.python.org/3/index.html">Python 语言和库参考资料</a></strong> - 语言参考资料和库参考资料比教程更具技术性，但肯定是可靠的信息来源。当你越来越熟悉 Python 时，应该更频繁地使用这些资源。</li><li><strong>第三方库文档</strong> - 第三方库会在自己的网站上发布文档，通常发布于 <a href="https://readthedocs.org/">https://readthedocs.org/</a> 。你可以根据文档质量判断第三方库的质量。如果开发者没有时间编写好的文档，很可能也没时间完善库。</li><li><strong>非常专业的网站和博客</strong> - 前面的资源都是主要资源，他们是编写相应代码的同一作者编写的文档。主要资源是最可靠的资源。次要资源也是非常宝贵的资源。次要资源比较麻烦的是需要判断资源的可信度。<a href="https://doughellmann.com/blog/">Doug Hellmann</a> 等作者和 <a href="http://eli.thegreenplace.net/">Eli Bendersky</a> 等开发者的网站很棒。不出名作者的博客可能很棒，也可能很糟糕。</li><li><strong><a href="http://stackoverflow.com/">StackOverflow</a></strong> - 这个问答网站有很多用户访问，因此很有可能有人之前提过相关的问题，并且有人回答了！但是，答案是大家自愿提供的，质量参差不齐。在将解决方案应用到你的程序中之前，始终先理解解决方案。如果答案只有一行，没有解释，则值得怀疑。你可以在此网站上查找关于你的问题的更多信息，或发现替代性搜索字词。</li><li><strong>Bug 跟踪器</strong> - 有时候，你可能会遇到非常罕见的问题或者非常新的问题，没有人在 StackOverflow 上提过。例如，你可能会在 GitHub 上的 bug 报告中找到关于你的错误的信息。这些 bug 报告很有用，但是你可能需要自己开展一些工程方面的研究，才能解决问题。</li><li><strong>随机网络论坛</strong> - 有时候，搜索结果可能会生成一些自 2004 年左右就不再活跃的论坛。如果这些资源是唯一解决你的问题的资源，那么你应该重新思考下寻找解决方案的方式。</li></ol><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>再看看这里的Anaconda和Jupyterbook</p><ol><li>Anaconda发行版中的可用软件包<code>conda</code>专注于数据科学，而这些软件包<code>pip</code>通常用于一般用途。Conda安装预编译的软件包。例如，Anaconda发行版随附使用<a href="https://docs.continuum.io/mkl-optimizations/">MKL库</a>编译的Numpy，Scipy和Scikit-learn ，从而加快了各种数学运算的速度。<strong>但是，有时候，您可能需要除Anaconda发行版中列出的软件包以外的软件包。</strong></li><li>Pip可以安装Python软件包和非Python软件包。Pip可以安装<a href="https://pypi.org/">Python软件包索引</a>（PyPI）上列出的任何软件包。</li></ol><p>conda list 列出安装的所有包</p><p>conda env list 检查环境列表</p><p>为了避免以后出现错误，最好在默认环境中更新所有软件包。打开终端/ Anaconda Prompt应用程序。在提示符下，运行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">conda upgrade condaconda upgrade --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并在询问是否要安装软件包时回答是。最初安装时附带的软件包往往已过时，因此立即更新它们可以防止将来的软件过时错误。</p><p>新环境里最好安装个pip</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Check if pip is already installed, by running this command on Terminal/Anaconda Prompt</span>pip --version<span class="token comment"># Once you have conda installed, run the command below on Terminal/Anaconda Prompt</span>conda <span class="token function">install</span> pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h2><p>您可以同时安装多个软件包。例如，下面的命令将同时安装所有三个软件包。</p><pre class="line-numbers language-none"><code class="language-none">conda install numpy scipy pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过添加版本号（例如）来指定所需的软件包版本<code>conda install numpy=1.10</code>。</p><p>Conda还会自动为您安装依赖项。例如<code>scipy</code>使用和要求<code>numpy</code>。如果仅安装<code>scipy</code>（<code>conda install scipy</code>），<code>numpy</code>则尚未安装的Conda也将安装。</p><pre class="line-numbers language-none"><code class="language-none">conda remove PACKAGE_NAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">conda update package_nameconda update --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果您不知道要查找的软件包的确切名称，可以尝试使用进行搜索<code>conda search *SEARCH_TERM*</code>。例如，我知道我想安装<a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>，但是我不确定确切的软件包名称。因此，我尝试<code>conda search *beautifulsoup*</code>。请注意，<code>*</code>在运行conda命令之前，您的shell可能会扩展通配符。要解决此问题，请将搜索字符串用单引号或双引号引起来，例如<code>conda search &#39;*beautifulsoup*&#39;</code>。</p><p>请参阅《<a href="https://conda.io/projects/conda/en/latest/commands.html">Conda命令参考指南》</a>以了解有关conda命令的更多信息</p><h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><pre class="line-numbers language-none"><code class="language-none">conda create -n env_name [python&#x3D;X.X] [LIST_OF_PACKAGES]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处<code>-n env_name</code>设置环境<code>-n</code>名称（用于名称），并且<code>LIST_OF_PACKAGES</code>是要在环境中安装的软件包的列表。如果要安装要安装的特定版本的Python，例如3.7，请使用<code>python=3.7</code>。例如，要创建一个以<code>my_env</code>Python 3.7命名的环境，并在其中安装NumPy和Keras，请使用以下命令。</p><pre class="line-numbers language-none"><code class="language-none">conda create -n my_env python&#x3D;3.7 numpy Keras<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>激活</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">activate my_envdeactivate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>保存和加载环境</strong></p><p>一个真正有用的功能是共享环境，以便其他人可以使用正确的版本安装代码中使用的所有软件包。让我们使用以下命令查看所有软件包名称，包括当前环境中存在的Python版本：</p><pre class="line-numbers language-none"><code class="language-none">conda env export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/conda-env-export.png" alt="img"></p><p>导出环境打印到终端</p><p>在上图中，您可以看到环境的名称，并且列出了所有依赖项（<em>以及版本</em>）。您可以将上述所有信息保存到<a href="http://www.yaml.org/">YAML</a>文件中<code>environment.yaml</code>，然后再通过GitHub或其他方式与其他用户共享此文件。该文件将在当前目录中创建（或覆盖）。</p><pre class="line-numbers language-none"><code class="language-none">conda env export &gt; environment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的export命令的第二部分，<code>&gt; environment.yaml</code>将导出的文本写入<code>environment.yaml</code>。现在可以使用Github存储库（或任何其他方式）共享此文件，其他人将能够创建与项目所用的环境相同的环境。</p><hr><p>对于不使用conda的用户，您可能希望共享当前环境中安装的软件包列表。您可以使用以下<code>pip</code>命令生成此类列表作为<code>requirements.txt</code>文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip freeze <span class="token operator">></span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>稍后，您可以<code>requirements.txt</code>通过Github与其他用户共享此文件。用户（或您自己）切换到另一个环境后，可以使用以下命令安装<code>requirements.txt</code>文件中提到的所有软件包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以<a href="https://pip.pypa.io/en/stable/reference/pip_freeze/">在此处了解更多</a>有关使用<code>pip</code>而不是的信息<code>conda</code>。这将使人们更容易为您的代码安装所有依赖项</p><p><strong>创建环境</strong></p><p>要从环境文件创建环境，请使用以下命令：</p><pre class="line-numbers language-none"><code class="language-none">conda env create -f environment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将创建一个新环境，其名称与中列出的相同<code>environment.yaml</code>。</p><pre class="line-numbers language-none"><code class="language-none">conda env list &#x2F;&#x2F;检查现有的环境<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有不再使用的环境，请使用下面的命令删除指定的环境（此处名为<code>env_name</code>）。</p><pre class="line-numbers language-none"><code class="language-none">conda env remove -n env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>要了解有关conda及其在Python生态系统中的适用性的更多信息，请查看Jake Vanderplas的这篇文章：<a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/">Conda的神话和误解</a>。</li><li>这是<a href="https://docs.conda.io/projects/conda/en/latest/glossary.html">conda词汇表文档，</a>供您参考。</li></ul><h1 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h1><p>一直想学来着，这个课程也太好了吧！</p><p>jupyter notebook是一个Web应用程序，可让您将说明性文本，数学方程式，代码和可视化结合在一个易于共享的文档中。</p><p>非常适合数据处理，可以执行部分代码，并查看上下文信息等</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Notebooks are a form of <a href="http://www.literateprogramming.com/">literate programming</a> proposed by Donald Knuth in 1984. With literate programming, the documentation is written as a narrative alongside the code instead of sitting off by its own. In Donald Knuth’s words,</p><blockquote><p>Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.</p></blockquote><p>After all, code is written for humans, not for computers. Notebooks provide exactly this capability. You are able to write documentation as narrative text, along with code. This is not only useful for the people reading your notebooks, but for your future self coming back to the analysis.</p><p>Just a small aside: recently, this idea of literate programming has been extended to a whole programming language, <a href="http://www.witheve.com/">Eve</a>.</p><p>Jupyter笔记本源自Fernando Perez发起的<a href="https://ipython.org/">IPython项目</a>。IPython是一个交互式shell，类似于普通的Python shell，但具有诸如语法突出显示和代码完成之类的强大功能。最初，笔记本通过将消息从Web应用程序（您在浏览器中看到的笔记本）发送到IPython内核（在后台运行的IPython应用程序）来工作。内核执行了代码，然后将其发送回笔记本。当前的架构与此类似，如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/notebook-components.png" alt="img"></p><p>中心点是笔记本服务器。您通过浏览器连接到服务器，并且笔记本呈现为Web应用程序。您在Web应用程序中编写的代码通过服务器发送到内核。内核运行代码并将其发送回服务器，然后所有输出将在浏览器中呈现。保存笔记本时，它将作为带有<code>.ipynb</code>文件扩展名的JSON文件写入服务器。</p><p>该体系结构的很大一部分是内核不需要运行Python。由于笔记本和内核是分开的，因此可以在它们之间发送任何语言的代码。例如，两个较早的非Python内核分别用于<a href="https://www.r-project.org/">R</a>和<a href="http://julialang.org/">Julia</a>语言。对于R内核，用R编写的代码将被发送到R内核并在其中执行，这与在Python内核上运行的Python代码完全相同。IPython笔记本被重命名，因为笔记本变得与语言无关。新名称<strong>Jupyter</strong>来自<strong>Ju</strong> lia，<strong>Pyt</strong> hon和<strong>R的组合</strong>。如果您有兴趣，这里<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">是可用内核</a>的<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">列表</a>。</p><p>另一个好处是服务器可以在任何地方运行并可以通过Internet访问。通常，您将在存储所有数据和笔记本文件的自己的计算机上运行服务器。但是，您也可以在远程计算机或云实例（例如Amazon的EC2）上<a href="http://jupyter-notebook.readthedocs.io/en/latest/public_server.html">设置服务器</a>。然后，您可以从世界任何地方在浏览器中访问笔记本。</p><p>可以同时启动多个笔记本服务器，这会在8888默认端口后继续创建</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>您应该考虑安装Notebook Conda软件包以帮助管理您的环境。运行以下终端命令：</p><pre class="line-numbers language-none"><code class="language-none">conda install nb_conda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功安装<code>nb_conda</code>软件包后，如果您在conda环境中运行笔记本服务器，则还可以访问下面显示的“ Conda”选项卡。在这里，您可以从Jupyter内部管理您的环境。您可以创建新环境，安装软件包，更新软件包，导出环境等等。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410125054498.png" alt="image-20210410125054498"></p><p>此外，<code>nb_conda</code>安装后，选择内核时，您将可以访问任何conda环境。例如，下图显示了在具有几种不同conda环境的计算机上创建新笔记本的示例：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410125313617.png" alt="image-20210410125313617"></p><p>关闭前记得保存</p><p>您可以通过标记服务器主页上笔记本旁边的复选框并单击“关闭”来关闭各个笔记本。不过，在执行此操作之前，请确保已保存您的工作！自上次保存以来所做的任何更改都将丢失。您还需要在下次运行笔记本时重新运行代码。</p><p>您可以通过在终端中按两次Control + C来关闭整个服务器。同样，这将立即关闭所有正在运行的笔记本，因此请确保您的工作已保存！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/server-shutdown.png" alt="img"></p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>先新建（选择一个内核）来创建一个notebook</p><p>上面的命令将在名为的新浏览器选项卡中创建一个新笔记本<code>Untitled.ipynb</code></p><p><strong>工具栏</strong></p><p>简单明了，真不戳</p><p>小键盘是命令面板。这将显示一个带有搜索栏的面板，您可以在其中搜索各种命令。这对于加速工作流程非常有帮助，因为您无需使用鼠标在菜单中四处搜索。只需打开命令面板，然后输入您要执行的操作即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410130030588.png" alt="image-20210410130030588"></p><p>选项栏</p><p>右边是内核类型（在我的情况下为Python 3），旁边是一个小圆圈。当内核运行单元时，它将填充。对于大多数快速运行的操作，它不会填充。这是一个小指示器，可以让您知道更长运行的代码实际上正在运行。</p><p>连同工具栏中的“保存”按钮一起，笔记本会定期自动保存。标题右侧会显示最近保存的内容。您可以保存按钮，或者按与手动保存<code>escape</code>，然后<code>s</code>在键盘上。该<code>escape</code>键将更改为命令模式，并且<code>s</code>是“保存”的快捷方式。稍后将介绍命令模式和键盘快捷键。</p><p><strong>存储</strong></p><p>在“文件”菜单中，您可以下载多种格式的笔记本。您通常会希望将其下载为HTML文件，以便与不使用Jupyter的其他人共享。另外，您可以将笔记本作为普通的Python文件下载，所有代码都将正常运行。 The <a href="https://daringfireball.net/projects/markdown/">Markdown</a> and <a href="http://docutils.sourceforge.net/rst.html">reST</a> formats are great for using notebooks in blogs or documentation.</p><p><strong>导入本地</strong></p><p>File -&gt; open 选择合适的<code>.ipynb</code>文件</p><p>或者直接upload，然后在文件导航里面查找你需要的文件</p><p>这里有一个markdown的<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">备忘单</a></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>又得学新的快捷键卧槽</p><p>首先，在编辑模式和命令模式之间切换。 编辑模式允许您键入单元格，而命令模式将使用按键来执行命令，例如创建新单元格和打开命令面板。 当您选择一个单元格时，您可以通过该单元格周围的框的颜色来判断当前正在使用哪种模式。 在编辑模式下，方框和左粗框显示为绿色。 在命令模式下，它们显示为蓝色。 同样在编辑模式下，您应该在单元格本身中看到一个光标。</p><p>默认情况下，当您创建一个新的单元格或移动到下一个单元格时，您将处于命令模式。 要进入编辑模式，请按<strong>Enter</strong> / Return。 要从编辑模式返回到命令模式，请按<strong>Escape键</strong>。</p><p>练习：单击此单元格，然后按<strong>Enter + Shift进入下一个单元格</strong>。 在编辑和命令模式之间切换几次。</p><p>在命令模式按下H可以打开帮助菜单<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410131817701.png" alt="image-20210410131817701"></p><hr><p><strong>常用的快捷键</strong></p><p>A 创建新单元格above当前单元格</p><p>B 创建新单元格below当前单元格</p><p>在markdown 和 code之间进行转换</p><p>markdown -&gt; code Y</p><p>code -&gt; markdown M </p><p>L 是显示行号d</p><p>双击D 可以删除单元格，Z撤销删除</p><p>S 保存！</p><p>最强的是C + S + P</p><p>打开万能的控制栏</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410132647354.png" alt="image-20210410132647354"></p><h2 id="魔术关键字"><a href="#魔术关键字" class="headerlink" title="*魔术关键字"></a>*魔术关键字</h2><p>Magic Keywords</p><p>魔术关键字是特殊命令，您可以在单元格中运行这些命令，以使您可以控制笔记本电脑本身或执行系统调用（例如更改目录）。例如，您可以使用设置matplotlib以在笔记本中进行交互工作<code>%matplotlib</code>。</p><p>魔术命令前面分别带有针对行魔术和单元魔术的一个或两个百分号（<code>%</code>或<code>%%</code>）。线魔术仅适用于在其上写入了魔术命令的行，而单元格魔术适用于整个单元。</p><p><strong>注意：</strong>这些魔术关键字特定于普通的Python内核。如果您使用的是其他内核，那么这些内核很可能无法正常工作。</p><p>如果您想计时整个单元需要多长时间，可以这样使用<code>%%timeit</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/magic-timeit2.png" alt="img"></p><p>以后学学。。。</p><p>在笔记本中嵌入可视化</p><p>如前所述，笔记本使您可以将图像以及文本和代码嵌入其中。当您使用<code>matplotlib</code>或其他绘图程序包创建可视化效果时，此功能最为有用。您可以使用<code>%matplotlib</code>设置<code>matplotlib</code>为在笔记本中进行交互使用。默认情况下，图形将在其自己的窗口中呈现。但是，您可以将参数传递给命令以选择特定的<a href="http://matplotlib.org/faq/usage_faq.html#what-is-a-backend">“后端”</a>，即渲染图像的软件。要直接在笔记本中绘制图形，您应该在命令中使用嵌入式后端<code>%matplotlib inline</code>。</p><blockquote><p><strong>提示：</strong>在高分辨率屏幕（例如Retina显示屏）上，笔记本计算机中的默认图像可能看起来模糊。使用<code>%config InlineBackend.figure_format = &#39;retina&#39;</code>after<code>%matplotlib inline</code>渲染更高分辨率的图像。</p></blockquote><p><img src="https://video.udacity-data.com/topher/2016/November/5833867f_magic-matplotlib/magic-matplotlib.png" alt="img"></p><p>在笔记本中调试</p><p>使用Python内核，您可以使用magic命令打开交互式调试器<code>%pdb</code>。导致错误时，您将能够检查当前名称空间中的变量。</p><p><img src="https://video.udacity-data.com/topher/2016/November/58337eac_magic-pdb/magic-pdb.png" alt="img"></p><p>在笔记本中调试</p><p>在上面可以看到我试图总结一个给出错误的字符串。调试器会引发错误，并提示您检查代码。</p><p><code>pdb</code>在<a href="https://docs.python.org/3/library/pdb.html">文档中</a>了解更多信息。要退出调试器，只需<code>q</code>在提示中输入即可。</p><p>更多阅读</p><p>还有很多其他魔术命令，我只涉及了一些您最常使用的命令。要了解有关它们的更多信息，<a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">这</a>是所有可用的魔术命令<a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">的列表</a>。</p><h2 id="转换笔记本"><a href="#转换笔记本" class="headerlink" title="转换笔记本"></a>转换笔记本</h2><p>Notebooks are just big <a href="http://www.json.org/">JSON</a> files with the extension <code>.ipynb</code>.</p><p>由于笔记本是JSON，因此很容易将它们转换为其他格式。Jupyter附带有一个实用程序，<code>nbconvert</code>用于将其转换为HTML，Markdown，幻灯片等。将给定<code>mynotebook.ipynb</code>文件转换为另一个FORMAT的一般语法为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert --to FORMAT mynotebook.ipynb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前支持的输出<code>FORMAT</code>可以是以下任意一种（忽略大小写）：</p><ol><li>HTML,</li><li>LaTeX,</li><li>PDF,</li><li>WebPDF,</li><li>Reveal.js HTML slideshow,</li><li>Markdown,</li><li>Ascii,</li><li>reStructuredText,</li><li>executable script,</li><li>notebook.</li></ol><p>For example, to convert a notebook to an HTML file, in your terminal use</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Install the package below, if not already</span>pip <span class="token function">install</span> nbconvertjupyter nbconvert --to html mynotebook.ipynb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>-如果您希望在conda中安装Anaconda发行版中<strong>没有的</strong>任何软件包（例如Airbase软件包），请使用<code>pip install airbase</code>，而不是<code>conda install airbase</code>。</p></blockquote><p><strong>转换为HTML可以与不使用笔记本的其他人共享您的笔记本。Markdown非常适合在博客和其他接受Markdown格式的文本编辑器中添加笔记本。</strong></p><p>与往常一样，从<a href="https://nbconvert.readthedocs.io/en/latest/usage.html">文档中</a>了解更多<code>nbconvert</code>信息。</p><h2 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h2><p>幻灯片是像普通笔记本一样在笔记本中创建的，但是您需要指定哪些单元格是幻灯片以及该单元格将是幻灯片的类型。在菜单栏中，单击“视图”&gt;“单元格工具栏”&gt;“幻灯片放映”以在每个单元格上弹出幻灯片单元格菜单。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/slides-cell-toolbar-menu.png" alt="img"></p><p>打开单元格的幻灯片工具栏</p><p>这将在每个单元格上显示一个菜单下拉菜单，使您可以选择该单元格在幻灯片中的显示方式。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/slides-choose-slide-type.png" alt="img"></p><p><strong>Slides</strong> are full slides that you move through left to right. <strong>Sub-slides</strong> show up in the slideshow by pressing up or down. <strong>Fragments</strong> are hidden at first, then appear with a button press. You can skip cells in the slideshow with <strong>Skip</strong> and <strong>Notes</strong> leaves the cell as speaker notes.</p><p>运行幻灯片</p><p>要从笔记本文件创建幻灯片，您需要使用<code>nbconvert</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert notebook.ipynb --to slides<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这只是将笔记本转换为幻灯片所需的文件，但是您需要将其与HTTP服务器一起使用才能实际查看演示文稿。</p><p>要转换并立即看到它，请使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert notebook.ipynb --to slides --post serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在您的浏览器中打开幻灯片放映，以便您进行演示。</p><h1 id="蓝桥杯半天冲刺"><a href="#蓝桥杯半天冲刺" class="headerlink" title="蓝桥杯半天冲刺"></a>蓝桥杯半天冲刺</h1><p>列表a: a.append()尾部添加   a.insert(0,1) 索引0处添加元素1      <strong>a.count(s) 返回列表中s的数量</strong></p><p>a.remove(234)  移除234这个元素    a.reverse()    b = [45, 56, 90]    <strong>a.extend(b) 添加 b 的元素而不是 b 本身</strong> </p><p>a.sort()  前提是列表的元素可较   del a[index]     a.pop(index)弹出index的，不传参就是末尾的</p><p>列表推导式</p><p>squares = list(map(lambda x: x**2, ran比ge(10)))</p><p>squares = [x**2 for x in range(10)]</p><p>两者等价</p><p>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] </p><p>——[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</p><p>可以嵌套</p><p>a=[1,2,3] </p><p>z = [x + 1 for x in [x ** 2 for x in a]]</p><p> z [2, 5, 10]</p><p>元组</p><p>元组是不可变类型，这意味着你不能在元组内删除或添加或编辑任何值。</p><p>要创建只含有一个元素的元组，在值后面跟一个逗号。</p><p><strong>divmod(15,2）      (7, 1)</strong></p><p>集合</p><p>集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p><p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典</p><p> basket = {‘apple’, ‘orange’, ‘apple’, ‘pear’, ‘orange’, ‘banana’}</p><p>&gt;&gt;&gt; print(basket)   # 你可以看到重复的元素被去除 {‘orange’, ‘banana’, ‘pear’, ‘apple’}</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210415162713775.png" alt="image-20210415162713775"></p><p> a.add(‘c’)   输入元素   a.pop()不传参数就是随机</p><p>字典</p><p>del  data[‘key’] 删除键值对    in  查询键是否在字典中&gt;&gt;&gt; ‘ShiYanLou’ in data  —— False</p><p><code>dict()</code> 可以从<strong>包含键值对的元组</strong>中创建字典。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'Indian'</span><span class="token punctuation">,</span><span class="token string">'Delhi'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Bangladesh'</span><span class="token punctuation">,</span><span class="token string">'Dhaka'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token string">'Indian'</span><span class="token punctuation">:</span> <span class="token string">'Delhi'</span><span class="token punctuation">,</span> <span class="token string">'Bangladesh'</span><span class="token punctuation">:</span> <span class="token string">'Dhaka'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你想要遍历一个字典，使用字典的 <code>items()</code> 方法。</p><p>&gt;&gt;&gt; for x, y in data.items():</p><p>​        print(“{} uses {}”.format(x, y))</p><p>试图索引一个不存在的键将会抛出一个 <em>keyError</em> 错误。我们可以使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p><p>&gt;&gt;&gt; data.get(‘foo’, 0)          ——0</p><p>如果你想要在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code>。</p><p>&gt;&gt;&gt; for i, j in enumerate([‘a’, ‘b’, ‘c’]): …     print(i, j)</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>如果你想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 。</p><p>title返回标题  swapcase()翻转大小写  upper  lower</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"shi yan lou"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'Shi Yan Lou'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> num<span class="token operator">=</span>string<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Python <strong>split()</strong> 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</p><p>默认num为-1，分割所有</p><p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字,空格都不行</p><p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 检查字符串是否所有字符为数字</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"ShiYanLou is coming"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 检查字符串是否所有字符为小写</span><span class="token boolean">False</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"Shiyanlou Is Coming"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># To 检查字符串是否为标题样式</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"CHINA"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 检查字符串是否所有字符为大写</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法 <code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"-"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"GNU/Linux is great"</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">'GNU/Linux-is-great'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上面的例子中，我们基于空格 <code>&quot; &quot;</code> 分割字符串 <code>&quot;GNU/Linux is great&quot;</code>，然后用 <code>&quot;-&quot;</code> 连接它们。</p><p>字符串有几个进行剥离操作的方法。最简单的一个是 <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符，代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"  a bc\n "</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'a bc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <code>lstrip(chars)</code> 或 <code>rstrip(chars)</code> </p><p>字符串有一些方法能够帮助你搜索字符串里的文本或子字符串。下面给出示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"faulty for a reason"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"for"</span><span class="token punctuation">)</span><span class="token number">7</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"fora"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"fa"</span><span class="token punctuation">)</span> <span class="token comment"># 检查字符串是否以 fa 开头</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">"reason"</span><span class="token punctuation">)</span> <span class="token comment"># 检查字符串是否以 reason 结尾</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1。</p><p><strong>z = s[::-1]  #把输入的字符串s 进行倒序处理形成新的字符串z</strong></p><p>列表也支持连接这样的操作，它返回一个新的列表：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">342</span><span class="token punctuation">,</span> <span class="token number">223</span><span class="token punctuation">,</span> <span class="token string">'India'</span><span class="token punctuation">,</span> <span class="token string">'Fedora'</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment"># 替换某些值</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment"># 现在移除他们</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment"># 通过替换所有元素为空列表来清空这个列表</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的同学可能发问了，前面不是说过切片操作不改变列表么？严格来说，这里并不算真正的切片操作，只是上面代码中赋值运算符左边的这种操作与切片操作形式一样而已。</p><p>(len(s.split(“ “))) 单词计数</p><p>ls = [“1”,”2”,”3”]</p><p>我们怎么样把这个列表变成一个字符串 “123”呢？</p><p>“”.join(ls)</p><p>s.replace(“c”,”d”) 把所有的c换成d    ，字符串是不可变的！</p><p>ls2 = list(map(int,ls))</p><p>假如ls1 = [“1”,”2”,”3”]</p><p>那么ls2 = [1,2,3]</p><p><strong>chr()</strong></p><p>把整数转化为字符。chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。</p><p><strong>ord()</strong></p><p>把字符转化成整型 。ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">str.decode(encoding&#x3D;&#39;UTF-8&#39;,errors&#x3D;&#39;strict&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">str.encode(encoding&#x3D;&#39;UTF-8&#39;,errors&#x3D;&#39;strict&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>encode() 和 decode() 以encoding的方式编码和解码字符串</p><p><strong>把x保留到小数点后要求的位数，比如3：</strong></p><p><strong>①round(x,3)</strong></p><p><strong>②print(‘%.3f’%x)</strong></p><p><strong>③print(“{:.3f}”.format(x))</strong></p><p><strong>sorted（）</strong></p><p>对所有可迭代的对象进行排序操作。</p><blockquote><p><em><strong>sort 与 sorted 区别：</strong></em><br><em>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</em><br><em>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</em></p></blockquote><p><strong>输入：</strong></p><blockquote><p>蓝桥杯输入单个数我一般不用eval函数（速度比较慢）</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 整型输入</span>n <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 浮点输入</span>k <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 输入三个数，例如：1 2 3</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 输入一串数字，例如：1 2 3 4 5</span>s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出：</strong></p><blockquote><p>输出我还是觉得格式化符号比较舒服一点，习惯format输出的也可以</p></blockquote><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3"># 隔空输出a &#x3D; [1,2,3,4]print(&#39; &#39;.join(map(str,a)))   #1 2 3 4# 四舍五入a &#x3D; 3.1415926print(int(a + 0.5))# 保留两位a &#x3D; 3.1415926print(&quot;%.2f&quot;%a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-不要被大学课本数据结构带走"><a href="#6-1-不要被大学课本数据结构带走" class="headerlink" title="6.1 不要被大学课本数据结构带走"></a>6.1 不要被大学课本数据结构带走</h3><p>算法比赛不是计算机专业考试，你不需要对数据与结构的实现有太多刻板印象。数据与结构在算法比赛中实现起来往往不需要课本上的那么繁琐，一些指针(python不用愁)以及结构的链接大部分都可以用链表代替，找到最简洁易懂的代码形式就行。</p><h3 id="6-2-有些题不要死磕"><a href="#6-2-有些题不要死磕" class="headerlink" title="6.2 有些题不要死磕"></a>6.2 有些题不要死磕</h3><p>在oj上经常能遇到一些奇怪的题目，它们的解题方法几乎仅适用它们本身。如果已经充分对其进行思考并且尝试暴力无果的情况下，建议不要对其死磕（有信仰的人除外）。</p><h3 id="6-3-少照抄代码"><a href="#6-3-少照抄代码" class="headerlink" title="6.3 少照抄代码"></a>6.3 少照抄代码</h3><p>代码照抄一时爽，键盘到手写不出来就很尴尬。建议第一遍写可以抄，第二编写建议边写边看，第三遍建议一步到位。</p><p>如果实在不行，经典的代码模板可以背。</p><h3 id="6-4-不要生搬硬套c"><a href="#6-4-不要生搬硬套c" class="headerlink" title="6.4 不要生搬硬套c++"></a>6.4 不要生搬硬套c++</h3><p>python和cpp虽然都是编程语言，但是实现起来还是有不少区别的。所以在学习算法的时候不要完全把cpp翻译成python，试着想用python的一些语法能不能更方便更省空间速度更快。除此以外，如果有现成的标准库或者函数能够实现当前功能(时复不变情况下)，尽量去用，这些内置函数运行的时候一般都比手打的代码来的快。</p><h2 id="大佬博客"><a href="#大佬博客" class="headerlink" title="大佬博客"></a>大佬博客</h2><p><a href="https://www.liboer.top/articles/detail/python-lanqiaobei/">https://www.liboer.top/articles/detail/python-lanqiaobei/</a></p><p><a href="https://www.cnblogs.com/baxianhua/p/9896926.html">Python的进制转换函数</a></p><p>fomat(x,’X’)表示用大写的十六进制数</p><p><a href="https://www.runoob.com/python/python-func-int.html">Python的int()函数</a><br><a href="https://www.cnblogs.com/cheneyboon/p/11609376.html">python 如何实现对字符和ASCII码的转换</a></p><p>多用end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;廖雪峰&quot;&gt;&lt;a href=&quot;#廖雪峰&quot; class=&quot;headerlink&quot; title=&quot;廖雪峰&quot;&gt;&lt;/a&gt;廖雪峰&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://example.com/2021/03/06/git/"/>
    <id>http://example.com/2021/03/06/git/</id>
    <published>2021-03-06T12:33:45.000Z</published>
    <updated>2021-04-06T08:39:29.231Z</updated>
    
    <content type="html"><![CDATA[<p>git init</p><p>git status</p><p>git add file</p><p>git commit -m “”</p><p>git log –oneline</p><p>git reflog</p><p>git reset –hard HEAD^(版本号)</p><p>HEAD^^  HEAD~100</p><p>git diff HEAD – file</p><p>查看工作区和版本库不同</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>checkout  -&gt; restore</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage）</p><p> `git reset HEAD -&gt; git restore –staged</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><p>远程</p><p>git remote -v</p><p>git remote remove origin</p><p>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;</a>:git_username/repository_name.git</p><p>git pull origin master –allow-unrelated-histories</p><pre class="line-numbers language-none"><code class="language-none">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>git push origin master</p><p>git push -u origin main -f 强制push！！</p><p>git clone url</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;创建 &lt;name&gt; 的分支并切换git switch -c &lt;name&gt;&#x2F;&#x2F;创建git branch &lt;name&gt;&#x2F;&#x2F;切换到&lt;name&gt;分支git checkout &lt;name&gt;git switch &lt;name&gt;&#x2F;&#x2F;查看分支树git branch &#x2F;&#x2F;删除分支git branch -d &lt;name&gt;&#x2F;&#x2F;合并分支 假设这里存在 master ， dev 分支  &#x2F;&#x2F; 1 切换到要保留的分支——这里是master  git checkout master  &#x2F;&#x2F; 2 合并掉分支dev  git merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log --graph</code>命令可以看到分支合并图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;git init&lt;/p&gt;
&lt;p&gt;git status&lt;/p&gt;
&lt;p&gt;git add file&lt;/p&gt;
&lt;p&gt;git commit -m “”&lt;/p&gt;
&lt;p&gt;git log –oneline&lt;/p&gt;
&lt;p&gt;git reflog&lt;/p&gt;
&lt;p&gt;git reset –hard H</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
</feed>
