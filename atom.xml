<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darren Blog</title>
  
  <subtitle>Stratch to WWW</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-14T12:58:12.744Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Darren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/2021/03/14/Linux/"/>
    <id>http://example.com/2021/03/14/Linux/</id>
    <published>2021-03-14T12:57:21.000Z</published>
    <updated>2021-03-14T12:58:12.744Z</updated>
    
    
    <summary type="html">An important skill</summary>
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="cisco" scheme="http://example.com/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>introduction-to-Networks</title>
    <link href="http://example.com/2021/03/14/introduction-to-Networks/"/>
    <id>http://example.com/2021/03/14/introduction-to-Networks/</id>
    <published>2021-03-14T08:10:41.000Z</published>
    <updated>2021-03-14T16:22:29.809Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>警告：Cisco课程，不可用于商用</p><p>因为我发现学这个课老是断断续续的，每次捡起来超级麻烦，所以趁这次来个大复习，把一些该有的知识点直接记下来好了</p><h1 id="1-当今网络"><a href="#1-当今网络" class="headerlink" title="1. 当今网络"></a>1. 当今网络</h1><h2 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h2><p>网络有很多组件:</p><p>终端设备，中间设备，网络介质巴拉巴拉</p><p>常见表示方法：</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314161643916.png" alt="image-20210314161643916"></p><p>除了这些表示之外，还使用专门的术语来描述这些设备和介质是如何相互连接的:</p><ul><li><strong>网络接口卡 (NIC)</strong> - 将设备物理连接到网络。</li><li><strong>物理端口</strong> - 网络设备上的接口或插口，介质通过它连接到终端设备或其他网络设备。</li><li><strong>接口</strong> - 网络设备上连接到独立网络的专用端口。由于路由器连接了不同的网络，路由器上的端口称为网络接口。</li></ul><p>还有物理拓扑图和逻辑拓扑图</p><p>几个类型：</p><p>内部网，外联网，Intranets and Extranets</p><p>LAN WAN</p><h2 id="常用连接技术"><a href="#常用连接技术" class="headerlink" title="常用连接技术"></a>常用连接技术</h2><p>家庭和小型办公室</p><ul><li><strong>有线电视</strong> （<strong>Cable</strong>）- 通常由有线电视服务提供商提供，互联网数据信号在输送有线电视信号的同一电缆上进行传输。它提供了高带宽、高可用性和始终在线的互联网连接。</li><li><strong>DSL</strong> - 数字用户线也可提供高带宽、高可用性和始终在线的互联网连接。DSL 通过电话线路运行。通常小型办公室和家庭办公室用户会选择使用非对称 DSL (ADSL)，这种方式的特点是下载速度高于上传速度。</li><li><strong>蜂窝网</strong>（<strong>Cellular</strong>） - 蜂窝网互联网接入使用手机网络进行连接。只要您能收到蜂窝网信号，就能获得蜂窝网互联网接入。性能会受手机功能和手机基站的限制。</li><li><strong>卫星</strong>（<strong>Satellite</strong>） - 对于根本没有互联网连接的地方来说，获得卫星互联网访问非常有用。卫星天线要求有到卫星的清晰视线。</li><li><strong>拨号电话</strong>（<strong>Dial-up Telephone</strong>） - 使用电话线和调制解调器，费用相对较低。拨号调制解调器连接提供的低带宽不足以用于大型数据传输，但对旅行过程中的移动访问非常有用。</li></ul><p>企业</p><ul><li><strong>专用租用线路</strong>（<strong>Dedicated Leased Line</strong> ） - 租用线路是服务提供商网络内连接地理位置分散的办公室的保留电路，提供个人语音和/或数据网络。电路按月或按年租用。</li><li><strong>城域以太网</strong>（<strong>Metro Ethernet</strong>） -有时被称为以太网 WAN. 在本模块中，我们把它称为城域以太网。城域以太网将 LAN 访问技术扩展到 WAN 中。以太网是一种 LAN 技术，您将在后面的模块中学习。</li><li><strong>DSL</strong>（<strong>Business DSL</strong>） - 企业 DSL 提供各种格式。一种常见的选择是对称数字用户线路 (SDSL)，它类似于 DSL 的普通用户版本，但是提供相同的上传和下载速度。</li><li><strong>卫星</strong> – 当有线解决方案不可用时，卫星服务可以提供连接。</li></ul><p>今天，独立的数据、电话和视频网络融合在了一起。与专用网络不同，融合网络能够通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频。此网络基础设施采用一组相同的规则、协议和实施标准。融合数据网络在一个网络中传送多种服务。</p><h2 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h2><p>容错能力-提供冗余的多条路径</p><p>可拓展性-设计人员可以遵循广为接受的标准和协议</p><p>服务质量 (QoS)-通过各种协议和优先级</p><p>网络安全-设备安全，网络安全：</p><ul><li><p><strong>机密性</strong> - 数据机密性意味着只有预定和授权收件人可以访问并读取数据。</p></li><li><p><strong>完整性</strong> - 数据完整性表示保证信息在从源到目的地的传输过程中不会被更改。</p></li><li><p><strong>可用性</strong> - 数据可用性表示保证授权用户及时可靠地访问数据服务。</p></li><li><p><strong>病毒、蠕虫和特洛伊木马</strong> <strong>Viruses, worms, and Trojan horses</strong>- 这些包括在用户设备上运行的恶意软件或代码。</p></li><li><p><strong>间谍软件和广告软件</strong> <strong>Spyware and adware</strong>-这些是安装在用户设备上的软件类型。这些软件会秘密收集有关用户的信息。</p></li><li><p><strong>零日攻击（也称零小时攻击）****Zero-day attacks</strong> - 在出现漏洞的第一天发起的攻击。</p></li><li><p><strong>威胁发起者攻击</strong> <strong>Threat actor attacks</strong>-恶意人员攻击用户设备或网络资源。</p></li><li><p><strong>拒绝服务攻击</strong> <strong>Denial of service attacks</strong>- 使网络设备上的应用和进程减缓或崩溃的攻击。</p></li><li><p><strong>数据拦截和盗窃****Data interception and theft</strong> - 通过公司网络捕获私人信息的攻击。</p></li><li><p><strong>身份盗窃****Identity theft</strong> - 窃取用户的登录凭证来访问私人数据的攻击。</p></li></ul><h2 id="一些趋势"><a href="#一些趋势" class="headerlink" title="一些趋势"></a>一些趋势</h2><p>BYOD 意味着设备由任何使用者在任意地点使用。</p><p>云计算</p><p>智能家庭技术（物联网）</p><p>电力网：</p><p>使用标准电源适配器，只要有电源插座，设备就可以连接到 LAN。无需安装数据线，也几乎不需要额外的电力。通过使用供电的同一线路，电力线网络通过按一定频率发送数据来发送信息。</p><p>当无线接入点无法到达家里的所有设备时，电力线网络特别有用。电力线网络不会取代数据网络中的专用布线。但是，当有线数据网络或无线通信不可行时，电力线网络可以备用。</p><p>无线互联网服务提供商 (WISP) 是使用类似家庭无线局域网 (WLAN) 的无线技术</p><h1 id="2-配置交换机-终端"><a href="#2-配置交换机-终端" class="headerlink" title="2. 配置交换机/终端"></a>2. 配置交换机/终端</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163007230.png" alt="image-20210314163007230"></p><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>默认情况下，交换机将转发流量，无需配置即可工作。例如，连接到同一新交换机的两个已配置了的主机能够进行通信。</p><p>无论新交换机的默认特性如何，都应配置并保护所有交换机。</p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>控制台 (Console)</strong></td><td align="left">这是一种物理管理端口，可通过该端口对思科设备进行带外访问。带外访问是指通过仅用于设备维护的专用管理通道进行访问。使用控制台端口的优势在于，即使没有配置任何网络服务，也可以访问设备，例如执行初始配置时。控制台连接需要运行终端仿真软件的计算机和用于连接设备的特殊控制台电缆。</td></tr><tr><td align="left"><strong>安全外壳(SSH)</strong></td><td align="left">SSH 是一种带内且被推荐的方法，它使用虚拟接口通过网络远程建立安全的 CLI连接。不同于控制台连接，SSH 连接需要设备上具有有效的网络服务，包括配置了地址的有效接口。大部分思科 IOS 版本配备了 SSH 服务器和 SSH 客户端，可用于与其他设备建立 SSH 会话。</td></tr><tr><td align="left"><strong>Telnet</strong></td><td align="left">Telnet 使用虚拟接口通过网络远程建立 CLI 会话，这种带内方法并不安全。与 SSH 不同，Telnet 不提供安全的加密连接，只能在实验室环境中使用。用户身份验证、密码和命令通过网络以明文形式发送。最好的做法是使用 SSH 而不是 Telnet。思科 IOS 包括 Telnet 服务器和 Telnet 客户端。</td></tr></tbody></table><p><strong>注意:</strong> 某些设备，比如路由器，还可以支持传统辅助端口，这种辅助端口可使用调制解调器通过电话连接远程建立 CLI 会话。类似于控制台连接，AUX 端口也是带外连接，且不需要配置或提供网络服务。</p><h2 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h2><p>作为一项安全功能，思科 IOS 软件将管理访问分为以下两种命令模式：</p><ul><li><strong>用户 EXEC 模式</strong>（user） - 该模式功能有限，但可用于有效执行基本操作。它只允许有限数量的基本监控命令，不允许执行任何可能改变设备配置的命令。用户 EXEC 模式由采用 &gt; 符号结尾的 CLI 提示符标识。</li><li><strong>特权 EXEC 模式</strong>（privileged） - 要执行配置命令，网络管理员必须访问特权 EXEC 模式。较高级别的配置模式，比如全局配置模式，只能通过特权 EXEC 模式访问。特权 EXEC 模式由采用# 符号结尾的提示符标识。</li></ul><p>要配置设备，用户必须进入全局配置模式。</p><p>在全局配置模式下， CLI 配置所做的更改将影响整个设备的运行。全局配置模式由在设备名称之后加(config)#结尾的提示符标识，比如Switch(config)#。</p><p>访问全局配置模式之后才能访问其他具体的配置模式。在全局配置模式下，用户可以进入不同的子配置模式。其中的每种模式可以用于配置 IOS 设备的特定部分或特定功能。两个常见的子配置模式包括：</p><ul><li><strong>线路配置模式</strong> - 用于配置控制台、SSH、Telnet 或 AUX 访问。</li><li><strong>接口配置模式</strong> - 用于配置交换机端口或路由器网络接口。</li></ul><p>当使用 CLI 时，每种模式由该模式独有的命令提示符来标识。默认情况下，每个提示符都以设备名称开头。命令提示符中设备名称后的部分用于表明模式。</p><p>例如，线路配置模式的默认提示符是 <strong>Switch(config-line)#</strong> </p><p>默认的接口配置模式提示符是 **Switch(config-if)#**。</p><ul><li><strong>startup-config(启动配置文件)</strong> -存储在 NVRAM 中的配置文件。它包含在启动时或重启时用到的所有命令。当设备断电后，其中的内容不会消失。</li><li><strong>running-config(运行配置文件)</strong> -存储在随机存取存储器（RAM）中。它反映了当前的配置。修改运行配置会立即影响思科设备的运行。RAM 是易失性存储器。如果设备断电或重新启动，则它会丢失所有内容。</li></ul><h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163957083.png" alt="image-20210314163957083"></p><table><thead><tr><th align="left"><strong>约定</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>粗体</strong></td><td align="left">粗体文本表示您需要原样输入的命令和关键字， 如显示的那样。</td></tr><tr><td align="left"><em>斜体</em></td><td align="left">斜体文本指示由您提供值的参数。</td></tr><tr><td align="left"><strong>[<strong>x</strong>]</strong></td><td align="left">方括号表示可选元素（关键字或参数）。</td></tr><tr><td align="left"><strong>{<strong>x</strong>}</strong></td><td align="left">大括号表示必需元素（关键字或参数）。</td></tr><tr><td align="left">**[**x **{**y <strong>|</strong> z <strong>}]</strong></td><td align="left">方括号中的大括号和垂直线表示 可选元素中的必填选项。空格用于清楚地描述 命令的各个部分。</td></tr></tbody></table><p>enable / disable</p><p>configure terminal / exit  (子配置—&gt;上一级)</p><p>end / Ctrl+Z (任何子配置-&gt;特权)</p><p>子配置模式间可以随意转换：</p><p><strong>line console 0</strong></p><p><strong>interface FastEthernet 0/1</strong></p><p><strong>line vty 0 15</strong></p><p>主机名字仅使用字母、数字和破折号</p><p>password ….  特定线路设置密码，如控制台</p><p>Login 启用登录，不启用就根本进不去</p><p>enable secret ….  限制特权（可能是某项命令？）</p><p><strong>service password-encryption</strong>（全局配置指令+加密所有）</p><p>show running-config /startup-config</p><p>**banner motd #<strong>当日消息</strong>#**（其实#可以换别的，向访问设备的人展示）</p><p>hostname 。。。设定主机名，</p><p>no hostname 取消</p><p>reload 清除为保存的running-config</p><p>erase start 删除启动设备，之后需重新加载设备来恢复出厂</p><p>copy 。。。</p><p>ipconfig （/all）</p><p>arp -a（这俩是主机终端的）</p><p>ip address a b 设置ipv4地址和子网掩码</p><p>no shutdown 启用虚拟接口（shutdown关闭）</p><p>ping … 测试链接，一般要两遍</p><p>show ip interface brief 检验接口的正确数量和标识</p><p>no ip domain-lookup 禁用DNS解析(特权模式)</p><p>show arp 交换机显示MAC地址信息（特权）</p><p>show mac address-table 查看mac地址表（特权）</p><p>clear mac address-table dynamic 清除mac地址表(特权)</p><p><strong>mdix auto</strong>接口配置命令（懂得都懂）</p><h2 id="好多缩写"><a href="#好多缩写" class="headerlink" title="好多缩写"></a>好多缩写</h2><p>interface  = int</p><p>FastEthernet = f</p><p>running-config = run</p><p>startup-config = start</p><h2 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h2><p>？：</p><p>直接输入则显示当前模式可用</p><p>指令输入一般会显示补全可能</p><p>缺参数可以显示参数</p><p>主要Ctrl+A/E</p><p>c+s+6</p><p>c+r返回被打扰的命令行</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Tab</strong></td><td align="left">补全部分输入的命令项。</td></tr><tr><td align="left"><strong>Backspace</strong></td><td align="left">删除光标左边的字符。</td></tr><tr><td align="left"><strong>Ctrl-D</strong></td><td align="left">删除光标所在的字符。</td></tr><tr><td align="left"><strong>Ctrl-K</strong></td><td align="left">删除从光标到命令行尾的所有字符。</td></tr><tr><td align="left"><strong>Esc D</strong></td><td align="left">删除从光标到词尾的所有字符。</td></tr><tr><td align="left"><strong>Ctrl+U</strong> 或 <strong>Ctrl+X</strong></td><td align="left">删除从光标到命令行首的 所有字符。</td></tr><tr><td align="left"><strong>Ctrl-W</strong></td><td align="left">删除光标左边的单词。</td></tr><tr><td align="left"><strong>Ctrl-A</strong></td><td align="left">将光标移至行首。</td></tr><tr><td align="left"><strong>向左箭头</strong> 或 <strong>Ctrl+B</strong></td><td align="left">将光标左移一个字符。</td></tr><tr><td align="left"><strong>Esc B</strong></td><td align="left">将光标向后左移一个单词。</td></tr><tr><td align="left"><strong>Esc F</strong></td><td align="left">将光标向前右移一个单词。</td></tr><tr><td align="left"><strong>向右箭头</strong> 或 <strong>Ctrl+F</strong></td><td align="left">将光标右移一个字符。</td></tr><tr><td align="left"><strong>Ctrl-E</strong></td><td align="left">将光标移至命令行尾。</td></tr><tr><td align="left"><strong>向上箭头</strong> 或 <strong>Ctrl+P</strong></td><td align="left">调出历史记录缓冲区中的命令， 从最近输入的命令开始。</td></tr><tr><td align="left"><strong>Ctrl+R</strong> 或 <strong>Ctrl+I</strong> 或 <strong>Ctrl+L</strong></td><td align="left">收到控制台消息后重新显示系统提示符和 命令行。</td></tr></tbody></table><p><strong>注意</strong>: 虽然 <strong>Delete</strong> 键通常用于删除提示符右侧的字符，但 IOS 命令结构无法识别 Delete 键。</p><p>当命令输出产生的文本超过终端窗口中可以显示的文本时，IOS 将显示一个 <strong>“–More–”</strong> 提示。下表描述了显示此提示时可以使用的键盘输入。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>回车</strong> 键</td><td align="left">显示下一行。</td></tr><tr><td align="left"><strong>空格</strong>键</td><td align="left">显示下一屏。</td></tr><tr><td align="left">任何其他按键</td><td align="left">结束显示字符串，返回特权模式。</td></tr></tbody></table><p>此表列出了用于退出操作的命令。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl-C</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。处于设置模式下时，用于中止并返回命令 提示符。</td></tr><tr><td align="left"><strong>Ctrl-Z</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。</td></tr><tr><td align="left"><strong>Ctrl-Shift-6</strong></td><td align="left">通用中断序列用于中止 DNS lookup、traceroutes、 pings等</td></tr></tbody></table><h1 id="3-协议和模型"><a href="#3-协议和模型" class="headerlink" title="3. 协议和模型"></a>3. 协议和模型</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>常用的计算机协议包含以下要求：</p><ul><li>消息编码-将信息转换成可传输和解码的</li><li>消息格式和封装（encapsulation）-取决于消息类型和传递信道</li><li>消息大小</li><li>消息时序（timing）<ul><li><strong>流量控制（flow control）-</strong> 这是管理数据传输速率的过程。流量控制定义了可以发送多少信息以及传递信息的速率。例如，如果一个人讲话太快，对方就难以听清和理解。在网络通信中，源设备和目的设备使用网络协议来协商和管理信息流。</li><li><strong>响应超时</strong>(responce timeout) -如果一个人提问之后在合理的时间内没有得到回答，就会认为没有获得回答并作出相应的反应。此人可能会重复这个问题，也可能继续谈话。网络上的主机会使用网络协议来指定等待响应的时长，以及在响应超时的情况下执行什么操作。</li><li><strong>访问方法</strong> -这决定人们可以发送消息的时间。如果两个人同时讲话，就会发生信息冲突，两个人必须作出让步，重新开始的动画演示。同样，当设备想要在无线局域网上传输时，有必要使用 WLAN 网络接口卡 (NIC) 来确定无线介质是否可用。</li></ul></li><li>消息传输选项</li></ul><p>单播广播组播</p><p>网络协议定义了用于设备之间交换消息的通用格式和规则集。协议由软件、硬件或两者中的终端设备和中间设备实现。每个网络协议都有自己的功能、格式和通信规则。</p><p>该表列出了在一个或多个网络上通信所需的各种协议类型。</p><table><thead><tr><th align="left"><strong>协议类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>网络通信协议</strong></td><td align="left">这类协议使两个或多个设备能够在一个或多个 网络上通信。以太网技术家族涉及多种协议， 例如IP，传输控制协议（TCP）， 超文本传输协议（HTTP）等。</td></tr><tr><td align="left"><strong>网络安全协议</strong></td><td align="left">这类协议保护数据以提供身份验证、数据完整性和 数据加密。安全协议的示例包括安全外壳协议 (SSH)、安全套接字层协议 (SSL) 和传输层安全协议 (TLS)。</td></tr><tr><td align="left"><strong>路由（routing）协议</strong></td><td align="left">这类协议使路由器能够交换路由信息，比较路径 信息，然后选择到达目标网络的 最佳路径。路由协议的示例包括开放最短路径优先协议 (OSPF)和边界网关协议 (BGP)。</td></tr><tr><td align="left"><strong>服务发现协议。</strong></td><td align="left">这类协议用于设备或服务的自动检测。 服务发现协议的示例包括发现用于IP地址分配 服务的动态主机配置协议（DHCP）， 和用于执行域名到IP地址转换的 域名系统（DNS）。</td></tr></tbody></table><p>执行某种通信功能所需的一组内在相关协议称为协议簇。</p><p>要形象地表现协议簇中的协议如何互动，最佳方法之一就是将这种互动看成一个堆栈。协议栈展示了协议簇中的单个协议是如何实施的。<strong>协议显示为分层结构，每种上层服务都依赖于其余下层协议所定义的功能。协议栈的下层负责通过网络传输数据和向上层提供服务，而上层则负责处理发送的消息内容。</strong></p><p>当年多种协议簇，只剩下TCP/IP（互联网协议簇）和一点点OSI（开放系统互连协议）</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="*TCP/IP"></a>*TCP/IP</h2><p>免费 且 标准</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314171619114.png" alt="image-20210314171619114"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314173907739.png" alt="image-20210314173907739"></p><table><thead><tr><th><strong>4 - 应用层</strong></th><th>向用户提供数据，以及编码和对话控制。</th></tr></thead><tbody><tr><td><strong>3 - 传输层</strong></td><td>支持各种设备之间通过不同网络通信。</td></tr><tr><td><strong>2 - 互联网层</strong></td><td>确定通过网络的最佳路径。</td></tr><tr><td><strong>1 - 网络接入层</strong></td><td>控制组成网络的硬件设备和介质。</td></tr></tbody></table><p>OSI 5/6/7层供应用程序开发者参考</p><p>而底层通常使用OSI的1/2层</p><p>#应用层#(Applicaton Layer)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">域名系统</span><br><span class="line">DNS - 域名系统(Domain Name System)。将域名（例如 cisco.com）转换为 IP 地址。</span><br><span class="line"></span><br><span class="line">主机配置</span><br><span class="line">DHCPv4 - IPv4动态主机配置协议(Dynamic Host Configuration Protocol for IPv4)。DHCPv4 服务器在启动时动态地将 IPv4 编址信息分配给 DHCPv4 客户端，并允许在不再需要时重新使用这些地址。</span><br><span class="line">DHCPv6 - IPv6动态主机配置协议。DHCPv6类似于DHCPv4。</span><br><span class="line">SLAAC -无状态地址自动配置(Stateless Address Autoconfiguration)。一种允许设备在不使用DHCPv6服务器的情况下获得其IPv6编址信息的方法。</span><br><span class="line"></span><br><span class="line">邮件</span><br><span class="line">SMTP -简单邮件传输协议(Simple Mail Transfer Protocol)。使客户端能够将邮件发送到邮件服务器，并使服务器能够将邮件发送到其他服务器。</span><br><span class="line">POP3 -邮局协议第 3 版(Post Office Protocol version 3)。使客户端能够从邮件服务器检索电子邮件并将电子邮件下载到客户端本地邮件应用程序。</span><br><span class="line">IMAP -互联网消息访问协议(Internet Message Access Protocol)。使客户端能够访问存储在邮件服务器上的电子邮件，并在服务器上维护电子邮件。</span><br><span class="line">文件传输</span><br><span class="line"></span><br><span class="line">FTP - 文件传输协议(File Transfer Protocol)。它设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件。FTP是一种可靠、面向连接且进行确认的文件传输协议。</span><br><span class="line">SFTP - SSH文件传输协议(SSH...)。作为安全外壳 (SSH)协议的扩展，SFTP可用于建立安全的文件传输会话，在该会话中对文件传输进行加密。SSH 是一种安全远程登录的方法，通常用于访问设备的命令行。</span><br><span class="line">TFTP -简单文件传输协议(Trivial...)。这是一个简单的，无连接的文件传输协议，使用尽最大努力、无需确认的文件传输方式。它使用的开销比FTP少。</span><br><span class="line">Web和Web服务</span><br><span class="line"></span><br><span class="line">HTTP(Hybertext Transfer Protocol) -超文本传输协议。这是有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集。</span><br><span class="line">HTTPS -安全 HTTP(HTTP Secure)。这是一种安全的HTTP形式，它对在万维网上交换的数据进行加密。</span><br><span class="line">REST -具象状态传输协议(Representational State Transfer)。它使用应用程序编程接口 (API) 和 HTTP 请求创建 Web 应用程序的 Web 服务。前后端交接！！</span><br></pre></td></tr></table></figure><p>#传输层#(Transport layer)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向连接</span><br><span class="line">TCP -传输控制协议(Transmission Control Protocol)。它使运行在不同主机上的进程之间能够进行可靠的通信，并提供可靠的、需要确认的传输，以确保传输成功。</span><br><span class="line"></span><br><span class="line">无连接</span><br><span class="line">UDP -用户数据报协议(User Datagram Protocol)。它允许一台主机上运行的进程向另一台主机上运行的进程发送数据包。但是，UDP不会确认数据报传输是否成功。</span><br></pre></td></tr></table></figure><p>#互联网层#(Internet Layer)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Internet 协议</span><br><span class="line">IPv4 -互联网协议第 4 版(Internet Protocol version 4)。它接收来自传输层的消息段，将消息打包成数据包，并为通过网络进行端到端传递的数据包进行地址分配。IPv4 使用 32 位地址。</span><br><span class="line">IPv6 - 互联网协议第 6 版。与 IPv4 类似，但使用 128 位地址。</span><br><span class="line">NAT -网络地址转换(Network Address Translation)。将私有网络 IPv4 地址转换为全球唯一的公有 IPv4 地址。</span><br><span class="line"></span><br><span class="line">消息传送</span><br><span class="line">ICMPv4 - IPv4 互联网控制消息协议(Internet Control Message Protocol for IPv4)。目的主机针对数据包传输中出现的错误，向源主机提供反馈。</span><br><span class="line">ICMPv6 -用于 IPv6 的ICMP。与 ICMPv4 类似的功能，但用于 IPv6 数据包。</span><br><span class="line">ICMPv6 ND -IPv6 邻居发现(IPv6 Neighbor Discovery)。包括用于地址解析和重复地址检测的四个协议消息。</span><br><span class="line"></span><br><span class="line">路由协议</span><br><span class="line">OSPF -开放最短路径优先协议(Open Shortest Path First)。它使用基于区域的分层设计的链路状态路由协议。OSPF是一种开放式标准内部路由协议。</span><br><span class="line">EIGRP — 增强型内部网关路由协议(Enhanced Interior Gateway Routing Protocol)这是一种思科开发的开放标准路由协议，使用基于带宽、延迟、负载和可靠性的复合度量。</span><br><span class="line">BGP -边界网关协议(Border Gateway Protocol)。这是一种开放标准的外部网关路由协议，用于互联网服务提供商(ISP)之间。BGP 还通常用于 ISP 与其大型私有客户端之间来交换路由信息。</span><br></pre></td></tr></table></figure><p>#网络接入层#(Network Access Layer)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址解析</span><br><span class="line">ARP -地址解析协议(Address Resolution Protocol)。提供 IPv4 地址与硬件地址之间的动态地址映射。</span><br><span class="line">注意：您可能会看到其他文档声明 ARP 在互联网层（OSI 第 3 层）运行。但是，在本课程中，我们声明 ARP 在网络接入层（OSI 第 2 层）运行，因为它的主要目的是发现目标的 MAC 地址。MAC 地址是第 2 层地址。</span><br><span class="line"></span><br><span class="line">数据链路协议</span><br><span class="line">Ethernet -为网络接入层的布线和信令标准定义规则。</span><br><span class="line">WLAN -无线局域网(Wirelee Local Area Network)。定义 2.4 GHz 和 5 GHz 无线电频率的无线信号规则。</span><br></pre></td></tr></table></figure><h2 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314174259989.png" alt="image-20210314174259989"></p><p>PDU协议数据单元</p><p>Data 数据 </p><p>Segment 段  Datagram 报</p><p>Packet 包</p><p>Frame 帧</p><p>Bits 位</p><h1 id="4-物理层"><a href="#4-物理层" class="headerlink" title="4. 物理层"></a>4. 物理层</h1><p>网络接口卡 (NIC) 将设备连接到网络。以太网网卡用于有线连接（如图所示），而无线局域网（WLAN）网卡用于无线连接。最终用户设备可能包括一种或两种类型的网卡。</p><p>在连接网络时，所有物理连接的性能水平并不是相等的。</p><p>OSI 物理层通过网络介质传输构成数据链路层帧的比特（位）。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。帧由经过编码的比特（位）构成，这些位可以被终端设备或中间设备接收。</p><h2 id="物理层标准"><a href="#物理层标准" class="headerlink" title="物理层标准"></a>物理层标准</h2><p>由以下组织定义和管理：</p><ul><li>国际标准化组织 (ISO)</li><li>电信工业协会/电子工业协会 (TIA/EIA)</li><li>国际电信联盟 (ITU)</li><li>美国国家标准学会 (ANSI)</li><li>电气电子工程师协会 (IEEE)</li><li>国家级电信管理局包括美国联邦通信委员会 (FCC) 和欧洲电信标准协会 (ETSI)。</li></ul><p>除了这些组织之外，通常还有地方性布线标准组织，例如 CSA（加拿大标准协会）、CENELEC（欧洲电工标准化委员会）和 JSA/JIS（日本标准协会），开发本地规范。（放在这里谨表敬意，绝对不记！！）</p><p>物理层标准管理三个功能区：</p><ul><li>物理组件 - 电子硬件设备、介质和其他连接器</li><li>编码 - 将数据位流转换为预先定义“代码”的方法，这些代码就是位的编组，用于提供一种可预测模式，以便发送者和接收者均能识别。换句话说，编码是用于表示数字信息的方法或模式。（比如曼切斯特）</li><li>信令 - 表示位的方法称为信令方法，在介质上生成代表“1”和“0”的电信号、光信号或无线信号，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。长脉冲可能代表 1，而短脉冲可能代表 0。</li></ul><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>用来衡量带宽质量的术语包括:</p><p><strong>延迟</strong></p><p>延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。</p><p>在拥有多个网段的网际网络或网络中，吞吐量不能超过从源到目的地之间路径的最低链路。纵使这些网段全部或多数具备高速带宽，它也只使用那段低速率路径的吞吐量，这就会造成整个网络的吞吐量瓶颈。</p><p><strong>吞吐量</strong></p><p>吞吐量是给定时段内通过介质传输的位的量度。</p><p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符。吞吐量通常低于带宽。影响吞吐量的因素</p><ul><li>流量大小</li><li>流量类型</li><li>从源通往目的地的过程中遇到的网络设备数量所造成的延时。</li></ul><p><strong>实际吞吐量</strong></p><p>用于评估可用数据传输的第三个测量标准称为实际吞吐量。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。实际吞吐量就是吞吐量减去建立会话、确认、封装和重传所产生的流量开销。实际吞吐量总是低于吞吐量，而吞吐量通常低于带宽。</p><h2 id="铜缆"><a href="#铜缆" class="headerlink" title="铜缆"></a>铜缆</h2><p>有三种不同类型的铜缆布线，每一种都用于特定的情况。</p><p>价格低廉、易于安装、对电流的电阻低。但是，铜介质受到距离和信号干扰的限制。</p><p>信号传输的距离越远，信号下降就越多。这称为信号衰减。</p><ul><li>**电磁干扰 (EMI) 或射频干扰 (RFI) - EMI 和 RFI 干扰信号会扭曲和损坏通过铜介质承载的数据信号。EMI 和 RFI 的潜在来源包括无线电波和电磁设备（如荧光灯或电动机）。</li><li>**串扰 - 串扰是一根电线中信号的电场或磁场对邻近电线中的信号造成的干扰。在电话线上，串扰会由相邻电路中另一语音会话的接听部分引起。具体而言，当电流流经电线时，会在电线周围产生一个较小的环形磁场，而相邻电线可能接收到该磁场。</li></ul><p>为了应对 EMI 和 RFI 的负面影响，某些类型的铜缆会用金属屏蔽套包裹，并要求适当的接地连接。</p><p>为了应对串扰的负面影响，某些类型的铜缆将相反电路线对绞合在一起以有效消除串扰。</p><p>使用以下建议也可以限制电子噪音对铜缆的影响：</p><ul><li>选择的电缆类型或类别要适合特定的网络环境。</li><li>设计电缆基础设施时应规避建筑结构中已知和潜在的干扰源。</li><li>使用包括正确处理和端接电缆的布线技术。</li></ul><p>UTP非屏蔽双绞线 Unshielded twisted-pair </p><p>最常用的网络介质。通过 RJ-45 连接器端接的 UTP 布线用于<strong>网络主机与中间网络设备的互连</strong>，例如交换机和路由器。四对用颜色标记的电线组成</p><p>STP屏蔽双绞线 Shielded twisted-pair</p><p>比 UTP 布线提供更好的噪声防护。但是，与 UTP 电缆相比，STP 电缆更加昂贵而且不易安装。和 UTP 相同，STP 也使用 RJ-45 连接器。为了充分利用屏蔽的优势，STP 电缆使用特殊屏蔽 STP 数据连接器进行端接。如果电缆接地不正确，屏蔽就相当于一个天线，会接听多余信号。</p><p>多了金属编制和金属箔</p><p>Coaxial cable</p><p>同轴电缆，或简称同轴，由于它的两根导线共享同一个中轴而得名</p><p>同轴电缆使用许多不同类型的连接器</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314182735686.png" alt="image-20210314182735686"></p><p>虽然 UTP 电缆在现代以太网安装中最终取代了同轴电缆，但在以下情形中仍采用同轴电缆设计：</p><ul><li><strong>无线安装</strong> - 用同轴电缆将<strong>天线连接到无线设备</strong>。同轴电缆可传送天线和无线电设备之间的射频 (RF) 能量。</li><li><strong>有线电视互联网安装</strong> - 有线电视服务提供商为其客户提供互联网连接，他们会使用光缆替换同轴电缆和支撑放大元件部分。但是，<strong>客户所在地的布线</strong>仍采用同轴电缆。</li></ul><h2 id="UTP布线"><a href="#UTP布线" class="headerlink" title="UTP布线"></a>UTP布线</h2><p>标准规定了一些要素</p><ul><li>电缆类型</li><li>电缆长度</li><li>连接器</li><li>电缆端接</li><li>测试电缆的方法</li></ul><p>IEEE 按照它的性能对 UTP 布线划分等级。电缆分类的依据是它们承载更高速率带宽的能力。例如，5类电缆通常用于 100BASE-TX 快速以太网安装。其他类别包括增强型 5类电缆、6类电缆 和 6a 类电缆。</p><p>为了支持更高的数据传输速率，人们设计和构造了更高类别的电缆。随着新的千兆位以太网技术的开发和运用，如今已经很少采用 5e 类电缆，新建筑安装推荐使用 6 类电缆。</p><p>-3 类电缆最初用于语音线路的语音通信，但后来用于数据传输。 -5 类和5e 类电缆用于数据传输。5类电缆支持 100Mbps，5e 类电缆支持 1000 Mbps -6类电缆在每对线之间增加了一个分隔器以支持更高的速度。 6类电缆支持高达 10 Gbps。 -7类电缆也支持 10 Gbps。 -8类电缆支持 40 Gbps。</p><p>UTP 电缆的端头通常为 RJ-45 连接器。TIA/EIA-568 标准描述为以太网电缆进行引脚分配（引出线）的电线颜色标记。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200028243.png" alt="image-20210314200028243"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200013783.png" alt="image-20210314200013783"></p><p>直通和交通</p><ul><li><strong>以太网直通电缆</strong> -最常见的网络电缆类型。它通常用于主机到交换机和交换机到路由器的互连。</li><li><strong>以太网交叉电缆</strong> -用于互连相似设备的电缆。例如，交换机到交换机、主机到主机或路由器到路由器的连接。但是，由于网卡使用介质相关接口交叉（auto-MDIX）来自动检测电缆类型并进行内部连接，因此现在已将交叉电缆视为传统电缆。</li><li>但是主机链接路由器竟然也是用交叉线！</li></ul><p><strong>注意</strong>: 另一种类型的电缆是思科专有的全反电缆。它用于连接路由器或交换机的控制台端口。</p><p>在设备间错误使用交叉电缆或直通电缆不会损坏设备，但也无法连通设备并进行通信</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200350348.png" alt="image-20210314200350348"></p><table><thead><tr><th align="left">电缆类型</th><th align="left">标准</th><th align="left">应用</th></tr></thead><tbody><tr><td align="left">以太网直通线</td><td align="left">两端均为 T568A 或两端均为 T568B</td><td align="left">将网络主机连接到交换机或集线器之类的网络设备</td></tr><tr><td align="left">以太网交叉线</td><td align="left">一端为 T568A，另一端为 T568B</td><td align="left">连接两个网络主机或连接两台网络中间设备 （交换机到交换机或路由器到路由器）</td></tr><tr><td align="left">全反电缆</td><td align="left">思科专有</td><td align="left">使用适配器连接工作站串行端口与路由器 控制台端口。</td></tr></tbody></table><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><ul><li>单模光纤 (SMF) Single-mode fiber</li><li>多模光纤 (MMF) Mulitimode fiber</li></ul><p>单模光纤包含一个极小的芯，使用昂贵的激光技术来发送单束光，如图所示。单模光纤在跨越数百公里的长距离传输情况下很受欢迎，例如应用于长途电话和有线电视中的光纤。</p><p>多模光纤包含一个稍大的芯，使用 LED 发射器发送光脉冲。具体而言，LED 发出的光从不同角度进入多模光纤，t有多条光路，普遍用于 LAN 中，因为它们可以由低成本的 LED 提供支持。它可以通过长达 550 米的链路提供高达 10 Gb/s 的带宽。</p><p>多模和单模光纤之间的主要区别之一就是色散的数量。色散是指光脉冲在时间上的分布。色散增加意味着信号强度损失增加。多模光纤具有比单模光纤更大的色散。这就是为什么多模光纤在信号丢失之前只能传播 500 米。</p><ul><li><strong>企业网络</strong> - 用于主干布线和基础设施设备互连。</li><li><strong>光纤到户 (FTTH)</strong> - 用于为家庭和小型企业提供不间断宽带服务。</li><li><strong>长距离传输网络</strong> - 由服务提供商用于连接国家/地区与城市。</li><li><strong>水下有线网络</strong> - 用于提供可靠高速、高容量的网络解决方案，使其在深度与横跨海洋的距离相当的严酷海下环境中仍能生存。在互联网上搜索“海底电缆电信地理地图”，以在线查看各种地图。</li></ul><p>连接器：</p><p>直通式ST Straight-tip</p><p>用户连接器SC Subscriber Connector</p><p>朗讯连接器LC单工 Lucent Connector Simplex Connectors</p><p>双工多模LC连接器 Duplex Multimode</p><p>直到最近，光还只能在光纤上沿一个方向传播。因此，需要两根光纤来支持全双工操作。因此，光纤跳线是将两根光纤线缆捆绑在一起，并通过一对标准的单光纤接头端接。有些光纤连接器可以在单个连接器上同时传送和接收光纤，称为双工连接器，其实就是连接了俩线</p><p>需要使用光纤接插线（即光纤跳线）互连基础设施设备。人们使用不同颜色来区分单模和多模接插线。黄色表皮的是单模光缆，橙色（或浅绿色）的是多模光缆。</p><p>有SC-SC多模  LC-LC 单模 ST-LC多模 SC-ST单模 。。。</p><h2 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h2><p>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。</p><p>以下是无线网络的一些局限性:</p><ul><li><strong>覆盖面积</strong> - 无线数据通信技术非常适合开放环境。但是，在楼宇和建筑物中使用的某些建筑材料以及当地地形将会限制它的有效覆盖。</li><li><strong>干扰</strong> - 无线电易受干扰，可能会受到家庭无绳电话、某些类型的荧光灯、微波炉和其他无线通信装置等常见设备的干扰。</li><li><strong>安全性</strong> - 无线通信覆盖无需进行介质的物理接线。因此，未获得网络访问授权的设备和用户可以访问传输。所以网络安全是无线网络管理的重要组成部分。</li><li><strong>共享介质</strong> - WLAN 以半双工模式运行，意味着一台设备一次只能发送或接收。无线介质由所有无线用户共享。许多用户同时访问WLAN会导致每个用户的带宽减少。</li></ul><p>标准规定了：</p><ul><li>数据到无线电信号编码</li></ul><ul><li>传输频率和功率</li><li>信号接收和解码要求</li><li>天线的设计和施工</li></ul><p>这些是无线标准：</p><ul><li><strong>Wi-Fi (IEEE 802.11)</strong> - 无线 LAN (WLAN) 技术，通常称为 Wi-Fi。WLAN 使用一种称为“载波侦听多路访问/冲突避免 (CSMA/CA)”的争用协议。无线 NIC 在传输数据之前必须先侦听，以确定无线信道是否空闲。如果其他无线设备正在传输，则 NIC 必须等待信道空闲。Wi-Fi 是 Wi-Fi 联盟的标记。Wi-Fi 与基于 IEEE 802.11 标准的认证 WLAN 设备结合使用。</li><li><strong>蓝牙 (IEEE 802.15)</strong> - 这是一个无线个人局域网 (WPAN) 标准，通常称为 “蓝牙”。它采用设备配对过程进行通信，距离为 1 到 100 米。</li><li><strong>WiMAX (IEEE 802:16)</strong> - 通常称为微波接入全球互通 (WiMAX)，这个无线标准采用点到多点拓扑结构，提供无线带宽接入。</li><li><strong>Zigbee (IEEE 802.15.4)</strong> - Zigbee是一种用于低数据速率、低功耗通信的规范。它适用于需要短距离、低数据速率和长电池寿命的应用。Zigbee 通常用于工业和物联网 (IoT) 环境，如无线照明开关和医疗设备数据采集。</li></ul><p>WLAN 要求具备下列网络设备：</p><ul><li><strong>无线接入点 (AP) Wireless Access Point</strong> - 集中用户的无线信号，并连接到现有基于铜介质的网络基础设施，如以太网。如图所示，家庭和小型企业无线路由器将路由器、交换机和接入点的功能整合到了一起。</li><li><strong>无线网卡适配器Wireless NIC adapters</strong> - 能够为每台网络主机提供无线通信</li></ul><p>以太网网卡用于有线连接，而 WLAN（无线局域网）网卡用于无线连接。</p><h1 id="5-数制系统"><a href="#5-数制系统" class="headerlink" title="5. 数制系统"></a>5. 数制系统</h1><p>IPV4每一个地址包含一串 32 位字符串，并分为四个部分，称为二进制八位组。每一个二进制八位组包含 8 位（或 1 个字节），用句点分隔。IPv4 地址通常表达为点分十进制记法</p><p>十六进制数制系统在网络中用于表示以太网 MAC 地址和 IP V6 地址。</p><p>IPv6地址长度为128位，每 4 位以一个十六进制数字表示，共 8组32 个十六进制值。IPv6 地址不区分大小写，可用大写或小写书写。首选格式为<code> x:x:x:x:x:x:x:x</code>，</p><p>每个“x”称为一个十六进制数，包括四个十六进制值</p><h1 id="6-数据链路层"><a href="#6-数据链路层" class="headerlink" title="6. 数据链路层"></a>6. 数据链路层</h1><p>与 TCP/IP 的上层协议不同，数据链路层协议通常不是由征求意见 (RFC) 文档定义的。互联网工程任务组 (IETF) 虽然维护着 TCP/IP 协议簇上层的工作协议和服务，但它没有定义TCP/IP模型的网络接入层的功能和操作。</p><p>定义适用于网络接入层（即，OSI的物理和数据链路层）的开放标准和协议的工程组织包括：</p><ul><li>电气电子工程师协会 (IEEE)</li><li>国际电信联盟 (ITU)</li><li>国际标准化组织 (ISO)</li><li>美国国家标准学会 (ANSI)</li></ul><p>OSI模型的数据链路层(第2层)为物理网络准备网络数据。数据链路层负责网络接口卡 (NIC) 到网络接口卡的通信。数据链路层执行以下操作：</p><ul><li>允许上层访问介质。上层协议完全不知道用于转发数据的介质类型。</li><li>接受数据，通常是第 3 层数据包（即 IPv4 或 IPv6），并将它们封装到第 2 层帧中。</li><li>控制数据在介质上的放置和接收方式，</li><li>通过网络介质在终端之间交换帧。</li><li>接收封装的数据，通常是第 3 层数据包，并将它们定向到适当的上层协议。</li><li>执行错误检测并拒绝任何损坏的帧。</li></ul><p>如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。此外，每当开发出一种新的网络技术或介质时，IP 必须做出相应调整。而这些交给数据链路层来考虑，IP只需考虑更加抽象的架构</p><h2 id="IEEE-802-LAN-MAN"><a href="#IEEE-802-LAN-MAN" class="headerlink" title="IEEE 802 LAN/MAN"></a>IEEE 802 LAN/MAN</h2><p>IEEE 802 LAN/MAN 标准专用于以太网局域网、无线局域网 (WLAN)、无线个人区域网 (WPAN) 和其他类型的局域网和城域网。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：</p><ul><li><strong>逻辑链路控制 (LLC)</strong> - 这个 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。<strong>它放入帧中的信息用于确定帧所使用的网络层协议</strong>。此信息<strong>允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</strong>不必让每个协议自己研究这些</li><li><strong>介质访问控制 (MAC)</strong> - 在硬件上实现这个子层（IEEE 802.3、802.11 或 802.15）。它负责数据<strong>封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</strong></li></ul><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314205917487.png" alt="image-20210314205917487"></p><p>LLC 子层获取网络协议数据（通常是 IPv4 或 IPv6数据包）并加入第2层控制信息，帮助将数据包传送到目的节点。 </p><p>MAC子层控制网卡和负责在有线或无线LAN/MAN介质上发送和接收数据的其他硬件。</p><p>MAC 子层提供数据封装：</p><ul><li><strong>帧定界</strong> - 在成帧过程中提供重要的定界符，用来标识帧中的字段。这些定界符位可以在发送节点与接收节点之间提供同步。</li><li><strong>编址</strong> - 提供源和目的编址，用于在同一共享介质上的设备之间传输第 2 层帧。</li><li><strong>错误检测</strong> - 包含一个帧尾，用于检测传输错误。</li></ul><p>MAC 子层还提供介质访问控制，允许多个设备通过共享（半双工）介质进行通信。全双工通信不需要访问控制。</p><h2 id="介质访问"><a href="#介质访问" class="headerlink" title="介质访问"></a>介质访问</h2><p>在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。例如，以太网 LAN 通常由许多争用网络介质访问的主机组成。MAC 子层解决了这个问题。对于串行链路，访问方法可能只包括两个设备之间的直接连接，通常是两个路由器。因此，它们不需要 IEEE 802 MAC 子层所使用的技术。</p><p>路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p><p>在路径上的每一跳，路由器都执行以下第 2 层功能：</p><ol><li>从介质接受帧</li><li>解封帧</li><li>将数据包重新封装到新帧中</li><li>从适合该物理网络网段的介质转发新帧</li></ol><h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><ul><li><strong>物理拓扑</strong> - 标识物理连接，以及终端设备和中间设备（即，路由器、交换机和无线接入点）如何互连。这个拓扑还可能包括特定的设备位置，如房间号和设备机架上的位置。物理拓扑通常是点对点拓扑或星型拓扑。</li><li><strong>逻辑拓扑</strong> - 是指网络将帧从一个节点传输到另一节点的方法。此拓扑使用<strong>设备接口和<em>第 3 层</em> IP 寻址方案识别虚拟连接。</strong></li></ul><p>在控制对介质的数据访问时，数据链路层“看见”的是网络的逻辑拓扑。正是逻辑拓扑在影响网络成帧和介质访问控制的类型。</p><p><strong>WAN拓扑</strong></p><p>点对点：在这种布局中，两个节点无需与其他主机共享介质。此外，当使用串行通信协议，如点对点协议(PPP)时，节点无需判定收到的帧是指向它还是指向另一节点。因此，逻辑数据链路协议将非常简单，因为介质中的所有帧都只去往或来自这两个节点。节点将帧放置到一端的介质上，然后点对点线路另一端的节点从介质取走帧。<br><strong>在网络中使用物理设备并不会影响逻辑拓扑</strong></p><p>中心辐射：这是星型拓扑的 WAN 版本，在该拓扑中一个中心站点使用点对点链路互连分支机构站点。如果不经过中心站点，分支站点就不能与其他分支站点交换数据。</p><p>网状：该拓扑可用性高，但要求每个终端系统都与其他各个系统互连。因此管理成本和物理成本都会非常高。每条链路实质上是另一节点的点对点链路。</p><p>混合拓扑（任意拓扑的变体和组合）</p><p><strong>LAN拓扑</strong></p><p>在多路访问局域网中，终端设备（即节点）使用星型或扩展星型拓扑相互连接，如图所示。在这种类型的拓扑中，终端设备连接到一个中央中间设备，在本例中是一个以太网交换机。扩展星型（<strong>扩展星型</strong>）通过连接多个以太网交换机来扩展此拓扑。星型和扩展星型拓扑安装简单、扩展性好（易于添加和删除终端设备），而且故障排除容易。早期的星型拓扑使用以太网集线器互连终端设备。</p><p><strong>传统LAN拓扑</strong></p><p>早期的以太网和传统令牌环局域网技术包括另外两种拓扑结构:</p><ul><li><strong>总线</strong> - 所有终端系统都相互连接，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。传统的以太网络中会使用采用同轴电缆的总线拓扑，因为它价格低廉而且安装简易。</li><li><strong>环</strong> - 终端系统与其各自的邻居相连，形成一个环状。与总线拓扑不同，环拓扑不需要端接。传统的光纤分布式数据接口 (FDDI) 和令牌环网络使用环拓扑。</li></ul><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314211820357.png" alt="image-20210314211820357"></p><p><strong>半双工</strong></p><p>两台设备都可以通过该介质发送和接收，但无法同时执行这两个操作。WLAN和带有以太网集线器的传统总线拓扑使用半双工模式。</p><p><strong>全双工</strong></p><p>两台设备都可以在共享介质上同时发送和接收，现代Ethernet</p><p>双工不匹配会导致效率严重下降！重要错误</p><h2 id="访问控制方法"><a href="#访问控制方法" class="headerlink" title="访问控制方法"></a>访问控制方法</h2><p>多路访问网络是指可能有两个或多个终端设备同时试图访问网络的网络。</p><p>以太网 LAN 和 WLAN 都是多路访问网络的示例</p><p>对于共享介质，有两种基本的访问控制方法：</p><ul><li>基于竞争的访问</li><li>受控访问</li></ul><p><strong>受控访问</strong></p><p>在基于控制的多路访问网络中，每个节点都有自己的时间来使用介质。这种确定性的传统网络类型效率很低，因为设备必须等到轮到自己才能访问介质。使用受控访问的多路访问网络的示例包括：</p><ul><li>传统令牌环</li><li>传统ARCNET</li></ul><p><strong>基于竞争的访问</strong></p><p>在基于竞争的多路访问网络中，所有节点都工作在半双工方式，争夺介质的使用。然而，一次只有一台设备能够发送。因此，当多台设备同时传输时，会使用一个处理过程。基于竞争的访问方法示例如下：</p><ul><li>在<strong>传统总线拓扑/使用集线器的以太网局域网</strong>上使用载波侦听多路访问/冲突检测(CSMA/CD)</li><li>在<strong>无线局域网</strong>上使用载波侦听多路访问/冲突避免(CSMA/CA)</li></ul><p><em>基于竞争的系统在介质使用率高的情况下都无法很好地扩展。</em></p><p><strong>CSMA/CD</strong></p><p>如果两台设备同时传输，则会发生冲突。对于传统以太网局域网，两台设备将会检测到网络上的冲突。这就是 CSMA/CD 的冲突检测 (CD) 部分。网卡通过比较传输的数据与接收的数据，或通过识别介质中的信号振幅是否高于正常状况来实现。两台设备发送的数据会损坏且需重新发送。</p><p>集线器例子：</p><p>在没有载波信号时，假定网络可用，A发送给B，帧首先到集线器，然后从所有端口发送，由于帧拥有 PC3 的目的数据链路地址，只有该设备会接受并被全帧复制。所有其他设备的网卡都将忽略该帧</p><p>它还提供了一种回退重传算法。</p><p><strong>CSMA/CA</strong></p><p>在无线环境中，设备可能无法检测到冲突。CMSA/CA 不检测冲突，但会通过在传输之前等待来尝试避免冲突。每台设备发送时都会包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有久不可用。</p><p><em><strong>注意: 使用交换机的以太网 LAN 不使用基于竞争的系统，因为交换机和主机网卡在全双工模式下运行</strong></em></p><h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><p>附加到帧的信息由正在使用的协议决定。</p><p>数据链路协议负责同一网络中的网卡间通信。虽然有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有三个基本组成部分：</p><ul><li>帧头</li><li>数据</li><li>帧尾</li></ul><p>没有一种帧结构能满足通过所有类型介质的全部数据传输需求。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。例如，WLAN帧必须包含避免冲突的过程，因此与以太网帧相比需要额外的控制信息。在脆弱的环境下，需要更多控制才能确保送达。由于所需控制信息较多，因此帧头和帧尾字段都较大。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213324158.png" alt="image-20210314213324158"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213352540.png" alt="image-20210314213352540"></p><p><em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p><p>在 TCP/IP 网络中，所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用。但是，所用的第 2 层协议取决于逻辑拓扑和物理介质。</p><p>每个协议执行指定第 2 层逻辑拓扑的介质访问控制。这意味着在执行这些协议时，有很多种不同的网络设备都可以充当运行在数据链路层上的节点。这些设备包括计算机上的网卡以及路由器和第 2 层交换机上的接口。</p><p>用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。所使用的技术取决于网络规模（根据主机数量和地理范围判断）以及通过网络提供的服务。</p><p>带宽差异常会导致 LAN 和 WAN 使用不同的协议。</p><p>数据链路层协议包括：</p><ul><li>以太网</li><li>802.11 无线</li><li>点对点协议 (PPP)</li><li>高级数据链路控制 (HDLC) High-Level Data Link Control</li><li>帧中继 Frame Relay</li></ul><h1 id="7-以太网交换"><a href="#7-以太网交换" class="headerlink" title="7. 以太网交换"></a>7. 以太网交换</h1><p>以太网是如今广泛使用的两种局域网技术之一，另一种是无线局域网（WLAN）。它使用有线通信，包括双绞线、光纤链路和同轴电缆。</p><p>以太网在数据链路层和物理层运行，是 IEEE 802.2 和 802.3 标准中定义的一系列网络技术。（无线是802.11）</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214332628.png" alt="image-20210314214332628"></p><p>以太网也使用802 LAN/MAN协议的俩子层</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214654631.png" alt="image-20210314214654631"></p><h2 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h2><p>MAC 子层负责数据封装和访问介质。</p><p><strong>数据封装</strong></p><p>IEEE 802.3 数据封装包括以下内容：</p><ul><li><strong>以太网帧</strong> - 这是以太网帧的内部结构。</li><li><strong>以太网寻址</strong> - 以太网帧中包含源和目的MAC 地址，用于将该以太网帧从以太网网卡传送到<strong>同一LAN</strong>上的以太网网卡。</li><li><strong>以太网错误检测</strong> - 以太网帧中包含用于错误检测的帧校验序列 (FCS) 帧尾。</li></ul><p>它也负责使用CSMA/CD and CSMA/CA技术</p><h2 id="以太网帧字段"><a href="#以太网帧字段" class="headerlink" title="以太网帧字段"></a>以太网帧字段</h2><p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。在描述帧的大小时，不包含“前导码”字段。</p><p>任何长度小于 64 个字节的帧都被接收站点视为“冲突碎片”或“残帧”而自动丢弃。超过 1500 个字节的数据帧被视为“巨帧”或“小型巨型帧”。</p><p>如果发送的帧小于最小值或者大于最大值，接收设备将会丢弃该帧。帧之所以被丢弃，可能是因为冲突或其他多余信号。它们被视为无效。大多数快速以太网和千兆以太网交换机和网卡通常都支持巨帧。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214944369.png" alt="image-20210314214944369"></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">前导码和帧首定界符字段</td><td align="left">前导码（Preamble）（7 字节）和帧首定界符(Start Frame Delimiter)（SFD），也称为 帧首（1 字节），该字段用于发送设备 与接收设备之间的同步。帧开头的八个字节 用于引起接收节点的注意。基本上，前几个字节的 作用是告诉接收方准备接收新帧。</td></tr><tr><td align="left">目的 MAC 地址字段</td><td align="left">该 6 字节字段是预期接收方的标识符。读者应该还记得， 此地址被第2层用来协助设备 确定帧是否发送到目的地。帧中的地址将会与设备中的 MAC 地址进行比对。如果匹配， 设备就接受该帧。可以是单播、组播或广播 地址。</td></tr><tr><td align="left">源 MAC 地址字段</td><td align="left">该 6 字节字段标识发出帧的网卡 或接口。</td></tr><tr><td align="left">类型/长度</td><td align="left">该字段包含两个字节，<strong>标识封装于以太网帧中的 上层协议</strong>。常见值为十六进制，0x800 用于 IPv4， 0x86DD 用于 IPv6，0x806 用于 ARP。 <strong>注意</strong>：您也可能会看到此字段称为 EtherType、类型或长度。</td></tr><tr><td align="left">数据字段</td><td align="left">该字段（46-1500 字节）包含来自 较高层的封装数据，一般是第3层PDU。最常见是IPv4 数据包。所有帧至少必须有 64 个字节。<strong>如果封装的是小数据包， 则使用填充位将帧增大到最小值</strong>。</td></tr><tr><td align="left">帧校验序列字段</td><td align="left">“帧校验序列 (Frame Check Sequence)(FCS)”字段（4 个字节）用于检测帧中 的错误。它使用循环冗余校验 (CRC)。发送设备 在帧的 FCS 字段中包含 CRC 的结果。接收设备 接收帧并生成 CRC 以查找 错误。如果计算匹配，就不会发生错误。计算 不匹配则表明数据已经改变。因此， 帧会被丢弃。数据的变化可能是 由于代表比特位的电信号受到干扰所致。</td></tr></tbody></table><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>在以太网中，每台网络设备都连接到同一个共享介质。MAC 地址用于标识本地网段上的物理源和目的设备。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。</p><p>以太网 MAC 地址是使用 <strong>12个十六进制数字</strong>表示的 48 位地址，因为一个字节等于 8 位，我们也可以说 一个MAC 地址长度为 6 个字节。</p><p>所有 MAC 地址对于以太网设备或以太网接口必须是唯一的。<br>为了确保这一点，所有销售以太网设备的供应商必须向 IEEE 注册才能获得唯一的 6个十六进制（即 24 位或 3 字节）代码，称为组织唯一标识符 (OUI)。（Organization unique identifier）</p><p>当供应商为设备或以太网接口分配 MAC 地址时，供应商必须执行以下操作：</p><ul><li>使用其分配的 OUI 作为前 6 个十六进制数字。</li><li>为后 6 个十六进制数字分配唯一值。</li></ul><p>查询网址：<a href="http://standards-oui.ieee.org/oui/oui.txt">http://standards-oui.ieee.org/oui/oui.txt</a></p><p>供应商有责任确保其设备不被分配相同的 MAC 地址。但是，由于制造过程中出现的错误、某些虚拟机部署方式中的错误或使用多种软件工具之一进行的修改，可能存在重复的 MAC 地址。若出现以上任一情况，必须在新网卡或软件中修改 MAC 地址。</p><p>MAC 地址通常称为烧录地址(Built-in Address) (BIA)，因为传统上该地址被烧录到网卡的只读存储器（ROM）中。这意味着该地址会永久编码到 ROM 芯片中。</p><p><strong>注意</strong>: 在现代 PC 操作系统和网卡中，可以在软件中更改MAC 地址。当试图访问基于 BIA 进行过滤的网络时，这一点非常有用。因此，根据 MAC 地址来过滤或控制流量就不再安全了。</p><p>当计算机启动时，网卡将 MAC 地址从 ROM 复制到 RAM 中</p><p>收到以太网帧时，网卡会查看帧中的目的 MAC 地址是否与设备 RAM 中存储的物理 MAC 地址匹配。如果不匹配，设备就会丢弃帧。如果与帧中的目的 MAC 匹配，则网卡会将帧向上传送到 OSI 层进行解封处理。</p><p><em><strong>单播，广播，组播MAC地址</strong></em></p><p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p><p>以太网单播 MAC 地址是帧从一台发送设备去往一台目的设备时使用的唯一地址</p><p>源主机用来确定目的IPv4地址所对应的目的 MAC 地址的流程称为**地址解析协议 (ARP)<strong>。源主机用来确定目的IPv6地址所对应的目的 MAC 地址的流程称为</strong>邻居发现 (ND)**。（参看TCP/IP）</p><p>以太网广播帧由以太网LAN上的每个设备接收和处理。以太网广播的功能如下：</p><ul><li>它有一个十六进制（在二进制中是 48 个 1）FF-FF-FF-FF-FF-FF的<strong>目的 MAC</strong> 地址。</li><li>它向除输入端口以外的所有以太网交换机端口泛洪。</li><li>路由器不会转发该帧。</li></ul><p>IPv4 的 DHCP 是使用以太网和 IPv4 广播地址的一个协议示例。</p><p>以太网组播帧由属于同一组多播组的以太网LAN上的一组设备接收和处理。以太网组播的功能如下：</p><ul><li>当封装数据为IPv4组播包时，目的MAC地址为01-00-5E;<br>当封装数据为IPv6组播包时，目的MAC地址为33-33。</li><li>当封装的数据不是IP时，还有其他预留的组播目的MAC地址，<br>如生成树协议Spanning Tree Protocol(STP)和链路层发现协议Link Layer Discovery Protocol(LLDP)。</li><li>除非交换机被配置为用于组播窥探multicast snooping，否则它将向除传入端口之外的所有以太网交换机端口泛洪flooded out。</li><li>它不会由路由器转发，除非路由器配置为路由组播数据包。</li></ul><p>如果封装的数据是一个IP组播包，则属于组播组的设备都分配有该组播组IP地址。IPv4 组播地址的范围为 224.0.0.0 到 239.255.255.255。IPv6 组播地址的范围以 ff00::/8 开头。由于组播地址代表一组地址（有时称为主机组），因此只能用作数据包的目的地址。源地址始终应为单播地址。</p><h2 id="MAC地址表"><a href="#MAC地址表" class="headerlink" title="MAC地址表"></a>MAC地址表</h2><p>现在就该讨论交换机如何使用这些地址将帧转发(或丢弃)到网络上的其他设备。如果交换机只是转发出它接收到的每一帧到所有端口，您的网络将会非常拥挤，以至于它可能会完全停止工作。</p><p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，交换机仅根据第 2 层以太网 MAC 地址做出转发决策。这才实现了真正的分工和可复用</p><p>一个以太网交换机检查它的<strong>MAC地址表</strong>，为每个帧做出一个<strong>转发决策</strong>，不像传统的以太网集线器，向除了传入端口以外的所有端口重复发出比特位。</p><p><strong>注意</strong>: MAC 地址表有时也称为内容可寻址内存Content-addressable-memory (CAM) 表。虽然 CAM 表这一术语相当常见，但在本课程中，我们将称其为 MAC 地址表。</p><p><strong>学习Learn</strong></p><p>进入交换机的每个帧被检查，以确定其中是否有可被学习的新信息。它是通过检查帧的源 MAC 地址和帧进入交换机的端口号来完成这一步的。如果源 MAC 地址在该网络不存在（就是来自另一局域网），会将其和传入端口号一并添加到表中。如果源 MAC 地址已存在表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</p><p><strong>注意</strong>: 如果源 MAC 地址已经保存在表中，但是对应的是不同的端口，那么交换机会将其视为一个新的条目。使用相同的 MAC 地址和最新的端口号来<strong>替换</strong>该条目。</p><p><strong>转发Forward</strong></p><p>如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。如果表中存在该目的MAC地址，交换机会从指定端口转发帧。如果表中不存在该目的MAC地址，交换机会从除传入端口外的所有端口转发帧。这称为未知单播。</p><p><strong>注意</strong>: 如果目的 MAC 地址为广播或组播，该帧也将被泛洪到除传入端口外的所有端口。</p><p>交换机是从不同的设备接收帧，因此它可以通过检查每个帧的源 MAC 地址来填充它的 MAC 地址表。如果MAC 地址表包含目的MAC 地址，则交换机将“滤过”该帧并将其从单个端口转发出去。</p><h2 id="交换机速率-转发方法"><a href="#交换机速率-转发方法" class="headerlink" title="交换机速率/转发方法"></a>交换机速率/转发方法</h2><p>对于思科交换机，实际上有两种帧转发的方法，根据具体情况，有充分的理由使用其中一种来代替另一种。</p><p>在过去，交换机使用下面的两种转发方法之一来进行网络端口间的数据交换：</p><ul><li><strong>存储转发交换</strong> - 这个帧转发的方法接收整个帧并计算CRC。CRC 根据帧中的比特位为 1 的位数量，使用数学公式来确定收到的帧是否有错。如果 CRC 有效，则交换机查找目的地址，目的地址决定了转发接口。帧然后从正确的端口转发出去。</li></ul><p>ps：<em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p><ul><li><strong>直通交换</strong> - 这种帧转发的方法在收到整个帧之前即转发帧。在可以转发帧之前，至少必须读取帧的目的地址。</li></ul><p><strong>存储转发交换</strong>的一大优点是，它可以在传播帧之前确定帧是否有错误。当在帧中检测到错误时，交换机丢弃该帧。丢弃有错的帧可减少损坏的数据所耗用的带宽量。存储转发交换对于融合网络中的服务质量 (QoS) 分析是必需的，在融合网络中，必须对帧进行分类以划分流量优先级。如 IP 语音数据流的优先级需要高于 Web 浏览流量。</p><p><strong>直通交换</strong>中，交换机在收到数据时立即处理数据，即使传输尚未完成。交换机只缓冲帧的一部分，缓冲的量仅足以读取目的 MAC 地址，以便确定转发数据时应使用的端口。目的 MAC 地址位于帧中前导码后面的前 6 个字节。交换机在其交换表中查找目的 MAC 地址，确定转发端口，然后通过指定的交换机端口将帧转发到其目的地。交换机对该帧不执行任何错误检查。</p><ul><li><strong>快速转发交换 -</strong> 快速转发交换提供最低程度的延时。快速转发交换在读取目的地址之后立即转发数据包。由于快速转发交换在收到整个数据包之前就开始转发，因此有时候中继数据包时会出错。这种情况并不经常发生，而且目的网络适配器在收到含错数据包时会将其丢弃。在快速转发模式下，延时是指从收到第一个位到传出第一个位之间的时间差。快速转发交换是典型的直通交换方法。<strong>Fast-forward switching</strong></li><li><strong>免分片交换 -</strong> 在免分片交换中，交换机在转发之前存储帧的前 64 个字节，原因是，大部分网络错误和冲突都发生在前 64 个字节。免分片交换在转发帧之前对帧的前 64 个字节执行小错误检查以确保没有发生过冲突，并且尝试通过这种方法来增强快速转发交换功能。免分片交换是存储转发交换的高延时和高完整性与快速转发交换的<strong>低延时和弱完整性之间的折衷</strong>。<strong>Fragment-free switching</strong></li></ul><p>某些交换机可配置为按端口执行直通交换，当达到用户定义的错误阈值时，这些端口自动切换为存储转发。当错误率低于该阈值时，端口自动恢复到直通切换。（牛啊！）</p><p>以太网交换机在转发帧之前，可以使用<strong>缓冲技术</strong>存储帧。当目的端口由于拥塞而繁忙时，也可以使用缓冲。交换机将帧存储起来，直到可以传输。</p><p>有两种内存缓冲方法：</p><table><thead><tr><th align="left">方法(………)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>基于端口的内存</strong></td><td align="left">帧存储在链接到特定传入端口和传出 端口的队列中。只有当队列前面的所有帧都成功传输后， 才会将帧传输到传出端口。由于目地端口繁忙， 单个帧可能会造成内存中所有帧的传输延迟。即使其他帧可以传送到开放的目的端口， 这种延迟仍然会发生。</td></tr><tr><td align="left"><strong>共享内存</strong></td><td align="left">将所有帧存储到由所有交换端口共享的公共内存缓冲区中， 并且动态分配一个端口所需的 缓冲区内存量。缓冲区中的帧动态地链接到目的端口， 允许在一个端口上接收数据包，然后 在另一个端口上发送，而无需移动到另一个队列。</td></tr></tbody></table><p>而且<strong>共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少</strong>。这对于非对称交换非常重要，因为它允许在不同端口上使用<strong>不同的数据速率</strong>，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p><p>交换机上最基本的两个设置是带宽(有时称为“速率”)和每个交换机端口的双工设置。交换机端口和连接的设备（例如计算机或另一台交换机）的双工设置和带宽设置必须匹配。</p><p>自动协商是大多数以太网交换机和网卡的一项可选功能。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。</p><p><strong>注意</strong>: 大多数思科交换机和以太网网卡默认采用自动协商功能，以提高速率和实现双工。千兆以太网端口仅以全双工模式运行。</p><p>当链路上的一个或两个端口被重置时，会发生双工不匹配，自动协调过程并不会使链路上的两个端口的配置相同。当用户重新配置链路的一端而忘记重新配置另一端时，也会出现这样的情况。链路的两端均应都使用或都不使用自动协商。最佳实践是将两个以太网交换端口都配置为全双工。</p><h2 id="Auto-MDIX"><a href="#Auto-MDIX" class="headerlink" title="Auto-MDIX"></a>Auto-MDIX</h2><p>现在，大多数交换机设备都支持自动介质相关接口交叉 (auto-MDIX) 功能。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。因此，如果要连接到交换机上的铜缆 10/100/1000 端口，您既可以使用交叉线，也可以使用直通线，而无需考虑连接另一端的设备类型。</p><p>在运行思科 IOS Release 12.2(18)SE 或更高版本的交换机上，默认启用 auto-MDIX 功能。当然，该功能可以被禁用。因此，您应始终使用正确的线缆类型，而不是依赖auto-MDIX 功能。Auto-MDIX 可以使用接口配置命令 <strong>mdix auto</strong> 重新启用。</p><h1 id="8-网络层"><a href="#8-网络层" class="headerlink" title="8. 网络层"></a>8. 网络层</h1><p>要向不在本地网络上的任何人发送电子邮件（视频或文件等），您必须能够访问路由器。要访问路由器，您必须使用网络层协议。</p><h2 id="网络层特征"><a href="#网络层特征" class="headerlink" title="网络层特征"></a>网络层特征</h2><p>网络层即 OSI 第 3 层，提供能够<em><strong>让终端设备跨整个网络交换数据的服务</strong></em></p><p>IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括路由协议，如开放式最短路径优先协议(OSPF)，和消息传递协议，如Internet控制消息协议(ICMP)。</p><p>为了实现跨网络边界的端到端通信，网络层协议执行四个基本操作:</p><ul><li>**终端设备编址 - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li><li>**封装 - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</li><li>**路由 - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是<strong>为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由</strong>。数据包可能需要经过很多路由器才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</li><li>**解封 - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</li></ul><p>传输层（OSI 第 4 层）负责管理每台主机上的运行进程之间的数据传输，而网络层通信协议（即，IPv4和IPv6）则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。网络层工作时<strong>无需考虑每个数据包中所携带的数据</strong>，这使其能够为多台主机之间的多种类型的通信传送数据包</p><p><strong>逐层封装数据的流程使我们可以开发和扩展位于不同层的服务而不影响其他层</strong>。这意味着传输层数据段可以随时通过 IPv4 或 IPv6 进行封装，或使用未来可能开发出的任何新协议进行封装。</p><p>从数据包离开源主机到达目的主机之前，IP编址信息保持不变，除非是由为IPv4执行网络地址转换(NAT)的设备进行转换。</p><p><em><strong>IP的基本特征</strong></em></p><p>IP 被设计为一种<strong>低开销</strong>协议。它只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。并不负责跟踪和管理数据包的流动。这些功能（如果需要）将由其他层的其他协议（主要是第 4 层的 TCP）执行。</p><p>IP的基本特征：</p><ul><li><strong>无连接</strong> - 发送数据包前不与目的地建立连接。IP 在转发数据包前，并不需要初步交换控制信息来创建端到端连接。</li><li><strong>尽力而为</strong> - IP本质上是<strong>不可靠</strong>的，因为不保证数据包交付。IP 也不需要报头中包含其他字段来维持建立的连接。此过程显著降低了 IP 的开销。但是，由于没有预先建立端到端连接，发送数据包时，发送方不知道目的地是否存在和正常运行，同时发送数据包时，也不会知道目的地是否接收数据包，或者，目的设备是否可以访问并读取数据包。确认由其他协议负责</li><li><strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。如果数据包顺序错乱或丢失，则使用数据或上层服务的应用程序必须解决这些问题。这让 IP 可以非常有效地发挥作用。在 TCP/IP 协议簇中，可靠性是TCP协议在传输层的功能。IP 数据包既可以作为电信号通过铜缆传送，也可以作为光信号通过光纤传送或作为无线电信号无线传送。</li></ul><p>但是，网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (MTU)。数据链路层和网络层之间的部分控制通信就是确定数据包的最大尺寸<strong>。数据链路层将 MTU 值向上传送到网络层</strong>。网络层会由此确定可以传送的数据包的大小。</p><p>有时，中间设备（通常是路由器），在将IPv4数据包从一个介质转发到具有更小 MTU 的介质时，必须分割数据包。此过程称为数据包分片或分片。<strong>分片会导致延迟。IPv6 数据包不能被路由器分片。</strong></p><p>OSI传输层发送被封装在IPv4或IPv6包中的数据段</p><p>OSI数据链路层负责接收数据包并准备数据包以在通信介质上传输</p><h2 id="IPv4数据包"><a href="#IPv4数据包" class="headerlink" title="IPv4数据包"></a>IPv4数据包</h2><p>IPv4 是主要网络层通信协议之一。IPv4 数据包报头用于确保此数据包在到达目的地终端设备的路上被传递到其下一站。</p><p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233828847.png" alt="image-20210314233828847"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233849824.png" alt="image-20210314233849824"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314234312571.png" alt="image-20210314234312571"></p><p>其他字段用于重新排列分段的数据包。具体而言，IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段。路由器从一种介质向具有较小 MTU 的另一种介质转发IPv4数据包时必须将它分片。</p><p>注意：选项和填充字段很少使用，因此不在本模块的介绍范围之内。</p><p><em><strong>8.2.3的视频描述wireshark中检测IPv4报头非常好！</strong></em></p><h2 id="IPv6数据包"><a href="#IPv6数据包" class="headerlink" title="*IPv6数据包"></a>*IPv6数据包</h2><p>IPv6它最终将取代 IPv4</p><p>多年来，为应对新的挑战，已经制定了附加议定书和规程。但是，尽管经历了多次变更，IPv4 仍然有三个重要问题：</p><ul><li><strong>IPv4地址耗尽 -</strong> IPv4 的可用唯一公有地址数量有限。尽管有大约 40 亿的 IPv4 地址，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li><li><strong>缺乏端到端连接 -</strong> 网络地址转换 (NAT) 是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li><li><strong>增加的网络复杂性</strong> - 虽然NAT延长了IPv4的寿命，但它只是作为一种过渡到IPv6的机制。NAT在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。</li></ul><p>IPv6 的功能提升包括以下：</p><ul><li><strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li><li><strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</li><li><strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</li></ul><p>32 位的 IPv4 地址空间提供大约 4,294,967,296 个地址。IPv6 地址空间提供 340,282,366,920,938,463,463,374,607,431,768,211,456 个或 340 涧（10 的 36 次方）个地址。这大致相当于地球上的每一粒沙子。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314235834424.png" alt="image-20210314235834424"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000426978.png" alt="image-20210315000426978"></p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000511899.png" alt="image-20210315000511899"><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000554634.png" alt="image-20210315000554634"></p><p>共40个八位组，8个报头字段</p><h1 id="遗漏知识"><a href="#遗漏知识" class="headerlink" title="*遗漏知识"></a>*遗漏知识</h1><h2 id="2-1-5终端仿真程序"><a href="#2-1-5终端仿真程序" class="headerlink" title="2.1.5终端仿真程序"></a>2.1.5终端仿真程序</h2><h2 id="2-3-8用Tera-Term连接控制台"><a href="#2-3-8用Tera-Term连接控制台" class="headerlink" title="2.3.8用Tera Term连接控制台"></a>2.3.8用Tera Term连接控制台</h2><h2 id="2-5-4捕获配置到文本中"><a href="#2-5-4捕获配置到文本中" class="headerlink" title="2.5.4捕获配置到文本中"></a>2.5.4捕获配置到文本中</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;警告：Cisco课程，不可用于商用&lt;/p&gt;
&lt;p&gt;因为我发现学这个课老是断断续续的，每次捡起来超级麻烦，所以趁这次来个大复习，把一些该有的知识点直接记下来好了&lt;/p&gt;
&lt;h1 id=&quot;1-当今网络&quot;&gt;&lt;a href=&quot;#1-当今网络&quot; class=</summary>
      
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="cisco" scheme="http://example.com/tags/cisco/"/>
    
  </entry>
  
  <entry>
    <title>ctf-misc</title>
    <link href="http://example.com/2021/03/14/ctf-misc/"/>
    <id>http://example.com/2021/03/14/ctf-misc/</id>
    <published>2021-03-13T16:34:29.000Z</published>
    <updated>2021-03-14T03:22:23.076Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="信息搜集技术"><a href="#信息搜集技术" class="headerlink" title="信息搜集技术"></a>信息搜集技术</h1><p>不科学上网的人不配做软工人（doge</p><p>善用谷歌搜索引擎，再不济用一个bing</p><p>还有很多好用的导航网站</p><h1 id="编码分析"><a href="#编码分析" class="headerlink" title="编码分析"></a>编码分析</h1><h2 id="通信领域"><a href="#通信领域" class="headerlink" title="通信领域"></a>通信领域</h2><h3 id="电话拨号编码"><a href="#电话拨号编码" class="headerlink" title="电话拨号编码"></a>电话拨号编码</h3><p>1-9 分别使用 1-9 个脉冲，0 则表示使用 10 个脉冲。</p><p>或者是信号DTMF decoding</p><h3 id="摩尔斯编码"><a href="#摩尔斯编码" class="headerlink" title="摩尔斯编码"></a>摩尔斯编码</h3><p><strong>特征特点</strong>：用点（.）和划（-）来编码范围<strong>0-9、A-Z</strong>的字符，字母不区分大小写，两个字母之间的空格用斜杠（/）或者三个点（.）或者一个划（-）表示，两个单词之间的间隔是七个点（.）。  根据摩斯编码的原理，CTF中也有出现过变种的摩斯编码，比如点（.）和划（-）用数字0和1来表示等此类变种的思路。  </p><p><strong>在线解密&amp;工具</strong>：  <a href="http://www.jb51.net/tools/morse.htm">http://www.jb51.net/tools/morse.htm</a> （编码的时候不转换空格） <a href="http://ctf.ssleye.com/morse.html">http://ctf.ssleye.com/morse.html</a> （编码的时候不转换空格）  <a href="http://rumkin.com/tools/cipher/morse.php">http://rumkin.com/tools/cipher/morse.php</a> （空格用斜杠表示）</p><h3 id="敲击码"><a href="#敲击码" class="headerlink" title="敲击码"></a>敲击码</h3><table><thead><tr><th align="left">Tap Code</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">A</td><td align="left">B</td><td align="left">C/K</td><td align="left">D</td><td align="left">E</td></tr><tr><td align="left">2</td><td align="left">F</td><td align="left">G</td><td align="left">H</td><td align="left">I</td><td align="left">J</td></tr><tr><td align="left">3</td><td align="left">L</td><td align="left">M</td><td align="left">N</td><td align="left">O</td><td align="left">P</td></tr><tr><td align="left">4</td><td align="left">Q</td><td align="left">R</td><td align="left">S</td><td align="left">T</td><td align="left">U</td></tr><tr><td align="left">5</td><td align="left">V</td><td align="left">W</td><td align="left">X</td><td align="left">Y</td><td align="left">Z</td></tr></tbody></table><p>先竖后横，工具👇</p><p><a href="http://ctf.ssleye.com/tapcode.html">http://ctf.ssleye.com/tapcode.html</a></p><h3 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h3><p>它用<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%A3%93">电压</a>的变化来分辨0和1，从高电平到低电平的跳变代表1，</p><p>而从低电平到高电平的跳变代表0（G.E.Tomas编码方式)。</p><p>从高电平到低电平的跳变代表0，</p><p>而从低电平到高电平的跳变代表1(IEEE 802.3编码方式)，</p><h3 id="差分曼切斯特"><a href="#差分曼切斯特" class="headerlink" title="*差分曼切斯特"></a>*差分曼切斯特</h3><p><a href="https://www.cnblogs.com/BinB-W/p/5045918.html">曼切斯特编码和差分曼切斯特编码 </a></p><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>循环二进制单位距离码</p><p>是任意两个相邻数的代码只有一位<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>数不同的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81">编码</a>，它与<a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D">奇偶校验码</a>同属<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%BC%96%E7%A0%81&action=edit&redlink=1">可靠性编码</a></p><p>编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码</p><table><thead><tr><th>十进制数</th><th>4位自然二进制码</th><th>4位典型格雷码</th><th>十进制余三格雷码</th><th>十进制空六格雷码</th><th>十进制跳六格雷码</th><th>步进码</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0000</td><td>0010</td><td>0000</td><td>0000</td><td>00000</td></tr><tr><td>1</td><td>0001</td><td>0001</td><td>0110</td><td>0001</td><td>0001</td><td>00001</td></tr><tr><td>2</td><td>0010</td><td>0011</td><td>0111</td><td>0011</td><td>0011</td><td>00011</td></tr><tr><td>3</td><td>0011</td><td>0010</td><td>0101</td><td>0010</td><td>0010</td><td>00111</td></tr><tr><td>4</td><td>0100</td><td>0110</td><td>0100</td><td>0110</td><td>0110</td><td>01111</td></tr><tr><td>5</td><td>0101</td><td>0111</td><td>1100</td><td>1110</td><td>0111</td><td>11111</td></tr><tr><td>6</td><td>0110</td><td>0101</td><td>1101</td><td>1010</td><td>0101</td><td>11110</td></tr><tr><td>7</td><td>0111</td><td>0100</td><td>1111</td><td>1011</td><td>0100</td><td>11100</td></tr><tr><td>8</td><td>1000</td><td>1100</td><td>1110</td><td>1001</td><td>1100</td><td>11000</td></tr><tr><td>9</td><td>1001</td><td>1101</td><td>1010</td><td>1000</td><td>1000</td><td>10000</td></tr><tr><td>10</td><td>1010</td><td>1111</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>11</td><td>1011</td><td>1110</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>12</td><td>1100</td><td>1010</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>13</td><td>1101</td><td>1011</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>14</td><td>1110</td><td>1001</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>15</td><td>1111</td><td>1000</td><td>—-</td><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><p>表中典型格雷码具有代表性。若不作特别说明，格雷码就是指<strong>典型格雷码</strong>，它可从自然二进制码转换而来。</p><p> <a href="http://www.ab126.com/system/2780.html">http://www.ab126.com/system/2780.html</a></p><h2 id="计算机相关"><a href="#计算机相关" class="headerlink" title="计算机相关"></a>计算机相关</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>变种是转成至多七位的二进制</p><p>还有就是十六进制</p><p><a href="http://www.ab126.com/goju/1711.html">http://www.ab126.com/goju/1711.html</a></p><h3 id="经典base"><a href="#经典base" class="headerlink" title="经典base"></a>经典base</h3><p><strong>1.base64</strong></p><p><strong>特征特点</strong>：密文由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个</p><p><strong>在线解密&amp;工具</strong>： <a href="http://ctf.ssleye.com/base64.html">http://ctf.ssleye.com/base64.html</a></p><p><strong>2. base32</strong></p><p><strong>特征特点</strong>：密文由32个字符（A-Z,2-7)组成，末尾可能会有‘=’，但最多有6个  <strong>在线解密&amp;工具</strong>： <a href="http://ctf.ssleye.com/base64.html">http://ctf.ssleye.com/base64.html</a></p><p><strong>3. base16</strong></p><p><strong>特征特点</strong>：密文由16个字符（0-9,A-F）组成  <strong>在线解密&amp;工具</strong>： <a href="http://ctf.ssleye.com/base64.html">http://ctf.ssleye.com/base64.html</a></p><p><strong>4. base36</strong></p><p><strong>特征特点</strong>：密文由36个字符（0-9,a-z）组成，加密仅支持整数数字，解密仅支持字符串，不支持中文  密文由36个字符（0-9,A-Z）  <strong>在线解密&amp;工具</strong>： <a href="http://ctf.ssleye.com/base36w.html">http://ctf.ssleye.com/base36w.html</a></p><p><strong>5. base58编码</strong></p><p><strong>特征特点</strong>：  Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+”和”/”符号  <strong>在线解密&amp;工具</strong>：  <a href="http://ctf.ssleye.com/base58w.html">http://ctf.ssleye.com/base58w.html</a></p><p><strong>6. base62编码</strong></p><p><strong>特征特点</strong>：密文由62字符（0-9，a-z，A-Z）组成  <strong>在线解密&amp;工具</strong>：  <a href="https://base62.io/%EF%BC%88%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%EF%BC%89">https://base62.io/（支持中文）</a>  <a href="http://decode-base62.nichabi.com/">http://decode-base62.nichabi.com</a>  <a href="http://ctf.ssleye.com/base62.html%EF%BC%88%E4%BB%85%E6%94%AF%E6%8C%81%E6%95%B0%E5%AD%97%EF%BC%89">http://ctf.ssleye.com/base62.html（仅支持数字）</a></p><p><strong>7. base91编码</strong></p><p><strong>特征特点</strong>：密文由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~”）组成  <strong>在线解密&amp;工具</strong>：  <a href="http://ctf.ssleye.com/base91.html">http://ctf.ssleye.com/base91.html</a></p><p><a href="https://bugwz.com/2019/11/18/baseX/#%E4%B8%83-base91">大佬解析原理</a></p><h3 id="霍夫曼"><a href="#霍夫曼" class="headerlink" title="霍夫曼"></a>霍夫曼</h3><p><strong>霍夫曼编码</strong>（英语：Huffman Coding），又译为<strong>哈夫曼编码</strong>、<strong>赫夫曼编码</strong>是一种用于<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E6%8D%9F%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9">无损数据压缩</a>的<a href="https://zh.wikipedia.org/wiki/%E7%86%B5%E7%BC%96%E7%A0%81">熵编码</a>（权编码）<a href="https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95">算法</a>。</p><p>根据出现概率和期望来编码字符并进行压缩</p><p>卧槽，这是数据结构啊。。。</p><h3 id="XXencoding"><a href="#XXencoding" class="headerlink" title="XXencoding"></a>XXencoding</h3><p>XXencode 将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有 24 个 Bit，以 6bit 为单位分为 4 个组，每个组以十进制来表示所出现的数值只会落在 0 到 63 之间。以所对应值的位置字符代替。</p><p>原理：<a href="http://blog.chacuo.net/778.html">http://blog.chacuo.net/778.html</a></p><p>工具： <a href="http://web.chacuo.net/charsetxxencode">http://web.chacuo.net/charsetxxencode</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跟base64打印字符相比，就是XXencode多一个“-” 字符，少一个”&#x2F;” 字符。</span><br></pre></td></tr></table></figure><h3 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h3><p>又称百分号编码</p><p>参见<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81"> URL 编码 - 维基百科</a>。</p><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>万国编码</p><p>参见<a href="https://zh.wikipedia.org/wiki/Unicode"> Unicode - 维基百科</a>。</p><p>注意，它有四种表现形式。</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]: <code>The</code></p><p>&amp;# [Decimal]: <code>The</code></p><p>\U [Hex]: <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]: <code>\U+0054\U+0068\U+0065</code></p><h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><h3 id="条形码"><a href="#条形码" class="headerlink" title="条形码"></a>条形码</h3><ul><li>宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符</li><li>国际标准</li><li>EAN-13 商品标准，13 位数字</li><li>Code-39：39 字符</li><li>Code-128：128 字符</li><li><a href="https://online-barcode-reader.inliteresearch.com/">条形码/二维码在线识别</a></li></ul><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/qr2.jpg" alt="img"></p><h2 id="取证隐写前置"><a href="#取证隐写前置" class="headerlink" title="取证隐写前置"></a>取证隐写前置</h2><p>检查一个静态数据文件从而获取隐藏信息</p><ol><li>了解常见编码</li><li>利用脚本语言如python操作二进制数据</li><li>熟知常见文件的文件格式，尤其是各类 <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">文件头</a>、协议、结构等</li><li>运用工具</li></ol><p>卧槽，我是废物。。<a href="https://ctf-wiki.org/misc/prefix/">https://ctf-wiki.org/misc/prefix/</a></p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>​    识别文件格式的第二种方法是<em>使用</em>有关存储在文件本身内部的格式的信息，或者为此目的而准备的信息，或者是<a href="https://en.wikipedia.org/wiki/String_(computer_science)#Non-text_strings">二进制字符串</a>，这些<a href="https://en.wikipedia.org/wiki/String_(computer_science)#Non-text_strings">字符串</a>总是位于某些格式的文件中的特定位置。由于最容易找到它们的位置是在开头，因此当该区域大于几个<a href="https://en.wikipedia.org/wiki/Byte">字节时</a>，通常将其称为<em>文件头</em>；如果长度只有几个<a href="https://en.wikipedia.org/wiki/Byte">字节</a>，则将其称为<em>幻数</em>。</p><p>​    <a href="https://en.wikipedia.org/wiki/Header_(computing)">文件头</a>中包含的元数据通常存储在文件的开头，但也可能存在于其他区域中，通常包括结尾，具体取决于文件格式或所包含数据的类型。基于字符的（文本）文件通常具有基于字符的标头，而二进制格式通常具有二进制标头</p><p>​    文件头还可以包含有关文件及其内容的元数据。例如，大多数<a href="https://en.wikipedia.org/wiki/Image_file_formats">图像文件都</a>存储有关图像格式，大小，分辨率和<a href="https://en.wikipedia.org/wiki/Color_space">色彩空间的信息</a></p><p>**    <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">维基百科常见文件签名</a>**</p><p><a href="https://www.tooleyes.com/app/hex_editor.html">工具</a></p><h3 id="Python-struct模块。。"><a href="#Python-struct模块。。" class="headerlink" title="Python struct模块。。"></a>Python struct模块。。</h3><p>。。。有工具是不是可以先不学</p><p>file命令</p><p>strings命令打印可打印字符</p><p>打印文件中可打印的字符，经常用来发现文件中的一些提示信息或是一些特殊的编码信息，常常用来发现题目的突破口。</p><ul><li><p>可以配合 <code>grep</code> 命令探测指定信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings test|grep -i XXCTF</span><br></pre></td></tr></table></figure></li><li><p>也可以配合 <code>-o</code> 参数获取所有 ASCII 字符偏移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root in ~/Desktop/tmp λ strings -o flag|head</span><br><span class="line">    14 IHDR</span><br><span class="line">    45 gAMA</span><br><span class="line">    64  cHRM</span><br><span class="line">    141 bKGD</span><br><span class="line">    157 tIME</span><br><span class="line">    202 IDATx</span><br><span class="line">    223 NFdVK3</span><br><span class="line">    361 |;*-</span><br><span class="line">    410 Ge%&lt;W</span><br><span class="line">    431 5duX@%</span><br></pre></td></tr></table></figure></li></ul><p>`binwalk` 命令</p><p>binwalk 本是一个固件的分析工具，比赛中常用来发现多个文件粘合再在一起的情况。根据文件头去识别一个文件中夹杂的其他文件，有时也会存在误报率（尤其是对 Pcap 流量包等文件时）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root in ~&#x2F;Desktop&#x2F;tmp λ binwalk flag</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             PNG image, 450 x 450, 8-bit grayscale, non-interlaced</span><br><span class="line">134           0x86            Zlib compressed data, best compression</span><br><span class="line">25683         0x6453          Zip archive data, at least v2.0 to extract, compressed size: 675, uncompressed size: 1159, name: readme.txt</span><br><span class="line">26398         0x671E          Zip archive data, at least v2.0 to extract, compressed size: 430849, uncompressed size: 1027984, name: trid</span><br><span class="line">457387        0x6FAAB         End of Zip archive</span><br></pre></td></tr></table></figure><p>配合 <code>-e</code> 参数可以进行自动化提取。</p><p>也可以结合 <code>dd</code> 命令进行手动切割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root in ~&#x2F;Desktop&#x2F;tmp λ dd if&#x3D;flag of&#x3D;1.zip bs&#x3D;1 skip&#x3D;25683</span><br><span class="line">431726+0 records in</span><br><span class="line">431726+0 records out</span><br><span class="line">431726 bytes (432 kB, 422 KiB) copied, 0.900973 s, 479 kB&#x2F;s</span><br></pre></td></tr></table></figure><h3 id="010-Editor使用"><a href="#010-Editor使用" class="headerlink" title="010 Editor使用"></a>010 Editor使用</h3><p>SweetScape 010 Editor 是一个全新的十六进位文件编辑器，它有别于传统的十六进位编辑器在于它可用「范本」来解析二进位文件，从而让你读懂和编辑它。它还可用来比较一切可视的二进位文件。</p><p>利用它的模板功能可以非常轻松的观察文件内部的具体结构并且依此快速更改内容。</p><p>[教程](<a href="https://blog.csdn.net/weixin_42417767/article/details/81227166">7.23 010Editor.exe的使用_duan哥哥的博客-CSDN博客</a>)</p><h2 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h2><p>元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（Data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。</p><p>全都不会，心态炸了</p>]]></content>
    
    
    <summary type="html">misc-basic</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="misc" scheme="http://example.com/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>ctf-learn</title>
    <link href="http://example.com/2021/03/13/ctf-learn/"/>
    <id>http://example.com/2021/03/13/ctf-learn/</id>
    <published>2021-03-13T12:56:31.000Z</published>
    <updated>2021-03-14T09:57:38.502Z</updated>
    
    <content type="html"><![CDATA[<p>3.13</p><p>学习了最基础的http协议和misc的部分知识。。。</p><p>主要看了常用的编码和特征。</p><p>激活一个010 editor但是还不会用，有一个在线工具可以帮忙查看文件名。</p><p>CTFhub里的工具好多啊</p><p>明天可以多肝一会，基础的肝完我就开始钻web咯</p><p>3.14</p><p>今天刷网络基础去了，不过顺便学了点wireshark嘿嘿</p><p>那道希希题发现后面藏了个vmdk文件，但是弄出来竟然读取不了？</p><p>作者把文件头顺序改乱了，改回来还是不行。。</p>]]></content>
    
    
    <summary type="html">Start to learn ctf</summary>
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="ctf-general" scheme="http://example.com/tags/ctf-general/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://example.com/2021/03/13/http/"/>
    <id>http://example.com/2021/03/13/http/</id>
    <published>2021-03-13T12:51:18.000Z</published>
    <updated>2021-03-13T12:55:04.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>[toc]</p><h2 id="几个知识"><a href="#几个知识" class="headerlink" title="几个知识"></a>几个知识</h2><p>http2已经越来越普及：</p><p>二进制编码报文，仍采用TCP，分为若干个帧，来加快传输</p><p>HPACK算法压缩大量重复的http头</p><p>用服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间</p><p>http-&gt;SPDY-&gt;舍弃-&gt;http2.0-&gt;http2</p><p>HTTPS完全在TLS之上搭载HTTP，因此可以对整个基础HTTP协议进行加密</p><p>有大致相同的语法，</p><p><strong>MDN Web Docs</strong>，以前是<strong>Mozilla开发人员网络</strong>，以前是<strong>Mozilla开发人员中心</strong>，是<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>，<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft</a>，<a href="https://en.wikipedia.org/wiki/Google">Google</a>和<a href="https://en.wikipedia.org/wiki/Samsung">Samsung</a>使用的Web开发人员的文档资料库和学习资源。该项目由<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>于2005年启动[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-MitchellBlog-2">2]</a>，是有关开放式Web标准，Mozilla自己的项目和开发人员指南的统一场所。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-3">3]</a>在2017年，微软，谷歌和三星宣布将关闭自己的文档项目，并将所有文档移至MDN Web Docs。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-:0-4">4]</a></p><p>MDN Web文档的内容由Mozilla和Google的员工和志愿者（开发人员和技术作家的社区）维护。主题包括<a href="https://en.wikipedia.org/wiki/HTML5">HTML5</a>，<a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>，<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>，<a href="https://en.wikipedia.org/wiki/Web_API">Web API</a>，<a href="https://en.wikipedia.org/wiki/Django_(web_framework)">Django</a>，<a href="https://en.wikipedia.org/wiki/Node.js">Node.js</a>，<a href="https://en.wikipedia.org/wiki/WebExtension">WebExtensions</a>，<a href="https://en.wikipedia.org/wiki/MathML">MathML</a>等。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-5">5]</a></p><p>TCP是<a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">面向连接的</a>，并且可以在发送数据之前在客户端和服务器之间建立连接。建立连接之前，服务器必须正在侦听（被动打开）来自客户端的连接请求。三向握手（主动打开），<a href="https://en.wikipedia.org/wiki/Retransmission_(data_networks)">重传</a>和错误检测可增加可靠性，但会延长<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">等待时间</a>。不需要可靠<a href="https://en.wikipedia.org/wiki/Data_stream">数据流</a>服务的应用程序可以使用<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">用户数据报协议</a>（UDP），该<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">协议</a>提供无<a href="https://en.wikipedia.org/wiki/Connectionless_communication">连接</a> <a href="https://en.wikipedia.org/wiki/Datagram">数据报</a>服务，该服务优先考虑时间而不是可靠性。TCP采用<a href="https://en.wikipedia.org/wiki/TCP_congestion_control">避免网络拥塞的方法</a>。但是，TCP存在一些漏洞，包括<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">拒绝服务</a>，<a href="https://en.wikipedia.org/wiki/TCP_sequence_prediction_attack">连接劫持</a>，TCP否决权和<a href="https://en.wikipedia.org/wiki/TCP_reset_attack">重置攻击</a>。</p><p><strong>握手</strong>是在通信电路建立之后，信息传输开始之前。 握手用于达成参数，如信息传输率，字母表，奇偶校验， 中断过程，和其他协议特性。TCP三握手：</p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN—SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=i+j)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN—RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包．向服务器发送确认包ACK(ack=k+1)．此包发送完毕．客户端和服务器进入ESTABI．ISHED状态。完成三次握手。完成三次握手．客户端与服务器开始传送数据 [1]</p><h2 id="标识互联网内容"><a href="#标识互联网内容" class="headerlink" title="标识互联网内容"></a>标识互联网内容</h2><p>每个资源都由一个 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URI">URI</a>) 来进行标识。</p><p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p><p>URI 的最常见形式是统一资源定位符 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">URL</a>)，它也被称为 <em>Web 地址</em>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org</span><br><span class="line">https://developer.mozilla.org/en-US/docs/Learn/</span><br><span class="line">https://developer.mozilla.org/en-US/search?q=URL</span><br></pre></td></tr></table></figure><p>URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urn:isbn:9780141036144</span><br><span class="line">urn:ietf:rfc:7230</span><br></pre></td></tr></table></figure><h3 id="URI语法"><a href="#URI语法" class="headerlink" title="URI语法"></a>URI语法</h3><ol><li><p>“://“前是方案或协议</p><p><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">websocket协议</a>全双工的兼容http的协议</p><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">data</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URIs</a></td></tr><tr><td align="left">file</td><td align="left">指定主机上文件的名称</td></tr><tr><td align="left">ftp</td><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/FTP">文件传输协议</a></td></tr><tr><td align="left">http/https</td><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">超文本传输协议／安全的超文本传输协议</a></td></tr><tr><td align="left">mailto</td><td align="left">电子邮件地址</td></tr><tr><td align="left">ssh</td><td align="left">安全 shell</td></tr><tr><td align="left">tel</td><td align="left">电话</td></tr><tr><td align="left">urn</td><td align="left">统一资源名称</td></tr><tr><td align="left">view-source</td><td align="left">资源的源代码</td></tr><tr><td align="left">ws/wss</td><td align="left">（加密的） <a href="https://developer.mozilla.org/zh-CN/docs/WebSockets">WebSocket</a> 连接</td></tr></tbody></table></li><li><p>“//到:之间的域名”</p><p>这既是域名，也代表管理域名的机构，指示了一台主机</p></li><li><p>”：xx“是端口</p><p>它表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p></li><li><p>后面跟着一串路径</p></li><li><p>查询字符串</p><p><code>?key1=value1&amp;key2=value2</code> 是提供给 Web 服务器的额外参数。这些参数是用 &amp; 符号分隔的键/值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。</p></li><li><p>片段</p><p><code>#SomewhereInTheDocument</code> 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p></li></ol><h3 id="Data-URLs"><a href="#Data-URLs" class="headerlink" title="Data URLs"></a>Data URLs</h3><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、如果非文本则为可选的<code>base64</code>标记、数据本身：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line">mediatype `是个 MIME 类型的字符串，例如 &quot;`image/jpeg`&quot; 表示 JPEG 图像文件。如果被省略，则默认值为 `text/plain;charset=US-ASCII</span><br></pre></td></tr></table></figure><p>有很多问题：</p><ol><li>语法容易出错</li><li>html代码若转化成base64可能有问题</li><li>长度限制</li><li>缺乏错误处理</li><li>不支持查询字符串</li></ol><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><p><strong>媒体类型</strong>（通常称为 <strong>Multipurpose Internet Mail Extensions</strong> 或 <strong>MIME</strong> 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在<a href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>中进行了定义和标准化。</p><p>互联网号码分配机构（<a href="https://www.iana.org/">IANA</a>）是负责跟踪所有官方MIME类型的官方机构，您可以在<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">媒体类型</a>页面中找到最新的完整列表。</p><p><strong>重要：</strong>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><p>type/subtype  </p><p>独立（离散）类型/子类型</p><ul><li><p><code>application</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#application">在IANA上列出</a></p><p>没有明确属于其他类型之一的任何类型的二进制数据；或者将以某种方式执行或解释的数据，或者需要特定应用程序或应用程序类别使用的二进制数据。通用二进制数据（或真实类型未知的二进制数据）为<code>application/octet-stream</code>。其他常见的例子包括<code>application/pdf</code>， <code>application/pkcs8</code>，和<code>application/zip</code>。</p></li><li><p><code>audio</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio">在IANA上列出</a></p><p>音频或音乐数据。例子包括<code>audio/mpeg</code>， <code>audio/vorbis</code>。</p></li><li><p><code>example</code></p><p>保留用作展示如何使用MIME类型的示例中的占位符。这些代码绝对不能在示例代码清单和文档之外使用。 <code>example</code>也可以用作子类型；例如，在一个与在Web上处理音频有关的示例中，MIME类型<code>audio/example</code>可用于指示该类型是占位符，并且在现实世界中使用代码时应使用适当的占位符替换。</p></li><li><p><code>font</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#font">在IANA上列出</a></p><p>字体/字体数据。常见的例子包括<code>font/woff</code>， <code>font/ttf</code>，和<code>font/otf</code>。</p></li><li><p><code>image</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#image">在IANA上列出</a></p><p>图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本，例如动画<a href="https://developer.mozilla.org/en-US/docs/Glossary/gif">GIF</a>或APNG。常见的例子是<code>image/jpeg</code>，<code>image/png</code>和 <code>image/svg+xml</code>。</p></li><li><p><code>model</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#model">在IANA上列出</a></p><p>3D对象或场景的模型数据。示例包括<code>model/3mf</code>和 <code>model/vml</code>。</p></li><li><p><code>text</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#text">在IANA上列出</a></p><p>纯文本数据，包括任何人类可读的内容，源代码或文本数据，例如逗号分隔值（CSV）格式的数据。实例包括 <code>text/plain</code>，<code>text/csv</code>，和<code>text/html</code>。</p></li><li><p><code>video</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video">在IANA上列出</a></p><p>视频数据或文件，例如MP4电影（<code>video/mp4</code>）。</p></li></ul><p>对于没有特定子类型的文本文档，<code>text/plain</code>应使用。同样，对于没有特定或已知子类型的二进制文件， <code>application/octet-stream</code>应使用。</p><p><strong>多部分</strong>类型表示文档的分类，通常分为不同的MIME类型。它们也可以用来表示多个独立的文件，尤其是在电子邮件场景中，这些文件都是同一笔交易的一部分。它们代表一个<strong>复合文档</strong>。</p><p>除了<code>multipart/form-data</code>用于 <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML Forms</a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST"><code>POST</code></a>方法中的和用于发送文档的一部分外，HTTP不会以特殊方式处理多部分文档：消息会传输到浏览器（可能会显示“另存为”窗口（如果它不知道如何显示文档）。<code>multipart/byteranges</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> <code>Partial Content</code></p><p>有两种多部分类型：</p><ul><li><p><code>message</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">在IANA上列出</a></p><p>包含其他消息的消息。例如，它可以用来表示包含转发的消息作为其数据一部分的电子邮件，或者允许以块的形式发送非常大的消息，就像它是多条消息一样。示例包括<code>message/rfc822</code>（用于转发或回复的消息引用），并 <code>message/partial</code>允许将大消息分解为较小的消息，以便收件人自动进行重组。</p></li><li><p><code>multipart</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">在IANA上列出</a></p><p>由多个组件组成的数据，这些组件可能分别具有不同的MIME类型。示例包括<code>multipart/form-data</code>（对于使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a>API生成的数据）和<code>multipart/byteranges</code>（在<a href="https://tools.ietf.org/html/rfc7233">RFC 7233：5.4.1中</a>定义 ），并与<a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> “部分内容”响应一起使用，当获取的数据仅是内容的一部分（例如使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"><code>Range</code></a>标头传递的内容）时返回）。</p></li></ul><p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#%E9%87%8D%E8%A6%81%E7%9A%84mime%E7%B1%BB%E5%9E%8B">常用的</a></strong></em>*</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">常见MIME类型列表</a></p><p>很多web服务器使用默认的 <code>application/octet-stream</code> 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，导致用户必须存储到本地以使用。常见的导致服务器配置错误的文件类型如下所示：</p><ul><li>RAR编码文件。在这种情况，理想状态是，设置真实的编码文件类型；但这通常不可能（可能是服务器所未知的类型或者这个文件包含许多其他的不同的文件类型）。这这种情况服务器将发送 <code>application/x-rar-compressed</code> 作为MIME类型，用户不会将其定义为有用的默认操作。</li><li>音频或视频文件。只有正确设置了MIME类型的文件才能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">``</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">``</a> 识别和播放。 可参照  <a href="https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements">use the correct type for audio and video</a>。</li><li>专有文件类型。是专有文件时需要特别注意。使用 <code>application/octet-stream</code> 作为特殊处理是不被允许的：对于一般的MIME类型浏览器不允许定义默认行为（比如“在Word中打开”）</li></ul><p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 来设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> 以阻止MIME嗅探。</p><p>MIME类型不是传达文档类型信息的唯一方式：</p><ul><li>有时会使用名称后缀，特别是在Microsoft Windows系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是Linux和Mac OS），并且像外部MIME类型一样，不能保证它们是正确的。</li><li>魔术数字。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个GIF文件以47 49 46 38十六进制值[GIF89]或89 50 4E 47 [.PNG]的PNG文件开头。 并非所有类型的文件都有幻数，所以这也不是100％可靠的方式。</li></ul><h3 id="选择www吗"><a href="#选择www吗" class="headerlink" title="选择www吗"></a>选择www吗</h3><p>一个服务器不一定是一个独立的物理机：几台服务器可以驻留在同一台物理机器上，或者一台服务器可以通过几台机器进行处理，协作处理并响应或负载均衡它们之间的请求。关键点在于语义上<strong>一个域名代表一个单独的服务器</strong>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Choosing_between_www_and_non-www_URLs">两种设定非官方网站的方法</a>：HTTP301 和&lt;link rel =”canonical”</p><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>![概念图](<a href="https://mdn.mozillademos.org/files/13673/HTTP">https://mdn.mozillademos.org/files/13673/HTTP</a> &amp; layers.png)</p><p>ps:TLS是传输层安全协议，建立在TCP之上</p><p>HTTP被设计于20世纪90年代初期，是一种可扩展的协议。它是应用层的协议，通过<a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP">TCP</a>，或者是<a href="https://developer.mozilla.org/en-US/docs/Glossary/TLS">TLS</a>－加密的TCP连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。</p><p>实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 …）发起请求来获取部分或全部资源。</p><p>Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a>头部中，它们甚至可以共享同一个IP地址。</p><h3 id="代理（Proxies）（这是思科学的东西吧）"><a href="#代理（Proxies）（这是思科学的东西吧）" class="headerlink" title="代理（Proxies）（这是思科学的东西吧）"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#%E4%BB%A3%E7%90%86%EF%BC%88proxies%EF%BC%89">代理（Proxies）（这是思科学的东西吧）</a></h3><p>在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为<strong>代理（Proxies）</strong>。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用：</p><ul><li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li><li>过滤（像反病毒扫描，家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（对不同资源进行权限管理）</li><li>日志记录（允许存储历史信息）</li></ul><p>http简单，可扩展，无状态有会话</p><h3 id="HTTP-是无状态，有会话的"><a href="#HTTP-是无状态，有会话的" class="headerlink" title="HTTP 是无状态，有会话的"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84">HTTP 是无状态，有会话的</a></h3><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p><p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p><p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误），HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p><p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议<em><a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>。</em></p><h3 id="HTTP-能控制什么"><a href="#HTTP-能控制什么" class="headerlink" title="HTTP 能控制什么"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E8%83%BD%E6%8E%A7%E5%88%B6%E4%BB%80%E4%B9%88">HTTP 能控制什么</a></h3><p>多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。</p><p>以下是可以被HTTP控制的常见特性。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">缓存 </a><br>文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。</li><li><em>开放同源限制</em><br>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于<strong>相同来源</strong>的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。</li><li><em>认证</em><br>一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authenticate"><code>Authenticate</code></a>相似的头部即可，或用HTTP Cookies来设置指定的会话。</li><li><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling">代理和隧道</a></em><br>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。</li><li><em>会话</em><br>使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。</li></ul><p>当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的 <strong>帧 </strong>所取代。</p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。</p><p>即使HTTP/2为了提高性能将HTTP报文嵌入到帧中这一举措增加了复杂度，但是从Web应用的角度看，报文的基本结构没有变化，从HTTP/1.0发布起就是这样的结构。会话流依旧简单，通过一个简单的 <a href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">HTTP message monitor</a>就可以查看和纠错。</p><p>请求由以下元素组成：</p><ul><li>一个HTTP的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">method</a>，经常是由一个动词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 或者一个名词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML form</a>表单值（POST方法），虽然在一些情况下也会有其他操作。</li><li>要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有<a href="https://developer.mozilla.org/en-US/docs/Glossary/Protocol">protocol</a> （<code>http://</code>），<a href="https://developer.mozilla.org/en-US/docs/Glossary/Domain">domain</a>（<code>developer.mozilla.org</code>），或是TCP的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port</a>（HTTP一般在80端口）。</li><li>HTTP协议版本号。</li><li>为服务端表达其他信息的可选头部<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>。</li><li>对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。</li></ul><p>响应报文包含了下面的元素：</p><ul><li>HTTP协议版本号。</li><li>一个状态码（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li><li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li><li>HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>，与请求头部类似。</li><li>可选项，比起请求报文，响应报文中更常见地包含获取的资源body。</li></ul><h3 id="基于HTTP的APIs"><a href="#基于HTTP的APIs" class="headerlink" title="基于HTTP的APIs"></a>基于HTTP的APIs</h3><p>基于HTTP的最常用API是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API，可用于在<a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent">user agent</a>和服务器之间交换数据。 现代<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API"><code>Fetch API</code></a>提供相同的功能，具有更强大和灵活的功能集。双工</p><p>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a>接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a>对象，并将它们传递给专门处理这类<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/type"><code>type</code></a>事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage"><code>onmessage</code> (en-US)</a>事件处理程序处理</p><h2 id="HTTP信息"><a href="#HTTP信息" class="headerlink" title="HTTP信息"></a>HTTP信息</h2><p>HTTP消息由采用ASCII编码的多行文本构成。在HTTP/1.1及早期版本中，这些消息通过连接公开地发送。在HTTP/2中，为了优化和性能方面的改进，曾经可人工阅读的消息被分到多个HTTP帧中。</p><p>Web 开发人员或网站管理员，很少自己手工创建这些原始的HTTP消息︰ 由软件、浏览器、 代理或服务器完成。他们通过配置文件（用于代理服务器或服务器），API （用于浏览器）或其他接口提供HTTP消息</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsg2.png" alt="From a user-, script-, or server- generated event, an HTTP/1.x msg is generated, and if HTTP/2 is in use, it is binary framed into an HTTP/2 stream, then sent."></p><p>HTTP/2二进制框架机制被设计为不需要改动任何API或配置文件即可应用︰ 它大体上对用户是透明的。</p><p>HTTP 请求和响应具有相似的结构，由以下部分组成︰</p><ol><li>一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</li><li>一个可选的HTTP头集合指明请求或描述消息正文。</li><li>一个空行指示所有关于请求的元数据已经发送完毕。</li><li>一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。</li></ol><p>起始行和 HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsgStructure2.png" alt="Requests and responses share a common structure in HTTP"></p><p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages#http_%E8%AF%B7%E6%B1%82">HTTP请求详细在这里</a></strong></em></p><p>HTTP/1.x 报文有一些性能上的缺点：</p><ul><li>Header 不像 body，它不会被压缩。</li><li>两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。</li><li>无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。</li></ul><p>HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 <em>多路复用 (multiplexing)</em> 的过程，它允许更有效的底层 TCP 连接。</p><p>热连接就是活跃的连接，冷连接应该是指新连接的意思。因为 TCP 接连建立需要一定的耗时，还要握手，所以 HTTP 应用保持长连接的话，就可以在多个请求之间复用一个 TCP 连接，这样只需要一次连接和握手，从而大幅度提高资源的加载速度。</p><p>从 HTTP1.1 开始，长连接和多路复用就就已经被主流浏览器支持，但是某些网站或者不标准的客户端，还是会在一次请求完成之后关闭连接，变成短连接，从而造成资源的浪费。一般来说，请求头或者响应头字段 Connection: keep-alive 用来告诉另一方自己希望保持连接，并持续复用，直到服务器设定的超时限制达到，或者客户端认为所有资源已经加载完成并主动断开连接。</p><p>HTTP2 则在原有长连接和多路复用的基础上，实现了头部压缩和封包发送，以及无序请求-响应模型。HTTP1 的多路复用必须等待前一个请求完成才发送下一个请求，这造成了同步阻塞的问题，而 HTTP2 解决了这个问题，客户端给每一个请求打上序号发给服务器，服务器响应时返回这个序号，客户端就知道这个响应属于那个请求，从而实现了无序异步的多路复用，大大提高了客户端的并发能力并加快了资源的加载。同时 HTTP1 客户端还会在检测当前连接拥塞（被前一个连接长时占用）时开新连接加载其他资源。而HTTP2因为无需等待，则可以永远复用一个连接，减少了连接资源的消耗。–A-yon知乎</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/Binary_framing2.png" alt="HTTP/2 modify the HTTP message to divide them in frames (part of a single stream), allowing for more optimization."></p><h2 id="HTTTP-1-x-连接管理"><a href="#HTTTP-1-x-连接管理" class="headerlink" title="HTTTP/1.x 连接管理"></a>HTTTP/1.x 连接管理</h2><p><em>短连接</em>, <em>长连接</em>, 和 <em>HTTP 流水线。</em></p><p>都有很多问题，还有莫名诡异的域名分片</p><p>好像http2中解决了很多很多的问题</p><p>自己看吧</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</a></p><h2 id="HTTP内容协商"><a href="#HTTP内容协商" class="headerlink" title="HTTP内容协商"></a>HTTP内容协商</h2><p>在 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a> 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如，文档使用的自然语言，图片的格式，或者内容编码形式）。</p><p>注意：HTTP内容协商的一些不好的地方在这篇文章中有介绍<a href="https://wiki.whatwg.org/wiki/Why_not_conneg">a wiki page from WHATWG</a>，HTML5提供其他的选择来进行内容协商，如<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source">source&gt; element</a>。</p><p>这个功能好复杂，知道有就好了。。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation</a></p><h2 id="HTTP发展"><a href="#HTTP发展" class="headerlink" title="HTTP发展"></a>HTTP发展</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></p><h2 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h2><p>非常方便的，可由服务器端或者客户端发起的协议升级</p><p>不要看他下面的中文翻译。。。错得离谱</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism</a></p><h2 id="MDN暂时没有"><a href="#MDN暂时没有" class="headerlink" title="MDN暂时没有"></a>MDN暂时没有</h2><p>http会话流程</p><p>HTTP/2中的帧结构</p><p>HTTP/2连接管理</p><p>商定http版本</p>]]></content>
    
    
    <summary type="html">web-between-first</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="http://example.com/2021/03/13/css/"/>
    <id>http://example.com/2021/03/13/css/</id>
    <published>2021-03-13T12:51:04.000Z</published>
    <updated>2021-03-14T06:31:47.973Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h1><p>在MDN上每个属性都有单独的页面，不论你是忘记了某个属性，还是想要知道一个属性还能接受什么其它的值，这些页面都可以帮助你。</p><p><strong>注意</strong>：在MDN上的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference">CSS reference</a> 页面列举了所有的 CSS属性页面（同时也包括其它的CSS特性）。 另外，当你想要寻找一个CSS特性的更多内容时，多使用你的搜索引擎来搜索 “mdn <em>css-feature-name</em>“ 。例如，搜索 “mdn color” 和 “mdn font-size”！</p><p>查看特性的实现状态(implementation status)是非常有用的。在 MDN 上的每个属性的页面中都标有它们对应的状态，你可以通过这种方法来查看你是否可以去使用它。</p><p><strong>重要事项：</strong>如果属性未知或某个值对给定属性无效，则声明被视为无效，并被浏览器的CSS引擎完全忽略。</p><p><strong>重要：</strong>在CSS(和其他网络标准)中，当语言表达存在不确定性时，美国的拼写被视作公认的标准。例如，颜色应该始终拼写为color。colour是不起作用的。</p><p>虽然大多数值是相对简单的关键字或数值，但也有一些可能的值以函数的形式出现。一个例子是calc()函数。这个函数允许您在CSS中进行简单的计算，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width: calc(90% - 30px);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(0.8turn);</span><br></pre></td></tr></table></figure><p>一个函数由函数名和一些括号组成，其中放置了该函数的允许值。在上面的calc()示例中，我要求此框的宽度为包含块宽度的90%，减去30像素。这不是我可以提前计算的东西，只是在CSS中输入值，因为我不知道90%会是什么。与所有值一样，MDN上的相关页面将有使用示例，这样您就可以看到函数是如何工作的。</p><h2 id="构建CSS"><a href="#构建CSS" class="headerlink" title="构建CSS"></a>构建CSS</h2><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E8%A7%84%E5%88%99">@规则</a></h3><p>到目前为止，我们还没有遇到 <code>@rules</code> (pronounced “at-rules”). 这是一些特殊的规则，为 CSS提供了一些关于如何表现的指导。 有些<code>@rules</code> 规则很简单，有规则名和值。例如，要将额外的样式表导入主CSS样式表，可以使用<code>@import</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;styles2.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>您将遇到的最常见的 <code>@rules</code> 之一是@media，它允许您使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries">媒体查询 </a>来应用CSS，仅当某些条件成立(例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时)。</p><p>在下面的 CSS中，我们将给 <code>&lt;body&gt;</code> 元素一个粉红色的背景色。但是，我们随后使用@media创建样式表的一个部分，该部分仅适用于视口大于30em的浏览器。如果浏览器的宽度大于30em，则背景色将为蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">30em</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="速记属性"><a href="#速记属性" class="headerlink" title="速记属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E9%80%9F%E8%AE%B0%E5%B1%9E%E6%80%A7">速记属性</a></h3><p>一些属性，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 等属性称为速记属性–这是因为它们允许您在一行中设置多个属性值，从而节省时间并使代码更整洁。</p><p><strong>Warning</strong>: One less obvious aspect of using CSS shorthand is how omitted values reset. A value not specified in CSS shorthand reverts to its initial value. This means an omission in CSS shorthand can <strong>override previously set values</strong>.</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>您选择的代码布局通常是个人偏好，尽管当您开始在团队中工作时，您可能会发现现有团队有自己的样式指南，指定要遵循的约定。　</p><p>如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。</p><p>相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个CSS选择器。</p><p>这样做好处多多，代表着你使用最新的CSS优化的过程中浏览器遇到无法解析的规则也不会报错。当你为一个元素指定多个CSS样式的时候，浏览器会加载样式表中的最后的CSS代码进行渲染（样式表，优先级等请读者自行了解），也正因为如此，你可以为同一个元素指定多个CSS样式来解决有些浏览器不兼容新特性的问题（比如指定两个<code>width</code>）。</p><p>这一特点在你想使用一个很新的CSS特性但是不是所有浏览器都支持的时候（浏览器兼容）非常有用，举例来说，一些老的浏览器不接收<code>calc()</code>(calculate的缩写，CSS3新增，为元素指定动态宽度、长度等，注意此处的动态是计算之后得一个值)作为一个值。我可能使用它结合像素为一个元素设置了动态宽度（如下），老式的浏览器由于无法解析忽略这一行；新式的浏览器则会把这一行解析成像素值，并且覆盖第一行指定的宽度。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a></li></ul><h1 id="CSS构建"><a href="#CSS构建" class="headerlink" title="CSS构建"></a>CSS构建</h1><p>开始进入真正学习</p><h2 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h2><p>同级后者优先</p><h3 id="控制继承"><a href="#控制继承" class="headerlink" title="控制继承"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E6%8E%A7%E5%88%B6%E7%BB%A7%E6%89%BF">控制继承</a></h3><p>CSS 为控制继承提供了四个特殊的通用<em><strong>属性值</strong></em>。每个css属性都接收这些值。</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inherit"><code>inherit</code></a></p><p>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial"><code>initial</code></a></p><p>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 <code>inherit</code> 。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset"><code>unset</code></a></p><p>将属性重置为自然值，也就是如果属性是自然继承那么就是 <code>inherit</code>，否则和 <code>initial</code>一样</p></li></ul><p><strong>注</strong>: 还有一个新的属性, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/revert"><code>revert</code> (en-US)</a>， 只有很少的浏览器支持。</p><p>CSS 的 shorthand 属性 <code>all</code> 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(<code>inherit</code>, <code>initial</code>, <code>unset</code>, or <code>revert</code>)。这是一种撤销对样式所做更改的简便方法，以便回到之前已知的起点。</p><p><em><strong>现在，我们将要了解层叠如何定义在不止一个元素的时候怎么应用css规则。</strong></em></p><p>有三个因素需要考虑，根据重要性排序如下，前面的更重要：</p><ol><li>重要程度</li><li>优先级</li><li>资源顺序</li></ol><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E8%B5%84%E6%BA%90%E9%A1%BA%E5%BA%8F">资源顺序</a></p><p>我们已经看到了顺序对于层叠的重要性。如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E4%BC%98%E5%85%88%E7%BA%A7_2">优先级</a></h3><p>一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</p><ol><li><strong>千位</strong>： 如果声明在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style"><code>style</code></a> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</li><li><strong>百位</strong>： 选择器中包含ID选择器则该位得一分。</li><li><strong>十位</strong>： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li><li><strong>个位</strong>：选择器中包含元素、伪元素选择器则该位得一分。</li></ol><p><strong>注</strong>: 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p><p><strong>警告:</strong> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p><p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — <code>!important</code>。</p><p>这是个属性值！！用于修改特定属性的值， 能够覆盖普通规则的层叠。</p><p><strong>注</strong>： 覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有 相同<em>优先级</em> 而且顺序靠后，或者更高优先级。</p><p>了解 <code>!important</code> 是为了在阅读别人代码的时候知道有什么作用。 <strong>但是，强烈建议除了非常情况不要使用它。</strong> <code>!important</code> 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难，特别是在大型样式表中。</p><p><em><strong>相互冲突的声明将按以下顺序适用，后一种声明将覆盖前一种声明</strong></em>：</p><ol><li>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</li><li>用户样式表中的常规声明(由用户设置的自定义样式)。</li><li>作者样式表中的常规声明(这些是我们web开发人员设置的样式)。</li><li>作者样式表中的<code>!important</code>声明</li><li>用户样式表中的<code>!important</code> 声明</li></ol><p>对于web开发人员的样式表来说，覆盖用户样式表是有意义的，因此设计可以按预期进行，但是有时用户充足的理由覆盖web开发人员样式，正如上面提到的—这可以通过在他们的规则中使用<code>!important</code>来实现。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p><p>但是在被组合起来以后，整个规则都会失效，无论是<code>h1</code>还是这个class都不会被样式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1, ..special &#123;</span><br></pre></td></tr></table></figure><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。</p><p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">学习CSS的教程</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">类型选择器</a></td><td align="left"><code>h1 &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Type_selectors">类型选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通配选择器</a></td><td align="left"><code>* &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#The_universal_selector">通配选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a></td><td align="left"><code>.box &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Class_selectors">类选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID选择器</a></td><td align="left"><code>#unique &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#ID_Selectors">ID选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">标签属性选择器</a></td><td align="left"><code>a[title] &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Attribute_selectors">标签属性选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类选择器</a></td><td align="left"><code>p:first-child &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-class">伪类</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素选择器</a></td><td align="left"><code>p::first-line &#123; &#125;</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-element">伪元素</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代选择器</a></td><td align="left"><code>article p</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Descendant_Selector">后代运算符</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">子代选择器</a></td><td align="left"><code>article &gt; p</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Child_combinator">子代选择器</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">相邻兄弟选择器</a></td><td align="left"><code>h1 + p</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Adjacent_sibling">相邻兄弟</a></td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器</a></td><td align="left"><code>h1 ~ p</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#General_sibling">通用兄弟</a></td></tr></tbody></table><p>将所有类连成一串代表匹配包含所有这些类的元素</p><p>.a.b.c{}匹配同时含有a,b,c类的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span> =<span class="string">&#x27;a b&#x27;</span>&gt;</span>此处li拥有a和b类<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[*attr*]</code></td><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>[*attr*=*value*]</code></td><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>[*attr*~=*value*]</code></td><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">`[<em>attr</em></td><td align="left">=<em>value</em>]`</td><td align="left">`div[lang</td></tr></tbody></table><p>子字符串匹配选择器</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[*attr*^=*value*]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[*attr*$=*value*]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[*attr**=*value*]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table><p>普通伪类如：first-child   invaild使用 :</p><p><strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong></p><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::pseudo-element-name</span><br></pre></td></tr></table></figure><p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p><p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^=<span class="string">&quot;a&quot;</span> i]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“伪“"><a href="#“伪“" class="headerlink" title="“伪“"></a>“伪“</h3><p>:first-child 表示选择的对象是其父元素的首个子元素，而不是选择它的首个子元素,伪类表状态！！！</p><p>：：before和：：after可以使用content属性插入字符串，而无法被阅读器识别，一般插入符号</p><p>也可以将该伪元素设置为block，然后对其进行css修饰</p><p>在CSS中被叫做“生成内容”</p><p>这种链接伪类先后顺序被称为 <em>LVHA 顺序</em>：<code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code>。</p><p>[参考列表</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E4%BC%AA%E7%B1%BB"></a></p><h3 id="关系选择"><a href="#关系选择" class="headerlink" title="关系选择"></a>关系选择</h3><p>空格-所有后代</p><p>‘&gt;’    -  直系儿子</p><p>a+b  -  b必须紧跟a后且同级，插入br都不行</p><p>a ~b - 选择！后面的！所有兄弟</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级****盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)<strong>。</strong>这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li><p>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</p></li><li><p>每个盒子都会换行</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</p></li><li><p>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</p><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p></li></ul><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p><ul><li>盒子不会产生换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p><code>inline-block</code>：</p><ul><li>盒子不会换行</li><li>width和height起作用</li><li>垂直起作用，会推开</li><li>水平起作用，会推开</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的 <strong>外部</strong> 显示类型</p><p>​    同样盒模型还有 <strong>内部</strong> 显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 <strong><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流</a></strong> 布局，也意味着它们和其他块元素以及内联元素一样(如上所述).</p><p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。 </p><p>​    你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px).</p><p>​    这种模型设定了总大小后，增加边距会压缩内容，换算时注意*2的关系</p><p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">the CSS Tricks article on box-sizing</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a><strong>外边距折叠</strong></h3><p>理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h3><p>是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p><p>分别设置每边的宽度、颜色和样式，可以使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li></ul><p>设置所有边的颜色、样式或宽度，请使用以下属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li></ul><p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></p><p>…………………….</p></li></ul><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code>是像<code>&lt;span</code>&gt;一样的内联元素；你可以使用<code>display: inline-block</code>来设置内边距，让用户更容易点击链接。</p><p>一般直接一个border：就好啦</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>border-radius</code></strong> 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/border-radius-sh.png" alt="Images of CSS3 rounded corners: no rounding, rounding w/ an arc of circle, rounding w/ an arc of ellipse"></p><p>border-radius: a b 是指定a:左上+右下 b剩下俩,4个值是顺时针指定</p><p>然而 a/b 是分别指定椭圆的长轴和短轴</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>屏幕阅读者不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是HTML页面的一部分，而不是包含在背景中。！！！！！</p><p><strong>backgroung-color</strong></p><p><strong>background-image</strong>: 小图平铺循环  大图不会缩小（。。）</p><p>图像会覆盖在颜色顶部</p><p>控制背景平铺</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>属性用于控制图像的平铺行为。可用的值是:</p><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><p>调整背景图像的大小</p><p>在上面的例子中，我们有一个很大的图像，由于它比作为背景的元素大，所以最后被裁剪掉了。在这种情况下，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。</p><p>你也可以使用关键字:</p><ul><li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li><li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li></ul><p><strong>background-position:</strong></p><p><strong>注意：</strong><code>background-position</code>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-x"><code>background-position-x</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-y"><code>background-position-y</code></a>的简写，它们允许您分别设置不同的坐标轴的值。</p><p>参数都在这：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position</a></p><p>有关键字：长度值.百分比，可混用</p><p>最后，您还可以使用4-value语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的CSS中，我们将背景从顶部调整20px，从右侧调整10px:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">star.png</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: top <span class="number">20px</span> right <span class="number">10px</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>background-image可用于渐变背景</p><p><a href="https://cssgradient.io/%E7%94%9F%E6%88%90%E5%99%A8%F0%9F%91%88">https://cssgradient.io/生成器👈</a></p><p>也可以有多个背景图像——在单个属性值中指定多个<code>background-image</code>值，用逗号分隔每个值。</p><p>当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p><p><strong>background-attachment</strong></p><p><code>background-attachment: scroll</code>使元素的背景固定在页面上，以便在滚动页面时滚动。如果滚动元素内容，则背景不会移动。</p><p><code>background-attachment: fixed</code>导致将元素的背景固定到视口，以便在滚动页面或元素内容时不会滚动。它将始终保持在屏幕上的相同位置。</p><p><code>background-attachment: local</code>，是CSS3的新增功能，可将元素的背景固定为实际的元素本身。因此，当滚动页面时，仅当元素这样做时，元素的背景才会随之移动（对于带有<code>position: fixed</code>。的元素则不会）。滚动元素的内容时，背景将与其一起滚动。</p><p>看这个很清晰。。个屁啊视口是啥</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment</a></p><p><code>background-clip</code> 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下</p><p>border-box,padding-box,content-box,text</p><p>background-origin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-box</span><br></pre></td></tr></table></figure><p>背景图片的摆放以border区域为参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding-box</span><br></pre></td></tr></table></figure><p>背景图片的摆放以padding区域为参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-box</span><br></pre></td></tr></table></figure><p>背景图片的摆放以content区域为参考</p><h3 id="background简写"><a href="#background简写" class="headerlink" title="background简写"></a>background简写</h3><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。</p><p>对于所有简写属性，任何没有被指定的值都会被设定为它们的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial_value">初始值</a></p><ul><li><code>&lt;bg-size&gt;</code> 只能紧接着 <code>&lt;position&gt;</code> 出现，以”/“分割，如： “<code>center/80%</code>“.</li><li><code>&lt;box&gt;</code> 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。如果出现 2 次，第一次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a>，第二次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。</li><li><code>&lt;background-color&gt;</code> 只能被包含在最后一层！！。</li></ul><p><strong>注意:</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a> 只能在background的最后一个属性上定义，因为整个元素只有一种背景颜色。</p><p>其他顺序随意</p><h2 id="处理文本"><a href="#处理文本" class="headerlink" title="处理文本"></a>处理文本</h2><p>writing-mode</p><p>a-b：a可取horizontal 和vertical 代表文本方向（内联布局）</p><p>horizontal有tb和bt  vertical有rl和lr代表块流向（块布局）</p><p>我们想要的实际上是使宽和高随着书写模式一起变化。当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。</p><p>为了更容易实现这样的转变，CSS最近开发了一系列映射属性。这些属性用逻辑（<strong>logical</strong>）和相对变化（<strong>flow relative</strong>）代替了像宽<code>width</code>和高<code>height</code>一样的物理属性。</p><p>横向书写模式下，映射到<code>width</code>的属性被称作内联尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a>）——内联维度的尺寸。而映射<code>height</code>的属性被称为块级尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>），这是块级维度的尺寸。牛啊！</p><p><code>margin-top</code>属性的映射是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-block-start"><code>margin-block-start</code></a>——总是指向块级维度开始处的边距。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>属性映射到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-inline-start"><code>padding-inline-start</code></a>，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>属性映射到的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-block-end"><code>border-block-end</code></a>，也就是块级维度结尾处的边框。</p><p>挺好理解的，不需要死记</p><p>但此时你的物理属性仍然适用</p><h2 id="CSS溢出"><a href="#CSS溢出" class="headerlink" title="CSS溢出"></a>CSS溢出</h2><p>溢出是在盒子无法容纳下太多的内容的时候发生的。在这篇教程里面，你将会学习到什么是溢出，以及如何控制它。<strong>CSS中万物皆盒</strong>，因此我们可以通过给<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>（或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着</p><h1 id="以后再学"><a href="#以后再学" class="headerlink" title="以后再学"></a>以后再学</h1><h2 id="css层叠"><a href="#css层叠" class="headerlink" title="css层叠"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade#origin_of_css_declarations">css层叠</a></h2><h2 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">外边距重叠</a></h2><h2 id="视口-视口概念-CSS（层叠样式表）-MDN-mozilla-org"><a href="#视口-视口概念-CSS（层叠样式表）-MDN-mozilla-org" class="headerlink" title="[视口](视口概念 - CSS（层叠样式表） | MDN (mozilla.org))"></a>[视口](<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Viewport_concepts">视口概念 - CSS（层叠样式表） | MDN (mozilla.org)</a>)</h2>]]></content>
    
    
    <summary type="html">web-second(continue)</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>html</title>
    <link href="http://example.com/2021/03/11/html/"/>
    <id>http://example.com/2021/03/11/html/</id>
    <published>2021-03-10T16:12:05.000Z</published>
    <updated>2021-03-13T12:53:50.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML基础排版"><a href="#HTML基础排版" class="headerlink" title="HTML基础排版"></a>HTML基础排版</h1><p>[toc]</p><h2 id="html简介和语义"><a href="#html简介和语义" class="headerlink" title="html简介和语义"></a>html简介和语义</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Chris Mills&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;The MDN Web Docs Learning Area。。。这是搜索引擎显示的</span></span></span><br></pre></td></tr></table></figure><p><a href="http://ogp.me/">Open Graph Data</a>是Facebook发明的一种元数据协议，旨在为网站提供更丰富的元数据</p><p>可以通过以下方式将收藏夹图标添加到您的页面：</p><ol><li><p>将其保存在与网站的索引页相同的目录中，并以<code>.ico</code>格式保存（大多数浏览器将以更常见的格式（例如<code>.gif</code>或）支持网站<code>.png</code>图标，但使用ICO格式将确保其可追溯至Internet Explorer6。）</p></li><li><p>将以下行添加到您的HTML</p><p><code>&lt;head&gt;</code></p><p>块中以引用它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>在外部示例中，我们使用一种更现代的JavaScript功能来解决问题，即<code>defer</code>属性，该属性告诉浏览器<code>&lt;script&gt;</code>在到达tag元素后继续下载HTML内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，脚本和HTML将同时加载，并且代码将起作用。</p><p><strong>注意</strong>：在外部情况下，我们不需要使用<code>DOMContentLoaded</code>事件，因为该<code>defer</code>属性为我们解决了问题。<code>defer</code>对于内部JavaScript示例，我们没有使用该解决方案，因为它<code>defer</code>仅适用于外部脚本。</p><p>这个问题的老式解决方案曾经是将脚本元素放在正文的底部（例如，紧接在<code>&lt;/body&gt;</code>标记之前），以便在解析所有HTML之后将其加载。该解决方案的问题在于，脚本的加载/解析被完全阻止，直到HTML DOM被加载为止。在具有许多JavaScript的大型网站上，这可能会导致严重的性能问题，从而降低您的网站速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en-US&quot;</span>&gt;</span><span class="comment">&lt;!--设置文档主要语言--&gt;</span>zh-Hans （简体中文）zh-CN</span><br></pre></td></tr></table></figure><p>html重要的是含义！</p><p>em强调</p><p>strong特别重要</p><ul><li>i&gt;用于传达传统上由斜体表示的含义：外来词，分类名称，技术术语，思想…</li><li>b&gt;用于传达传统上由粗体表示的含义：关键字，产品名称，主句…</li><li>u&gt;用于传达传统上由下划线传达的含义：专有名称，拼写错误…</li></ul><p>关于下划线的一种警告：<strong>人们将下划线与超链接紧密关联。</strong>因此，在Web上，最好仅对链接加下划线。在<code>&lt;u&gt;</code>语义上适当时使用该元素，但请考虑使用CSS将默认下划线更改为Web上更合适的内容。</p><h2 id="html超链接"><a href="#html超链接" class="headerlink" title="html超链接"></a>html超链接</h2><p>href：’url’</p><p>title：提醒，当鼠标hover时显示</p><p>在a&gt;标签中加入别的元素可使用区块级链接，省略url则是当前网站</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/en-US/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mozilla-image.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;mozilla logo that links to the mozilla homepage&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在src后紧跟选择器可以选择链接道文件片段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;contacts.html#Mailing_address&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&gt;链接到id是Mailing_address的地方&lt;/--&gt;</span></span><br></pre></td></tr></table></figure><p><em><strong>好的</strong>连结文字：</em><a href="https://firefox.com/">下载Firefox</a></p><p><em><strong>不好的</strong>连结文字：</em><a href="https://firefox.com/">点这里</a>来下载Firefox</p><ul><li><p>让你的连结越短越好— 太长的连结会使萤幕阅读器的使用者蒙受其害，因为他们必须从头听到尾。</p></li><li><p>尽量让连结的文字不一样，太多重复的连结文字会带给萤幕阅读器的使用者麻烦，因为他们可能会从一个连结表中选择连结，因此若有许多重复的「点这里」会让他们相当困惑。</p></li><li><p>尽可能使用相对连接来增强代码可读性和效率</p></li><li><p>连接到非HTML资源时要说明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/large-report.pdf&quot;</span>&gt;</span></span><br><span class="line">  下載銷售報告(PDF, 10MB)</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/car-game&quot;</span>&gt;</span></span><br><span class="line">  遊玩賽車遊戲(需要 Flash)</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>当你连结一个需要下载的资源时，你可以使用<code>download</code>属性来提供一个预设的储存档名。以下范例是最新版的Windows版Firefox的下载连结：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=en-US&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span></span><br><span class="line">  下載Windows上的最新版Firefox (64-bit) (English, US)</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>你可以建立一个连结或按钮，使得它被点击之后，开启一个正在撰写中的电子邮件讯息。这可以透过<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a">``</a>元素和<code>mailto:</code>URL scheme来达成。</p><p>多数情况<code>mailto:</code>会填入收信人的电子邮件地址。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:nowhere@mozilla.org&quot;</span>&gt;</span>Send email to nowhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>你可以建立一个连结或按钮，使得它被点击之后，开启一个正在撰写中的电子邮件讯息。这可以透过<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a">``</a>元素和<code>mailto:</code>URL scheme来达成。</p><p>多数情况<code>mailto:</code>会填入收信人的电子邮件地址。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;mailto:nowhere@mozilla.org&quot;&gt;Send email to nowhere&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>它的结果会像是这样：<a href="mailto:nowhere@mozilla.org">Send email to nowhere</a>。</p><p>事实上，电子邮件地址是选填的。如果你将它留空(也就是说，你的<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a#attr-href"><code>href</code></a>只写了”mailto:”)，使用者的mail client会开启一个寄信视窗，其中并没有指定收信人，这在使用「分享」连结时非常有用，使用者可以自行决定要寄给谁。</p></li><li><p>除了电子邮件地址之外，你还可以提供其他资讯，事实上，任何标准的邮件标头栏位都能被加到 <code>mailto</code>URL中，常见的有主旨(subject)、副本(cc)以及主体(body) (这个虽然不是真的标头栏位，但能让你放一条简短的讯息在新邮件的主体中)。每个栏位与它的值被定义成一组查询项(query term)。</p><p>下面是一个包含cc、bcc(密件副本)、subject 和body 的范例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:nowhere@mozilla.org?cc=name2@rapidtables.com&amp;bcc=name3@rapidtables.com&amp;subject=The%20subject%20of%20the%20email&amp;body=The%20body%20of%20the%20email&quot;</span>&gt;</span></span><br><span class="line">  Send mail with cc, bcc, subject and body</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**Note:**每一个栏位的值必须以URL编码，也就是将空白及不可印字元(不可见的字元如缩排(tabs)、回车(carriage return )、换页(page breaks)等等)转换成<a href="http://en.wikipedia.org/wiki/Percent-encoding">百分号编码</a>。也请注意这里使用问号( <code>?</code>)来分隔主要URL和其他栏位；以&amp;来分隔<code>mailto:</code>URL中的不同的栏位，这是标准的URL查询记号(query notation)。你可以阅读<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data#the_get_method">GET方法</a>来得知有那些常用的查询记号。</p></li></ul><h2 id="html高级文本"><a href="#html高级文本" class="headerlink" title="html高级文本"></a>html高级文本</h2><ul><li><p>说明列表使用与其他列表类型不同的包装器- <dl>另外，每个术语都包装在<dt>（描述术语）元素中，每个描述都包装在<dd>（描述描述）元素中。</p></li><li><p>Quatation（块）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">cite</span>=<span class="string">&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">strong</span>&gt;</span>HTML <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="symbol">&amp;lt;</span>blockquote<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span> Element<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> (or <span class="tag">&lt;<span class="name">em</span>&gt;</span>HTML Block</span><br><span class="line">  Quotation Element<span class="tag">&lt;/<span class="name">em</span>&gt;</span>) indicates that the enclosed text is an extended quotation.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表明引用自cite所示网页</p><p>Browser default styling will render this as an indented paragraph, as an indicator that it is a quote;</p></li><li><p>Quatation（inline）</p><p>replace blockquote with q</p><p>Browser default styling will render this as normal text put in quotes to indicate a quotation</p><p>由于cite属性并没有提供什么链接功能，需要我们自己最好提供链接，有效的方法是将cite标签嵌套于a标签内</p></li><li><p><abbr>— this is used to wrap around an abbreviation or acronym, and provide a full expansion of the term (included inside a <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Global_attributes#attr-title"><code>title</code></a> attribute.) </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Reverend&quot;</span>&gt;</span>Rev.<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML有一个用于标记联系方式的元素<address>。这只是将html文档开发者的联系方式包括在内，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Chris Mills, Manchester, The Grim North, UK<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上下标<sup><sub></p></li><li><p><code>：用于组成通用的计算机代码。</p></li><li><pre>：用于标记固定宽度的文本块，其中保留空白（通常是代码块）。</li><li><p><var>：用于专门标记变量名。</p></li><li><p><kbd>：用于标记输入到计算机中的键盘（和其他类型的）输入。</p></li><li><p><samp>：用于标记计算机程序的输出。</p></li><li><p><time>：datetime属性标记元素时间</p></li></ul><h2 id="html结构布局"><a href="#html结构布局" class="headerlink" title="html结构布局"></a>html结构布局</h2><p><em><strong>信息架构</strong></em></p><p>应用于网站设计和开发的信息体系结构是一种组织网站的信息/内容/功能的实践，以便它可以提供最佳的用户体验，并且信息和服务易于使用和发现。</p><ul><li><h2 id="HTML5中的Section元素"><a href="#HTML5中的Section元素" class="headerlink" title="HTML5中的Section元素"></a><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines#section_elements_in_html5">HTML5中的Section元素</a></h2><ul><li><strong>HTML导航元素</strong>《nav》定义了一个部分，其中包含经常出现在网站上的导航链接。您可以具有主菜单和辅助菜单，但是不能将一个<code>&lt;nav&gt;</code>元素嵌套在另一个 <code>&lt;nav&gt;</code>元素中。</li><li><strong>HTML文章元素</strong>《article》定义了一条独立的内容。它不单指主要内容，而是可以用于注释和小部件。</li><li><strong>HTML Section Element</strong>《section》定义了文档的一部分，以指示语义含义的相关分组。使用section元素为父元素提供额外的上下文是有意义的。</li><li><strong>HTML Aside Element</strong>《aside》定义了一个部分，尽管该部分与main元素相关，但不属于主流，例如说明框或广告。aside元素具有自己的轮廓，但不属于主要元素。</li></ul><h3 id="分区中使用的其他语义HTML元素"><a href="#分区中使用的其他语义HTML元素" class="headerlink" title="分区中使用的其他语义HTML元素"></a><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines#other_semantic_html_elements_used_in_sectioning">分区中使用的其他语义HTML元素</a></h3><ul><li><strong>HTML正文元素</strong>《body》定义了文档的所有内容。它包含所有内容和HTML标记。</li><li><strong>HTML标头元素</strong>《header》定义了一个页面区域，通常包含徽标，标题和导航。标头也可以在其他语义元素（例如<code>&lt;article&gt;</code>，<code>&lt;section&gt;</code>，《aside》，《nav》都行）可以放一些作者信息啊什么的东西，</li><li><strong>HTML页脚元素</strong>《footer》定义了页脚，通常包含版权或法律声明，有时还包含一些链接。在节的上下文中，页脚可能包含节内容的发布日期，许可证信息等，同样，上述标间也均可以自己的页脚，尽管有页脚的名称，页脚也不一定位于页面或节的末尾。</li></ul></li><li><p>无语义元素：块级div  内敛span</p></li></ul><p><strong>警告：</strong><code>&lt;div&gt;</code> 非常便利但容易被滥用。由于它们没有语义值，会使 HTML 代码变得混乱。要小心使用，只有在没有更好的语义方案时才选择它，而且要尽可能少用， 否则文档的升级和维护工作会非常困难。</p><p><strong>重要提示</strong>：Web浏览器中没有拟议大纲算法的实现，也没有辅助技术。它从来都不是最终的W3C规范的一部分。因此，<a href="https://www.w3.org/TR/html5/sections.html#outline">大纲</a>算法<em>不应用于</em>将文档结构传达给用户。建议作者使用标题<a href="https://www.w3.org/TR/html5/sections.html#rank">等级</a>（<code>h1</code>- <code>h6</code>）传达文档结构。</p><p>大纲算法是神马？？？</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines">用法指导</a>规定了各个部分的建议使用方法</p><p><em><strong>兼容古老浏览器</strong></em>：</p><p>HTML5语义元素不需要特殊的DOM接口，但是在较旧的浏览器中，它们将需要特定的CSS样式，这些样式不明确支持它们。<code>display: inline</code>默认情况下，未知元素的样式设置为默认样式，因此您需要将其设置为<code>display: block</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当你的受众可能用那些鬼浏览器时</p><p>The <strong>HTML <code>&lt;noscript&gt;</code> element</strong> defines a section of HTML to be inserted if a script type on the page is unsupported or if scripting is currently turned off in the browser.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script&gt;</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;article&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;aside&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;footer&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;header&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;nav&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;section&quot;);</span></span><br><span class="line"><span class="comment">    document.createElement(&quot;time&quot;);</span></span><br><span class="line"><span class="comment">  &lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>This web page requires JavaScript to be enabled.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>JavaScript is an object-oriented computer programming language</span><br><span class="line">    commonly used to create interactive effects within web browsers.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://goo.gl/koeeaJ&quot;</span>&gt;</span>How to enable JavaScript?<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="HTML多媒体"><a href="#HTML多媒体" class="headerlink" title="HTML多媒体"></a>HTML多媒体</h1><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>你不应该使用HTML属性来改变图片的大小。如果你把尺寸设定的太大，最终图片看起来会模糊；如果太小，会在下载远远大于你需要的图片时浪费带宽。如果你没有保持正确的<a href="https://zh.wikipedia.org/wiki/%E9%95%B7%E5%AF%AC%E6%AF%94_(%E5%BD%B1%E5%83%8F)">宽高比</a>，图片可能看起来会扭曲。在把图片放到你的网站页面之前，你应该使用图形编辑器使图片的尺寸正确。</p><p>善用alt属性</p><p>使用 HTML5 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure">``</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figcaption">``</a> 元素，它正是为此而被创造出来的：为图片提供一个语义容器，在标题和图片之间建立清晰的关联。我们之前的例子可以重写为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">&quot;一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">width</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">height</span>=<span class="string">&quot;341&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>曼彻斯特大学博物馆展出的一只霸王龙的化石<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>从无障碍的角度来说，说明文字和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-alt"><code>alt</code></a> 文本扮演着不同的角色。看得见图片的人们同样可以受益于说明文字，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-alt"><code>alt</code></a> 文字只有在图片无法显示时才这样。 所以，说明文字和 <code>alt</code> 的内容不应该一样，因为当图片无法显示时，它们会同时出现。尝试让你的图片不显示，看看效果如何。</p><p><strong>如果图像对您的内容里有意义，则应使用HTML图像。 如果图像纯粹是装饰，则应使用CSS背景图片</strong></p><p>ps: 谷歌搜索引擎把连字符当作单词的分隔符， 但不会识别下划线。基于此，最好在一开始就养成习惯，文件夹和文件名使用小写，用短横线而不是空格来分隔。可以避免许多问题。</p><h2 id="Video-amp-Audio"><a href="#Video-amp-Audio" class="headerlink" title="Video&amp;Audio"></a>Video&amp;Audio</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.webm&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当中的一些属性如下:<br>src同 <img> 标签使用方式相同，src 属性指向你想要嵌入网页当中的视频资源，他们的使用方式完全相同。controls用户必须能够控制视频和音频的回放功能。你可以使用 controls 来包含浏览器提供的控件界面，同时你也可以使用合适的 JavaScript API 创建自己的界面。界面中至少要包含开始、停止以及调整音量的功能。</p><p>video 标签内的内容这个叫做后备内容 — 当浏览器不支持 video标签的时候，就会显示这段内容，这使得我们能够对旧的浏览器提供回退内容。你可以添加任何后备内容，在这个例子中我们提供了一个指向这个视频文件的链接，从而使用户至少可以访问到这个文件，而不会局限于浏览器的支持。</p><p>像 MP3、MP4、WebM这些术语叫做<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers">容器格式</a>。他们定义了构成媒体文件的音频轨道和视频轨道的储存结构，其中还包含描述这个媒体文件的元数据，以及用于编码的编码译码器等等。</p><p>刚刚所说的格式主要用于将音频和视频压缩成可管理的文件（原始的音频和视频文件非常大）。浏览器包含了不同的 <strong><a href="https://developer.mozilla.org/en-US/docs/Glossary/Codec">Codecs</a></strong>,，如 Vorbis 和 H.264，它们用来将已压缩的音频和视频转化成二进制数字。不同的编码器和不同的容器都有各自的优缺点，在你更了解它们后，你可以自己选择使用哪个编码器和容器。</p><!-- 注：这并没有那么简单，你可以从这里看到 [音视频编码兼容表](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/Media/Formats#浏览器兼容情况)。此外，许多移动平台的浏览器能够播放一些不支持的格式，但是它们用的却是底层系统的媒体播放器。但这也仅是现在支持。--><p>我们该怎么做呢？请看如下例子（你可以点击这里<a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/video-and-audio-content/multiple-video-formats.html">查看</a>网页，或者点击这里<a href="https://github.com/mdn/learning-area/blob/gh-pages/html/multimedia-and-embedding/video-and-audio-content/multiple-video-formats.html">查看</a>源代码）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们将 <code>src</code> 属性从 <code>&lt;video&gt;</code> 标签中移除，转而将它放在几个单独的标签 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source">``</a> 当中。在这个例子当中，浏览器将会检查 <code>&lt;source&gt;</code> 标签，并且播放第一个与其自身 codec 相匹配的媒体。你的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。</p><p>每个 <code>&lt;source&gt;</code> 标签页含有一个 <code>type</code> 属性，这个属性是可选的</p><p>新的特性：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-height"><code>height</code></a></p><p>你可以用属性控制视频的尺寸，也可以用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS">CSS</a> 来控制视频尺寸。 无论使用哪种方式，视频都会保持它原始的长宽比 — 也叫做<strong>纵横比</strong>。如果你设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-autoplay"><code>autoplay</code></a></p><p>这个属性会使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。建议不要应用这个属性在你的网站上，因为用户们会比较反感自动播放的媒体文件。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-loop"><code>loop</code></a></p><p>这个属性可以让音频或者视频文件循环播放。同样不建议使用，除非有必要。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-muted"><code>muted</code></a></p><p>这个属性会导致媒体播放时，默认关闭声音。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-poster"><code>poster</code></a></p><p>这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-preload"><code>preload</code></a></p><p>这个属性被用来缓冲较大的文件，有3个值可选：<code>&quot;none&quot;</code> ：不缓冲<code>&quot;auto&quot;</code> ：页面加载后缓存媒体文件<code>&quot;metadata&quot;</code> ：仅缓冲文件的元数据</p></li></ul><p>你可以点击<a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/video-and-audio-content/extra-video-features.html">这里</a>查看以上的例子，也可以点击<a href="https://github.com/mdn/learning-area/blob/gh-pages/html/multimedia-and-embedding/video-and-audio-content/extra-video-features.html">这里</a>查看源代码。注意我们并没有使用 autoplay 属性在这个版本的例子中 — 如果当页面一加载就开始播放视频的话，就不会看到 poster 属性的效果了。</p><p>audio和video几乎完全一样，但不支持width/height和poster</p><h2 id="嵌入iframe"><a href="#嵌入iframe" class="headerlink" title="嵌入iframe"></a>嵌入iframe</h2><p>以前，插件在网络上是不可或缺的。还记得你必须安装Adobe Flash Player才能在线观看电影的日子吗？并且你还会不断地收到关于更新Flash Player和Java运行环境的烦人警报。Web技术已经变得更加强大，那些日子已经结束了。对于大多数应用程序，现在是停止依赖插件传播内容，开始利用Web技术的时候了</p><p>iframe元素出现了（连同其他嵌入内容的方式，如canvas&gt;，video&gt;等），它提供了一种将整个web页嵌入到另一个网页的方法，看起来就像那个web页是另一个网页的一个<img>或其他元素一样。iframe&gt;现在经常被使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowfullscreen</span><br></pre></td></tr></table></figure><p>如果设置，<code>&lt;iframe&gt;</code>则可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API">全屏API</a>设置为全屏模式（稍微超出本文的范围）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameborder</span><br></pre></td></tr></table></figure><p>如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0删除边框。不推荐这样设置，因为在<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS">CSS中</a>可以更好地实现相同的效果。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border"><code>border</code></a><code>: none;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src</span><br></pre></td></tr></table></figure><p>该属性与<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video">``</a>/<code>&lt;img&gt;</code>一样包含指向要嵌入文档的URL路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width&#96; 和 &#96;height</span><br></pre></td></tr></table></figure><p>这些属性指定您想要的iframe的宽度和高度。</p><p>备选内容</p><p>与video &amp; audio等其他类似元素相同，您可以在<code>&lt;iframe&gt;&lt;/iframe&gt;</code>标签之间包含备选内容，如果浏览器不支持<code>&lt;iframe&gt;</code>，将会显示备选内容，这种情况下，我们已经添加了一个到该页面的链接。现在您几乎不可能遇到任何不支持<code>&lt;iframe&gt;</code>的浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sandbox</span><br></pre></td></tr></table></figure><p>该属性需要在已经支持其他<code>&lt;iframe&gt;</code>功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置; 我们将在下一节中更加详细地谈到。</p><p><strong>注意</strong>：为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的<code>src</code>属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间（重要的<a href="https://developer.mozilla.org/en-US/docs/Glossary/SEO">SEO</a>指标）。</p><p>未沙盒化(Unsandboxed)内容可以做得太多（执行JavaScript，提交表单，弹出窗口等）默认情况下，您应该使用没有参数的<code>sandbox</code>属性来强制执行所有可用的限制，如我们前面的示例所示。</p><p>如果绝对需要，您可以逐个添加权限（<code>sandbox=&quot;&quot;</code>属性值内） - 请参阅<code>sandbox</code>所有可用选项的参考条目。其中重要的一点是，你<em>永远不</em>应该同时添加<code>allow-scripts</code>和<code>allow-same-origin</code>到你的<code>sandbox</code>属性中-在这种情况下，嵌入式内容可以绕过阻止站点执行脚本的同源安全策略，并使用JavaScript完全关闭沙盒。</p><p>但还有其它的有待关注，如 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">``</a>用于JavaScript生成的2D和3D图形，<code>&lt;svg&gt;</code>用于嵌入矢量图形</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ul><li>位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (<code>.bmp</code>), PNG (<code>.png</code>), JPEG (<code>.jpg</code>), and GIF (<code>.gif</code>.)</li><li>矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 <a href="https://developer.mozilla.org/en-US/docs/Glossary/SVG">SVG</a> 格式可以让我们创造用于 Web 的精彩的矢量图形。</li></ul><p>此外，矢量图形相较于同样的位图，通常拥有更小的体积，因为它们仅需储存少量的算法，而不是逐个储存每个像素的信息。</p><p>SVG很容易手工编码。 是的，您可以在文本编辑器中手动编写简单的SVG，但是对于复杂的图像，这很快就开始变得非常困难。 为了创建SVG图像，大多数人使用矢量图形编辑器，如 <a href="https://inkscape.org/en/">Inkscape</a> 或 <a href="https://en.wikipedia.org/wiki/Adobe_Illustrator">Illustrator</a>。 这些软件包允许您使用各种图形工具创建各种插图，并创建照片的近似值（例如Inkscape的跟踪位图功能）。</p><p>SVG除了迄今为止所描述的以外还有其他优点：</p><ul><li>矢量图像中的文本仍然可访问（这也有利于 <a href="https://developer.mozilla.org/en-US/docs/Glossary/SEO">SEO</a>)）。</li><li>SVG 可以很好地适应样式/脚本，因为图像的每个组件都是可以通过CSS或通过JavaScript编写的样式的元素。</li></ul><p>那么为什么会有人想使用光栅图形而不是SVG？ 其实 SVG 确实有一些缺点：</p><ul><li>SVG非常容易变得复杂，这意味着文件大小会增加; 复杂的SVG也会在浏览器中占用很长的处理时间。</li><li>SVG可能比栅格图像更难创建，具体取决于您尝试创建哪种图像。</li><li>旧版浏览器不支持SVG，因此如果您需要在网站上支持旧版本的 IE，则可能不适合（SVG从IE9开始得到支持）。</li></ul><p>由于上述原因，光栅图形更适合照片那样复杂精密的图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">    src=&quot;equilateral.svg&quot;</span><br><span class="line">    alt=&quot;triangle with all three sides equal&quot;</span><br><span class="line">    height=&quot;87px&quot;</span><br><span class="line">    width=&quot;100px&quot; /&gt;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>快速，熟悉的图像语法与<code>alt</code>属性中提供的内置文本等效。</li><li>可以通过在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">``</a>元素嵌套<code>&lt;img&gt;</code>，使图像轻松地成为超链接。</li></ul><p>缺点</p><ul><li>无法使用JavaScript操作图像。</li><li>如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 （从SVG文件调用的外部样式表不起作用）</li><li>不能用CSS伪类来重设图像样式（如<code>:focus</code>）。</li></ul><p>！！你还可以在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中 - 这有时称为将<strong>SVG内联</strong>或<strong>内联SVG</strong>。确保您的SVG代码在<code>&lt;svg&gt;&lt;/svg&gt;</code>标签中（不要在外面添加任何内容）。这是一个非常简单的示例，您可以粘贴到文档中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;</span><br><span class="line">    &lt;rect width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot; fill&#x3D;&quot;green&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>将 SVG 内联减少 HTTP 请求，可以减少加载时间。</li><li>您可以为 SVG 元素分配<code>class</code>和<code>id</code>，并使用 CSS 修改样式，无论是在SVG中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute#presentation_attributes">SVG外观属性</a> 作为CSS属性。</li><li>内联SVG是唯一可以让您在SVG图像上使用CSS交互（如<code>:focus</code>）和CSS动画的方法（即使在常规样式表中）。</li><li>您可以通过将 SVG 标记包在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">``</a>元素中，使其成为超链接。</li></ul><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>一个改进的方法是，当网站在狭窄的屏幕上观看时，显示一幅图片的包含了重要细节的裁剪版本，第二个被裁剪的图片会在像平板电脑这样的中等宽度的屏幕设备上显示，这就是众所周知的<strong>美术设计问题（art direction problem）</strong>。</p><p>另外，如果是在小屏手机屏幕上显示网页，那么没有必要在网页上嵌入这样大的图片。这被称之为<strong>分辨率切换问题（resolution switching problem）</strong>。位图有固定数量的像素宽，固定数量的像素高，与 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web">矢量图</a> 外观相同，但本质不同。如果显示尺寸大于原始尺寸，一张自身较小的位图看起来会有颗粒感（矢量图则不会）。</p><p>相反，没有必要在比图片实际尺寸小的屏幕上显示一张大图，这样做会浪费带宽——当可以在设备上使用小图像时，手机用户尤其不愿意因为下载用于桌面的大图像而浪费带宽。理想的情况是当访问网站时依靠不同的设备来提供不同的分辨率图片和不同尺寸的图片。</p><p>让事情变得复杂的是，有些设备有很高的分辨率，为了显示的更出色，可能需要超出你预料的更大的图像。这从本质上是一样的问题，但在环境上有一些不同。</p><p>你可能会认为矢量图形能解决这些问题，在某种程度上是这样的——它们无论是文件大小还是比例都合适，无论在哪里你都应该尽可能的使用它们。然而，它们并不适合所有的图片类型，虽然在简单图形、图案、界面元素等方面较好，但如果是有大量的细节的照片，创建矢量图像会变得非常复杂。像JPEG格式这样的位图会更适合上面例子中的图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-480w.jpg 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-800w.jpg 800w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 320px) 280px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            (max-width: 480px) 440px,</span></span></span><br><span class="line"><span class="tag"><span class="string">            800px&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;elva-fairy-800w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>srcset</code>和<code>sizes</code>属性看起来很复杂，但是如果你按照上图所示进行格式化，那么他们并不是很难理解，每一行有不同的属性值。每个值都包含逗号分隔的列表。列表的每一部分由三个子部分组成。让我们来看看现在的每一个内容：</p><p><strong>srcset</strong>定义了我们允许浏览器选择的图像集，以及每个图像的大小。在每个逗号之前，我们写：</p><ol><li>一个<strong>文件名</strong> (<code>elva-fairy-480w.jpg</code>.)</li><li>一个空格</li><li><strong>图像的固有宽度</strong>（以像素为单位）（480w）——注意到这里使用<code>w</code>单位，而不是你预计的<code>px</code>。这是图像的真实大小，可以通过检查你电脑上的图片文件找到（例如，在Mac上，你可以在Finder上选择这个图像，然后按 Cmd + I 来显示信息）。</li></ol><p><code>**sizes**</code>定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择—我们在之前已经讨论了一些提示。在这种情况下，在每个逗号之前，我们写：</p><ol><li>一个<strong>媒体条件</strong>（<code>(max-width:480px)</code>）——你会在 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS">CSS topic</a>中学到更多的。但是现在我们仅仅讨论的是媒体条件描述了屏幕可能处于的状态。在这里，我们说“当可视窗口的宽度是480像素或更少”。</li><li>一个空格</li><li>当媒体条件为真时，图像将填充的<strong>槽的宽度</strong>（<code>440px</code>）</li></ol><p><strong>注意</strong>: 对于槽的宽度，你也许会提供一个固定值 (<code>px</code>, <code>em</code>) 或者是一个相对于视口的长度(<code>vw</code>)，但不是百分比。你也许已经注意到最后一个槽的宽度是没有媒体条件的，它是默认的，当没有任何一个媒体条件为真时，它就会生效。 当浏览器成功匹配第一个媒体条件的时候，剩下所有的东西都会被忽略，所以要注意媒体条件的顺序。</p><p>所以，有了这些属性，浏览器会：</p><ol><li>查看设备宽度</li><li>检查<code>sizes</code>列表中哪个媒体条件是第一个为真</li><li>查看给予该媒体查询的槽大小</li><li>加载<code>srcset</code>列表中引用的最接近所选的槽大小的图像</li></ol><p>如果你支持多种分辨率显示，但希望每个人在屏幕上看到的图片的实际尺寸是相同的，你可以让浏览器通过<code>srcset</code>和x语法结合——一种更简单的语法——而不用<code>sizes</code>，来选择适当分辨率的图片。你可以看一个例子 <a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/responsive-images/srcset-resolutions.html">srcset-resolutions.html</a>（或 <a href="https://github.com/mdn/learning-area/blob/master/html/multimedia-and-embedding/responsive-images/srcset-resolutions.html">the source code</a>）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-fairy-320w.jpg,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-480w.jpg 1.5x,</span></span></span><br><span class="line"><span class="tag"><span class="string">             elva-fairy-640w.jpg 2x&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;elva-fairy-640w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>sizes</code>并不需要——浏览器只是计算出正在显示的显示器的分辨率，然后提供<code>srcset</code>引用的最适合的图像。因此，如果访问页面的设备具有标准/低分辨率显示，一个设备像素表示一个CSS像素，<code>elva-fairy-320w.jpg</code>会被加载（1x 是默认值，所以你不需要写出来）。如果设备有高分辨率，两个或更多的设备像素表示一个CSS像素，<code>elva-fairy-640w.jpg</code> 会被加载。640px的图像大小为93KB，320px的图像的大小仅仅有39KB。</p><p><em><strong>美术设计问题</strong></em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 799px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-480w-close-portrait.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 800px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;elva-800w.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;elva-800w.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Chris standing up holding his daughter Elva&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li> <code>&lt;source&gt;</code>元素包含一个<code>media</code>属性，这一属性包含一个媒体条件——就像第一个<code>srcset</code>例子，这些条件来决定哪张图片会显示——第一个条件返回真，那么就会显示这张图片。在这种情况下，如果视窗的宽度为799px或更少，第一个<code>&lt;source&gt;</code>元素的图片就会显示。如果视窗的宽度是800px或更大，就显示第二张图片。</li><li> <code>srcset</code>属性包含要显示图片的路径。请注意，正如我们在<code>&lt;img&gt;</code>上面看到的那样，<code>&lt;source&gt;</code>可以使用引用多个图像的<code>srcset</code>属性，还有<code>sizes</code>属性。所以你可以通过一个 <code>&lt;picture&gt;</code>元素提供多个图片，不过也可以给每个图片提供多分辨率的图片。实际上，你可能不想经常做这样的事情。</li><li> 在任何情况下，你都必须在 <code>&lt;/picture&gt;</code>之前正确提供一个<code>&lt;img&gt;</code>元素以及它的<code>src</code>和<code>alt</code>属性，否则不会有图片显示。当媒体条件都不返回真的时候（你可以在这个例子中删除第二个<code>&lt;source&gt;</code> 元素），它会提供图片；如果浏览器不支持 <code>&lt;picture&gt;</code>元素时，它可以作为后备方案。</li></ul><p>为了保证效率，响应式设计最好不用JavaScript</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images#%E5%A4%A7%E8%83%86%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F">大胆的使用现代图像格式</a></p><p>有很多令人激动的新图像格式（例如WebP和JPEG-2000）可以在有高质量的同时有较低的文件大小。然而，浏览器对其的支持参差不齐。</p><p><code>&lt;picture&gt;</code>让我们能继续满足老式浏览器的需要。你可以在<code>type</code>属性中提供MIME类型，这样浏览器就能立即拒绝其不支持的文件类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;pyramid.svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;pyramid.webp&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;pyramid.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;regular pyramid built from four equilateral triangles&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不要使用<code>media</code>属性，除非你也需要美术设计。</li><li>在<code>&lt;source&gt;</code> 元素中，你只可以引用在<code>type</code>中声明的文件类型。</li><li>像之前一样，如果必要，你可以在<code>srcset</code>和<code>sizes</code>中使用逗号分割的列表。</li></ul><h1 id="表格设计"><a href="#表格设计" class="headerlink" title="表格设计"></a>表格设计</h1><p>table<br>tr表格行<br>th表格小标题<br>td表格基础单元</p><p>rowspan 调高度</p><p>colspan = “2” 宽度是两个单元格</p><p>为了舍弃这种做法，我们可以只定义一次，在 <code>&lt;col&gt;</code> 元素中。<code>&lt;col&gt;</code> 元素被规定包含在 <code>&lt;colgroup&gt;</code> 容器中，而 <code>&lt;colgroup&gt;</code>就在 <code>&lt;table&gt;</code> 标签的下方。我们可以通过如下的做法来创建与上面相同的效果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">&quot;background-color: yellow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Calcutta<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Robots<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jazz<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们使用了两个 <code>&lt;col&gt;</code>来定义“列的样式”，每一个<code>&lt;col&gt;</code>都会制定每列的样式，对于第一列，我们没有采取任何样式，但是我们仍然需要添加一个空的 <code>&lt;col&gt;</code> 元素，如果不这样做，那么我们的样式就会应用到第一列上，这和我们预想的不一样。</p><p>如果你想把这种样式信息应用到每一列，我们可以只使用一个 <code>&lt;col&gt;</code> 元素，不过需要包含 span 属性，像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">&quot;background-color: yellow&quot;</span> <span class="attr">span</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标题属性caption</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span>Dinosaurs in the Jurassic period<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li> <code>&lt;thead&gt;</code> 需要嵌套在 table 元素中，放置在头部的位置，因为它通常代表第一行，第一行中往往都是每列的标题，但是不是每种情况都是这样的。如果你使用了 / 元素，那么 <code>&lt;thead&gt;</code>元素就需要放在它们的下面。</li><li> <code>&lt;tfoot&gt;</code> 需要嵌套在 table 元素中，放置在底部 (页脚)的位置，一般是最后一行，往往是对前面所有行的总结，比如，你可以按照预想的方式将<code>&lt;tfoot&gt;</code>放在表格的底部，或者就放在 <code>&lt;thead&gt;</code> 的下面。(浏览器仍将它呈现在表格的底部)</li><li> <code>&lt;tbody&gt;</code> 需要嵌套在 table 元素中，放置在 <code>&lt;thead&gt;</code>的下面或者是 <code>&lt;tfoot&gt;</code> 的下面，这取决于你如何设计你的结构。(<code>&lt;tfoot&gt;</code>放在<code>&lt;thead&gt;</code>下面也可以生效.)</li></ul><p><strong>注意</strong>: <code>&lt;tbody&gt;</code> 总是包含在每个表中，如果你没有在代码中指定它，那就是隐式的。可以来验证一下，打开一个你之前没有包含 <code>&lt;tbody&gt;</code> 的例子，然后在你的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">browser developer tools</a> 中观察你的代码，你会看到浏览器为你添加了这个标签。你也许会想问，为什么你应该在所有表中都需要这个元素，因为它可以让你更好地控制表格结构和样式。</p><p><strong>表格可以嵌套，虽然通常不建议</strong></p><p>为了帮助屏幕阅读器，赋予行，列标题scole属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th scope&#x3D;&quot;col&quot;&gt;Purchase&lt;&#x2F;th&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;th scope&#x3D;&quot;row&quot;&gt;Haircut&lt;&#x2F;th&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;th colspan=&quot;3&quot; scope=&quot;colgroup&quot;&gt;Clothes&lt;/th&gt;</code></p><p>colgroup和rowgroup结合colspan和rowspan使用</p><p>也可以用这个精细但是很麻烦的id+headers</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;purchase&quot;</span>&gt;</span>Purchase<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;location&quot;</span>&gt;</span>Location<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;date&quot;</span>&gt;</span>Date<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;evaluation&quot;</span>&gt;</span>Evaluation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;cost&quot;</span>&gt;</span>Cost (€)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;haircut&quot;</span>&gt;</span>Haircut<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;location haircut&quot;</span>&gt;</span>Hairdresser<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;date haircut&quot;</span>&gt;</span>12/09<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;evaluation haircut&quot;</span>&gt;</span>Great idea<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;cost haircut&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="以后再看"><a href="#以后再看" class="headerlink" title="以后再看"></a>以后再看</h1><p>这些内容有一丢丢难</p><h2 id="配置CSP指令"><a href="#配置CSP指令" class="headerlink" title="配置CSP指令"></a>配置CSP指令</h2><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>代表**<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP">内容安全策略</a>*<em>，它提供<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives">一组HTTP标头</a>（由web服务器发送时与元数据一起发送的元数据），旨在提高HTML文档的安全性。在<code>&lt;iframe&gt;</code>s安全性方面，您可以</em><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/X-Frame-Options">将服务器配置为发送适当的<code>X-Frame-Options</code> 标题。</a>*这样做可以防止其他网站在其网页中嵌入您的内容（这将导致<a href="https://en.wikipedia.org/wiki/clickjacking">点击</a>和一系列其他攻击），正如我们之前看到的那样，MDN开发人员已经做了这些工作。</p><h2 id="添加字幕"><a href="#添加字幕" class="headerlink" title="添加字幕"></a>添加字幕</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Video_and_audio_content#%E6%98%BE%E7%A4%BA%E9%9F%B3%E8%BD%A8%E6%96%87%E6%9C%AC">添加字幕操作</a></p><h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>object&gt;<code>元素的功能不同于</code>iframe&gt;`—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容！</p><p><strong>注意</strong>：<strong>插件</strong>是一种对浏览器原生无法读取的内容提供访问权限的软件。</p><p>然而，您不太可能使用这些元素 - Applet几年来一直没有被使用；由于许多原因，Flash不再受欢迎（见下面的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#The_case_against_plugins">插件案例</a>）；PDF更倾向于被链接而不是被嵌入；其他内容，如图像和视频都有更优秀、更容易元素来处理。插件和这些嵌入方法真的是一种传统技术，我们提及它们主要是为了以防您在某些情况下遇到问题，比如内部网或企业项目等。</p><p>如果您发现自己需要嵌入插件内容，那么您至少需要一些这样的信息：</p><p>|                                                              | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed">``</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">``</a> |<br>| :———————————————————– | :———————————————————– |<br>| 嵌入内容的<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">网址</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-src"><code>src</code></a> |<br>| 嵌入内容的<em>准确</em><a href="https://developer.mozilla.org/en-US/docs/Glossary/MIME_type">媒体类型</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-type"><code>type</code></a> |<br>| 由插件控制的框的高度和宽度（以CSS像素为单位）                | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-height"><code>height</code></a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-width"><code>width</code></a> |<br>| 名称和值，将插件作为参数提供                                 | 具有这些名称和值的ad hoc属性                                 |<br>| 独立的HTML内容作为不可用资源的回退                           | 不支持（<code>&lt;noembed&gt;</code>已过时）                                  |</p><p><strong>注意</strong>：<code>&lt;object&gt;</code>需要<code>data</code>属性，<code>type</code>属性或两者。如果您同时使用这两个，您也可以使用该<code>typemustmatch</code>属性（仅在Firefox中实现，在本文中）。<code>typemustmatch</code>保持嵌入文件不运行，除非<code>type</code>属性提供正确的媒体类型。<code>typemustmatch</code>因此，当您嵌入来自不同<a href="https://developer.mozilla.org/en-US/docs/Glossary/origin">来源的</a>内容（可以防止攻击者通过插件运行任意脚本）时，可以赋予重要的安全优势。</p><h2 id="SVG元素参考"><a href="#SVG元素参考" class="headerlink" title="SVG元素参考"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">SVG元素参考</a></h2><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web#see_also">See also</a></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started">SVG tutorial</a> on MDN</li><li><a href="http://thenewcode.com/744/Making-SVG-Responsive">Quick tips for responsive SVGs</a></li><li><a href="https://tympanus.net/codrops/2014/08/19/making-svgs-responsive-with-css/">Sara Soueidan’s tutorial on responsive SVG images</a></li><li><a href="https://www.w3.org/TR/SVG-access/">Accessibility benefits of SVG</a></li><li><a href="https://css-tricks.com/scale-svg/">How to scale SVGs </a>(it’s not as simple as raster graphics!)</li></ul><h2 id="响应者适应模式"><a href="#响应者适应模式" class="headerlink" title="响应者适应模式"></a><a href="https://developer.mozilla.org/en-US/docs/Tools/Responsive_Design_Mode">响应者适应模式</a></h2>]]></content>
    
    
    <summary type="html">web-first(continue)</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2021/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-03-09T05:15:59.000Z</published>
    <updated>2021-03-13T12:58:36.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>来自菜鸟教程</p><h2 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ol><li><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p></li><li><p>非打印字符</p><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table></li><li><p>特别字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。比如限定符</p></li><li><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>以下正则表达式匹配一个正整数，**[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]*** 表示任意多个数字：</p></li><li><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table></li><li><p>选择</p><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)</p><p>但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 <strong>?:</strong> 放在第一个选项前来消除这种副作用</p></li><li><p>先/后行断言</p><p>个人感觉这是一种修饰，不会有括号那种缓冲的副作用</p><p>**exp1(?=exp2)**：查找 exp2 前面的 exp1</p><p><strong>(?&lt;=exp2)exp1</strong>：查找 exp2 后面的 exp1。</p><p>**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。</p><p><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</p></li><li><p>修饰符：(置于表达式之后)</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table></li></ol><h3 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h3><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td align="left">(?=pattern)</td><td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?!pattern)</td><td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?&lt;=pattern)</td><td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td align="left">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">\nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">\un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h2 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h2><p>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^once</span><br></pre></td></tr></table></figure><p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket$</span><br></pre></td></tr></table></figure><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 <strong>^</strong> 和 <strong>$</strong> 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^bucket$</span><br></pre></td></tr></table></figure><p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">once</span><br></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was a man from NewYork</span><br><span class="line">Who kept all of his cash in a bucket.</span><br></pre></td></tr></table></figure><p>是匹配的。</p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:<strong>、</strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Is is the cost of of gasoline going up up?</span><br></pre></td></tr></table></figure><p>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Is is the cost of of gasoline going up up&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/\b([a-z]+) \1\b/ig</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(patt1));</span><br></pre></td></tr></table></figure><h2 id="小ps："><a href="#小ps：" class="headerlink" title="小ps："></a>小ps：</h2><ol><li><em>*<em>*</em>** 和 *</em>+** 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。**</li></ol><h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><p>转自<a href="https://oddfar.com/archives/35/">https://oddfar.com/archives/35/</a></p><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、数字：^[0-9]*$</span><br><span class="line">2、n位的数字：^\d&#123;n&#125;$</span><br><span class="line">3、至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line">4、m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line">5、零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line">6、非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">7、带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line">8、正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">9、有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line">10、有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line">11、非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br><span class="line">12、非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="line">13、非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="line">14、非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="line">15、非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="line">16、非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="line">17、正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line">18、负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line">19、浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-  1、汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="line">-  2、英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="line">-  3、长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="line">-  4、由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line">-  5、由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line">-  6、由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line">-  7、由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line">-  8、由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="line">-  9、中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line">- 10、中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br><span class="line">- 11、可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+</span><br><span class="line">- 12、禁止输入含有~的字符：[^~\x22]+</span><br></pre></td></tr></table></figure><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-  1、Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">-  2、域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br><span class="line">-  3、InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br><span class="line">-  4、手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line">-  5、电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ </span><br><span class="line">-  6、国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line">-  7、身份证号码(数字、字母x结尾)：^(\d&#123;15&#125;$|^\d&#123;18&#125;$|^\d&#123;17&#125;(\d|X|x))$</span><br><span class="line">-  9、帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line">- 10、密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line">- 11、强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  </span><br><span class="line">- 12、日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 1、  中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line">- 2、  双字节字符：  [^\x00-\xff](包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line">- 3、 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)</span><br><span class="line">- 4、 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line">- 5、 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)  (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">- 6、 腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)</span><br><span class="line">- 7、 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)</span><br><span class="line">- 8、 IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)</span><br><span class="line">- 9、 匹配所有字符：(.*?)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">useful skill-Regular expression</summary>
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="Regular expression" scheme="http://example.com/tags/Regular-expression/"/>
    
  </entry>
  
  <entry>
    <title>pythoning</title>
    <link href="http://example.com/2021/03/08/pythoning/"/>
    <id>http://example.com/2021/03/08/pythoning/</id>
    <published>2021-03-08T06:28:04.000Z</published>
    <updated>2021-03-13T12:58:13.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python学习中！"><a href="#Python学习中！" class="headerlink" title="Python学习中！"></a>Python学习中！</h1><p>[toc]</p><h2 id="python要学的"><a href="#python要学的" class="headerlink" title="python要学的"></a>python要学的</h2><ol><li>基础语法（Y）</li><li>进阶语法（）</li><li>内置函数（）</li><li>高级：库（），正则表达式（），进程线程（），mySQL（）</li><li>后端三大框架（Django、 Flask以及Tornado）</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。</p></li><li><p>可变对象和不可变对象：可变指存在某项操作可以改变本身如list</p></li><li><p>set里都是key，set可以做&amp;和|操作</p></li><li><p>tuple里的不变指“指向对象不变”，指向的对象自身可以变（如list）</p></li><li><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p></li><li><p>占位符pass什么都不做</p></li><li><p>函数可以同时返回多个值，但其实就是一个tuple，多个变量可以同时接收一个tuple，按位置赋给对应的值</p></li><li><p>定义默认参数要牢记一点：默认参数必须指向不变对象！如果指向可变对象如一个list，默认参数则指向这个list，且内容会被记住，每次调用都有继承，通过妙用不变对象来规避</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">L=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><p>​    因为Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p></li><li><p>参数前加*可以接受list和tuple并组装成tuple，加**则自动组装成dict，不过此时的key不用加引号</p></li><li><p>命名关键字：</p></li><li><p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p></li><li><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, *args, city, job</span>):</span></span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure></li><li><p>函数参数规则：</p><ol><li><em><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></em></li><li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</li><li><strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li></ol></li><li><p>```python<br> a, b = b, a + b #这个挺诡异的，记录了初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">15. 切片可用于str，list，tuple</span><br><span class="line"></span><br><span class="line">16. 判断一个对象是可迭代对象：通过collections模块的Iterable类型判断</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;python</span><br><span class="line">    &gt;&gt;&gt; from collections import Iterable</span><br><span class="line">    &gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代</span><br></pre></td></tr></table></figure></li><li><p>列表解析：</p><ol><li>可以使用两层循环，可以生成全排列：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>for后面的<code>if</code>是一个筛选条件，不能带<code>else</code></p></li><li><p>for前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果，必须加上else，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>生成器generator：</p><ol><li><p>第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code></p></li><li><p>二：如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator</p><p>​    变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p></li><li><p>generator函数的“调用”实际返回一个generator对象：</p></li><li><p>但是用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;g:&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;Generator return value:&#x27;</span>, e.value)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p></li><li><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为不同地方都指向同一个对象，多处修改</p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" title="来自廖雪峰的装饰器详解">装饰器详解</a>functools.wraps(func)</p></li><li><p>偏函数：</p><p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。其实也可以传入其他值，会自动加到左侧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2 &#x3D; functools.partial(max, 10)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) = <span class="built_in">max</span>(<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li><p>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.__name</span><br></pre></td></tr></table></figure><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p></li><li><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p></li><li><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是 <em><strong>多态真正的威力</strong></em>：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p></li><li><p>动态语言的“鸭子类型”，它并不要求严格的继承体系,只要同样能进行操作，并不会检查它的类型，即使你要求的参数是animal类</p></li><li><p>千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p></li><li><p>可以给实例动态绑定属性（直接）</p><p>A是类，a=A()  </p><p> a.name=’darren’  del(a.name)可以直接操作</p><p>print(a.attribute)要是没有特殊的，就打印A的</p><p>还可以动态绑定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span>(<span class="params">self, age</span>):</span> <span class="comment">#定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p>可以直接给类动态绑定方法</p><p>A.set_age=set_age</p><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字</p></li><li><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure><p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p><p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p><p>（怪怪的）</p></li><li><p>@property   @method_name.setter将方法变成类</p></li><li><p><em><strong>定制类</strong></em>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">len</span>--:<span class="built_in">len</span>函数自动调用的计算长度工具</span><br><span class="line">--name--:获得当前函数的名族(functions.wraps(fun))</span><br><span class="line">--<span class="built_in">str</span>--:返回用户信息</span><br><span class="line">--<span class="built_in">repr</span>--:返回开发者信息</span><br><span class="line">--<span class="built_in">iter</span>--:返回迭代对象，使一个类可以被<span class="keyword">for</span> <span class="keyword">in</span>使用</span><br><span class="line">--<span class="built_in">next</span>--:迭代将调用--<span class="built_in">next</span>--方法</span><br><span class="line">--getitem--:实现下标访问[]（切片要分类。。。不懂）</span><br><span class="line">--setitem--:把对象视作<span class="built_in">list</span>/<span class="built_in">dict</span>来赋值</span><br><span class="line">--delitem--:删除某元素</span><br><span class="line">--<span class="built_in">getattr</span>--:在没有找到属性/方法时返回定义好的，可实现动态调用！</span><br><span class="line">--call--:直接对实例进行调用！可调用对象是Callable</span><br><span class="line">Python的官方文档:</span><br><span class="line">  https://docs.python.org/<span class="number">3</span>/reference/datamodel.html<span class="comment">#special-method-names</span></span><br></pre></td></tr></table></figure></li><li><p>枚举：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum，unique</span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure><p><em>value默认从1开始！！！！</em></p><p>用@unique精确控制Enum衍生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line">    day1=Weekday.Mon</span><br><span class="line">    day1==Weekday(<span class="number">1</span>)</span><br><span class="line">    day1.value==<span class="number">1</span></span><br></pre></td></tr></table></figure><p>用.value获得对应的值</p></li><li><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数，所以类的类型是‘type’。</p></li><li><p>object是python的默认类，有很多的方法，python种默认的list,str,dict等等都是继承了object类的方法，继承了object的类属于新式类 ，没有继承属于经典类，在python3种默认都是新式类，也即是所有的自定义类，基类都会继承object类！</p></li><li><p>type也可创建新类</p><ol><li>class的名称；</li><li>继承的父类集合</li><li>class的方法名称与函数绑定，</li></ol></li><li><p>先定义metaclass，就可以创建类，最后创建实例。</p><p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”，它可以改变类创建时的行为。</p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。。。</p><p>按照默认习惯，metaclass的类名总是以Metaclass结尾</p><p>（写法着实奇怪。。不放了。。希望这辈子碰不到！听说ORM要用。。）</p><p>url：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072#0">使用元类 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p></li></ol><h3 id="错误-amp-异常"><a href="#错误-amp-异常" class="headerlink" title="错误&amp;异常"></a>错误&amp;异常</h3><ol><li><p>错误衍生：</p><p>The class hierarchy for built-in exceptions is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure></li><li><p>try .. except.. excepy…else…finally</p><p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>bar()</code>，<code>bar()</code>调用<code>foo()</code>，结果<code>foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理</p></li><li><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出.</p><p>顺着错误信息一路向下就可以找到根源</p></li><li><p>logging可以记录错误信息，要配置。。。<a href="https://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程 -</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">try</span>://</span><br><span class="line"><span class="keyword">except</span>: Excerption <span class="keyword">as</span> e:</span><br><span class="line">    logging.excerption(e)</span><br></pre></td></tr></table></figure><p>这样，在抛出错误信息后继续运行</p><p>当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理，raise不带参数则原样抛出</p></li><li><p>assert … , ‘decleration’可以在解释时<code>python -O file.py</code>来终止调用assert</p><p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看</p></li><li><p>logging.info()输出一段文本</p><p>在import logging后加<code>logging.basicConfig(level=logging.INFO)</code>指定记录信息的级别</p><p>error&gt;warning&gt;info&gt;debug，上面规定INFO后，logging.debug就失效了</p></li><li><p>PDB我不想学。。不如IDE自带</p></li><li><p>测试unittest参见《入门》</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest mydict_test</span><br></pre></td></tr></table></figure><p>可以直接启用测试，常用的assetRaises,Equal,NotEqual,True,False,In,NotIn</p><p>在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行</p></li><li><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure></li></ol><h2 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h2><ol><li><p><code>str.replace(&#39;a&#39;,&#39;A&#39;) 把字符串里的a替换成A</code></p></li><li><p>abs（）绝对值，max（）返回最大值</p></li><li><p>help(function_name)放到print里克查看帮助信息</p></li><li><p>int，float，str，bool 内置数据类型转换</p></li><li><p>hex（）函数把一个整数转换成十六进制表示的字符串</p></li><li><p>内置函数<code>isinstance()</code>用于数据类型检查，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p></li><li><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素，并返回的是一个<code>Iterator</code></p></li><li><p>sorted（列表，映射函数，reverse=True）</p><p>比较对每一项使用映射函数后的新列表！</p></li><li><p>基本类型都可以用<code>type()</code>判断，返回相应class</p><p>可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(fn)==types.FunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)==types.BuiltinFunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="keyword">lambda</span> x: x)==types.LambdaType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))==types.GeneratorType</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>函数，它返回一个包含字符串的list获得一个对象的所有属性和方法</p></li><li><p>```python<br>getattr()<code>、</code>setattr()<code>以及</code>hasattr()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以分别验证，设置，得到某个instance的属性和方法</span><br><span class="line"></span><br><span class="line">如果试图获取不存在的属性，会抛出AttributeError的错误：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;</span><br></pre></td></tr></table></figure><p>可以传入一个default参数，如果属性不存在，就返回默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span></span><br></pre></td></tr></table></figure></li><li><pre><code class="python"> raise ValueError(&#39;score must be an integer!&#39;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">15. eval()解析字符串为指令</span><br><span class="line"></span><br><span class="line">## 一些包</span><br><span class="line"></span><br><span class="line">1. math包用很多常用数学函数</span><br><span class="line"></span><br><span class="line">2. Python内置的&#96;enumerate&#96;函数可以把一个list变成索引-元素对，这样就可以在&#96;for&#96;循环中同时迭代索引和元素本身：</span><br><span class="line"></span><br></pre></td></tr></table></figure>&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):...     print(i, value)...0 A1 B2 C</code></pre></li></ol><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol><li><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p></li></ol><h2 id="以后再学"><a href="#以后再学" class="headerlink" title="以后再学"></a>以后再学</h2><ol><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904" title="廖雪峰">定制类</a></li><li></li></ol>]]></content>
    
    
    <summary type="html">web-backend-base</summary>
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://example.com/2021/03/06/git/"/>
    <id>http://example.com/2021/03/06/git/</id>
    <published>2021-03-06T12:33:45.000Z</published>
    <updated>2021-03-13T12:53:31.579Z</updated>
    
    <content type="html"><![CDATA[<p>git init</p><p>git status</p><p>git add file</p><p>git commit -m “”</p><p>git log –oneline</p><p>git reflog</p><p>git reset –hard HEAD^(版本号)</p><p>HEAD^^  HEAD~100</p><p>git diff HEAD – file</p><p>查看工作区和版本库不同</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>checkout  -&gt; restore</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage）</p><p> `git reset HEAD -&gt; git restore –staged</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><p>远程</p><p>git remote -v</p><p>git remote remove origin</p><p>git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>:git_username/repository_name.git</p><p>git pull origin master –allow-unrelated-histories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>git push origin master</p><p>git push -u origin main -f 强制push！！</p><p>git clone url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建 &lt;name&gt; 的分支并切换</span><br><span class="line">git switch -c &lt;name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建</span><br><span class="line">git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切换到&lt;name&gt;分支</span><br><span class="line">git checkout &lt;name&gt;</span><br><span class="line">git switch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看分支树</span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除分支</span><br><span class="line">git branch -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合并分支 假设这里存在 master ， dev 分支</span><br><span class="line">  &#x2F;&#x2F; 1 切换到要保留的分支——这里是master</span><br><span class="line">  git checkout master</span><br><span class="line">  &#x2F;&#x2F; 2 合并掉分支dev</span><br><span class="line">  git merge dev</span><br></pre></td></tr></table></figure><p><code>git log --graph</code>命令可以看到分支合并图</p>]]></content>
    
    
    <summary type="html">git commands</summary>
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
</feed>
