<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Observatory</title>
  
  <subtitle>逆水行舟，不进则退，何堪清醒，且行且醉。</subtitle>
  <link href="https://darren-dong.com/atom.xml" rel="self"/>
  
  <link href="https://darren-dong.com/"/>
  <updated>2022-05-13T12:41:34.996Z</updated>
  <id>https://darren-dong.com/</id>
  
  <author>
    <name>Darren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Book Of Why</title>
    <link href="https://darren-dong.com/2022/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>https://darren-dong.com/2022/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88/</id>
    <published>2022-05-10T03:46:04.000Z</published>
    <updated>2022-05-13T12:41:34.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在开始前：</p><p>我在大二上学习概率论时，我曾经对事件的独立性的描述感到奇怪，书上仅描述了事件组之间相互独立的性质上的结论，却没有式子来刻画更本质的因果和独立性的传递，还追问了老师很久，最好不了了之，没有发现因果科学。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111037508.png" alt="image-20220511103728428" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111037136.png" alt="image-20220511103754059" style="zoom: 33%;" /></p><p>没想到，阴差阳错下有机会学习因果科学，弥补心中的遗憾。笔者认为，这是一门直指世界本质的，值得一学的伟大科学。</p></blockquote><h1 id="为什么——因果科学"><a href="#为什么——因果科学" class="headerlink" title="为什么——因果科学"></a>为什么——因果科学</h1><h2 id="0-思维胜于数据"><a href="#0-思维胜于数据" class="headerlink" title="0. 思维胜于数据"></a>0. 思维胜于数据</h2><p>对于没有概率统计基础的读者来说，笔者的阅读建议是略过数学细节，着重抓住内容大意；</p><p>而对于有一定概率统计基础的读者来说，笔者认为在阅读时<u>一定不能放过正文中的数学精髓</u>，这本书中的数学公式不多不少，刚好自圆其说。</p><p><strong>本书目标</strong>：</p><p>首先，用非数学的语言阐述因果革命的知识内涵，说明它将怎样影响我们的生活和未来。</p><p>其次，分享在解决重要的因果问题时，我们的科学家前辈走过的英勇征程，无论成败，这些故事都值得讲述。</p><p>最后，回溯因果革命在人工智能领域的发源地，目的是向你介绍如何开发出用我们的母语——因果语言进行交流的机器人。新一代机器人应该能够向我们解释事情为何发生，为何机器人以它们选择的某种方式做出反应，以及大自然为何以这样而非那样的方式运作。一个更加雄心勃勃的目标是，它们也应该能够让我们进一步认识人类自身：我们的思维为什么以这样的方式运行，以及理性思考原因和结果、信任和遗憾、目的和责任究竟意味着什么。</p><p><strong>what is 因果推断</strong>：</p><p>它假设人类大脑是大自然有史以来为处理因果知识而设计出的最先进的工具。我们的大脑存储了海量的因果知识，而在数据的辅助下，我们可以利用这些知识解决当代社会所面临的最紧迫的问题。一个更宏伟的目标是，一旦我们真正理解了因果思维背后的逻辑，我们就可以在现代计算机上模拟它，进而创造出一个“人工科学家”。这个智能机器人将会为我们发现未知的现象，解开悬而未决的科学之谜，设计新的实验，并不断从环境中提取更多的因果知识。</p><p>这门新科学催生出了一种简单的数学语言，用以表达我们已知和欲知的因果关系。<u>以数学形式表达因果关系的能力让我们得以开发出许多强大的、条理化的方法</u>，将我们的知识与数据结合起来，并最终回答出如上述那5个涉及因果关系的问题。</p><p><strong>why too late</strong>：</p><p>在我看来，阻碍因果推断这一科学诞生的最大障碍，是我们用以提出因果问题的词汇和我们用以交流科学理论的传统词汇之间的鸿沟。</p><p>科学工具的开发是为了满足科学需要。</p><p>随着人类求知欲的不断增强，以及社会现实开始要求人们讨论在复杂的法律、商业、医疗等领域的决策情境中出现的因果问题，我们终于发现我们缺少一门成熟的科学所应提供的用于回答这些问题的工具和原理。</p><blockquote><p>具有讽刺意味的是，对因果关系理论的需求正是在统计学产生的那一刻浮出水面的。事实上，现代统计学的创立正源自因果问题——高尔顿和皮尔逊提出了一个关于遗传的因果问题，并独具匠心地尝试用跨代数据来解答它。遗憾的是，这一努力失败了，他们没有停下来问为什么，反而声称这些问题是禁区，转而去发展另一项刚刚兴起、不涉及因果关系的事业——统计学。</p><p>这是科学史上的一个关键时刻。给因果问题配备一套专属语言的机会眼看就要被成功捕捉并转化为现实，却被白白浪费掉了。在接下来的几年里，这些问题被宣布为“非科学”，被迫转入地下。尽管遗传学家休厄尔·赖特（1889—1988）为此做出了艰苦卓绝的努力，但因果词汇仍然被科学界禁用了半个多世纪。我们知道，禁止言论就意味着禁止了思想，同时也扼杀了与此相关的原则、方法和工具。【第二章】</p></blockquote><p>统计学盲目迷恋这种常识性的观察结论。它告诉我们，相关关系不等于因果关系，但并没有告诉我们因果关系是什么。在统计学教科书的索引里查找“因果”这个词是徒劳的。统计学不允许学生们说X是Y的原因[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0005.xhtml#note2n">2]</a>，只允许他们说X与Y“相关”或“存在关联”。</p><p>这一禁律也潜移默化地让人们认同了处理因果问题的数学工具毫无用武之地这一结论，与此同时，统计学唯一关注的就是如何总结数据，而不关注如何解释数据。</p><hr><p><strong>【纯粹数据driven的局限】</strong></p><p>统计学的其他分支，以及那些依赖统计学工具的学科仍然停留在禁令时代，<u>错误地相信所有科学问题的答案都藏于数据之中，有待巧妙的数据挖掘手段将其揭示出来。</u></p><p>今天，这种以数据为中心的观念仍然阴魂不散。我们生活在一个相信大数据能够解决所有问题的时代。大学中“数据科学”方面的课程激增，在涉足“数据经济”的公司中，“数据科学家”享有极高的工作待遇。然而，我希望本书最终能说服你相信这一点：数据远非万能。数据可以告诉你服药的病人比不服药的病人康复得更快，却不能告诉你原因何在。也许，那些服药的人选择吃这种药只是因为他们支付得起，即使不服用这种药，他们照样能恢复得这么快。</p><p>在科学和商业领域，仅凭数据不足以解决问题的情况一再发生。尽管或多或少地意识到了其局限所在，但多数热衷于大数据的人仍然选择盲目地继续追捧以数据为中心的问题解决方式，仿佛我们仍活在因果禁令时代。</p><blockquote><p>在20年前，询问一个统计学家诸如“是阿司匹林治愈了我的头痛吗”这样的问题还会被视为在问他是否相信巫术。引用我的一位备受尊敬的同事的话，讨论这种问题“与其说是科学探索，不如说是鸡尾酒会上的八卦闲谈”。但今天，流行病学家、社会学家、计算机科学家以及一些开明的经济学家和统计学家开始频繁地提出这样的问题，并能够借助具有高度精确性的数学工具作答。对我来说，这种改变就是一场革命。</p></blockquote><p>（感觉因果科学是对现有相关框架的弥补，而不是对数据驱动的完全否定）</p><hr><p><strong>数学工具</strong></p><p>它背后有数学工具上的发展作为支撑，这种数学工具最恰当的名称应该是“因果关系演算法”</p><p>因果关系演算法由两种语言组成：其一为<strong>因果图（causal diagrams）</strong>，用以表达我们已知的事物，其二为<u>类似代数的符号语言</u>，用以表达我们想知道的事物。因果图是由简单的点和箭头组成的图，它们能被用于概括现有的某些科学知识。点代表了目标量，我们称之为“变量”，箭头代表这些变量之间已知或疑似存在的因果关系，即哪个变量“听从于”哪个变量。</p><p>有些科学家（比如计量经济学家）喜欢使用数学方程；另一些研究者（比如纯统计学家）则更倾向于借助一组假设来描述问题，这些假设表象化地概括了因果图的关系结构。不管使用哪种语言，因果模型都应该描述，哪怕是定性地<u>描述数据的生成过程</u>，换句话说，就是那些<u>在环境中控制并塑造数据生成的因果力量。</u></p><p>与图表式的“知识语言”并存的还有一种<strong>符号式的“问题语言”</strong>，它被用于表述我们想要回答的问题。do算子表明了我们正在进行主动干预而非被动观察，这一概念是经典统计学不可能涉及的。</p><blockquote><p><em>An example</em></p><p>干预算子do（D）来确保观察到的病人存活期L的变化能完全归因于药物本身，而没有混杂其他影响寿命长短的因素。如果我们不进行干预，而是让病人自己决定是否服用该药物，那么<u>其他因素就可能会影响病人的决定</u>，而服药和未服药的两组病人的存活期差异也将无法再被仅仅归因于药物。</p><p>假设只有疾病发展到末期的病人服用了这种药，那么这些人的情况就显然不同于那些不服药的病人，两组的比较结果实际上反映的是其病情的严重程度，而非药物的影响。<br>相比之下，随机地指示一些病人服用药物或不服用药物，而不考虑先决条件如何，则可以去除两组病人之间原有的差异，提供有效的比较结果。</p></blockquote><p>注意P（L|D）与P（L|do（D））完全不同。观察到（seeing）和进行干预（doing）有本质的区别，它解释了我们不认为气压计读数下降是风暴来临的原因。<br>观察到气压计读数下降意味着风暴来临的概率增加了，但人为迫使气压计读数下降对风暴来临的概率并不会产生影响。</p><p><u>对观察和干预的混淆成为悖论之源</u>，对此本书将展开详细的讨论。缺少P（L|do（D）），而完全由P（L|D）统治的世界将是十分荒诞的。在这个世界中，病人不去就诊就能减少人们患重病的概率，城市解雇消防员就能减少火灾的发生</p><p>因果革命<strong>最重要的成果之一</strong>就是解释了<u>如何在不实际实施干预的情况下预测干预的效果</u>。</p><p><strong>反事实（counterfactual）</strong></p><p>经典统计学只关注总结数据，因此它甚至无法提供一种语言让我们提出上面那个问题。因果推断则不仅提供了一种表达符号，更重要的是，它还提供了一种解决方案。这使得我们在预测干预效果时，在多数情况下能够借助一种算法来模拟人类的反思性思考，通过将我们<u>对观测世界的了解输入算法系统</u>，其将输出有关<u>反事实世界的答案</u>。</p><p>反事实并非异想天开之物，而是反映了现实世界运行模式的特有结构。共享同一因果模型的两个人也将共享所有的反事实判断。</p><p>反事实是道德行为和科学思想的基石。回溯自己过去的行为以及设想其他可能情景的能力是自由意志和社会责任的基础。反<u>事实的算法化</u>使“思维机器”（thinking machine）习得这种人类特有的能力，并掌握这种目前仍为人类所独有的思考世界的方式成为可能。</p><blockquote><p>20世纪80年代末，我意识到智能机器缺乏对因果关系的理解，这也许是妨碍它们发展出相当于人类水平的智能的最大障碍。我坚信强人工智能是一个可实现的目标，也是一个完全无须恐惧的目标，因为我们在实现它的过程中纳入了因果关系。因果推理模块将使智能机器有能力反思它们的错误，找到自身软件程序中的弱点，并能像一个道德实体那样思考和行动，自然地与人类交流它们自己的选择和意图。</p></blockquote><p><strong>因果模型</strong></p><p>因果模型将科学、知识、数据这些晦涩的概念纳入了一个具体的、有意义的背景框架，让我们得以看到三者是如何相互协作以解答棘手的科学问题的。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111009358.png" alt="image-20220511100924246"></p><p>因果推断引擎是一种问题处理机器，它接收三种不同的输入——假设、问题和数据，并能够产生三种输出。能够将数据与因果知识相结合生成目标问题的答案。(虚线框不是引擎的组成部分，但它是构建引擎的<u>必要基础</u>。箭头也可以从方框4和方框9指向方框1，也即是把答案添加到已有的知识中去)</p><p>第一种输出是“是/否”判断，用于判定<u>在现有的因果模型下，假设我们拥有完美的、无限的数据</u>，那么给定的问题在理论上是否有解。</p><p>如果答案为“是”，则接下来推断引擎会生成一个被估量。这是一个数学公式，可以被理解为一种能<u>从任何假设数据中生成答案的方法</u>，只要这些数据是可获取的。</p><p>最后，在推断引擎接收到数据输入后，它将用上述方法生成一个问题答案的实际估计值，并给出对该估计值的不确定性大小的统计估计。这种不确定性反映了样本数据集的代表性以及可能存在的测量误差或数据缺失。</p><blockquote><p>1.“知识”指的是推理主体（reasoning agent）过去的经验，包括过去的观察、以往的行为、接受过的教育和文化习俗等所有被认为与目标问题有关的内容。“知识”周围的虚线框表示它仍隐藏在推理主体的思想中，<u>尚未在模型中得到正式表达</u>!</p><p>2.研究者所拥有的大部分知识都隐藏于他的大脑，只有假设能将其公之于世，也只有假设才能被嵌入模型。</p><p>4.以因果模型的路径来表示的变量之间的听从模式通常会导向<u>数据中某种显而易见的<em>模式或相关关系</em></u>。这些模式可被用于测试模型，因此也被称为“<u>可验证的蕴涵”（testable implications）</u>。将“D和L之间没有连接路径”翻译成统计学语言，就是“D和L相互独立”，也就是说，发现D的存在不会改变L发生的可能性。而如果实际数据与这一推断相抵触，那么我们就需要修改模型。此类修改涉及另一个引擎，它从方框4和方框7中获取输入，并计算模型的“拟合度”，即数据与模型假设的匹配程度。为尽可能简化示意图起见，我没有在图0.1中表示出这个引擎。</p><blockquote><p>在命题逻辑和谓词逻辑中，蕴涵这一概念用于描述两个陈述语句集合之间的联系(离散那个概念)</p></blockquote><p>5.向推理引擎提交的问题就是我们希望获得解答的科学问题，这一问题必须用<em>因果词汇</em>来表述。例如，我们现在感兴趣的问题是：P（L|do（D））是什么？因果革命的主要成就之一就是确保了这一语言在<u>科学上容易理解，同时在数学上精确严谨</u>。</p><p>6.被估量“estimand”来自拉丁语，意思是“需要估计的东西”。它是我们<u>从数据中估算出来的统计量</u>。一旦这个量被估算出来，我们便可以用它来合理地表示问题的答案。虽然被估量的<em>表现形式</em>是一个概率公式，如P（L|D，Z）×P（Z），但<u>实际上它是一种<em>方法</em>，可以让我们根据我们所掌握的数据类型回答因果问题</u>（前提是推断引擎证实了这种数据类型就是我们需要的）</p><p>与传统的统计学所提供的估计方法不同，在当前的因果模型下，无论我们收集到多少数据，<u>有些问题可能仍然无法得到解答</u>。例如，如果我们的模型显示D和L都依赖于第三变量Z（比如疾病的发展阶段），并且，如果我们没有任何方法可以测量Z的值，那么问题P（L|do（D））就无法得到解答。在这种情况下，<u>收集数据完全就是浪费时间。相反，我们需要做的是回过头完善模型</u>，具体方式则是<em>输入新的科学知识</em>，使我们可以估计Z的值，或者<em>简化假设</em>（注意，此处存在犯错的风险），例如假设Z对D的影响是可以忽略不计的。（看完第二章的例子就懂了）</p><p>:star: 7.一定要认识到，<u>数据本身不具备表述因果关系的能力。</u>数据告诉我们的只是数量信息，如P（L|D）或P（L|D，Z）的值。<u>而被估量则能够告诉我们如何将这些统计量转化为一个表达式。</u>基于模型假设，该表达式<u>在逻辑上等价于我们所要回答的因果问题</u>，比说P（L|do（D））。</p><p>被估量这个概念以及图0.1顶部的所有概念在统计分析的传统方法中都是不存在的。在传统的统计方法中，被估量就等同于有待解决的问题。</p><p>8.你已经得到了一个新鲜出炉的估计值。不过，它只是一个近似值，其原因涉及关于数据的另一个真相：数据永远是从<u>理论上无限的总体中抽取的有限样本。</u>即使这种筛选是随机的，我们也无法避免根据样本测量的概率无法代表整个总体的相应概率的可能性。幸运的是，依靠机器学习领域所提供的先进技术，统计学科为我们提供了很多方法来应对这种不确定性，这些方法包括<u>最大似然估计、倾向评分、置信区间、显著性检验</u>等</p></blockquote><p>请注意，我们是在完成了以下步骤之后才收集的数据：根据假设确定了因果模型，提出了我们想要解决的科学问题，推导出被估量。这与上面提到的传统统计方法形成了鲜明对比，后者甚至没有用到因果模型。</p><p>【许多人工智能领域的研究者仍然想跳过构建因果模型或识别出已有的因果模型这一难度较大的步骤，只依赖数据解决所有的认知难题。他们希望在因果问题出现时，数据本身就能指引他们找到正确的答案】</p><p>但对于因果关系方面的知识来说，数据没有任何发言权。例如，有关行动或干预结果的信息根本无法从原始数据中获得，<u>这些信息只能从对照试验操作中收集。</u></p><p>因果模型所具备而数据挖掘和深度学习所缺乏的另一个优势就是<strong>适应性</strong>。注意在图0.1中，被估量是在我们<u>真正检查数据的特性之前仅仅根据因果模型计算出来的</u>，这就使得因果推断引擎适应性极强，因为无论变量之间的数值关系如何，被估量都能适用于与定性模型适配的数据。</p><blockquote><p>通过观察许多服用药物D的患者的存活期L，某研究者能够预测出某个具有Z特征的病人存活L年的概率。现在，假设她被调职到位于城市另一地区的医院，而那里的人口总体特征（饮食、卫生、工作习惯）与原来的地区有所不同。即使这些新特性仅仅改变了以前她所记录的变量之间的数值关系，她仍不得不重新自我训练，再次从头学习新的预测函数。这就是深度学习程序所能做的：将函数与数据拟合。</p><p>而如果该研究者掌握了药物的作用机制，并且新地区的因果模型结构仍与原来保持一致，那么她在以往的训练中获得的被估量就依然有效，可被应用于新数据，产生一个新的关于特定总体的预测函数。</p></blockquote><p>贝叶斯网络是让计算机得以在“灰色地带”进行思考的第一个工具，有段时期，我曾坚信它掌握着开启人工智能大门的钥匙。而到了20世纪80年代末，我终于确信自己错了，本章讲述的正是我从贝叶斯倡导者变身为“叛教者”的整段旅程。不过，<u>贝叶斯网络仍然是人工智能领域的一个非常重要的工具，其涵盖了因果图的大部分数学基础。</u></p><p>这些悖论是一种警示，用以提醒科学家们人类的直觉是根植于因果的，而不是根植于统计和逻辑的。</p><p>如果能用一句话来概括本书的内容，那就是“<u>你比你的数据更聪明”。数据不了解因果，而人类了解</u>。我希望因果推断这门新科学能让我们更好地理解我们是如何做到这件事的，因为除了自我模拟，我们没有更好的方法来了解人类自身了。与此同时，在计算机时代，这种新的理解也有望被应用于增强人类自身的因果直觉，从而让我们更好地读懂数据，无论是大数据还是小数据。</p><p>（感觉要读懂，就得破除思想中对客观数据的迷信，更何况数据本身也可能是不客观的。）</p><h2 id="1-因果关系之梯"><a href="#1-因果关系之梯" class="headerlink" title="1. 因果关系之梯"></a>1. 因果关系之梯</h2><ul><li>首先，人类在进化早期就意识到世界并非由枯燥的事实（我们今天可能称之为数据）堆砌而成；相反，这些<u>事实是通过错综复杂的因果关系网络融合在一起</u>的。</li><li>其次，<u>因果解释而非枯燥的事实构成了我们大部分的知识，它应该成为机器智能的基石</u>！！</li><li>最后，我们从数据处理者向因果解释者的过渡不是渐进的，而是一次“大跃进”，借助的是某种奇异的外部推力。这与我在因果关系之梯上的理论观察完全吻合：没有哪台机器可以从原始数据中获得解释。对数据的解释需要借助外部推力。</li></ul><p><strong>因果关系的三个层级</strong></p><p>可能大家会觉得，我们将关于这个世界的知识组织起来融入因果关系网络的能力是一种一体化的能力，是可以一下子学会或领悟的。</p><p>事实上，我在机器学习方面的研究经历告诉我，因果关系的学习者必须熟练掌握至少三种不同层级的认知能力：<br><em>观察能力（seeing）、行动能力（doing）和想象能力（imagining）。</em></p><p>第一层级是观察能力，具体而言是指发现环境中的规律的能力。在认知革命发生之前，这种能力为许多动物和早期人类所共有。</p><p>第二层级是行动能力，涉及<u>预测对环境进行刻意改变后的结果，并根据预测结果选择行为方案以催生出自己期待的结果</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111138036.png" alt="image-20220511113834921" style="zoom:67%;" /><p>处于第一层级的是<strong>关联</strong>，在这个层级中我们通过观察寻找规律。如果观察到某一事件改变了观察到另一事件的可能性，我们便说这一事件与另一事件相关联。因果关系之梯的第一层级要求我们基于被动观察做出预测。其典型问题是：“如果我观察到……会怎样？”<br>统计学本身并不能告诉我们，牙膏或牙线哪个是因，哪个是果。好的预测无须好的解释。</p><blockquote><p>强人工智能这一目标是制造出拥有类人智能的机器，让它们能与人类交流并指导人类的探索方向。而深度学习只是让机器具备了高超的能力，而非智能。这种差异是巨大的，原因就在于后者缺少现实模型</p></blockquote><p>当我们开始改变世界的时候，我们就迈上了因果关系之梯的更高一层台阶。这一层级的一个典型问题是：“如果我们把牙膏的价格翻倍，牙线的销售额将会怎么样？”这类问题处于因果关系之梯的第二层级，提出及回答这类问题要求我们掌握一种脱离于数据的新知识，即<strong>干预</strong>。</p><blockquote><p>无论数据集有多大或者神经网络有多深，<u>只要使用的是被动收集的数据，我们就无法回答有关干预的问题</u>。从统计学中学到的任何方法都不足以让我们明确表述类似“如果价格翻倍将会发生什么”这样简单的问题，更别说回答它们了。</p><p>为什么不直接进入存有历史购买信息的庞大数据库，看看在牙膏价格翻倍的情况下实际发生了什么呢？原因在于，在以往的情况中，涨价可能出于完全不同的原因，例如产品供不应求，其他商店也不得不涨价等。但现在，我们<u>并不关注行情如何，只想通过刻意干预为牙膏设定新价格</u>，因而其带来的结果就可能与此前顾客在别处买不到便宜牙膏时的购买行为大相径庭。如果你有历史行情数据，也许你可以做出更好的预测……但是，你知道你需要什么样的数据吗？你准备如何理清数据中的各种关系？这些正是因果推断科学能帮助我们回答的问题。</p><p>:star: 一个足够强大的、准确的<em>因果模型</em>可以让我们<u>利用第一层级（关联）的数据来回答第二层级（干预）的问题</u>。没有因果模型，我们就不能从第一层级登上第二层级。这就是深度学习系统（只要它们只使用了第一层级的数据而没有利用因果模型）永远无法回答干预问题的原因，干预行动据其本意就是要打破机器训练的环境规则。</p></blockquote><p>因果关系之梯第二层级的典型问题就是：“如果我们实施……行动，将会怎样？”也即，如果我们改变环境会发生什么？第二层级中的另一个热门问题是：“怎么做？”</p><p><strong>反事实</strong>与数据之间存在着一种特别棘手的关系，因为数据顾名思义就是事实。数据无法告诉我们在反事实或虚构的世界里会发生什么，在反事实世界里，观察到的事实被直截了当地否定了。然而，人类的思维却能可靠地、重复地进行这种寻求背后解释的推断。</p><blockquote><p>你可能会怀疑，对于“假如”（would haves）这种并不存在的世界和并未发生的事情，科学能否给出有效的陈述。科学确实能这么做，而且一直就是这么做的。举个例子，“在弹性限度内，假如加在这根弹簧上的砝码重量是原来的两倍，弹簧伸长的长度也会加倍”（胡克定律），像这样的<u>物理定律就可以被看作反事实断言</u>。当然，这一断言是从诸多研究者在数千个不同场合对数百根弹簧进行的实验中推导出来的，得到了大量试验性（第二层级）证据的支持。然而，一旦被奉为“定律”，物理学家就把它解释为一种函数关系，自此，这种函数关系就在假设中的砝码重量值下支配着某根特定的弹簧。所有这些不同的世界，其中砝码重量是x磅[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0006.xhtml#note1n">1]</a>，弹簧长度是Lx英寸[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0006.xhtml#note2n">2]</a>，都被视为客观可知且同时有效的，哪怕它们之中只有一个是真实存在的世界。</p></blockquote><p>假如当时发生的事情与实际不同，那会怎样？”对这个问题的回答让我们得以从历史和他人的经验中获取经验教训，这是其他物种无法做到的。</p><p>:star: 如果第一层级对应的是观察到的世界，第二层级对应的是一个可被观察的美好新世界，那么第三层级对应的就是一个无法被观察的世界（因为它与我们观察到的世界截然相反）</p><p><strong>迷你图灵测试</strong></p><p>在创造出具备孩童智能水平的机器人之前，我们可能的确无法成功创造出类人智能，而创造出前者的关键要素就是掌握因果关系。</p><p>机器如何才能获得关于因果关系的知识呢？目前，这仍然是一项重大挑战，其中无疑会涉及复杂的输入组合。这些输入来自<u>主动实验、被动观察和（最关键的）程序员输入</u>，这与儿童所接收的信息输入非常相似，他们的输入分别来自进化、父母和他们的同龄人（对应于程序员这个角色）</p><p>“迷你图灵测试”，其主要思路是选择一个简单的故事，用某种方式将其编码并输入机器，测试机器能否正确回答人类能够回答的与之相关的因果问题。之所以称其为“迷你”，原因有二。首先，该测试<u>仅限于考察机器的因果推理能力，而不涉及人类认知能力的其他方面</u>，如视觉和自然语言。其次，我们允许参赛者以任何他们认为便捷的表示方法对故事进行编码，这就免除了机器必须依据其自身经验构造故事的任务。让智能机器通过这个迷你测试是我毕生的事业——在过去的25年里是自觉而为，在那之前则是无意而为。</p><p>在让机器进行迷你图灵测试的准备阶段，表示问题必须优先于获取问题。如果缺少表示方法，我们就不知道如何存储信息以供将来使用。人工智能对认知研究的一个主要贡献就是确立“<u>表示第一，获取第二</u>”的范式。通常，在寻求一个好的表示方法的过程中，关于如何获取知识的洞见就会自然产生，无论这种洞见是来自数据，还是来自程序员。</p><p>作弊是困难的，假设我们有10个因果变量，每个变量只取两个值（0或1），那么我们可以提出大约3000万个关于这些变量的可能问题<br>人类的大脑肯定拥有某种<u>简洁的信息表示方式</u>，同时还拥有某种<u>十分有效的程序</u>用以正确解释每个问题，并从存储的信息表示中提取正确答案。因此，为了通过迷你图灵测试，我们需要给机器装备同样高效的表示信息和提取答案的算法。</p><p>这种表示不仅存在，而且具有孩童思维般的简洁性，它就是<strong>因果图</strong>。如果我们希望计算机能理解因果关系，我们就必须教会它如何打破规则，让它懂得<u>“观察到某事件”和“使某事件发生”</u>之间的区别。“无论何时，如果你想使某事发生，那就删除指向该事的所有箭头，之后继续根据逻辑规则进行分析..(中间)</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112002381.png" alt="image-20220511200237236"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205121301177.png" alt="image-20220512130121103" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112005168.png"/></p><p>使某事发生就意味着将它从所有其他影响因子中解放出来，并使它受限于唯一的影响因子——能强制其发生的那个因子。</p><p>假如A决定不开枪，犯人是否还活着？在虚构世界中，A没有射击，指向A的箭头被去除，这进而又解除了A与C的听命关系。现在，我们将A的值设置为假，并让A行动之前的所有其他变量的水平与现实世界保持一致。（右图）</p><hr><p>在许多情境中，人类可能需要花费很大的努力才能找到那个正确的因果结论。定量的因果推理通常超出了我们的直觉范畴。此外，为了处理不确定因素，我们就需要掌握有关异常事件发生可能性的信息。【引入概率】</p><p>从计算的角度来看，我们设计出的这种让机器通过迷你图灵测试的方案也很出色。在所有三个例子中，我们都使用了相同的程序：<br><u>将故事转化成因果图，解读问题，执行与既定问题（干预问题或反事实问题）相对应的“手术”（如果问题是关联类的，则不需要进行任何“手术”），并使用修改后的因果模型计算答案。</u><br>并且，每次改变故事的时候，我们也不必根据各种新的问题重新训练机器。这一方法具有足够的灵活性，只要我们能绘制出因果图，我们就能解决问题，无论这个问题是关乎长毛象狩猎、行刑队执行枪决还是关乎疫苗接种。这正是我们希望因果推断引擎具备的特性：一种为人类所独享的<strong>灵活性</strong>。</p><p>这些变化将对前文提到的例子中的绝大部分变量的概率产生极大的影响；但显然，原有的<u>因果图结构仍将保持不变</u>。这正是构建因果模型的关键秘诀。此外，一旦我们完成了之前的分析工作，我们就不必在条件改变时从头开始重复整个分析过程。如导言所述，同样的被估量（也就是回答相应问题的方法）将一直有效，并且只要因果图不变，该被估量就可以<u>应用于新数据，并为特定问题生成新的估计值</u>。我猜想，正是由于具备这种<strong>稳健性</strong>，人类的直觉才以因果关系而非统计关系为组织的核心。</p><p><strong>论概率与因果关系</strong></p><p>哲学家几乎无一例外地使用了条件概率来表示“X提高了Y的概率”，记作P（Y|X）&gt;P（Y）。你肯定注意到了，这种解释是错的，因为“提高”是一个因果概念，意味着X对Y的因果效应，而公式P（Y|X）&gt;P（Y）只涉及观察和手段，表示的是“如果我们观察到了X，那么Y的概率就提高了”。但是，这种概率提高完全可能是由其他因素造成的，比如Y是X的因，或者其他变量（Z）是它们二者的因——这就是症结所在！</p><p>一旦用条件概率的语言歪曲“概率提高”，即使再多的概率补丁也无法让你登上更高一层的因果关系阶梯。我知道这听起来很奇怪，但<u>概率提高这个概念确实不能单纯用概率来表示</u>。</p><p>拯救概率提高这一概念的正确方法是借助do算子来定义：如果P（Y|do（X））&gt;P（Y），那么我们就可以说X导致了Y。由于干预是第二层级的概念，因此这个定义能够体现概率提高的因果解释，也可以让我们借助因果图进行概率推算。换言之，当研究者询问是否P（Y|do（X））&gt;P（Y）时，如果我们手头有因果图和数据，我们就能够在算法上条理清晰地回答他的问题，从而在概率提高的意义上判断X是否为Y的一个因。</p><blockquote><p>我并非一直把因果放在第一位，把概率放在第二位。恰恰相反！20世纪80年代初，我开始踏足人工智能方面的研究，并认定不确定性正是人工智能缺失的关键要素。此外，我坚持不确定性应由概率来表示。因此，正如我将在第三章中解释的那样，我创建了一种关于不确定性的推理方法，名为“贝叶斯网络”，用于模拟理想化的、去中心化的人类大脑将概率纳入决策的方法。贝叶斯网络可以根据我们观察到的某些事实迅速推算出某些其他事实为真或为假的概率。不出所料，贝叶斯网络立即在人工智能领域流行开来，甚至直至今天仍被视为人工智能在包含不确定性因素的情况下进行推理的主导范式。</p><p>但它并没能弥合人工智能和人类智能之间的差距。我相信你现在也能找出那个缺失的要素了——没错，就是因果论。</p><p>当时我认为因果关系只是一个从属概念，最多不过是一种便利的思维工具或心理速记法，用以表达概率的相关性以及区分相关变量和无关变量（好有道理）</p><p>贝叶斯网络适用于一个所有问题都被简化为概率或者（用本章的术语来说就是）变量间的关联程度的世界，它无法自动升级到因果关系之梯的第二层级或第三层级。</p><p>我想说明的<strong>主要观点</strong>是：概率能将我们对静态世界的信念进行编码，而因果论则告诉我们，当世界被改变时，无论改变是通过干预还是通过想象实现的，<u>概率是否会发生改变以及如何改变</u>。</p></blockquote><h2 id="2-因果推断的起源"><a href="#2-因果推断的起源" class="headerlink" title="2. 因果推断的起源"></a>2. 因果推断的起源</h2><p>——从海盗（皮尔逊）到豚鼠</p><p>对高尔顿来说，梅花机就是一种关于身高遗传的模型，甚至可能也是关于许多其他遗传特征的模型。这是一个因果模型。简单来说，高尔顿相信，就像人类会遗传他们上一代的身高一样，金属小球也会“遗传”它们在梅花机中的位置。</p><p>但是，如果我们暂且接受这个模式，就会出现一个难题，这也是高尔顿当晚的主题。钟形曲线的宽度取决于放置在钉板顶部和底部之间钉子的行数。假设我们将行数加倍，我们就构建了一个能够表示两代遗传的模型，其中上半部分代表第一代，下半部分代表第二代。此时你就会发现，第二代比第一代出现了更多的变异情况，而在随后的几代中，钟形曲线会变得越来越宽。</p><p>然而，人类身高的真实状况并未出现此种趋势。</p><p>高尔顿在此过程中还是有所发现的，特别是当他开始关注类似身高这样的遗传特征的时候。与“卓越”相比，身高特征更易测量，跟遗传的关联也更强。高个子男性的儿子往往身高也比普通人高——但很可能不如他们的父辈高；矮个子男性的儿子往往身高比一般人矮——但很可能不如他们的父辈矮。一开始，高尔顿称这种现象为“复归”（reversion），后又改称为“向均值回归”（regression toward mediocrity）（regression也有退化的意思）。</p><p>散点图分析：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112049380.png" alt="image-20220511204930285" style="zoom:80%;" /><p>分析每一个垂直框，预测总是落在一条直线上，他称这条直线为回归线，它比椭圆的主轴（或对称轴）的斜率小（见图2.3）。事实上，这样的直线有两条，我们选择哪条线作为回归线取决于我们要预测哪个变量而将哪个变量作为证据。</p><p>表明，<u>对于向均值回归这一现象，因和果是没有区别的</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112052229.png" alt="image-20220511205232096" style="zoom: 80%;" /><p>如果你知道父亲的身高，则直线OM将为你提供其儿子身高的最佳预测；如果你知道儿子的身高，则直线ON将为你提供其父亲身高的最佳预测。这两条直线都不同于散点图中的主轴（对称轴）</p><blockquote><p>相关性概念首次在不依赖于人的判断或解释的前提下以客观度量说明了两个变量是如何关联的。找到这样一种通用的方式来描述随机变量之间的关系，高尔顿和皮尔逊一定曾为此激动不已。尤其是皮尔逊，在他的眼中，与相关系数这种在数学上清晰且精确的概念相比，那些关于因果的模糊而陈旧的概念似乎已经完全过时而丧失科学性了。</p><p>高尔顿以寻找因果关系为起点，最终却发现了相关性——一种无视因果的关系。这是一段颇具讽刺意味的历史。</p></blockquote><p>小球在下一层的位移继承了其沿路撞到的所有钉子带给它的变化的总和。这就与卡尼曼的方程产生了明显的矛盾：</p><p>成功=天赋+运气</p><p>巨大的成功=更多的天赋+更多的运气</p><p>根据卡尼曼的方程，第二代的成功不会继承第一代的运气。按其定义，运气本身是一个只具有短暂影响的事件，因此其对后代没有影响。然而这一具有短暂影响的事件与高尔顿的梅花机是不兼容的。</p><p>为将这两个概念放在一起比较，让我们试着画出相应的因果图。</p><p>（a）高尔顿板模型，在这种模型下，运气世代相传，这就导致成功的分布不断变宽。（b）遗传模型，在这种模型下，运气不会累积，这就导致成功在代际间的稳定分布</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112102796.png" alt="image-20220511210237673" style="zoom:80%;" /><p>在皮尔逊的眼中，高尔顿扩展了科学的词汇。因果关系被简化为仅仅是相关关系的一个特例（在这一特例中，相关系数为1或–1，两个变量x和y之间的关系是确定的）。因果关系对于皮尔逊来说仅仅是一种重复，在确定性的意义上是永不可证的。数据就是科学的全部,因果关系之梯的最底层就是科学家进行科学研究所需的一切。</p><p>【皮尔逊带给我的启示：不要迷信权威的论文和观点，并奉为圭臬，比如batch_norm是好的，还是得自己阅读文献，看看作者的发现和对此的解释，独立思考。】</p><p>我们现在已经意识到了，在某些情况下，正确的分析结果只能来自聚合数据，而非来自分组数据。</p><p><strong>莱特的分析方法</strong></p><p>赖特开创的分析方法在他之后得到了极大的发展，其应用范畴远远超越了最初的豚鼠基因研究。</p><p>在寻求某个未知量的值时，你可以先赋予该量一个符号，然后用数学方程的形式描述你对该量和其他相关量的认识，最后，如果你有足够多的耐心和足够多的方程，你就可以解出方程式，并算出目标量的值。</p><p>许多人仍然会犯尼尔斯的错误，认为因果分析的目的只是证明X是Y的因或从头开始找到Y的因。这的确是<u>因果关系研究中的因果发现难题</u>，也是我第一次投身于图形化建模时雄心勃勃地试图解决的问题，直到现在，这依然是一个充满活力的研究领域。相比之下，赖特的研究重点，以及本书的讨论重点，则是<u>用数学语言表达看似合理的因果知识，将其与经验数据相结合，回答具有实际价值的因果问题。</u></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205121309116.png" alt="image-20220512130908053"></p><p>妊娠时长P对于出生体重X的直接效应是什么？【具体见书】</p><p>赖特的方法告诉我们如何用路径系数来表示每个<u>需要测量的相关性</u>。在对每组变量间的相关性（P，X）、（L，X）和（L，P）执行此操作之后，我们就会得到3个方程，并可以据此用代数方法求解未知路径系数p、l’以及l×q。然后问题就解决了，因为我们想要的路径系数p的值现在已经可以计算出来了。</p><p>第一个经验是：因果分析允许我们量化在现实世界中实际存在的某个过程，而非只能分析数据中的模式。</p><p>第二个经验是：无论是否采用数学处理，在路径分析中，你都能通过检查整个路径图得出关于单个因果关系的结论。而如果你想测算某个具体的路径系数，你可能就需要进一步分析路径图的整体结构了</p><p>因果分析绝不只是针对数据的分析；在因果分析中，我们必须将<u>我们对数据生成过程的理解</u>体现出来，并<u>据此得出初始数据不包含的内容</u>。但有一点费舍尔说得没错：<u>一旦你从统计学中删除因果关系，那么剩下的就只有数据约简了</u>。</p><p><strong>贝叶斯连接——从客观性到主观性</strong></p><p>赖特认为：“路径分析这种灵活的方法与为尽可能避免偏离客观性而设计的刻板的描述统计方法有很大的区别。”</p><p>这句话是什么意思？首先，赖特想说的是，路径分析的应用应该以研究者对因果过程的个人理解为基础，这种理解就反映在其所绘制的因果图或路径图中。它不能被简化为一个机械性的程序，就像统计手册里列出的那些操作方法一样。</p><p>1834年3月15日伦敦统计学会成立伊始，<u>客观性就是统计学家的圣杯</u>。学会的创始章程规定，在所有的情况下，数据都优先于观点和解释。数据是客观的，而观点是主观的。这个规则的提出远远早于皮尔逊时代。为客观性而奋斗，完全根据数据和实验进行推理的思想，自伽利略以来一直是科学定义自身存在方式的一部分。</p><p>与相关性分析和大多数主流统计学不同，<u>因果分析要求研究者做出主观判断</u>。研究者必须绘制出一个因果图，其反映的是他对于某个研究课题所涉及的因果过程拓扑结构的定性判断，或者更理想的是，他所属的专业领域的研究者对于该研究课题的共识。为了确保客观性，他反而必须放弃传统的客观性教条。在因果关系方面，睿智的主观性比任何客观性都更能阐明我们所处的这个真实世界。</p><p><em>【一时也有点难以接受，统计学家们希望寻找到一种通法、真理吗，再看看，保留一些疑惑】</em></p><p>在今天的统计学会议上，你已经不会再见到“贝叶斯学派”和“频率派”（frequentists）之间发生激烈辩论的情形，而在20世纪60年代和70年代，此类争论曾频繁爆发</p><blockquote><p>贝叶斯分析的原型是这样的：<u>先验判断+新的证据→经过修正的判断</u>。例如，假设你抛掷10次硬币，发现其中有9次结果是正面朝上。那么此时你认为硬币抛掷是一个公平的游戏这一判断就可能会发生动摇，但你具体在多大程度上动摇了呢？一位正统的统计学家会说：“在没有任何额外证据的情况下，我倾向于认为这枚硬币掺有杂质，所以我敢打赌，下一次抛掷硬币时，硬币正面朝向的概率为9∶1。”</p><p>而一位贝叶斯统计学家会说：“等一下，我们还需要考虑一下我们对于这枚硬币的<u>先验知识</u>。”这枚硬币是从附近的杂货店买的，还是从一个名声不怎么样的赌徒那儿得来的？如果这只是一枚普通的硬币，那么大多数人是不会因为9次结果为正面朝上的巧合就发生动摇的。相反，如果我们可以合理怀疑这枚硬币被做了手脚，那我们会更愿意得出这一结论，即9次正面朝上的结果充分证明了偏倚的存在。</p><p>贝叶斯统计为我们提供了一种将观察到的证据与我们已有的相关知识（或主观判断）结合起来以获得修正后的判断的客观方法，借由这种方法，我们就可以对下一次硬币抛掷结果的预测进行修正。而频率派无法忍受的正是贝叶斯学派允许观念<u>以主观概率的形式“入侵”“纯洁”的统计学王国</u>的做法。在贝叶斯分析被证明是一种优秀的工具，且适用于各种应用场景，包括天气预报和追踪敌方潜艇之后，主流的统计学家也只能勉强地承认对手的成功。此外，许多例子已经证明，<u>随着数据量的增加，先验判断的影响会越来越小，乃至彻底消失，这就让我们最终得到的那个结论仍然是客观的</u>。</p></blockquote><p>遗憾的是，主流统计学界对贝叶斯学派的主观性的接受并<u>没能</u>促进其对因果主观性的接受。答案在于<u>表述语言上的巨大障碍</u>。为了阐明主观假设，贝叶斯统计学家沿用了高尔顿和皮尔逊的“母语”——概率语言。而阐述因果推断的假设需要的是一种内涵更丰富的语言（如因果图）。</p><p>此外，<u>即使数据量增加，因果信息中的主观成分也不一定会随着时间的推移而减少</u>。绘制出两个不同的因果图的两个人可以分析相同的数据，但很可能永远不会得出相同的结论，无论数据有多“大”。这对于科学客观性的倡导者来说是一个可怕的前景，也说明了他们拒绝依赖主观因果信息的确有其必然性。</p><p>从积极的一面说，<em>因果推断在一个极其重要的意义上是客观的</em>：一旦两个人就假设达成了一致，因果推断就为他们提供了一种百分之百客观的方法用以解释任何新出现的证据（或数据）。</p><h2 id="3-从证据到因"><a href="#3-从证据到因" class="headerlink" title="3. 从证据到因"></a>3. 从证据到因</h2><p>——当贝叶斯牧师遇见福尔摩斯先生</p><blockquote><p>福尔摩斯所做的并非只是从假设推出结论的演绎，他的拿手本领是归纳。与演绎正好相反，<u>归纳是从证据推出假设</u>。</p></blockquote><p>近年来，人工智能专家在<u>从证据到假设</u>以及<u>从结果到原因</u>的自动化推理方面取得了相当大的进展。我有幸借助开发了实现该功能所必需的一项基本工具（贝叶斯网络）参与了这一发展进程的最初阶段。在本章中，我将简略地对贝叶斯网络做一下介绍，考察当前该工具的一些应用实例，并向大家讲述我在最终进入因果关系研究领域之前所走过的曲折道路。</p><p>如果你有一部手机，那么从成千上万个电话中筛选出打给你的电话就是通过<u>信念传播算法（belief propagation）</u>来解码的，而信念传播是专为贝叶斯网络设计的一种算法。作为“互联网之父”之一的温顿·瑟夫曾说：“我们所有人都是贝叶斯方法的超级用户。</p><p>:star: <u>贝叶斯网络与因果图之间的关系</u>很简单：因果图就是一个贝叶斯网络，其中每个箭头都表示一个直接的因果关系，或者至少表明了存在某个因果关系的可能性。反过来，并非所有的贝叶斯网络都是因果关系网络，而在很多实际应用中这一点并不重要。但是，一旦你想问关于贝叶斯网络的第二层级或第三层级的问题，你就必须认真对待因果论，一丝不苟地画出因果图。</p><blockquote><p>贝叶斯留给后世的资料很少，他生前发表过的两篇文章都与概率论无关，但他的遗作《论有关机遇问题的求解》（1763）给他带来了无尽的荣耀。在这篇论文中，他推导出了逆概率公式，即著名的贝叶斯法则。很难评述贝叶斯本人对概率的哲学认识，他的学说被后继者们赋予了更广泛、更深刻的内涵，以致发展成为贝叶斯学派，甚至贝叶斯主义。</p><p>频率派和贝叶斯学派<u>对贝叶斯法则的理解是不同的</u>，因而两派借助它来进行推断的手法也不相同。贝叶斯法则是贝叶斯推断的核心，拉普拉斯称之为“<strong>最基本原理</strong>”</p></blockquote><p>对于贝叶斯来说，休谟的观点很自然地引发了一个问题，有人可能会称其为福尔摩斯式的问题：需要<u>多少</u>证据才能让我们相信，我们原本认为不可能发生的事情真的发生了？在何种情况下，某个假设才会越过绝不可能的界限抵达不大可能，甚至变为可能或确凿无疑呢？虽然这个问题是用概率语言表述的，其含义却带有明显的神学色彩。</p><p>贝叶斯法则它表明了我们可以从一个果推断某个因的概率。如果我们知道因，那我们很容易就能估计出果的概率，这是一个前向概率（forward probability）。而它的反面，也就是贝叶斯时代的“逆概率”推理，则难度要大得多。贝叶斯没有解释为什么它很困难，他认为这一点不言而喻，但他向我们证明了逆概率推理是可行的，并展示了如何操作。</p><p>这也许是贝叶斯法则在统计学中最重要的应用：我们可以<u>在我们的判断较为可靠的一个方向上直接估算出条件概率，并利用数学工具推导出在我们的判断较为模糊的另一方向上的条件概率</u>。在贝叶斯网络中，该方程也扮演了同样的角色：我们告诉计算机前向概率，在需要时，计算机告诉我们逆概率。</p><p>我们还可以将贝叶斯法则看作一种方法，用以更新我们对某一特定假设的信念。理解这一点非常重要，因为人类对未来事件的信念大多取决于该事件或类似事件在过去发生的频率。</p><hr><p><strong>两条异议</strong></p><p>两条深刻的异议的存在，一条是哲学层面的，另一条是应用层面的。</p><p><em>哲学层面的异议</em>聚焦于将概率解释为一种信念度（degree of belief）的观点，这一哲学争论的关键在于，我们是否可以合法地将“假设我知道”这句表达翻译成概率语言。</p><blockquote><p>贝叶斯学派认为，随机事件（或不确定性事件）A的概率仅是个体主观认为A会发生的<strong>信念度</strong>。例如，我认为“爱因斯坦在1945年8月6日早上掷过骰子”的概率是90%，而显然没有可重复的随机试验能证实此事，它仅仅表达了我对这个陈述的相信程度。</p></blockquote><p>以符号P（S）作为表示法的概率语言，其根本目的是捕捉概率游戏中的<u>“频率”这一概念</u>。但“假设我知道”是一种<u>认识论范畴的表达</u>，受到知识的逻辑而非频率和比例的逻辑的约束。</p><p>在形式上，贝叶斯法则只是贝叶斯给出的条件概率定义的一个初等推论。但在认识论上，它远远超出了初等概念的范畴。事实上，它作为一种<u>规范性规则，能够应用于根据证据更新信念这一重要操作</u>。【哲学起来了。。】其忠实地表达了“假设我知道”这句短语。这句话断定，人们在观察到T之后对S的信念度，永远不会低于人们在观察到T之前对“S且T”的信念度。</p><p><em>应用层面的异议</em></p><p>贝叶斯法则需要先验概率，这取决于不同个体的过往经验，因人而异。<br>这种变异性也被称为“主观性”，有时被看作贝叶斯推理的一个缺陷。<br>但也有一些人认为这是贝叶斯推理的一个强大优势，它允许我们在数学上<u>表达我们的个人经验</u>，并以条理化的、易懂的方式将其与数据结合起来。在普通的直觉不起作用或情绪可能导致我们误入歧途的情况下，贝叶斯法则能引导我们<u>进行正确的推理</u>。我们之后将在一些大家熟悉的场景中展示这种力量。</p><blockquote><p>为了明确表述这一问题，我们假设疾病是乳腺癌，你所做的专项体检是乳房X光检测。在这个例子中，<strong>前向概率</strong>指的是，假设你的确患有乳腺癌，检测结果为阳性的概率：P（检测|疾病）。<strong>逆概率</strong>指的是：假定检测结果为阳性，检测者确实得了乳腺癌的概率有多大？也就是P（疾病|检测），它表示的是非因果方向的信息流动，根据检测结果推断疾病的概率。</p><p>现在，一位40岁的女性做了乳房X光检查以检测乳腺癌，其得到的检测结果为阳性。<strong>假设D</strong>（代表“疾病”）指她得了癌症，<strong>证据T</strong>（代表“检测”）指乳房X光检查的结果。那么，她应该在多大程度上相信这个假设？她应该做手术吗？</p><p>$（D的更新概率）=P（D|T）=（似然比）×（D的先验概率）$</p><p>新术语“似然比”（likelihood ratio）由$P（T|D）/P（T）$给定。它衡量的是，该疾病的患者得到阳性检测结果的概率比一般群体要高多少。因此，方程3.2告诉我们的就是，<u>不管先验概率是多少，新证据T都会通过一个固定的比率增加D的概率。</u></p><p>我们对这一结果的惊讶源于对前向概率和逆概率的认知偏差，即认为<u>前者的得出经过了深入研究，支持资料翔实，而后者的得出则多涉及个人的主观决策。</u></p><p>前向概率涉及的是疾病本身的性质、发展阶段或检测仪器的灵敏度，其对<strong>患病原因</strong>（如流行病、饮食、卫生、社会经济地位、家庭史）是不敏感的。逆概率P（疾病|检测）则对这些因素非常敏感。</p><p>例子挺不错的，第三章中间。</p></blockquote><blockquote><p>从许多层面来说，贝叶斯法则都是对科学方法的提炼。教科书对科学方法的描述是这样的：（1）提出一个假设，（2）推断假设的可检验结果，（3）进行实验并收集证据，（4）更新对假设的信念。通常，教科书涉及的只是简单的正确和错误两种结果的检测和更新，证据要么证实了假设，要么驳斥了假设。但是生活和科学从来不会那么简单！所有的证据都<u>包含一定程度的不确定性</u>。贝叶斯法则告诉我们的正是<u>如何在现实世界中执行步骤（4）</u>。</p></blockquote><p><strong>从贝叶斯法则到贝叶斯网络</strong></p><blockquote><p>人工智能的主导机制就一直是所谓的基于规则的系统或专家系统，它将人类知识组织为具体事实和一般事实的集合，并通过推理规则来连接两者。例如：苏格拉底是一个人（具体事实）。所有人都会死（一般事实）。从这个知识库中，我们（或一台智能机器）可以使用普遍推理规则推断出苏格拉底会死的事实，也就是：如果所有A都是B，x是A，那么x也是B。</p><p>到了1980年，专家系统显然被证明难以从不确定的知识中做出正确的推断。计算机无法复制人类专家的推理过程，因为<u>专家本身无法使用系统所使用的语言阐明他们的思维过程</u>。</p><p>20世纪70年代末，人工智能领域针对如何处理不确定性因素展开了激烈讨论，各种主张层出不穷。</p><p>遗憾的是，这些方法虽然具有独创性，却有一个共同的缺陷：它们模拟的是专家，而不是现实世界</p><p>在1982年，当时我提出了一个表面上平淡无奇但实际上非常激进的建议：将概率视作常识的“守护者”，聚焦于<u>修复其在计算方面的缺陷</u>，而不是从头开始创造一个新的不确定性理论。更具体地说，我们不能再像以前那样用一张巨大的表格来表示概率，而是要用一个松散耦合的变量网络来表示概率。假设我们只让每个变量与它的几个相邻变量发生相互作用，那么我们就可以克服导致其他概率论者犯错的计算障碍。</p></blockquote><p>作者更确信了这一点，即任何人工智能都必须建立在模拟我们所知道的人类神经信息处理过程的基础上，并且不确定性下的机器推理必须借助类似的信息传递的体系结构来构建。信息是<u>一个方向上的条件概率和另一个方向上的似然比。</u></p><p>网络应该是分层的，<u>箭头从更高层级的神经元指向较低层级的神经元</u>，或者从“父节点”指向“子节点”。每个节点都会向其所有的相邻节点（包括层次结构中的上级节点和下级节点）发送信息，告知当前它对所跟踪变量的信念度（例如，“我有2/3的把握认为这个字母是R”）。接收信息的节点会根据信息传递的方向，以两种不同的方式处理信息。</p><p>如果信息是从父节点传递到子节点的，则子节点将使用条件概率更新它的信念，如同我们在茶室例子中见到的那样。如果信息是从子节点传递到父节点的，则父节点将通过用自己的初始信念乘以一个似然比的计算得到更新信念，如乳房X光检查的例子所示。</p><p>将这两条规则反复应用于网络中的每个节点的做法就被称为信念传播。</p><p><strong>贝叶斯网络</strong></p><p>更具普遍意义的说法是：<u>假设→证据</u>。不同于贯穿于本书的因果图，贝叶斯网络并未假设箭头有任何因果意义，这里的箭头<u>仅仅意味着我们知道前向概率</u>，贝叶斯法则告诉我们的是<u>如何逆转正向推理的过程</u>，具体做法就是<u>用先验概率乘以似然比</u>。</p><p>在介绍完只包含一个连接的两节点网络后，我们的下一步自然是引入包含两个连接的三节点网络，我称此种网络为“接合”（junction）。这是所有贝叶斯网络（以及因果网络）的构建模块。接合有三种基本类型或形式，借助这些基本形式，我们就可以在网络中表征出所有的箭头模式。</p><p><code>1.A→B→C</code>被称为“链”接合或中介接合。人们常常将B视为某种机制，或“中介物”，它将A的效应传递给C。关于链接合的一个重要概念点：中介物B“屏蔽”（screen off）了从A到C的信息或从C到A的信息，若<u>已知B的值，我们就可以说A和C是条件独立的</u></p><blockquote><p>例如，一旦我们知道了烟雾的“值”，关于火的任何新信息便不会再以任何理由让我们增强或削弱对警报的信念。</p><p>条件独立性赋予了机器关注相关信息而忽略其他信息的自由。在日常思考中，我们每个人都需要这种许可，否则我们会把很多时间花在寻找虚假的信号之上。但是，当每条<u>新信息的出现都在改变着相关信息和无关信息的界限时</u>，我们要<u>如何决定忽略哪些信息</u>呢？对人类来说，这种筛选的能力是与生俱来的，即使是刚刚三岁，还在蹒跚学步的幼童也能理解这种屏蔽效应，尽管他们叫不出它的名字。我相信，他们的本能一定来自某种心理表征，这种表征的形式很可能类似于因果图。但是机器没有这种本能，这也是我们必须给它们配备因果图的一个原因。</p></blockquote><p><code>2.A←B→C。</code>这种接合形式被称为“叉”接合，B通常被视作A和C的共因（common cause）或<u>混杂因子</u>（confounder）。混杂因子会使A和C<u>在统计学上发生关联，即使它们之间并没有直接的因果关系</u>。给定B之后，A和C就是条件独立的。</p><p><code>3.A→B←C</code>。被称作“对撞”（collider）接合。当我们以中间的变量B为条件时，这种对撞接合的运作方式与链接合或叉接合正好相反。如果A和C原本是相互独立的，那么<u>给定B将使它们彼此相关</u>。这种<em>负相关</em>有时被称为对撞偏倚或“辩解”效应（explain-away effect）</p><blockquote><p>例如，如果我们只选取著名演员的数据（换言之，我们现在只观察“名人=1”的数据），那么我们就会看到才华与美貌之间出现了负相关，这种负相关可以解释为：发现某位名人并不美貌这一事实，会使我们更相信他富有才华。</p></blockquote><p>我刚才提到的条件独立性是在我们孤立地看这些接合时才展现出来的。如果另有因果路径包围它们，那么我们就需要把这些路径也考虑在内。贝叶斯网络所创造的奇迹就在于，理解了我们现在分别介绍的这三种基本接合就足以让我们读取贝叶斯网络所蕴含的所有独立性，不管这个网络有多复杂。</p><p>这是从第一层级到第二层级的窥探，而完全登上第二层级的钥匙是d-separation，在第七章。</p><hr><p><strong>条件概率表</strong></p><p>图示以定性的方式描述了变量间的关系，但如果你想要定量的答案，你就需要定量的输入。在贝叶斯网络中，我们必须具体给出在给定了“父节点”的条件下每个节点的条件概率。这类概率就是前向概率，P（证据|假设）</p><p>我们将A描述为根节点，并不是说A的发生不存在起因。实际上，几乎没有任何变量符合这种描述。我们真正的意思是，A的任何先验的因都可以被适当地概括为先验概率P（A），其中A为真。</p><p>当节点A有父节点时，在决定其自身状态之前，A必须先“听从于”其父节点，一个简单的条件概率表👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205122012019.png" alt="image-20220512201218906"></p><p>飞机和行李箱。</p><p>由于当父节点和父节点状态过多时，表会变得相当大，人们通常会对网络中的连接进行筛选，只保留那些最重要的连接，让网络保持一个相对“稀疏”的状态。在贝叶斯网络的发展过程中，其中一项技术成果就是开发出了一种方法让我们可以<u>利用网络结构的稀疏性实现合理的计算时间</u>。</p><p>贝叶斯网络有诸多优势。网络一经建立，调查员就不再需要对其进行干预，告诉它该如何评估新的数据片段。整个网络的升级更新可以很快完成。（贝叶斯网络尤其适合在分布式计算机上汇编和运行。）这个网络是<strong>一体化</strong>的，这意味着它作为一个整体对所有的新信息做出反应。</p><p>贝叶斯网络的<strong>透明性</strong>使它有别于机器学习的其他模型，后者多倾向于制造高深莫测的“黑箱”。在贝叶斯网络中，你可以一个节点接一个节点地追踪，了解每一个新的证据是如何以及为何改变了整个网络中各个连接的信念的。</p><p>2G手机使用的是“软解码”（概率），而不是信念传播。3G手机使用的是贝鲁的turbo码，4G手机使用的是加拉格的类turbo码。贝鲁的绝妙想法是对每条消息进行两次编码，一次是直接编码，另一次是在对信息进行加扰之后编码。如此，我们就得到了两个分开的码字，并且让接收方也接收到了两条带噪音的信息。</p><p>没有已知的公式可以直接解码这种双重信息，但贝鲁通过实验证明，如果你在这一贝叶斯网络上重复应用信念传播公式，两件特别神奇的事情就会发生：多数时间（我的意思是99.999%的时间）里，你会得到正确的信息比特。不仅如此，你还可以使用更短的码字。</p><p><strong>从贝叶斯网络到因果图</strong></p><p>从理论和实践的角度来看，贝叶斯网络抓住了实现因果图与数据的交互的关键。贝叶斯网络的所有概率性质（包括本章前面讨论的接合形式）和在其基础上发展起来的信念传播算法在因果图中仍然有效。事实上，对于理解因果推理，它们不可或缺。</p><p>贝叶斯网络和因果图的<u>主要区别在于它们的构造及用途</u>。【从存在和不存在箭头两种情况解释】</p><p>实际上，贝叶斯网络只不过是一张巨大的概率表的简洁表示形式。其中的箭头表示子节点的概率通过某个公式（条件概率表）与父节点的值<em>相关联</em>，并且此相关关系是充分的，即<u>发现该子节点还有其他祖先节点不会改变这个公式。</u><br>同样，一旦我们知道<u>任意两个节点的父节点</u>的值，那么这两个节点之间缺失的箭头就意味着<u>它们是相互独立</u>的。</p><p>然而，如果同样的关系图被绘制成一张因果图，那么绘制因果图的思路和最终我们对图示的解释就会发生改变。在构建阶段，我们需要检查每个变量，比方说C，然后在选择C的值之前弄明白它究竟“听从于”哪些其他变量。在A→B→C链中，B只听从于A，C只听从于B，A不听从于任何变量，即它是由外部力量决定的，这些外部力量不是我们所构建的模型的一部分。</p><p><u>这个<em>听从</em>隐喻浓缩了因果网络所传达的全部知识</u>；其余的知识都可以借此被推导出来，其中在某些情况下我们还需要用到数据。请注意，如果我们反转链接合中箭头的顺序，从而得到A←B←C，那么我们对该结构的<u>因果解读将发生剧烈变化，但其条件独立性则保持不变。</u>A和C之间缺失的箭头仍然意味着，一旦我们知道B的值，A和C就是相互独立的，就像在最初的那个链接合中一样。这一特性具有两个<strong>极其重要的含义</strong>：</p><ul><li>首先，因果假设不能是心血来潮的虚构；它们<em>必须经过数据的审查，并且是可证伪的</em>。例如，以B为条件，如果我们观测到的数据并没有表明A和C是独立的，那么我们就可以很有把握地断定<u>链模型与数据不兼容</u>，我们必须放弃（或修复）这一假设。</li><li>其次，因果图的图形属性决定了哪些<u>因果模型可以<em>借助数据来区分</em></u>，<u>哪些模型永远无法借助数据来区分</u>，无论数据集有多大。例如，仅靠数据我们不能区分叉接合A←B→C与链接合A→B→C，因为这两种接合的因果图有相同的条件独立性。</li></ul><p>:star: 解读因果模型的另一种便捷的方法是<strong>假设实验</strong>。因果图中的每个箭头可以被看作<u>一个假设实验的结果陈述</u>。<br>从A到C的箭头表示，如果我们可以只调整A，那么我们理论上就可以看到C的概率发生变化。<br>从A到C的箭头缺失则表示，在同一个实验中，一旦我们<u>保持C的父节点不变</u>（换言之就是上例中的B），我们在调整A后就不会看到C的任何变化。请注意，“一旦我们知道了B的值”这一概率表达，已经被“一旦我们保持B不变”这一因果表达取代，这意味着我们在这里所做的是在事实上<u>阻止了B的变化，从而使从A到B的箭头失效</u>。</p><hr><p>如果说贝叶斯网络只能告诉我们一个事件发生的可能性有多大，其前提是我们观察到了另一个事件（第一层级的信息），那么因果图就可以回答更高层级的关于干预和反事实的问题。例如，因果叉接合A←B→C就非常明确地告诉了我们，调整A不会对C产生任何影响，无论调整的幅度有多大。与此相对，贝叶斯网络则不具备处理“调整”的能力，也不能辨别“观察到”和“实施调整”的区别，或者明确区分叉接合和链接合。换句话说，链接合和叉接合都能预测我们观察到的A的变化与C的变化有关，但二者都无法预测“调整”A的效果是什么。</p><p>第二个意义，也是更为重要的一点，即贝叶斯网络对因果推断的影响。（被揭示出的）因果图的图形结构与它所代表的数据之间的关系，允许我们在不进行实际操作的情况下模拟调整。具体来说，利用一系列巧妙的控制变量操作，我们就可以在没有实际进行实验的情况下预测行动或干预的效果。为了论证这一点，我们可以再想想因果叉接合A←B→C。首先，我们宣称A和C之间的相关是伪相关。我们可以通过一个实验来验证这一论断——调整A，然后发现A和C之间没有相关关系。但我们还可以做得更好。我们可以利用因果图来模拟这个实验，让它告诉我们是否可以通过控制变量操作重现我们在实验中看到的关于相关性的结果。答案是肯定的：在对B进行变量控制之后，在因果图中测得的A和C之间的相关性将等同于我们在实验中得到的相关性结论。这种相关性可以从数据中估计出来，在这个例子中，相关性为零，它如实地确认了我们的直觉，即调整A不会影响到C。</p><blockquote><p>我只知道根据我当初的设想，贝叶斯网络无法回答我提出的问题。意识到自己甚至不能仅依靠数据来区分A←B→C和A→B→C，实在令人感到挫败和痛苦。</p></blockquote><p>我知道读者现在急于弄清因果图是如何让我们能够做出上述计算的，我将在第七章到第九章谈到这部分内容。。。。。</p><p>统计学家会在一种特殊的情况下“赦免”因果关系的讨论：<em>随机对照试验（RCT）</em>，其中“处理A”被随机地分配给某些个体，而不分配给其他个体，之后我们需要对比在两组个体中观察到的结果变量B的变化的差异。在这里，传统的统计学和因果推断一致认同“A导致B”这句话的含义。</p><p>下一章：</p><p>我们应该先试着理解旧的、模型盲科学的优势和局限性：<u>为什么我们必须进行随机化处理才能得出A导致B的结论，以及随机对照试验试图消除的威胁（被称为“混杂”）的性质</u>。在我们根据因果图梳理过这些问题之后，我们就可以将随机对照试验置于一个更为适当的理论框架中来讨论了。我们可以将其视为因果推断引擎的一个特例，也可以将因果推断视为随机对照试验的一个宽泛的扩展。</p><h2 id="4-混杂和去混杂"><a href="#4-混杂和去混杂" class="headerlink" title="4. 混杂和去混杂"></a>4. 混杂和去混杂</h2><p>——或者，消灭潜伏变量</p><p>当一个变量同时影响到选择接受处理的对象以及试验结果时，**混杂偏倚(confounding bias)**就产生了。有时混杂因子是已知的，另一些时候它们只是疑似存在，在分析中以“潜伏的第三变量”出现。在因果图中，混杂因子非常容易识别。</p><p>如果我们确实测量了第三变量的数据，那么我们很容易就能区分出真实效果和虚假效果。例如，如果混杂因子Z是年龄，而我们分别比较每个年龄组的处理组（treatment group）和对照组（control group）。根据各个年龄组在目标总体中所占的百分比对每个年龄组进行加权，我们就可以计算出药物的平均效果。这种补偿方法是所有统计学家都很熟悉的一种方法，它被称为“Z调整”或“Z控制”。</p><p>统计学家既高估又低估了为可能的混杂因子进行统计调整的重要性。<br>高估它，是指他们经常对过多的变量进行控制，甚至控制了不该控制的变量。你在各种研究中都能看到它。‘我们控制了……’，然后一张关于被控制的变量的列表就开始了，而且这个列表往往被认为越长越好哈哈哈统计学家对于应该控制和不应该控制哪些变量感到非常困惑，所以默认的做法是控制他们所能测量的一切。当今时代的绝大多数研究都采用了这种做法。这的确是一种可轻松遵循的、便捷的、简单的程序，但它既<u>浪费资源又错误百出</u>。而因果革命的一个关键成果就是<strong>终结这种混乱</strong>。<br>统计学家又在很大程度上低估了控制的意义，即他们不愿意谈论因果论，即使他们进行了正确的控制。</p><p>作者的观点：如果你在因果图中确定了去混因子（deconfounder）的充分集，收集了它们的数据，并对它们进行了适当的统计调整，那么你就有权说你已经计算出了那个因果效应X→Y</p><p>统计学家处理混杂的传统方法则与之截然不同，这些方法<u>大多建基于随机对照试验</u>，这是费舍尔极力主张的观点。这一主张本身完全正确，但费舍尔提出这一主张并不是出于一个完全合理的原因。随机对照试验确实是一项极好的发明——但直到最近，追随费舍尔脚步的几代统计学家仍然<u>无法证明他们从随机对照试验中得到的结果就是他们想要得到的东西</u>。他们<u>缺乏一种语言</u>来说明他们所寻找的东西，也就是X对Y的因果效应。</p><p>本章的<strong>目标之一</strong>就是从因果图的角度来解释，为什么随机对照试验能让我们估计出X→Y的因果效应，同时免除混杂偏倚的影响。</p><p>因果图使分析重心从<u>混杂因子向去混因子</u>的转变成为可能。前者引发了问题，后者则解决了问题。这两组因子<u>可能存在部分重叠，但并非必须重叠。</u>如果我们收集到了去混因子充分集的数据，那么即使我们忽略了一部分甚至所有的混杂因子也无关紧要了。</p><p>它使我们能够确定应该控制哪些变量，使其成为去混因子。它是一个因果概念，属于因果关系之梯的第二层级。</p><p>发明于20世纪90年代的因果图方法已经完全解决了混杂问题。特别是我们很快就会介绍的一种被称为“<strong>后门标准</strong>”（back-door criterion）的方法，它可以明确识别出因果图中哪些变量是<em>去混因子</em>。如果研究者能够收集到这些变量的数据，那么他就可以对这些变量进行统计调整，从而在不真正实施干预的情况下对干预的结果做出预测。</p><p>在某些情况下，即使我们没有去混因子充分集的数据，我们也可以控制混杂。在这些情况下，我们可以使用不同的统计调整公式（不是传统的统计调整公式，因为传统的公式只适用于后门标准）消除混杂。【第七章】</p><p>掌握既定结论背后的假设，比试图用随机对照试验来规避这些假设更有价值<br>而且我们在之后会发现，<u>随机对照试验自身也存在局限性</u>。</p><p><strong>随机对照试验为何有效</strong></p><p>费舍尔意识到，得到对正确问题的不确定答案比得到对错误问题的高度确定的答案要好得多。如果你向自然精灵提出了一个错误的问题，那么你就永远不会得到你想知道的答案。如果你提出了正确的问题，那么偶尔得到一个错的答案就完全不成问题了。你可以估计出答案的不确定性，因为这种不确定性来自<u>随机化的过程（这一过程是已知的）</u>而不是<u>土壤各个方面的特性（这一点是未知的）</u>。</p><p>随机化实际上带来了两个好处。第一，它<u>消除了混杂偏倚</u>（它向大自然提出了正确的问题）。第二，它使研究者能够<u>量化不确定性</u>。而根据史学家斯蒂芬·施蒂格勒的说法，第二个好处正是费舍尔提倡随机化的主要原因。</p><p>我们可以用do算子来填补费舍尔想要表达但无从表达的内容。让我们从因果的角度来考察一下随机化是如何让我们向自然精灵提出正确的问题的。</p><p>在正常情况下，农民对于每个地块最适合使用哪种肥料是<u>根据心血来潮的想法或偏见</u>来决定的。他想对自然精灵提出的问题是，“对整片土地均匀施撒肥料1（相比于施撒肥料 2）的产量是多少？”或者，用do算子来表示就是，P（产量|do（肥料=1））的值是多少？</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205122304958.png" alt="image-20220512230209350"></p><p>农民想要知道的世界实际上是由模型2描述的👇。do算子在这个例子中的作用是清除所有指向肥料的箭头，并强制赋予这个变量一个特定的值，比如，肥料=1。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205122304108.png" alt="image-20220512230439027"></p><p>我们让一些地块接受do（肥料=1），让其他地块接受do（肥料=2），但让哪些地块接受哪种处理是随机的。由此模拟出的世界见图4.6，它描述了“肥料”变量从一种随机设备那里获取赋值，比如费舍尔的扑克牌。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205122306437.png" alt="image-20220512230643359"></p><p>图示中没有从随机抽签指向产量的箭头，因为农作物并不能读懂抽签的结果。（对于农作物来说，这是一个相当安全的假设，但对随机化试验中的<u>人类受试者来说，这就是一个应予以严肃考虑的问题了</u>！）【有道理，非常“因果”】对人类受试者进行临床试验时，研究者必须不遗余力地向病人和主试隐瞒处理信息（该试验操作被称为<em>双盲试验</em>）。</p><p>模型3描述了这样一个世界，其中肥料和产量之间的关系不存在混杂（换句话说，肥料和产量没有共因）</p><p>随机化处理是模拟模型2的一种方法。<u>它让所有旧的混杂因子都失效了，同时并没有引入任何新的混杂因子。</u></p><p>我们还有其他的方式可以用来模拟模型2。如果你<u>知道所有可能存在的混杂因子</u>，那么一种方法就是测量它们并根据它们进行统计调整。不过相比之下，随机化处理确实有一个很大的优势：它切断了接受随机处理的那个变量的所有传入连接，包括我们<u>不知道或无法测量的那些</u>。</p><blockquote><p>很多时候，我们无法满足所有的条件。在某些情况下，干预可能<u>在事实上不可行</u>（例如在研究肥胖对心脏病的影响时，我们不能随机安排病人肥胖与否），或者干预可能是<u>不道德</u>的（例如研究吸烟的影响，我们也不能要求随机选择的一些人抽上10年的烟）。再或者，对于某些较为复杂、参与起来不方便的试验，我们可能会在招募受试者时遇到困难，而勉强找到的志愿参与者又<u>无法代表我们的目标总体</u>。</p></blockquote><p>do算子为我们提供了一种科学的方法，让我们能够在非试验性研究中确定因果效应。这一方法挑战了随机对照试验一直以来的霸主地位。</p><p><strong>混杂的新范式</strong></p><p>接下来让我们看看因果革命带来的其他消除混杂的方法。</p><p>学界对混杂或混杂因子的定义几乎始终未曾达成一致。缺乏对混杂本质的清晰理解</p><p>我们观察到的是给定处理效应的条件概率P（Y|X），我们要问自然的问题是X和Y之间的因果关系，该因果关系可以通过干预概率P（Y|do（X））获得。如此一来，混杂就可以简单地定义为：</p><p>:star: 导致P（Y|X）≠P（Y|do（X）），即两个概率出现差异的所有因素。</p><p>是不是很简单明了？定义困难的原因就在于<u>混杂并非统计学概念</u>。它代表了我们想要评估的内容（因果效应）和我们实际使用统计方法所评估的内容之间的差异。如果你不能在数学上表达出你想评估的内容，那你就无法定义是什么构成了这种差异。</p><blockquote><p>历史上，“混杂”的概念演变围绕着两个相关概念展开——不可比性和潜伏的第三变量。这两个概念都很“抵制”形式化。</p><p>当我们谈到可比性时，我们说的是，处理组和对照组应该在所有相关方面都相同，但这就要求我们必须从不相关的属性中区分出相关的属性。</p><p>第三变量，混杂因子是X和Y的共因吗？还是仅仅与它们每个都相关？</p><p>“混杂的经典流行病学定义”，它包含两个条件。X（处理）和Y（结果）的一个混杂因子Z，满足（1）在整个总体上与X相关，（2）在未接受处理X的人群中与Y相关。近年来，该定义又增加了第三个条件：（3）Z不应当出现在X和Y之间的因果路径上。</p><p>混杂因子的“经典流行病学定义”还有其他缺陷，如以下两个例子所示:</p><p>（i）X→Z→Y<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131109513.png" alt="image-20220513110904347" style="zoom:50%;" /></p><p>例（i）中，Z满足条件（1）和（2），但它不是一个混杂因子，而应该被称为“中介物”（mediator）。它是解释X对Y的因果效应的变量。如果你试图找出X对Y的因果效应，那么控制Z将带来一场灾难。</p><p>例（ii）中，Z是中介物M的替代物。当实际的因果变量无法测量时，统计学家通常会选择控制其替代物。控制Z本身仍然是一个错误，虽然它带来的偏倚可能会小于控制M，但偏倚仍然存在。</p><p>还有一些其他work</p></blockquote><p><strong>do算子和后门标准</strong></p><p>信息传递是双向的，既在因果方向传递，也在非因果方向传递。<u>非因果路径恰恰是混杂的根源。</u></p><p>大家应该还记得我将混杂定义为任何使P（Y|do（X））不同于P（Y|X）的因素。do算子会清除指向X的所有箭头，这样它就可以<u>防止有关X的任何信息在非因果方向流动</u>。随机化处理具有相同的效果。如果我们选择合适的变量进行统计调整，那么这种统计调整也具有相同的效果。</p><p>（a）在链接合A→B→C中，控制B可防止有关A的信息流向C或有关C的信息流向A。</p><p>（b）同样，在叉接合或混杂接合A←B→C中，控制B可以防止有关A的信息流向C，或有关C的信息流向A。</p><p>（c）最后，在对撞接合A→B←C中，信息流通规则与前两种是完全相反的。变量A和C原本是独立的，所以关于A的信息不能告诉你任何关于C的信息。但是，如果你控制了B，由于辩解效应的存在，信息就会开始在“管道”中流通。</p><p>（d）控制一个变量的后代节点（或替代物）就如同“<u>部分地</u>”控制变量本身。控制一个中介物的某个后代节点意味着<u>部分地关闭</u>了信息管道；控制一个对撞变量的某个后代节点则意味着<u>部分地打开</u>了信息管道。</p><p>如果我们有更长的管道和更多的接合单元，就像这样：</p><p><code>A←B←C→D←E→F→G←H→I→J</code>我们有许多方式来阻断A和J之间的交流：控制B，控制C，不控制D（因为它是一个对撞变量），控制E，等等，并且我们只需要做到其中的任何一项就足够了。这就是为什么<u>常规统计过程——控制我们可以测量的一切，造成了如此严重的误导。</u>对这条路径来说，在我们不去控制任何变量的前提下，该路径本身就是被阻断的！</p><p>为了去除X和Y中的混杂，我们只需要阻断它们之间的每个非因果路径，而不去阻断或干扰所有的因果路径就可以了。更确切地说，我们将<strong>后门路径</strong>（back-door path）定义为所有X和Y之间以指向X的箭头为开始的路径；<br>如果我们阻断了所有的后门路径（因为这些路径允许X和Y之间的伪相关信息在管道中流通），则我们就完成了<u>对X和Y的去混杂。</u>如果我们试图通过控制某一组变量Z来实现这一点，那么我们还需要确保<u>Z的任何成员都不是X的后代</u>，否则我们就可能部分或完全地关闭这条X与Y之间的因果路径。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131121361.png" alt="image-20220513112158259"></p><p>该图示中存在一个从X到Y的后门路径，X←B→Y，只能通过控制B来阻断。如果B无法被观测，那么不进行随机对照试验的话，我们就无法估计X对Y的因果效应。</p><p>在这种情况下，一些（事实上是大多数）统计学家会选择控制A，将其作为不可观测的变量B的替代物，但这种做法只能<u>部分消除</u>混杂偏倚，并<u>引入新的对撞偏倚</u>。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131123038.png" alt="image-20220513112355942"></p><p>这个游戏引入了一种新的偏倚，名叫“M偏倚”（以图的形状命名）。仅仅因为某个变量(指此处的B)与X和Y都相关就将变量（如B）视为混杂因子是错误的。要重申的是，<u>如果我们不控制B，则X和Y就是未被混杂影响的。只有当你控制了B时，B才会变成混杂因子</u>！</p><blockquote><p>以游戏4的因果图为例，安全带的使用（B）对吸烟（X）或肺部疾病（Y）没有因果影响，它仅仅反映了一个人对于社会规范的态度（A）与对于安全和健康相关措施的态度（C），而其中一些态度可能会影响此人对于肺部疾病的易感性（Y），另一些态度则可能影响人们是否选择吸烟（X）。在实际数据中，人们发现安全带的使用（B）与X和Y相关。事实上，在2006年一项关于烟草诉讼的研究中，安全带的使用甚至被列为需要控制的首要变量之一。而如果你接受了我在游戏4中给出的模型，那么你就能意识到单独控制B是错的。</p></blockquote><p>在掌握了这些新工具，理解了这些新见解之后，科学界终于可以着手处理一些更困难的问题，无论这些问题是理论上的还是实践中的。我们在后续章节会注重介绍这些内容。</p><h2 id="5-消除迷雾，澄清事实"><a href="#5-消除迷雾，澄清事实" class="headerlink" title="5. 消除迷雾，澄清事实"></a>5. 消除迷雾，澄清事实</h2><p>20世纪50年代末60年代初，统计学家和医生就整个20世纪最引人注目的一个医学问题产生了意见冲突：吸烟会导致肺癌吗？</p><blockquote><p>医学史上的很多里程碑式的发展成果都与特定病原体的识别有关。18世纪中叶，詹姆斯·林德发现柑橘类水果可以预防坏血病。19世纪中叶，约翰·斯诺发现被粪便污染的水导致了霍乱。（后来的研究发现了二者更具体的病因：缺乏维生素C会导致坏血病，霍乱杆菌会引起霍乱。）这些杰出的发现都蕴含着一个幸运的巧合——其原因与结果恰巧是一对一的关系。</p></blockquote><p>吸烟与癌症之关系的辩论挑战了这种单一的因果关系概念。许多人吸了一辈子的烟，却从未患肺癌。相反，有些人从不吸烟却依然患上了肺癌。</p><p>多尔和希尔将“病例”（患有疾病的人）与对照组进行了比较，因此这种研究类型现在也被称为“<u>病例—对照研究</u>”（case-control study）。相对于时间序列数据而言，借助这种方法搜集数据显然是一种进步，因为研究人员可以控制包括年龄、性别和所接触的环境污染物等混杂因子。然而，病例—对照设计也存在一些明显的弊端。</p><p>首先，它是<em>回顾性</em>的，这意味着我们已知研究对象患有癌症，在此前提下我们要回顾过去找出原因。其次，它的<u>概率逻辑也是反向的</u>，这些数据告诉我们的是癌症患者是吸烟者的概率，而不是吸烟者患癌症的概率。对于那些想知道是否应该吸烟的人，吸烟者患癌症的概率才是他们真正关心的概率。</p><p>病例—对照研究承认存在几种可能的偏倚来源。<br>其中之一被称为“回忆偏倚”。被采访者本人肯定知道他们自己是否患有癌症，而这一事实很可能会影响他们的回忆。<br>另一个来源是选择偏倚：已入院就医的癌症患者绝不是整个人口总体的代表性样本，甚至不能作为吸烟者总体的代表性样本。</p><p><em>前瞻性</em>研究，向6万名英国医生发放调查问卷，采集关于其吸烟习惯的信息，并对他们进行追踪调查。</p><blockquote><p>“剂量—响应效应”（dose-response effect）：如果物质A会导致生物反应B，则通常而言（但不是百分之百），更大剂量的A会导致更强的反应B。</p></blockquote><p><em>敏感度分析</em></p><p>对我们在导言中描述的由因果推断引擎得出的结论进行了补充。</p><p>该分析方法的使用者不是通过假设模型中缺少某些因果关系而进行进一步的推断，而是对这些假设直接提出挑战，并评估在解释所观察到的数据时，新的假设所内含的相关性应该达到怎样的强度，之后对此定量结果进行似然性判断，就像假设在这些因果关系不存在的情况下进行的初步判断那样。</p><blockquote><p>我并不否认，怀疑论在科学领域自有其重要意义。可以说，统计学家的工作就是质疑，他们是科学的良心。但是，合理的怀疑论与不合理的怀疑论是有区别的。</p></blockquote><p>因果模型的好处：它能够<u>调用研究者业已掌握的科学知识</u>来分析新问题。费舍尔的方法实际上是在假设研究者对所要测试的假设没有预先的知识或看法。他们<u>把无知强加给科学家</u>，而这正是吸烟致癌论怀疑者在这场争论中乐于利用的优势。</p><blockquote><p>委员会为编写报告准备了一年多的时间，其中一个需要解决的主要问题就是“导致”这个词的使用。委员会成员不得不舍弃19世纪关于因果关系的明确观念，同时还不得不撇开统计学。</p><p>委员会列出了5条这样的标准：一致性（在针对不同目标总体的多项研究中得到了类似的结果），关联强度（包括存在剂量—响应效应：吸烟多与更高的肺癌患病风险相关），关联的特异性（一个特定的病原体应该有一个与之对应的特殊的效果，而非带来一连串的影响），时序关系（果应该跟随因）和连贯性［具有生物学的合理性和与其他类型的证据（如实验室证据和时间序列数据）的一致性］。</p><p>后来在该清单的基础上又增加了4条标准。如此，这个包含9条标准的清单就成为此后为人所熟知的“<strong>希尔标准</strong>”。</p><p>实际上希尔本人称它们为“观点”，而<u>不是一种强制要求</u>，并强调在特定情况下，任何一条标准都有可能无法被满足。他写道：“我的9个观点中的任何一项都不能为支持或反对因果假设提供无可争辩的证据，而且也没有任何一项可以构成必要条件。”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131544248.png" alt="image-20220513154405164"></p><p>出生体重悖论是对撞偏倚的一个完美的例子。对撞因子是“出生体重”。<u>只观察低出生体重的婴儿，就相当于是在控制对撞因子</u>，从而也就打开了“（母亲）吸烟”和“婴儿死亡率”之间的后门路径，吸烟→出生体重←出生缺陷→婴儿死亡率。这条路径是非因果的，因为其中一个箭头指错了方向。这一路径导致了“吸烟”和“婴儿死亡率”之间的伪相关，造成对于实际（直接）的因果效应，吸烟→婴儿死亡率的估计存在偏倚。事实上，其带来的估计偏倚很大，以致吸烟看起来似乎从有害变成了有益。</p><blockquote><p>科学家因阐明了可能导致不良社会后果的真理而受到道德斥责，类似的事件在历史中屡见不鲜。罗马教廷对伽利略思想的批判无疑是出于对当时社会秩序的真诚的关注和维护。查尔斯·达尔文的进化论和弗朗西斯·高尔顿的优生学也遭受了同样的待遇。然而，此类由新的科学发现带来的文化冲击，最终往往是通过消化了这些发现的文化重组，而不是通过对这些发现的拒斥和掩盖来解决的。</p></blockquote><h2 id="6-悖论"><a href="#6-悖论" class="headerlink" title="6. 悖论"></a>6. 悖论</h2><p>谁能直面矛盾，谁就能触摸现实。——弗里德里希·迪伦马特（1962）</p><p>我们以对出生体重悖论的解决结束了第五章，这一悖论代表了成员众多的一大类悖论，其反映了因果关系和相关关系之间的张力。这种张力源自<u>二者处于因果关系之梯的两个不同的层级</u>之上，又因为<u>人类的直觉在因果逻辑</u>下运作，而<u>数据遵从的是概率和比例的逻辑</u>而进一步加剧。当我们将在一个领域所学到的规则<strong>误用</strong>到其他的领域时，悖论就出现了。</p><p>因果悖论突出强调了直觉性的因果推理模式与概率统计逻辑相冲突的地方。它是一个警示信号，表明如果不用因果透镜看世界，我们很可能会出差错。</p><p><strong>1. 蒙提·霍尔悖论</strong></p><p>假设你参加了一个竞猜游戏类电视节目，有三扇门供你选择，其中一扇门后面是一辆车（奖品），另外两扇门后面是山羊。</p><p>你挑了一扇门，比如说1号门，而主持人知道门后面是什么。现在，他打开了另一扇门，比如说3号门，你看到这扇门的后面是一只山羊。此时，如果他问你：‘你想重新选择，改选2号门吗？’那么，选择换门是否对你赢走奖品更有利？</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131554736.png" alt="image-20220513155436643" style="zoom: 67%;" /><p>解决这一悖论的关键是，我们不仅需要考虑数据（主持人打开某个特定门的事实），而且要<u>注意数据生成的过程，也就是游戏规则。</u></p><p>难怪统计学家对这个谜题的答案尤为不解，因为他们已经<u>习惯了“数据约简”</u>（据费舍尔1922年所言）和忽略数据的生成过程。</p><p>首先，让我们试着略微改变游戏规则，看看会对结论产生什么影响。游戏中蒙提·霍尔同样会打开你没有选择的两扇门之一，但他的选择是完全随机的。换句话说，他可能会打开那扇背后有车的门——真不走运！通过分析我们将会发现，虽然游戏情节看似相同，但根据新的规则，这一次选择换门并不会增加你的胜率。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131557233.png" alt="image-20220513155753141" style="zoom:67%;" /><p>如果蒙提·霍尔打开了3号门，看到了一只山羊，那么会发生什么呢？首先，这句话告诉了我们一条重要的信息：我们现在位于表格数据部分的第2行或第4行。现在，只关注第2行和第4行，我们可以看到，换门的策略不会再给我们带来任何额外的好处，无论是否换门，我们都只有1/2的获胜概率。</p><p>需要注意的是，两个游戏的<u>数据是一样</u>的。我们从这两个例子中得到的教训很简单：<u>获得信息的方式和信息本身一样重要。</u></p><p><em>因果图分析</em></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131601183.png" alt="image-20220513160135098"></p><p>“主持人打开的门”是一个对撞因子。一旦我们获得了关于这个变量的信息，图示中所有的概率就都变成了关于这一信息的条件概率。但是，当我们<u>以对撞因子为条件时</u>，我们就会在两个父节点之间<u>制造出一种虚假的依存关系</u>。这种依存可以体现在根据数据得到的概率中：在主持人打开了3号门的前提下，如果你最初选择了1号门，则车在2号门后面的可能性是其在1号门后面的2倍；如果你最初选择了2号门，则车在1号门后面的可能性是其在2号门后面的2倍。</p><p>这无疑是一种匪夷所思的依存关系，我们大多数人都不习惯处理这种类型的依存关系。这是一种没有原因的依存。它纯粹是贝叶斯式的变量控制带来的产物：<u>不涉及因果关系的神奇的信息传递</u>。我们的大脑会自发抵制这种信息传递，因为从幼年起，我们就学会了将相关性和因果关系联系起来。</p><p>为什么我说蒙提·霍尔打开3号门是一次“信息传递”呢？你对2号门的信念又是怎么从1/3上升到2/3的呢？答案是，在你选择了1号门之后，蒙提·霍尔就不能再打开它了——他本可以打开2号门，但他没有这样做，而是打开了3号门，这一事实表明他很有可能是不得不这样做的，因为2号门后面可能是汽车。因此，我们就有了比之前更多的证据表明汽车在2号门。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131606114.png" alt="image-20220513160559869"></p><p>在这张图中，以“打开的门”为条件是一种完全无效操作，因为“你选的门”和“车的位置”原本就是相互独立的</p><blockquote><p>:star: <em>贝叶斯推理</em> </p><p>贝叶斯分析的一个普遍主题：任何通过了威胁其有效性的测试的假设，其可能性都会变得更大。威胁越大，幸存下来的假设的可能性就越大。</p><p>在第一个因果图中：2号门很容易被驳斥（蒙提本可以打开它），而1号门则不然。因此，2号门后面更可能是汽车，而1号门后面则更可能不是汽车，汽车在1号门后的概率仍是1/3。</p><p>在第二个因果图中：1号门容易被驳斥。因为蒙提·霍尔可以打开3号门并发现门后的汽车，以此证明你选择的门是错的。而因为你最初选择的门和2号门同样容易被驳斥，所以二者背后有车的概率仍然相同。</p></blockquote><p>关于蒙提·霍尔悖论，我实际上给出了两个解释。<br>第一个解释借助<u>因果推理</u>说明了为什么我们观察到在“你选的门”和“车的位置”之间存在虚假的依存关系，<br>第二个解释借助<u>贝叶斯推理</u>说明了为什么在“让我们做个交易”中车在2号门背后的概率会增大。<br>这两种解释都很有价值。贝叶斯解释描述了现象，但并没有真正说明为什么我们在主观上认为它如此矛盾。</p><blockquote><p>在我看来，要想真正解决一个悖论，我们应该首先解释<u>为什么我们会把它看成一个悖论</u>。那么，它究竟揭示了我们对世界的直观看法存在着怎样的重大缺陷呢？【大佬！】</p><p>我们的大脑不擅长处理概率问题，但对因果问题则相当在行。而这种<u>因果性的思维方式会导致系统性的概率错误</u>，就像视错觉一样。因为“你选的门”和“车的位置”之间<u>没有因果联系</u>（无论这一因果联系是直接的还是由共因带来的），所以我们对于在数据中发现的<u>概率关联就完全无法理解</u>。</p><p>我们的大脑没有准备好去接受无缘无故的相关性，我们需要经过特殊训练，通过分析和学习如蒙提·霍尔悖论或我们在第三章中讨论的例子，才能辨别出这种相关性可能出现的场合。一旦我们完成了“大脑重塑”，<u>能够识别出对撞接合</u>，悖论就不会再令我们感到困惑了。</p></blockquote><p><strong>伯克森悖论</strong></p><p>1946年，梅奥诊所的生物统计学家约瑟夫·伯克森指出了在医院进行的观察性研究的一个特性：两种疾病即使在一般人群中彼此不存在实际联系，在医院的病人中也会形成某种似是而非的关联。</p><p>不妨先设想一种非常极端的可能情况：无论是疾病1还是疾病2都没有严重到足以让患者必须住院的地步，但<u>两者的结合会导致患者必须住院</u>。在这种情况下，我们的预测是在住院病人这个总体中疾病1与疾病2高度相关。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131622626.png" alt="image-20220513162244531"></p><p>在此前提下，在针对住院病人进行研究时，我们就相当于控制了“住院”这个因子。正如我们所知，以对撞因子为条件这一操作制造了“疾病1”和“疾病2”之间的伪相关。在我们以往提到的许多例子中，因为辩解效应的存在，这种伪相关多呈负相关，但在这个例子中，<u>这种伪相关是正向的</u>，因为患者住院的前提就是同时患有两种疾病。</p><p>今天的流行病学研究者已经理解了因果图以及其中包含的偏倚。关于该问题的讨论焦点已经转移到技术方面的细节，即偏倚可以是多大，以及它<u>是否大到可以在包含更多变量的因果图中被观察到</u>。这就是进步！</p><blockquote><p>我们大脑思考机制的缺陷。我们在实际生活中似乎就是遵循着共因原则行事的，无论何时，只要<u>观察到某种模式，我们就会去寻找一个因果解释</u>。事实上，我们本能地渴望根据数据之外的某个稳定机制对观察结果做出解释。</p><p>在最纯粹、最本质的意义上，我们观察到的<u>相关就是一种错觉</u>，甚至可能是一种自欺欺人：我们选择哪些事件进入数据集同时忽略另一些事件的做法给我们自己带来了错觉。重要的是要认识到，我们并非总能意识到自己做出了这个选择，这就是为什么对撞偏倚总是能轻易欺骗那些粗心的人。</p><p>对撞的扭曲棱镜在日常生活中同样普遍存在。正如乔丹·埃伦伯格在《魔鬼数学》（<em>How Not to Be Wrong</em>）中提出的问题：你有没有注意到，在你约会的人当中，那些有魅力的人往往是混蛋？可悲的事实是，没有魅力的人可能会和有魅力的人一样刻薄，但你永远意识不到这一点了，因为你永远不会约会既刻薄又没有魅力的人。</p></blockquote><p><strong>辛普森悖论</strong></p><p>假设有一名医生，我们称其为辛普森医生，他在办公室阅读文献时发现了一种很有前途的新药（药物D），这种新药似乎可以降低心脏病发作的风险。于是，他兴奋地在网上查找起了研究人员公布的实验数据。当他看到男性患者的数据时，他注意到如果这些患者服用了药物D，则他们的心脏病发作风险反而变得更高了。他的兴奋程度因此略有下降。“哦，好吧，”他想，“这样的话，药物D一定对女性非常有效。”</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131653308.png" alt="image-20220513165346208" style="zoom:67%;" /><p>让我再次强调一下悖论之所在。如你所见，在女性患者中，对照组中有5%（1/20）的患者后来心脏病发作，而服用该药的患者中有7.5%的人后来心脏病发作。因此我们认为，这种药物与女性患者中较高的心脏病发作风险有关。在男性患者中，对照组中有30%的患者后来心脏病发作，而处理组中有40%的患者后来心脏病发作。因此我们认为，这种药物与男性患者中较高的心脏病发作风险有关。辛普森医生是对的。</p><p>但现在让我们看看表6.4的最后一行。在对照组中，有22%的人后来心脏病发作，但处理组中的这一比例仅为18%。因此，如果我们仅根据最后一行判断，则药物D似乎的确降低了整个患者群体的心脏病发作风险——欢迎来到辛普森悖论的离奇世界！</p><blockquote><p>任何声称能够解决悖论（特别是那些经过几十年仍未得到解决的悖论）的方法都应该符合一些基本标准。第一，正如我上面讨论蒙提·霍尔悖论时说的那样，它应该能够解释为什么悖论会令人困惑或让人拒绝相信。第二，它应该能够确定悖论可能出现的场景类别。第三，它应该能够告诉我们，在哪些情况下悖论不可能发生（如果确实存在这种情况的话）。第四，当悖论真的发生，而我们必须在两个看似合理但矛盾的陈述中做出选择时，它应该能够告诉我们哪个说法是正确的。</p></blockquote><p>让我们从辛普森悖论为何会令人困惑这一问题开始。为了解释这一点，我们必须先区分两个概念：<strong>辛普森逆转和辛普森悖论</strong>。</p><p>辛普森逆转是一个纯粹的数字事实：在合并样本时，两个或多个不同的样本关于某一特定事件的相对频率出现反转。</p><p>很多人似乎相信，如果$A/B&gt;a/b$且$C/D&gt;c/d$，那么$（A+C）/（B+D）&gt;（a+c）/（b+d）$就是自然成立的。但这种民间智慧是完全错误的。</p><hr><p>现在让我们回到那个最重要的例子，BBG药物悖论。当“对男性有害”“对女性有害”“对人类有益”这三个陈述被理解为比例增减时，它们<u>在数学上并不矛盾</u>，然而，你可能仍然认为这种情况在现实世界中不可能出现，因为一种药物不可能既导致心脏病发作又防止心脏病发作。<u>BBG药物确实不存在</u>，也永远不可能被发明出来，我们可以在数学上证明这一结论。</p><p><em>“确凿性原则”（sure–thing principle）</em></p><p>假设一位商人正在考虑购买某处房产。他认为下一届总统选举的结果与之有重大关系。因此，为了弄清楚这件事，他问自己，如果他知道民主党候选人将获胜，他是否愿意购买此处房产，他的答案是他会购买。同样，他又问自己，如果他知道共和党候选人将获胜，他是否愿意购买此处房产，他发现他仍然会选择购买。当得知无论竞选结果如何他都会选择购买之后，他便决定这处房产是一定要购买的。但是这<u>有可能发生 辛普森逆转</u>！比如商人的购买决定可以改变选举的结果（比如借助媒体对其行为的曝光）</p><p>请注意，确凿性原则中<u>缺失的成分</u>（萨维奇对此未做明确说明）实际上是一个因果假设。该原则的<strong>正确版本</strong>应当这样表述：假设无论事件C是否发生，某个行动都会增加某一结果的可能性，则该行动也将在 我们不知道C是否发生的情况下 增加这个结果的可能性，<u>条件是该行动不改变C的概率。</u></p><p>根据修正后的确凿性原则，下面三句陈述之一必定为假：药物D增加了男性患者和女性患者的心脏病发作的概率；药物D降低了整个总体的心脏病发作的概率；这种药物不会改变男性和女性的数量。因为药物改变病人性别的事不太可能发生，所以前两句陈述中一定有一句为假。</p><p>要回答这个问题，我们必须在数据范围之外探寻数据生成的过程。在这项研究中，女性显然更倾向于服用药物D，而男性则相反。因此，性别就是是否服用药物和心脏病发作的混杂因子。<u>为了客观估计药物对心脏病发作的影响，我们必须<em>对混杂因子进行控制</em></u>。我们可以通过单独查看男性和女性的数据然后取平均值来做到这一点。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205131959502.png" alt="image-20220513195919407"></p><p>•对女性患者而言，未服用药物D者心脏病发作的概率为5%，服用药物D者心脏病发作的概率是7.5%。</p><p>•对男性患者而言，未服用药物D者心脏病发作的概率是30%，服用药物D者心脏病发作的概率是40%。</p><p>•取算术平均值（因为男性和女性在一般总体中比例接近1∶1），未服用药物D者心脏病发作的概率为17.5%（5和30的平均值），服用药物D者心脏病发作的概率为23.75%（7.5和40的平均值）。</p><p>这就是我们所寻找的对于这个问题的清晰、明确的答案。药物D不是BBG药物，它是BBB药物：对女性、男性有害，对人类有害。</p><p>辛普森悖论提醒我们，在某些情况下，至少存在一个统计趋势（无论是来自聚合数据、分层数据还是同时来自两者）无法代表真正的因果效应。例如，根据聚合数据估计出的因果效应大于根据分层数据估计出的每一层的因果效应，而如果我们恰当地控制了混杂因子，此类误差就不会出现。</p><hr><p>逆转也可能发生在包含连续变量的情况中，对此，我们可以绘制相应的图示，以便更好地理解。</p><p>只有当每个<u>子总体</u>（每个初始体重级别）的<u>相对比例</u>（男女生比例）<u>在各群组之间一致</u>的情况下，<u>确凿性原则才起作用</u>【上文中用于处理叉连结里的混杂因子B】。然而，在罗德的例子中，“处理”（性别）对每个体重级别里学生的百分比的影响非常大。</p><p>（用在上文的例子中，子总体是性别，<u>相对比例并未体现，是其他的量</u>，各群组是指男何女。）</p><h2 id="7-超越统计调整"><a href="#7-超越统计调整" class="headerlink" title="7. 超越统计调整"></a>7. 超越统计调整</h2><p>——征服干预之峰</p><p>在这一章，我们终于勇敢地登上了因果关系之梯的第二层级，干预——自古至今因果思考的圣杯。</p><p>混杂因子是导致我们混淆“观察”与“干预”的主要障碍。在用“路径阻断”工具和后门标准消除这一障碍后，我们就能精确而系统地绘制出登上干预之峰的路线图。最安全的路线是<u>后门调整和由此衍生的诸多同源路线</u>，它们有些可以归于<u>“前门调整”</u>名下，有些则可以归于<u>“工具变量”</u>名下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在开始前：&lt;/p&gt;
&lt;p&gt;我在大二上学习概率论时，我曾经对事件的独立性的描述感到奇怪，书上仅描述了事件组之间相互独立的性质上的结论，却没有式子来刻画更本质的因果和独立性的传递，还追问了老师很久，最好不了了之，没有发现因果科学。&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="Causality" scheme="https://darren-dong.com/categories/Causality/"/>
    
    
    <category term="理论" scheme="https://darren-dong.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅深度学习</title>
    <link href="https://darren-dong.com/2022/03/01/%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    <id>https://darren-dong.com/2022/03/01/%E6%9D%8E%E5%AE%8F%E6%AF%85/</id>
    <published>2022-03-01T06:08:16.000Z</published>
    <updated>2022-05-09T06:41:24.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Spatial-Transformer"><a href="#Spatial-Transformer" class="headerlink" title="Spatial Transformer"></a>Spatial Transformer</h3><p>普通的CNN能够显示的学习平移不变性，以及隐式的学习旋转不变性，但attention model 告诉我们，与其让网络隐式的学习到某种能力，不如为网络设计一个显式的处理模块，专门处理以上的各种变换。</p><p>李宏毅: CNN其实没有scaling的不变性，rotation的泛化性也不是很强。【not invariant to them】<br>translation的泛化性有一些，可以归功于max-pooling。但没有“完全的平移泛化性”</p><p>【<u>不然为啥还要数据增强呢xs</u>】</p><p>Spatial transformer 也是一种layer，放在了CNN的前面，用来转换输入的图片数据，其实也可以转换feature map,因为feature map说白了就是浓缩的图片数据，所以Transformer layer也可以放到CNN里面。</p><p>旋转和平移其实只用六个参数就能完全表示。</p><p>针对输出不是整数的情况，采用的是相邻点加权的方式。【不然没法反向求导】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953076.png" alt="image-20220413190037195" style="zoom:50%;" /><p>基本架构如下：【可以放在CNN外和CNN内】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953177.png" alt="这里写图片描述" style="zoom: 50%;" /><p>主要的部分一共有三个，它们的功能和名称如下：</p><p>参数预测：Localisation net<br>坐标映射：Grid generator<br>像素的采集：Sampler</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953889.png" alt="image-20220413190310131" style="zoom:50%;" /><p>直观理解，ST相当于提供一个更稳定的输入。cool啊</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953862.png" alt="image-20220413190529672" style="zoom:50%;" /><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><a href="https://www.jiqizhixin.com/articles/2018-12-10-8">从Word Embedding到Bert模型——自然语言处理预训练技术发展史</a></p><p>有人提到，图像、语音属于比较自然地低级数据表示形式，在图像和语音领域，最基本的数据是信号数据，我们可以通过一些距离度量，判断信号是否相似，在判断两幅图片是否相似时，只需通过观察图片本身就能给出回答。<br>而语言作为人类在进化了几百万年所产生的一种高层的抽象的思维信息表达的工具，其具有<u>高度抽象</u>的特征，文本是符号数据，两个词只要字面不同，就<u>难以刻画它们之间的联系</u>，即使是“麦克风”和“话筒”这样的同义词，从字面上也难以看出这两者意思相同（语义鸿沟现象），可能并不是简单地一加一那么简单就能表示出来，而判断两个词是否相似时，还需要更多的背景知识才能做出回答。</p><p>那么据上是不是可以自信地下一个结论呢：如何有效地表示出语言句子是决定NN能发挥出强大拟合计算能力的关键前提！</p><p><strong>语言模型</strong></p><p>语言模型包括文法语言模型和统计语言模型，一般我们指的是统计语言模型。</p><p>统计语言模型： 统计语言模型把语言（词的序列）看作一个随机事件，并赋予相应的概率来描述其属于某种语言集合的可能性。给定一个词汇集合 V，对于一个由 V 中的词构成的序列S = ⟨w1, · · · , wT ⟩ ∈ Vn，统计语言模型赋予这个序列一个概率P(S)，来衡量S 符合自然语言的语法和语义规则的置信度。一个句子的打分概率越高，越说明他是更合乎人说出来的自然句子。</p><p>常见的统计语言模型有N元文法模型（N-gram Model）</p><p>理想的语言模型就能够基于模型本身生成自然文本。 与猴子使用打字机完全不同的是，从这样的模型中提取的文本 都将作为自然语言（例如，英语文本）来<u>传递</u>。 只需要基于前面的对话片断中的文本， 就足以生成一个有意义的对话。 显然，我们<u>离设计出这样的系统还很遥远， 因为它需要“理解”文本，而不仅仅是生成语法合理的内容。</u></p><p><u><strong>表示方法</strong></u></p><ol><li>独热表示one-hot representation</li></ol><p>最直观，也是到目前为止<u>最常用</u>的词表示方法？<br>向量的维度会随着句子的词的数量类型增大而增大<br>任意两个词之间都是孤立的，根本无法表示出在语义层面上词语词之间的相关信息，而这一点是致命的。</p><ol start="2"><li>分布式表示distributed representation</li></ol><p>分布假说：<u>词的语义由其上下文决定</u>（ a word is characterized by thecompany it keeps）。<br>根据建模的不同，主要可以分为三类：基于矩阵的分布表示、基于聚类的分布表示和基于神经网络的分布表示。【均基于分布假说】</p><p>两部分：<u>一、选择一种方式描述上下文；二、选择一种模型刻画目标词与其上下文之间的关系。</u></p><p><em>分布式表示</em></p><ol><li><p>基于矩阵的分布表示 基于矩阵的分布表示通常又称为分布语义模型，在这种表示下，矩阵中的一行，就成为了对应词的表示，这种表示描述了该词的上下文的分布。由于分布假说认为上下文相似的词，其语义也相似，因此在这种表示下，<u>两个词的语义相似度可以直接转化为两个向量的空间距离。</u></p><p>常见到的Global Vector 模型（GloVe模型）是一种对“词-词”矩阵进行分解从而得到词表示的方法，属于基于矩阵的分布表示。</p></li><li><p>基于聚类的分布表示 基于聚类的分布表示作者也还不是太清楚，所以就不做具体描述。</p></li><li><p>基于神经网络的分布表示，词嵌入（word embedding）</p></li></ol><p><strong>词嵌入/词向量</strong></p><p>在前面基于矩阵的分布表示方法中，最常用的上下文是词。如果使用包含词序信息的 n-gram 作为上下文，当 n 增加时， n-gram 的总数会呈<u>指数级增长</u>，此时会遇到维数灾难问题。而神经网络在表示 n-gram 时，可以通过一些组合方式对 n 个词进行组合，参数个数仅以线性速度增长。有了这一优势，神经网络模型可以对更复杂的上下文进行建模，在词向量中包含更丰富的语义信息。</p><p>而神经网络在表示 n-gram 时，可以通过一些组合方式对 n 个词进行组合，参数个数仅以线性速度增长。有了这一优势，神经网络模型可以对更复杂的上下文进行建模，在词向量中包含更丰富的语义信息。</p><blockquote><p>当你的任务的训练集相对较小时，词嵌入的作用最明显，所以它广泛用于<strong>NLP</strong>领域。我只提到一些，不要太担心这些术语（下问列举的一些<strong>NLP</strong>任务），它已经用在命名实体识别，用在文本摘要，用在文本解析、指代消解，这些都是非常标准的<strong>NLP</strong>任务。</p><p>词嵌入在语言模型、机器翻译领域用的少一些，尤其是你做语言模型或者机器翻译任务时，这些任务你有大量的数据。</p></blockquote><p>统计语言模型statistical language model就是给你几个词，在这几个词出现的前提下来计算某个词出现的（事后）概率。</p><p>可以参考参考李沐的：<a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html">https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html</a></p><p>CBOW也是统计语言模型的一种，顾名思义就是根据某个词前面的C个词或者前后C个连续的词，来计算某个词出现的概率。Skip-Gram Model相反，是根据某个词，然后分别计算它前后出现某几个词的各个概率。</p><p>实现CBOW（ Continuous Bagof-Words）和 Skip-gram 语言模型的工具正是word2vec！另外，C&amp;W 模型的实现工具是SENNA。</p><p>NNLM 是怎么训练的？是输入一个单词的上文，去预测这个单词。这是有显著差异的。为什么 Word2Vec 这么处理？原因很简单，因为 Word2Vec 和 NNLM 不一样，NNLM 的主要任务是要学习一个解决语言模型任务的网络结构，语言模型就是要看到上文预测下文，而 word embedding 只是无心插柳的一个副产品。但是 Word2Vec 目标不一样，它单纯就是要 word embedding 的，这是主产品，所以它完全可以随性地这么去训练网络。</p><p><strong>预训练过程（18年以前）</strong></p><p>句子中每个单词以 Onehot 形式作为输入，然后乘以学好的 Word Embedding 矩阵 Q，就直接取出单词对应的 Word Embedding 了。那个 Word Embedding 矩阵 Q 其实就是网络 Onehot 层到 embedding 层映射的网络参数矩阵。</p><p>所以你看到了，使用 Word Embedding 等价于什么？等价于把 Onehot 层到 embedding 层的网络用预训练好的参数矩阵 Q 初始化了。这跟前面讲的图像领域的低层预训练过程其实是一样的，区别无非 Word Embedding <u>只能初始化第一层网络参数，再高层的参数就无能为力了。</u>下游 NLP 任务在使用 Word Embedding 的时候也类似图像有两种做法：</p><ul><li>一种是 Frozen，就是 Word Embedding 那层网络参数固定不动；</li><li>另外一种是 Fine-Tuning，就是 Word Embedding 这层参数使用新的训练集合训练也需要跟着训练过程更新掉。</li></ul><blockquote><p><strong>ELMO</strong></p><p>word embedding多义词问题。我们知道，多义词是自然语言中经常出现的现象，也是语言灵活性和高效性的一种体现。</p><p>在用语言模型训练的时候，不论什么上下文的句子经过 word2vec，都是预测相同的单词 bank，而同一个单词占的是同一行的参数空间，这导致两种不同的上下文信息都会编码到相同的 word embedding 空间里去。所以 word embedding 无法区分多义词的不同语义，这就是它的一个比较严重的问题。</p><p><u>ELMO</u> 提供了一种简洁优雅的解决方案。【论文：Deep contextualized word representation】</p><p>在此之前的 Word Embedding 本质上是个静态的方式，所谓静态指的是训练好之后每个单词的表达就固定住了<br>ELMO 的本质思想是：我事先用语言模型学好一个单词的 Word Embedding，此时多义词无法区分，在我实际使用 Word Embedding 的时候，单词已经具备了特定的上下文了，这个时候我可以根据上下文单词的语义去调整单词的 Word Embedding 表示，这样经过调整后的 Word Embedding 更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。</p><p>所以 ELMO 本身是个根据当前上下文对 Word Embedding 动态调整的思路。</p><p>ELMO 的预训练过程不仅仅学会单词的 Word Embedding，<u>还学会了一个双层双向的 LSTM 网络结构</u>，而这两者后面都有用。 </p><p>多义词问题解决了吗？解决了，而且比我们期待的解决得还要好。</p><p>对于 Glove 训练出的 Word Embedding 来说，多义词比如 play，根据它的 embedding 找出的最接近的其它单词大多数集中在体育领域，这很明显是因为训练数据中包含 play 的句子中体育领域的数量明显占优导致；而使用 ELMO，根据上下文动态调整后的 embedding 不仅能够找出对应的「演出」的相同语义的句子，而且还可以保证找出的句子中的 play 对应的词性也是相同的，这是超出期待之处。之所以会这样，是因为我们上面提到过，第一层 LSTM 编码了很多句法信息，这在这里起到了重要作用。</p><p>ELMO 有什么值得改进的缺点呢？首先，一个非常明显的缺点在<u>特征抽取器选择方面</u>，ELMO 使用了 LSTM 而不是新贵 Transformer</p><p><strong>GPT</strong></p><p>把 ELMO 这种预训练方法和图像领域的预训练方法对比，发现两者模式看上去还是有很大差异的。除了以 ELMO 为代表的这种基于特征融合的预训练方法外，NLP 里还有一种典型做法，这种做法和图像领域的方式就是看上去一致的了，一般将这种方法称为“基于 Fine-tuning 的模式”，而 GPT 就是这一模式的典型开创者。</p><p>GPT 也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过 Fine-tuning 的模式解决下游任务。<br>区别于ELMO，预训练使用Transformer作为特征抽取器，并且只用上文，不用下文（很吃亏，这限制了其在更多应用场景的效果）</p><p>对于不同的下游任务来说，本来你可以任意设计自己的网络结构，现在不行了，你要向 GPT 的网络结构看齐，把任务的网络结构改造成和 GPT 的网络结构是一样的。然后，在做下游任务的时候，利用第一步预训练好的参数初始化 GPT 的网络结构，这样通过预训练学到的语言学知识就被引入到你手头的任务里来了</p><p>GPT 论文给了一个改造施工图。</p><p>GPT 的效果是非常令人惊艳的，在 12 个任务里，9 个达到了最好的效果，有些任务性能提升非常明显。</p><blockquote><p>那么站在现在的时间节点看，GPT 有什么值得改进的地方呢？其实最主要的就是那个单向语言模型，如果改造成双向的语言模型任务估计也没有 Bert 太多事了。当然，即使如此 GPT 也是非常非常好的一个工作，跟 Bert 比，其作者炒作能力亟待提升。</p></blockquote></blockquote><p><strong>BERT</strong></p><p>Bert 采用和 GPT <u>完全相同</u>的两阶段模型，首先是语言模型预训练；其次是使用 Fine-Tuning 模式解决下游任务。和 GPT 的最主要不同在于在预训练阶段采用了类似 ELMO 的双向语言模型，当然另外一点是语言模型的数据规模要比 GPT 大。所以这里 Bert 的预训练过程不必多讲了。</p><p>在改造任务方面 Bert 和 GPT 有些不同</p><blockquote><p>先大致说下 NLP 的几类问题，以强调 Bert 的普适性有多强。通常而言，绝大部分 NLP 问题可以归入上图所示的四类任务中：</p><ul><li>一类是<u>序列标注</u>，这是最典型的 NLP 任务，比如中文分词，词性标注，命名实体识别，语义角色标注等都可以归入这一类问题，它的特点是句子中每个单词要求模型根据上下文都要给出一个分类类别。</li><li>第二类是<u>分类任务</u>，比如我们常见的文本分类，情感计算等都可以归入这一类。它的特点是不管文章有多长，总体给出一个分类类别即可。</li><li>第三类任务是<u>句子关系判断</u>，比如 Entailment，QA，语义改写，自然语言推理等任务都是这个模式，它的特点是给定两个句子，模型判断出两个句子是否具备某种语义关系。</li><li>第四类是<u>生成式任务</u>，比如机器翻译，文本摘要，写诗造句，看图说话等都属于这一类。它的特点是输入文本内容后，需要自主生成另外一段文字。</li></ul></blockquote><blockquote><p>作者言：</p><p>所以说 Bert 的模型没什么大的创新，更像最近几年 NLP 重要进展的集大成者，这点如果你看懂了上文估计也没有太大异议，如果归纳一下这些进展就是：</p><ul><li>首先是两阶段模型，第一阶段双向语言模型预训练，这里注意要用双向而不是单向，第二阶段采用具体任务 Fine-tuning 或者做特征集成；</li><li>第二是特征抽取要用 Transformer 作为特征提取器而不是 RNN 或者 CNN；</li><li>第三，双向语言模型可以采取 CBOW 的方法去做（当然我觉得这个是个细节问题，不算太关键，前两个因素比较关键）。</li></ul><p><strong>Bert 最大的亮点在于效果好及普适性强，几乎所有 NLP 任务都可以套用 Bert 这种两阶段解决思路，而且效果应该会有明显提升。</strong>可以预见的是，未来一段时间在 NLP 应用领域，Transformer 将占据主导地位，而且这种两阶段预训练方法也会主导各种应用。</p></blockquote><h3 id="wordembedding"><a href="#wordembedding" class="headerlink" title="wordembedding"></a>wordembedding</h3><p>Count-based方法：比如Glove</p><p>Prediction-based：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953357.png" alt="image-20220421091036530" style="zoom:31%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954579.png" alt="image-20220421092013452" style="zoom:33%;" /></p><p>可以拓展这个model到n个词汇，比如第二幅图就是词，但是<u>weight要相等</u>【我不能理解，这忽略了部分时序吧】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953960.png" alt="image-20220421091522784" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954011.png" alt="image-20220421092355716" style="zoom:33%;" /></p><p>有种种变形，难说哪种比较好，不同的test上互有胜负，包括了CBOW、Skip-gram。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953932.png" alt="image-20220421092438251" style="zoom:33%;" /><h2 id="Interpretability"><a href="#Interpretability" class="headerlink" title="Interpretability"></a>Interpretability</h2><h3 id="why-deep"><a href="#why-deep" class="headerlink" title="why deep"></a>why deep</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954074.png" alt="image-20220420114744949" style="zoom:40%;" /><p>更多的数据可以让你更接近理论上限（上限由你的模型决定，模型越复杂，越有可能包含更高的上限）</p><p>理论上一个“够胖的”的hidden layer就能做任何事情。研究发现，参数量相同时👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954913.png" alt="image-20220420123256784" style="zoom:33%;" /><p>WHY？</p><p>因为数学上，要拟合一个复杂function，用高瘦的network，需要参数比较少（毕竟指数增长和线性增长。）</p><p>而比较少的参数意味着不容易overfitting，需要更少的训练资料。</p><p>直观理解：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954012.png" alt="image-20220420123959298" style="zoom: 22%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954697.png" alt="image-20220420124351296" style="zoom: 23%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954663.png" alt="image-20220420124416548" style="zoom:23%;" /></p><p>就是线性增长咯。👆</p><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><h3 id="Why-Deep"><a href="#Why-Deep" class="headerlink" title="Why Deep"></a>Why Deep</h3><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>之所以不叫优化算法是因为，略过了数学证明：（即某些优化算法理论的精度上下限之类的），只关注深度学习的应用。</p><p>但是其实，由于deep learning的复杂性，<u>不管你理论有多强的gurantee，都是不够用的</u></p><p><strong>复习</strong></p><p>SGD、SGD with momentum、Adagrad、RMSProp、Adam</p><p>基本概念：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955203.png" alt="image-20220413105054745" style="zoom:50%;" /><p>on-line：每次只能看到当前时间步的数据（x，y）<br>off-line：每次能看到整个数据集（本节假设为off-line），实际过程中会受到内存的限制。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955584.png" alt="image-20220413105625708" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955227.png" alt="image-20220418130100646" style="zoom:30%;" /></p><p>SGDM在局部最小处，不会卡在那个点，而是继续动，就像多出了动量一样（但是可能会累积而使得learning-rate爆炸）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955171.png" alt="image-20220418130331872" style="zoom:33%;" /><p>Adsgrad思路是放缓下降太快的方向，增大平缓方向的学习率。但是其分母会无止境地累加，而RMSProp确保不会因为累积过多而卡住，但是它也有卡在局部最小点的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955757.png" alt="image-20220418130505388" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955835.png" alt="image-20220418131258751" style="zoom:33%;" /></p><p>Adam算法则结合了以上两者：（$m_t$一开始比较小，分母调节其大小）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955104.png" alt="image-20220418131424333" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955374.png" alt="image-20220418132133948" style="zoom:40%;" /></p><p>折几个经典的optimizer都是2014年左右提出来的，到底出了什么问题</p><p>BERT  Transformer  Tacotron（语音生成）Big-GAN（生物生成）MEMO演算法（寻找通式，提取共同信息） 【Adam】<br>YOLO  Mask R-CNN  【SGDM】</p><p><strong>新的分析</strong></p><p>这位助教老师自己分析：因为Adam和SGD直接抢到了两个极端的位置（来自某次实验）：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321935.png" alt="image-20220418210601396" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321590.png" alt="image-20220418210621657" style="zoom:33%;" /></p><blockquote><p>Adam: fast training, large generalization gap, unstable     快</p><p>SGDM: stable, little generation gap, better convergence   稳</p></blockquote><p>SWATS：先做Adam再做SGD</p><p>AMSGrad:有意义的方向更新被限制了大小，大的步长被限制成较小的值，无法起到好作用。作者的想法是减少无用而且小的gradient造成的影响。（但是还是有learning-rate变小的问题）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321277.png" alt="image-20220418212945087" style="zoom:33%;" /><p>还有AdaBound，助教说十分粗鲁，失去了数学的优雅，太工业了。</p><p>还有很多种比如SGDR、One-cycle LR一堆堆。总之有许多新奇的思路</p><p>Adam最开始的步骤里，即使分母有稳定数值，但是意义上是随机的，也会使其混乱。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321820.png" alt="image-20220418214320254" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317368.png" alt="image-20220418215343727" style="zoom:50%;" /><hr><p><strong>更新的</strong></p><p>Hinton团队的一个work，和MEML演算法（原学习）的Reptile很像。</p><p>希望你走到比较平坦的地方，避免走进太崎岖的的地方然后accuracy掉下去</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322131.png" alt="image-20220418215618841" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322438.png" alt="image-20220418215933127" style="zoom:33%;" /></p><p>能不能看到未来，避免走到太差的点：NAG（通过数学手段免除两倍内存消耗。）【以后可以回来看】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322293.png" alt="image-20220418220653067" style="zoom: 33%;" /><hr><p><strong>对优化器的一些讨论</strong></p><p>L2正则化时，正则化项要不要出现在动量的表达式中呢！</p><p>这个东西没有标准答案，但有人提出不加更好，也就是有实际价值的<u>SGDWM和AdamW</u></p><p>这两者被用于NLP，BERT系列之类的。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322898.png" alt="image-20220418221413513" style="zoom:36%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322484.png" alt="image-20220418221428662" style="zoom:38%;" /></p><p>这几个技术其实都是在做一件事，就是<u>鼓励你的探索，增加随机性</u>。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091404260.png" alt="image-20220418221740834" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091404567.png" alt="image-20220418221946621" style="zoom:33%;" /></p><p>curriculum的思路是：一开始的训练决定大方向，先找到一个比较好的local minimum，再接着用难数据找比较好的点，这样就不会掉到太狭窄的山谷里。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405443.png" alt="image-20220418222304412" style="zoom:50%;" /><p>==总结==：优化器</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405174.png" alt="image-20220418222518416" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405510.png" alt="image-20220418222602917" style="zoom:33%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405642.png" alt="image-20220418222730658" style="zoom:33%;" /><p>有必要指出，优化器的选择只不过是在你其他地方没有问题的基础上improve一些，架构、训练技巧、脏数据都是帮不了你的。</p><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h3><p><strong>自注意力</strong></p><p>引入：原本的<em>输入</em>都是一个长度已经定义好的向量，那么如何处理 一个<u>长度不一</u>的向量<u>序列</u>（他的顺序和沐神似乎不太一样）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405659.png" alt="image-20220412213425911" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405722.png" alt="image-20220412213557171" style="zoom:30%;" /></p><p>独热码并没有关心向量之间的关系和联系，word embedding解决了这个问题。👆还有对声音的处理。</p><p>输出大致有三种可能性：</p><ol><li>每个vector被model赋予一个label（输入和输出数目一样）</li><li>一整个seq输入，只得到一个输出，比如情感分析positive和negative</li><li>输出是不确定的，由model自己决定【seq2seq】</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405988.png" alt="image-20220412215649787" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423977.png" alt="image-20220412220002350" style="zoom:25%;" /></p><p>self-attention考虑到了整个输入，计算单个输出：也就是把对应的输入当作query，其他的当作key和value👆</p><p>此处的$b_1 - b_n$是<u>并行，同时被计算出来的</u>。所以说并行性好啊，举个例子：$b_2$，矩阵形式👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405023.png" alt="image-20220412220456271" style="zoom: 45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423978.png" alt="image-20220412220844435" style="zoom:45%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406984.png" alt="image-20220412221141790" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423979.png" alt="image-20220412221302896" style="zoom:40%;" /></p><p>他说这里不一定用softmax，还可以用relu什么的，效果也不会太差；这也太友好了吧，shape都帮你推出来。</p><p>不过从原始输入还要经过不同的变换才能得到q、k、v，这里直接是多头注意力了。（原理图给的是内积分数计算）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406030.png" alt="image-20220412221916722" style="zoom:40%;" /><p><strong>多头自注意力</strong></p><p>“相关”这个定义方式有很多种，因此我们需要得到多个q，k，v的组合，计算的时候是组内计算的，（如$b^{i,2}$不用${i,1}$的东西），最后把多头接起来，再通过一个变换得到最终的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406602.png" alt="image-20220412222748022" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406913.png" alt="image-20220412222943926" style="zoom:40%;" /></p><p><em>位置信息</em></p><p>下图黄绿那一片是最开始论文中采用的位置信息（人为设置的，有诸多问题）。</p><p>如今，还有许多人在研究position encoding，也没有人说sin cos就是最好的方法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406839.png" alt="image-20220412223145112" style="zoom: 50%;" /><p>有个问题，在诸如声音讯号中，长度非常长，计算量相当大，有一招叫做truncated self-attention，只考虑一个范围，这个范围如何选定取决于你对问题的理解。</p><p>self-attention也可以用在图像中，也就是换一个角度，不把图像看成很长的向量，而是看成一个vector set，每个vector是一个像素。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406269.png" alt="image-20220412223741608" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406163.png" alt="image-20220412223930206" style="zoom:45%;" /></p><p>如果比较CNN和self-attention，可以说self-attention是一个复杂化的CNN，考虑全局的信息而不是感受野之内的。也可以这样理解：感受野（receptive field）是自己学出来的，而不是人工设定的！【端到端狂喜！】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406369.png" alt="image-20220412224240774" style="zoom:46%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406377.png" alt="image-20220412224432391" style="zoom:45%;" /></p><p>但是，更free的model需要更多的数据才能学的好，self-attention比起CNN也需要更多的model</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406301.png" alt="image-20220412230307671" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406274.png" alt="image-20220412230938301" style="zoom:50%;" /></p><p>草，李宏毅说RNN基本都能被self-attention代替，所以不讲了</p><p>self-attention也可以用在graph上，只考虑有关联的，👆，这就是GNN</p><p>减少self-attention的计算量是非常值得研究的课题。还有各类的self-attention变形，见后文：各式SA</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>Transformer 是个叠加的“自注意力机制（Self Attention）”构成的深度网络，是目前 NLP 里==最强的特征提取器==，注意力这个机制在此被发扬光大，从任务的配角不断抢戏，直到 Transformer 一跃成为踢开 RNN 和 CNN 传统特征提取器，荣升头牌，大红大紫。</p><h4 id="Seq2seq"><a href="#Seq2seq" class="headerlink" title="Seq2seq"></a>Seq2seq</h4><p>和bert很有关系，输入是seq，输出是长度不确定的seq。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406635.png" alt="image-20220413112023113" style="zoom:33%;" /><p>之所以要弄speech-&gt;translation而不是直接拼合上面的，是因为世界上有许多语言是没有文字的（或者像台语一样没啥人用文字）。</p><p><u>很多NLP的任务都可以类比QA任务</u>：给model一个上下文context，问机器一个Q，机器返回一个A</p><p>而QA的问题就可以用seq2seq来解决【<em>通用方案？</em>】当然，对不同的任务采用特制的模型，可能得到更好的结果（本节不讨论）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406414.png" alt="image-20220413112921818" style="zoom: 40%;" /><p>还有很多问题，你不觉得是seq2seq，但也可以用这个方法硬解它！👇【甚至物体识别都行】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406889.png" alt="image-20220413113250621" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407096.png" alt="image-20220413113507114" style="zoom:33%;" /></p><hr><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>架构李沐讲的不错，都没有讲什么直观理解。</p><p>BERT其实就是transformer的encoder。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407681.png" alt="image-20220413124035656" style="zoom:33%;" /></p><p>当然，这个encoder架构不一定要这样设计，有人提出了别的架构方法。下面的论文探究了为什么batch不如layer normalization</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407431.png" alt="image-20220413123828320" style="zoom:33%;" /><p>Decoder其实有<u>两种（AT和NAT）</u>，比较常见的是Autoregressive，NAT用的也不少，比如在语音合成里。</p><p>Encoder和Decoder其实结构很像，第一个注意力层那里，decoder用的是掩码attention，不考虑后面的输入</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407461.png" alt="image-20220413124810744" style="zoom:33%;" /><p>为了不让程序永无止境地推到下去，需要准备一个特殊字符“EOS”（end of sentence）对比NT和NAT👇：</p><p>NAT在并行性和长度的人为可控性有优势（比如音频倍速，就可以利用这个先验信息更好的辅助）</p><p>但是<u>NAT这个decoder的表现往往不如AT</u>，decoder的设计现在也是一个热门主题。【选修课有讲NAT】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407719.png" alt="image-20220413125438287" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407238.png" alt="image-20220413130053827" style="zoom:33%;" /></p><p>注意力机制（李宏毅称cross-attention）</p><p>当然，是先有注意力机制，再有self-attention的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409311.png" alt="image-20220413130254120" style="zoom:33%;" /><p>encoder和decoder之间的联系：</p><p>原始论文给出的架构中，是<u>encoder的最后一层输入到decoder的每一层，但是完全可以有不同的联系方式。</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409674.png" alt="image-20220413131122361" style="zoom: 50%;" /><p>训练的时候是“强制教学[teacher forcing]”。</p><p><u>训练时用的损失函数是cross entropy</u>，单独考虑每一个词元与正确答案的误差。因为BLEU计算复杂，无法用来微分求导。</p><p>【遇到无法优化的目标，用RL硬train一发，把loss当reward，decoder当agent】</p><p>但是这不一定使得BLEU减小，<u>测试时用的是BLEU</u>，所以validation集要用BLEU来做评估。</p><p>训练和测试评估不一样导致：<em>exposure bias</em> 。</p><p>因为训练的时候decoder只看正确的东西，测试的时候便会一步错，步步错。</p><p>一个解决思路是：<em>scheduled sampling</em>，也就是在训练的时候加入一些错的“噪音”。</p><p>transformer和RNN的解决思路不一样，有一些reference：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409612.png" alt="image-20220413152100682" style="zoom: 40%;" /><p>==TIPs==</p><p><strong>Copy mechanism</strong></p><p>在比如chat-box、做摘要的场景中，要学从人的输入中copy一些词当作他的输出。</p><p>那么如何才能拥有这个能力？最早的工作是<em>pointer network</em></p><p><strong>Guided attention</strong></p><p>如果你对问题有一定的理解，那么强迫这个attention具有一定的模式，比如语音合成应该由左向右。</p><p>like monotonic attention；location-aware attention。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410053.png" alt="image-20220413142924697" style="zoom:33%;" align = 'left' /><p><strong>Beam Search</strong></p><p>xs，不一定分数高的结果就好，有时候你需要model发挥一点“创造力”【神tm自动生成小说】</p><p>TTS中你要生成好的，必须在decoder里加入一些杂音，否则生成的像机器声一样。</p><h3 id="各式SA"><a href="#各式SA" class="headerlink" title="各式SA"></a>各式SA</h3><p>self-attention其实有各式各样的。大部分叫做xxformer</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410543.png" alt="image-20220412231101454" style="zoom: 40%;" /><p>主要痛点是，指数增长的计算量，因此有各式各样的方法试图加速。主要计算来自于NxN的矩阵。</p><p>当然，self-attention只是整个network的一部分，如果占比不大，加速的效果也蛮有限的。<br>当input长度N非常大时，就有必要加速了，这些技术大部分在影像处理里，因为一张256x256的图的N有多达65536，计算还要平方。</p><p><strong>手工</strong></p><p><em>Local attention</em></p><p>有些问题，只用关注局部信息就能得到答案，无需关注全局信息。（又和CNN没差别了）</p><p>因此虽然能加快运算，但不一定能给你很好的结果。</p><p><em>Stride Attention</em></p><p>跳着看邻居的邻居的咨询，而不是直接看邻居的咨询。空几格也是超参数。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410283.png" alt="image-20220502094747031" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410283.png" alt="image-20220502094911355" style="zoom:33%;" /></p><p><em>Global Attention</em></p><p>通过特殊的符号（token）代表这个位置要做global attention</p><p>它先attend to所有token来看看全局发生了哪些事情，然后再由全局的来查看它以获得全局的咨询。例子：</p><p>【假设序列的前两个token设为global token】感觉这个idea非常nb，有点巧妙，可解释性也高。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410389.png" alt="image-20220502095556582" style="zoom:40%;" /><p>真实情况是，我全都要，多头注意力的每个头都能用不同种类的attention优化方法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410258.png" alt="image-20220502095743386" style="zoom:50%;" /><p>但是，刚刚提到的三种方法其实都是<u>人工设定</u>的，用了“先验知识”，但是凡是能用先验知识的地方，那必然有data driven</p><p><strong>data driven</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410864.png" alt="image-20220502100503991" style="zoom:33%;" /><p><em>Clustering</em>能采取很多加速的方法。<u>我个人理解，归一化后向量模长差不多，又因为用内积计算，所以相近的自然算的值大。</u></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410237.png" alt="image-20220502100633482" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410576.png" alt="image-20220502100813023" style="zoom:33%;" /></p><p>可学的模式：让另一个network去学，这种思想好常用。</p><p><em>sinkhorn sorting network</em>：重点是完成从NN生成的continuous的矩阵到一个二值矩阵的变换，并且需要该过程可微！不过这个过程如果真是老老实实算，其实不便宜多少，作者采用的是多个input共用1个NN生成的output来“取巧”，比如10个共用1个就是百倍加速。<br>那么为什么要分两步骤，不直接计算二值矩阵呢，这是作者下一篇paper干的事。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410729.png" alt="image-20220502101313732" style="zoom: 33%;" /><p><em>Linformer</em></p><p>发现是低秩矩阵，很多资讯重复，很多向量是相关的。</p><p>选用代表性的key，而不是有代表性的query，这样output length就不变，如果那种固定输出的，你可能可以用代表性query</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410063.png" alt="image-20220502102019578" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410305.png" alt="image-20220502102205724" style="zoom:33%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411803.png" alt="image-20220502103531704" style="zoom: 33%;" /><hr><p>除了对K和Q做内积加速以外，整体计算也有优化到空间。</p><p>先暂时忽略softmax</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411508.png" alt="image-20220502103923562" style="zoom:33%;" /><p>矩阵连乘，顺序不同，计算量不同，计算量为两矩阵共三个维度的积。哇哦！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411342.png" alt="image-20220502104212858" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411545.png" alt="image-20220502104604769" style="zoom: 33%;" /></p><p>一把softmax加回去，数学就上去了。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411244.png" alt="image-20220502104825762" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411422.png" alt="image-20220502105133904" style="zoom:33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411094.png" alt="image-20220502105238225" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411808.png" alt="image-20220502105401508" style="zoom:33%;" /></p><p>然后发现1，分子分母除了$\phi(q^i)$外，都与要算的$b^i$无关，因此<u>一次算好，以后都不用算</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411302.png" alt="image-20220502105616567" style="zoom:33%;" /><p><em>具体流程</em></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411683.png" alt="image-20220502110031049" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423980.png" alt="image-20220502110107280" style="zoom:33%;" /></p><p>直观上的理解没有原来好，但是快呀。</p><p>不同文献给出了不同的$\phi$方法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411251.png" alt="image-20220502110309453" style="zoom:33%;" /><hr><p>更多<u>神奇</u>的思考</p><p>把这个矩阵直接当成参数，根本不需要算。。。                   以前丢了recurrent，现在想丢掉attention</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412571.png" alt="image-20220502110623059" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412470.png" alt="image-20220502110704375" style="zoom:33%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412098.png" alt="image-20220502110757317" style="zoom:50%;" /><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Spatial"><a href="#Spatial" class="headerlink" title="Spatial"></a>Spatial</h3><p>why：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412679.png" alt="image-20220418224132613" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412037.png" alt="image-20220418224225620" style="zoom:30%;" /></p><p>人际关系图找凶手，人物之间的关系可以帮助我们提高识别凶手的准确率。</p><p>图非常大，不可能给所有的data都做labeling，如何利用有限的label和graph本身的structure训练出不错的模型【一般unlabelled更多】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412341.png" alt="image-20220419193943728" style="zoom:40%;" /><p><strong>很酷的路线图</strong>，其中用的最多的是圈起来的GCN和GAT</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412690.png" alt="image-20220419194236667" style="zoom:50%;" /><blockquote><p>Representation learning is a very important aspect of machine learning which automatically discovers the feature patterns in the data.</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412702.png" alt="image-20220419195000226" style="zoom:40%;" /><p>NN4G</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412360.png" alt="image-20220419195250478" style="zoom:26%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412809.png" alt="image-20220419195319737" style="zoom:30%;" /></p><p>DCNN</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412698.png" alt="image-20220419195706643" style="zoom:29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412043.png" alt="image-20220419195740654" style="zoom:30%;" /></p><p>MoNET就是处理了NN4G最后相加这个手法太粗糙的问题。（定义了一个距离的概念充当权重）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412122.png" alt="image-20220419200119029" style="zoom:40%;" /><p>但是，凡是能自己定的，为什么不让model自己学呢，后面会讲到。</p><p>GraphSAGE有好几种aggregate方式，甚至可以把邻居的feature喂到LSTM里，最后输出一个hidden stage用来做aggregate。【当然LSTM在实际测试结果不见得特别好。】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412453.png" alt="image-20220419200511061" style="zoom:50%;" /><p><strong>GAT</strong>（Graph Attention Networks）</p><p>对邻居做attention</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412973.png" alt="image-20220419200820494" style="zoom: 33%;" /><p>GIN给出了一些理论证明，结论是要用sum，不用mean或者max pooling【todo】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413531.png" alt="image-20220419201137233" style="zoom: 33%;" /><hr><h3 id="Spectral"><a href="#Spectral" class="headerlink" title="Spectral"></a>Spectral</h3><p>CNN要做的是学出一个filter，这相当于频域里的一个乘法，那么在GNN中该如何实现呢？请看理论解释：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413134.png" alt="image-20220419201917411" style="zoom:37%;" /><p>一些相关背景知识：A连接矩阵代表哪些节点相连（假设对称），D度数矩阵代表每一个节点有几个邻居，节点向量 f 代表signal</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413145.png" alt="image-20220419220234678" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423981.png" alt="image-20220419223403050" style="zoom:67%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413915.png" alt="image-20220419224211195" style="zoom: 33%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413009.png" alt="image-20220419224420154" style="zoom:28%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423982.png" alt="image-20220419224538421" style="zoom:30%;" /></p><p>重要概念：<u>频率越大，相邻两点间信号变化量越大。</u></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413705.png" alt="image-20220419225600209" style="zoom:29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423983.png" alt="image-20220419225858195" style="zoom:33%;" /></p><p>理论👇：$f^TLf$代表了这个graph相邻结点的信号能量差，也就是signal有多smooth，以量化graph signal的频率大小，</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423985.png" alt="image-20220419225244564" style="zoom: 29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413350.png" alt="image-20220419225348587" style="zoom: 28%;" /></p><p>也就是说，特征值$\lambda$可以代表特征向量变化频率的大小</p><p>那么怎么定义fourier transform，也就是怎么把一个图上的信号转到频域去呢，如下：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413167.png" alt="image-20220419231049875" style="zoom: 33%;" /><p>逆过程参考时域的积分：Amazing！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413791.png" alt="image-20220419231342360" style="zoom:31%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423986.png" alt="image-20220419231441272" style="zoom:29%;" /></p><p>而频域的filter其实就是对角矩阵，与之前转到频域的结果$\hat{x}$相乘（multiplication），最终的得到的新结果$\hat{y}$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413541.png" alt="image-20220420103134457" style="zoom:33%;" /><p>可见，我们最终要学的就是这个$g_\theta()$，也就是对拉普拉斯矩阵的函数，其中只关心对角（设了A和D对称），参数量为$N$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413193.png" alt="image-20220420103633182" style="zoom: 33%;" /><p>第一个问题，这个函数的shape与输入有关。</p><p>第二个问题，他不是localize的。<br>根据数学上给出的定理，$L^N$每一项都不为零，此时的感受野是全局，但我们希望像CNN的卷积核一样看到局部的信息。</p><hr><p>ChebNet</p><p>很快，解决了上述的两个问题。其实就是限制了多项式的级数到K。然而这带来了计算成本高昂的问题。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413553.png" alt="image-20220420110507865" style="zoom:33%;" /><p>ChebNet引入了数学上的技巧解决计算成本，把$\lambda$化为新的多项式表示，综合除法👇，此时会很好算。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414527.png" alt="image-20220420110849124" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413278.png" alt="image-20220420110808506" style="zoom:33%;" /></p><p>最终计算方式是递回的。。：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414434.png" alt="image-20220420111338954" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414943.png" alt="image-20220420111645797" style="zoom:30%;" /></p><p><strong>GCN</strong></p><p>简单直观，有一些数学基础。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414589.png" alt="image-20220420111838916" style="zoom:30%;" /><p>最终更新的式子就变成，把所有的neighbor经过transform相加取平均，加上bias</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414051.png" alt="image-20220420112126438" style="zoom:33%;" /><hr><p>接下来就是一些图领域的东西了。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414975.png" alt="image-20220420112228534" style="zoom:33%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414372.png" alt="image-20220420112505229" style="zoom:26%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423987.png" alt="image-20220420112523708" style="zoom:25%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414713.png" alt="image-20220420112625514" style="zoom: 33%;" /><p>但是结果看上去GCN很惨：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414876.png" alt="image-20220420112837020" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414629.png" alt="image-20220420112854189" style="zoom:33%;" /></p><p>做了weighted-sum的model一般结果好很多。</p><p>有人用理论证明说GCN在层数很多时，同一个子图内的edge会收敛到同一处。【只要Dropout就能解决这个问题】，但事实上，还是比浅一点的model要来的烂，有点离谱。至今还有待解决。<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414025.png" alt="image-20220420113135563" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414698.png" alt="image-20220420113308612" style="zoom:31%;" /></p><p>最后，GNN还可以用于generation，而且在NLP上有很多应用（比如知识图谱什么的）。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414492.png" alt="image-20220420113832248" style="zoom: 43%;" /><h2 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414999.png" alt="image-20220502154208307" style="zoom:33%;" /><p>why generator？</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415850.png" alt="image-20220502154419565" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415122.png" alt="image-20220502154641056" style="zoom:33%;" /></p><p>当我们的任务需要一点“<u>创造性</u>”，同一个输入，可能有很多不同的输出，而都是对的。（我笑死，老师太好玩了）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415486.png" alt="image-20220502154850821" style="zoom:33%;" /><h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><p>GAN实在太多啦！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415281.png" alt="image-20220502155034205" style="zoom:33%;" /><p>希望效果：从normal-distribution中sample不同的低维向量，都能由generator生成动画人脸（图片其实就是高维向量）</p><p>simple distribution的选择没有那么重要，generator负责把简单的distribution对应到复杂度distribution</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415061.png" alt="image-20220502155459705" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415746.png" alt="image-20220502155802970" style="zoom:33%;" /></p><p>generator和discriminator都是神经网络，只要能达到你想要的作用，用什么架构完全由你决定（我好像明白为啥那么多version了）</p><p><em>Basic idea</em></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415265.png" alt="image-20220502160011489" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415447.png" alt="image-20220502160219025" style="zoom:33%;" /></p><p>轮流固定，训练另一方。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415572.png" alt="image-20220502160632906" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415081.png" alt="image-20220502160651044" style="zoom:33%;" /></p><p>可以看成是一个大network，所谓的内插👇（吸收特征然后组合？！）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416230.png" alt="image-20220502161546788" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423988.png" alt="image-20220502161633843" style="zoom:33%;" /></p><h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><p>目标是学到$P_data$的分布，要用到概率论咯。</p><p>GAN牛逼的地方在于，解决了不知道怎么计算复杂的Diversion这个问题，只要你能从$P_G$ and $P_{data}$中采样，不需要知道这两个分布的formulation，就能算出divergence的逼近。</p><p>如右图，最终理论推导出这个$maxV(D,G)$竟然和divergence有关，【<u>注意不是V这个值本身，而是穷举能得到的最大值！</u>】本来作者选这个目标函数只是为了和分类问题挂钩hh</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416386.png" alt="image-20220502161900696" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416460.png" alt="image-20220502162622871" style="zoom:33%;" /></p><p>最终变成了一个极小极大值的优化问题：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416028.png" alt="image-20220502163058293" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416597.png" alt="image-20220502163343914" style="zoom:33%;" /></p><p>这篇文章给出了不同divergence的object function，也告诉大家即使很正确的minimize divergence，结果也没有很好。</p><p>GAN以不好train闻名哈哈</p><hr><p><strong>Tips</strong></p><p>GAN有很多很多训练的小技巧。</p><p>由于JS divergence的特性，只要没有相交，算出的是定值$log_2$，那在训练中就不能区别好坏。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416438.png" alt="image-20220502163838564" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416715.png" alt="image-20220502164117406" style="zoom:33%;" /></p><p>所以训练中accuracy不能提供资讯，以前训练GAN只能画出来人眼看，Wasserstein distance也能衡量分布的差异，但是贼难算，因为当样本很多时，有很多种moving的方式。但是这样确实能拟合分布，能真正优化。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416330.png" alt="image-20220502164421311" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416550.png" alt="image-20220502164911438" style="zoom:33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416131.png" alt="image-20220502165812221" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416606.png" alt="image-20220502170108059" style="zoom:33%;" /></p><p>最终把右图的第一条式子解出来就是衡量divergence的值。</p><p>现在最好用的还是$Spectral\ Normalization$</p><p>只要某一次一个人开摆，另一个人就玩不下去了。。。所以难train             👇不一定有效</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418387.png" alt="image-20220502171210217" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418924.png" alt="image-20220502171229467" style="zoom:33%;" /></p><p>很难用于文字，因为取了个max，你微小的变化根本不改变输出，也就没法传递回去，过去很长时间都没法train</p><p>当然有人通过爆改超参数炼起来了。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423989.png" alt="image-20220502171725228" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418346.png" alt="image-20220502171946467" style="zoom:33%;" /></p><p>还有GAN的更详细的一些理论：<a href="https://www.youtube.com/playlist?list=PLJV_el3uVTsMq6JEFPW35BCiOQTsoqwNw">here</a>的4、5、6</p><p>还有其他的generative models，不只是GAN：</p><p> <a href="https://youtu.be/8zomhgKrsmQ">VAE</a>           <a href="https://youtu.be/uXY18nzdSsM">FLOW-based Model</a></p><p>甚至generation能当作监督学习问题来做。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418923.png" alt="image-20220502174027179" style="zoom: 33%;" /></p><hr><h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418309.png" alt="image-20220502174308000" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423990.png" alt="image-20220502174438359" style="zoom:33%;" /></p><p>强如google暴搜都没法彻底解决这个问题，只能early stopping了，不过好歹容易侦测。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419980.png" alt="image-20220502174928402" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423991.png" alt="image-20220502175138788" style="zoom:33%;" /></p><p>但是inception score对同种多个体的不适用（二次元人脸），作业用的是FID</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419610.png" alt="image-20220502175436052" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419399.png" alt="image-20220502175922001" style="zoom:33%;" /></p><p>论文：Pros and cons of GAN evaluation measures 列举了很多方式供参考。</p><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>Conditional Genaration</strong></p><p>想进一步操纵输出，利用x向量输入模型来实现，以前用RNN，现在用transformer的encoder什么的都行。</p><p>x是一个控制，最终生成的效果和随机性取决于你sample的z，对应的discriminator也要更改，你训练的数据集要有pair</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420718.png" alt="image-20220502182143005" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419308.png" alt="image-20220502182454515" style="zoom:33%;" /></p><p><u>一般同时使用监督学习和GAN效果最好</u></p><p>还有根据声音生成画面的。还有产生会动的图片。</p><p><strong>用在unsupervised learning上</strong></p><p>你经常可能遇到一种情况，你有一堆x和一堆y，但是他们是不成对的，也就是unlabelled资料，那怎么训练呢？</p><p>比如影像风格转换就是这种情况。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420186.png" alt="image-20220502192825044" style="zoom:33%;" /><p>这个跟原来的GAN训练没什么不同，只是原本是从一个简单的分布中sample，现在是从人脸照片里面sample，后续步骤很接近。</p><p>但只是这样的话，输入和输出就没什么关系了，我们要强化他们之间的关系。</p><p>之前的conditional generation用的是paired资料，但是对这个场景，我们并没有这样的资料。</p><p><em>Cycle GAN</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419148.png" alt="image-20220502193422113" style="zoom:33%;" /><p>你可能会担心学到一些很奇怪的对应关系，也能满足上述条件，但实际work中一般都能比较好的完成。</p><p>甚至是你不用cycle GAN直接上也能train出来network比较懒，一般都会输出比较相近的东西，但理论上没有什么较好的解释。</p><p>同时训练<u>三个</u>：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419104.png" alt="image-20220502193744297" style="zoom:33%;" /><p>还有更厉害的work：starGAN可以在多种风格之间转换。</p><p>还有很多类似的text之间转换的work和领域。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419405.png" alt="image-20220502194502660" style="zoom:33%;" /><h2 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h2><p><strong>Self-Supervised Learning</strong></p><p>这个领域有许多的内容值得我们探索，见右下图</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419784.png" alt="image-20220503145400157" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420330.png" alt="image-20220504093737452" style="zoom:33%;" /></p><p>哈哈哈BERT有340M个参数。就这竟然还不算大的，xswl</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419263.png" alt="image-20220503145608341" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420978.png" alt="image-20220503145704977" style="zoom:33%;" /></p><p>然后还有个Switch Transformer比GPT-3大十倍！ 1.6T参数我日</p><p>所以自监督学习可以看作是无监督学习的一种。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420804.png" alt="image-20220503213211826" style="zoom:33%;" /><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>可以处理序列数据，因此不局限于NLP，还可以是语音、影像等等。</p><p>自己遮住某些词元（两种方法都可以），然后当作标签，训练来减少误差。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421372.png" alt="image-20220503214029359" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419219.png" alt="image-20220503214544826" style="zoom:33%;" /></p><p>现在大家说，这个什么next sentence prediction没什么用，也有很多文献证明这一点，反倒是SOP那种判断句子顺序的方法，在bert的一个进阶版本albert里就很有用了。</p><p>现在bert会做填空题，神奇的是，现在bert能被用在其他别的任务上。而这些任务甚至可能跟填空题没有什么关系。<br>这些任务被称为是downstream tasks，也就是我们真正在意的任务。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421606.png" alt="image-20220503214948740" style="zoom:33%;" /><p>他就像是干细胞，给他一点有标注的资料，他就能学会各式各样的任务，这也叫做Fine-tune</p><p><em>GLUE</em></p><p>由于bert这种特殊性，一般会测试你训练出的这个bert模型在各式各样的任务上的能力。也就是分别微调到9个任务上，然后看看你的模型表现的平均效果。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421250.png" alt="image-20220503215527545" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420326.png" alt="image-20220503215616415" style="zoom:33%;" /></p><p>这个基准线是人类能达到的程度，可以看到bert家族的能力逐年攀升。</p><p>可以看到模型已经“超越人类”，但显示的是这个资料集被玩坏了，所以就有人创建了更难的数据集，也就是啥super GLUE</p><p><em>使用流程</em>：</p><p>把你做填空题训练出的参数填到BERT模型里，这远比随机初始化的效果好很多。</p><p>然后用这个模型来“fine tune”，牛啊！然后就可以分化到各类任务了。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421967.png" alt="image-20220503220145523" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421054.png" alt="image-20220503220212012" style="zoom:33%;" /></p><p>看右边这张表，有了bert初始化的模型，不仅在训练过程中loss下降较快，而且最终的效果也更加好一点。</p><p>BERT上游是无监督、下游是有监督，合起来tm叫半监督。。。这着实太敷衍了一点。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421567.png" alt="image-20220503221007271" style="zoom:33%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421876.png" alt="image-20220503221134174" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423992.png" alt="image-20220503221234601" style="zoom:33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421431.png" alt="image-20220503221524289" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421462.png" alt="image-20220503221741295" style="zoom:33%;" /></p><p>但是要注意，这个问答系统是有限制的，也就是答案一定出现在原文里，上右图理解：随机初始化和BERT输出维度一样的橙色向量和蓝色向量，分别和输出做内积然后做softmax，橙色最大的那个输出的位置代表了答案开始的位置，蓝色是结束的位置。</p><p>理论上，BERT是transformer的encoder架构，可以接受任意长度的输入向量，但是从计算量考虑，512已经有些让人吃不消了。</p><p>训练成本太高了，如下，李老师的学生跑了100w次，用TPU跑了8天。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421499.png" alt="image-20220503222418423" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422149.png" alt="image-20220503223012887" style="zoom:33%;" /></p><p>右边那篇论文，介绍了对这个预训练过程的学习和了解，是李老师团队做的，有兴趣可以参考一下。</p><hr><p>然而上文并没有提到seq2seq的预训练过程，具体怎么做呢？</p><p>先把输入的向量弄坏，然后希望decoder能重建弄坏的结果，弄坏的方法多种多样</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422426.png" alt="image-20220503223954746" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422306.png" alt="image-20220503224109624" style="zoom:33%;" /></p><p>用哪种方法好，google已经尝试过了，详情见下图T5 paper：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422919.png" alt="image-20220503224512231" style="zoom:33%;" /><hr><p>至于为什么bert那么有效？可以看上文NLP——预训练的发家史。</p><p>相对于以前的词嵌入，bert是会考虑上下文的。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422711.png" alt="image-20220503225323069" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422978.png" alt="image-20220503224947088" style="zoom:33%;" /></p><p>训练bert的过程（做填空题），可以看作是从上下文抽取资讯。</p><p>李宏毅：这是你在文献上查到的，但事实真的如此吗？</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422055.png" alt="image-20220503230230967" style="zoom:33%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422000.png" alt="image-20220503230342292" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422319.png" alt="image-20220503230416919" style="zoom:33%;" /></p><p>硬train一发，结果依然相当好，这告诉我们它的效果好可能不仅仅是因为“看得懂文章”，甚至可能bert本身就是比较好的初始化参数，适合做这些研究。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422598.png" alt="image-20220503230603016" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422918.png" alt="image-20220503230652396" style="zoom:33%;" /></p><p>👆可以用多种语言来train                              这个work用多语言pretrain，英文微调，直接上中文正确率依然有78.8%。</p><p>MRR衡量不同语言 同样意思的词汇接近程度。高代表模型能学到不同语言同样意思的符号。</p><p>还有李老师的经历：数据够多才出现了这样的现象，后来加多资料量成功了👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422267.png" alt="image-20220503231110098" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422038.png" alt="image-20220503231414394" style="zoom:33%;" /></p><p>但是肯定有语言的咨询，不然英文填空蹦几个中文不是逆天？那么，语言的咨询藏在哪？</p><p>卧槽，英文输入加上平均距离的差，multi-bert模型以为你输入的是对应的中文！所以语言资讯也藏在multi-bert里面</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422865.png" alt="image-20220503231706629" style="zoom:33%;" /><hr><p><strong>GPT</strong></p><p>BERT做的事填空题，GPT做的是预测题，给他之前出现的，让他预测下一个出现的词是什么。很像transformer的decoder部分。可以把一句话补完，这一个小GPT例子：<a href="https://app.inferkit.com/demo">https://app.inferkit.com/demo</a></p><p>怎么use gpt呢，GPT可能太大了，fine-tune都有困难。</p><p>这个想法👇太nb了，但是目前看起来并没有做到太好</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423212.png" alt="image-20220504093535457" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423993.png" alt="image-20220504093559640" style="zoom:33%;" /></p><h3 id="语言预训练模型近年进展"><a href="#语言预训练模型近年进展" class="headerlink" title="语言预训练模型近年进展"></a>语言预训练模型近年进展</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CV&quot;&gt;&lt;a href=&quot;#CV&quot; class=&quot;headerlink&quot; title=&quot;CV&quot;&gt;&lt;/a&gt;CV&lt;/h2&gt;&lt;h3 id=&quot;Spatial-Transformer&quot;&gt;&lt;a href=&quot;#Spatial-Transformer&quot; class=&quot;header</summary>
      
    
    
    
    <category term="others" scheme="https://darren-dong.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>GRE教程</title>
    <link href="https://darren-dong.com/2022/02/22/GRE%20Note/"/>
    <id>https://darren-dong.com/2022/02/22/GRE%20Note/</id>
    <published>2022-02-22T06:08:16.000Z</published>
    <updated>2022-05-09T06:37:34.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>【最近趋势：考老题，】</p><p>雅思托福是保证基本语言能力。GRE考的是学术逻辑能力。</p><p>GRE是泛学科的，你可能遇到地理、生物。。一堆专业的东西，但是线索都会在文章给出，不需要专业知识。</p><p>1500+一考</p><p>GRE有单独的报名网站<a href="https://gre.neea.edu.cn/login.do">https://gre.neea.edu.cn/login.do</a> 每个月3场左右，要提前3-6个月抢考位。</p><p>现场考试，不能带文具，要带ID（身份证）和考试确认信。</p><p>考完后直接出分，但可以在看到成绩前选择是否保留，写作得7-10天后。可填写4个免费送分的机会。不然送分得通过ETS</p><p>搜索写作评分标准：gre+issue/argument+scoring+guide</p><p>语文数学都不答都有130分。</p><p>第二个section难度由第一个section正确率决定。</p><p>==大概数值==：</p><ul><li>对0-6个，进入easy模式，分数范围130-151</li><li>对7-12个，medium，143-161（161对语文已经算高分）</li><li>hard，151-170分</li></ul><p>325是一个节点分数，各种要求基本都能过了：数学考满分。。语文两个section错少于8个。</p><p>GRE基于section适应而不是题目，所以我们要放弃难题，保简单中等题</p><p>考多少分够用：</p><p>GRE不是选拔考试，而是基础水平测试，所以只要过了要求的线就行，所以高分并没有太大优势</p><p>备考策略：</p><ul><li>对英语水平、阅读是有要求的。<strong>雅思阅读7.5</strong>。即使先GRE，也得保证阅读</li><li>一个月，理论课+集中背单词 -&gt; 报了2个月后的GRE（开始冲刺到考试间1.5-2个月，而且考试和学习不能有间隔）</li><li>这俩月冲刺，每天3-4小时 x 60天 = 200小时。最后要上机模考练手感，<a href="https://gre.vip/home">广告</a></li><li>语文部分：多刷题，做正确的题【高高频和新新~其实就是浓缩的300和1300，首考可以不用刷其他的。】刷题、听讲解、看解析、分析、改错、背词、提速。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227057.png" alt="image-20220326132849083" style="zoom:50%;" /></li><li>数学部分：逐渐变难，完整学习官方的GRE数学部分，然后就开始刷题就好了。</li><li>写作部分：理科目标就是3.5，黑书不错（不需要花太多力气）</li></ul><hr><p><strong>背单词</strong></p><p>核心词差不多1w上下，包括小学学过的词，但是每次GRE都会冒出从没见过的词（不影响大局）</p><p><u>雅思的词汇也是需要的</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227059.png" alt="image-20220326120028964" style="zoom:50%;" /><p>:star: 前五遍，只看基本含义，其他都不管，是敲门砖；在做题的过程中补上其他的，理解这个词。</p><p>刷词，一个单词5-10s，一天重复一个list 2-3遍</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091233914.png" alt="image-20220326120732517" style="zoom:50%;" /><p>然后就开始备考的下一步。千万不要在这一刻打断，不然单词很容易直接忘掉（是个好问题。）</p><hr><h3 id="学科"><a href="#学科" class="headerlink" title="学科"></a>学科</h3><p>分析性写作（AW）、语文推理（verbal）、数学推理（Quant）</p><p>六个部分（写作，然后语文数学随机2，3）多了一个叫experimental加试，你不知道哪个是加试。</p><p>考试时间4个小时，考验体力。</p><h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h4><p>两篇（30mins*2）：总分六分，中国平均分3.1，全球3.6，大家不怎么投入写作。</p><p>GRE写作的分数不计入总分、很多高校并没有要求。所以只要达到比平均分高一些就行。</p><p>【500字】Issue议论文，命题写作，更有学术深度，深度思考。。</p><p>【450字】Argument 论证，先给阅读短文（论证某个观点），要求考生找出逻辑漏洞，按要求评价。</p><p>资料：</p><p>题库：搜索：gre issue/argument topic pool可以直接找到 <strong>官方题库</strong>。，。。</p><p>写作提纲：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227061.png" alt="image-20220326125920758" style="zoom:50%;" /></p><h4 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h4><p>均分148/170，不占优势，时间特别紧张，得训练速度，做完题目就是高手。</p><p>每个section 30分钟，填空题x10，阅读题x10<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227062.png" alt="image-20220326112554438" style="zoom:33%;" /></p><p>填空都是选择，不考语法、搭配、时态、词性，只考依据已知推理未知。</p><p>阅读（短、中、长）文章：每个verbel👇，题型和之前的类似，但是各种难度高。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227063.png" alt="image-20220326112818211" style="zoom:33%;" align = 'left'/><p>先学理论知识，然后开刷题。</p><p><strong>真题是唯一需要的备考材料</strong>，非官方风格差异很大，还有所谓的题库，机经。</p><p>黑名单：橙色的和蓝色的那两本24套和36套。。。真题已经足够多了，练真题完全够。</p><p>白名单：阅读机经300篇，填空机经1300题，这都是2015-2019的真题，【后面又说要那两个高高频】</p><p>套题：官方正式发布的GRE官方指南（4套题）、2套模考仿真系统 PP0（2免费，3收费）但题目太老，而且题库不共享</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227064.png" alt="image-20220326124353853" style="zoom:50%;" /><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>均分164.7/170</p><p>一个section 20个题目，选择&amp;填空。</p><p>比较大小题，计算题，图表题，应用题。</p><p>满分不容易拿，题干比较长可能理解错，有部分题虽然仍是高中知识，但是思维特别绕。</p><p>资料：Official GRE Quant 这个先用来学习理论，冲刺的话真题里面的数学部分就够了，学习成效通过模考的题来看效果就行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;常识&quot;&gt;&lt;a href=&quot;#常识&quot; class=&quot;headerlink&quot; title=&quot;常识&quot;&gt;&lt;/a&gt;常识&lt;/h3&gt;&lt;p&gt;【最近趋势：考老题，】&lt;/p&gt;
&lt;p&gt;雅思托福是保证基本语言能力。GRE考的是学术逻辑能力。&lt;/p&gt;
&lt;p&gt;GRE是泛学科的，你可能遇到地理</summary>
      
    
    
    
    <category term="others" scheme="https://darren-dong.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>李沐-实用机器学习</title>
    <link href="https://darren-dong.com/2022/02/13/%E6%9D%8E%E6%B2%902/"/>
    <id>https://darren-dong.com/2022/02/13/%E6%9D%8E%E6%B2%902/</id>
    <published>2022-02-13T03:08:21.000Z</published>
    <updated>2022-05-09T05:03:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>实用机器学习——课程：【20课时】关注DS的方方面面，很实际</p><p><strong>Coentents</strong></p><p>Machine Learning topics that matter but are often skipped </p><p>• Data: collection, preprocessing, features, dataset shift, non-iid. data （非独立同分布）</p><p>• Model training: model selection, model tuning, transfer learning, distillation, multimodality, scalability </p><p>• Deployment: efficiency, serving, fairness </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251740.png" alt="image-20220413110451857" style="zoom:50%;" /><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251369.png" alt="image-20220226223318983" style="zoom:50%;" /><p>可以先训练简单的模型，比如五六十年的线性回归，用来测试数据的好坏！部署不是结束，这是个不断迭代的过程。</p><p>算法本身不会不公，但数据会有偏差。蒸馏是指，将模型提炼出易于部署的，较小较快的数据。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251960.png" alt="image-20220226222409869" style="zoom:50%;" /><p>首先要关注自己公司的核心业务，把他做好，可能运气好会碰到简单问题，但也可能是无人车之类的复杂问题：</p><p>我们不缺数据，但是非常缺高质量的数据。最近七八年，模型的复杂度呈指数增长，越来越贵，越需要越来越多的数据。</p><p>当前一些行业中ML的应用：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251870.png" alt="image-20220421172359529" style="zoom: 33%;" /><p>场景分工：沐神说现在行业还很缺data scientists，这门课<u>主要关注的就是Data science</u>         职业规划👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251545.png" alt="image-20220226223531813" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303386.png" alt="image-20220226224149527" style="zoom:50%;" /></p><p>领域专家还要提出建议，将机器学习用在合适的地方，因为这是一件很贵的事情。</p><p>SDE有很多活要干，包括管理计算资源，能够有序的训练模型整个集群并加以管理（什么定时训练，还有负载均衡），pipeline，还有可能部署很多不同版本的新老模型、实验模型，异常模型上线、下线。</p><p>==数据科学家==有一点“全栈的味道”，什么都要干，看上图右边，<u>获取、clean、可视化、选择、训练、部署。</u>【区别大数据开发者】</p><p>ML专家根据业务对模型的要求，专门<u>定制化</u>、优化模型，包括很多模型的预训练数据都是学术上的数据集，要做出对应修改，还有比如蒸馏数据模型以使得模型的规模符合要求。 还可能负责领域研究，写论文</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251239.png" alt="image-20220226225522815" style="zoom:60;" /><p>data的协变量、概念、标签都会发生变化，而且还有许多不是假设中独立同分布的情况。</p><p>训练会讲模型怎么做验证，怎么做融合，调超参数。还有最近兴起的：从不同数据源获得type(文本、图片)的数据糅合起来做个大模型</p><p>部署，蒸馏       监控，公平性，可解释性（理解模型在干什么）</p><h3 id="数据获取-1"><a href="#数据获取-1" class="headerlink" title="数据获取"></a>数据获取</h3><p>当你成功把业务定义为ML问题后，第一步就是看你有没有足够多的数据，这部分是讲没有的：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251994.png" alt="image-20220301221924554" style="zoom:50%;" /><ul><li>如果你有办法找到数据，那就找数据，然后融合你有的数据</li><li>否则就看你有没有数据生成的办法来生成数据了</li></ul><p><strong>Discover</strong></p><p>根据不同的用途，你要找的数据也不一样，数据集 $\neq$ 数据，<u>做产品很可能没有数据集用，就需要自己收集</u>，要注意的是收集的数据能够覆盖到场景的方方面面</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251022.png" alt="image-20220421212533126" style="zoom:33%;" /><p><em>数据集</em></p><p>• MNIST: digits written by employees of the US Census Bureau   【有个叫Fashion-Mnist的】<br>• ImageNet: millions of images from image search engines<br>• AudioSet: YouTube sound clips for sound classification<br>• LibriSpeech: 1000 hours of English speech from audiobook<br>• Kinetics: YouTube videos clips for human actions classification<br>• KITTI:  traffic scenarios recorded by cameras and other sensors<br>• Amazon Review: customer reviews and from Amazon online shopping<br>• SQuAD: question-answer pairs derived from Wikipedia<br>More at <a href="https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research">https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research</a></p><p><em>Find Datasets</em><br>• <a href="https://paperswithcode.com/datasets">Paperswithcodes Datasets</a>: academic datasets with leaderboard 常用学术界的数据集都有，而且可以看到各论文在DS上精度<br>• <a href="https://www.kaggle.com/datasets">Kaggle Datasets</a>: ML datasets uploaded by data scientists 非常多，层次不齐（用户可上传）<br>• Google Dataset search: search datasets in the Web 搜索引擎<br>• Various toolkits datasets: tensorflow, <a href="https://huggingface.co/">huggingface</a>  工具自带的，比如torch的  hugging face专注文本的transformers<br>• Various conference/company ML competitions  一般竞赛数据集质量高，而且应用比较新。（还有奖金）<br>• <a href="https://registry.opendata.aws/">Open Data on AWS</a>: 100+ large-scale raw data 非常大，P级别<br>• Data lakes in your own organization 公司的数据堆砌</p><p><em>三种数据集</em>：<u>学术、竞赛、原始（处理后可能只剩下一丢丢）</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251020.png" alt="image-20220301222959267" style="zoom:80%;" /><p>Data integration——数据库的tabel join 过程，合并许多表到同一。 缺失数据处理、去掉语义重复值。</p><p>Data curation can be a big projection involving multiple teams.——<u>Processing pipeline, storage, legal issue, privacy</u></p><p>GAN生成、图像增强、文本来回翻译哈哈</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251880.png" alt="image-20220301224146209" style="zoom:60%;" /><p>工业上的产品就不要过于看重经典学术数据集的效果，还是得看实际。</p><h3 id="网页抓取"><a href="#网页抓取" class="headerlink" title="网页抓取"></a>网页抓取</h3><p>$\neq$ 爬取</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251778.png" alt="image-20220421220019350" style="zoom: 55%;" /><p>我们只关心网页里面的某些数据，爬是指感兴趣的网页都整个弄下来存好，抓取是只提取感兴趣的，可能变成table。</p><p>尽量假装成真人，整的跟攻防一样。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252742.png" alt="image-20220421220507073" style="zoom: 50%;" /><p>整下页面，页面解析，例子：</p><p>获得id列表后，依次替换url的部分内容，遍历访问一堆房子页面，要自己去看网页结构，找到信息在哪。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252871.png" alt="image-20220421221305792" style="zoom:42%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303819.png" alt="image-20220421221529017" style="zoom:41%;" /></p><p>属于是重复劳动力，有一些自动化工具做。</p><p><strong>成本</strong></p><p>用云主要有点需求的是内存，开几个chrome挺耗内存的（2G差不多够用），CPU和网络带宽最低级就好，基本用不满的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252267.png" alt="image-20220421221943375" style="zoom:50%;" /><p>被banned了，重启机器可以得到一个新的IP，然后继续爬。</p><p>除了文本，图片也是需要的，之前提到的multi-modality，就能利用多维数据【成本翻了很多倍】</p><p>基本思路：通过正则表达式获得所有id，然后构建url列表，随后遍历抓取。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252431.png" alt="image-20220421222348354" style="zoom:50%;" /><p>主要开销在存储（如果存云端），你可以减少图片尺寸或慢慢传回来，后续会介绍其他方法。</p><p><em>法律考虑</em></p><p>爬取行为本身不犯法，但是要注意版权、敏感隐私信息什么的，把有版权的数据存在本地是违法的。（还有robots）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252987.png" alt="image-20220421222841067" style="zoom:50%;" /><p>尤其是如果你爬取不是个人做分析，而是用于公司盈利，可以咨询公司的法律部门和律师。</p><p>如果按照沐神刚才说的一堆云实例来爬，100G 1个T可能也就几十块钱。</p><h3 id="数据标注"><a href="#数据标注" class="headerlink" title="数据标注"></a>数据标注</h3><p>当你有了足够数据后，你有几个选项，提高标注、数据或模型，本节讲标注。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252295.png" alt="image-20220421223410458" style="zoom:50%;" /><p>又没钱标注又不够，就得用弱监督学习 weak supervision。</p><p><em>半监督学习</em></p><p>第三个流形假设，可能数据具有内在结构，复杂性只分布在几个维度，远远比你看到的要低。</p><p>scenario 设想</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252969.png" alt="image-20220421224045273" style="zoom:50%;" /><p>自-训练——SSL的一种实现方法</p><p>由于不用线上部署，可以在本地选择模型复杂度更高，更贵的模型进行训练【deeper、ensemble】【不计成本、只要精度】。</p><p>当然，在右边“keep highly confident predictions”这就能整出各种算法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252510.png" alt="image-20220421224340822" style="zoom:50%;" /><p><em>众包</em>——有钱人的选择</p><p>现在作为愈加广泛的选择，座的人越来越多了，成本也越来越低，【真的有数据标注村这种东西吗】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252595.png" alt="image-20220421224939559" style="zoom:50%;" /><p>减少任务复杂度，能更容易找到更多的人做，价格也更便宜。</p><p>因为是人做的，质量会参差不齐，你得来<u>做质量控制</u>，或者找公司。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252398.png" alt="image-20220421225201094" style="zoom:50%;" /><p>标注公司会帮你设计好这些，但是得加钱~</p><p><em>主动学习</em></p><p>结合了半监督学习的假设（少量已标号）和众包，最大化利用人的帮助。训练出模型，吐出不确定的，再训练新的，不断迭代。</p><p>同样可以选择比较贵的模型，比如练多个模型投票</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252033.png" alt="image-20220421225918237" style="zoom: 50%;" /><p><em>混用</em></p><p>高级啊</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252521.png" alt="image-20220421230654050" style="zoom:50%;" /><p>质量控制</p><p>挺麻烦的事，因为不是找的真正专家来做，有可能故意，有可能你的任务他没看懂，反正可能性很多。还有标的不好的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252166.png" alt="image-20220422155044880" style="zoom:50%;" /><p>还有对标注工进行评估，筛掉部分。</p><p><em>Weak Supervision</em></p><p>半自动生成标号，比人标的差一点，但是还不错，够训练模型。</p><p>启发式学习，通过数据编程，把你对数据的认知转换为一些限制，然后</p><p>还有使用各大公司AI产品标号，然后聚合</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="探索性数据分析"><a href="#探索性数据分析" class="headerlink" title="探索性数据分析"></a>探索性数据分析</h3><p>只做了一小些分析，类似EDA，一般做完以后有很多块，可以share 给大家</p><p>本节slide：<a href="https://c.d2l.ai/stanford-cs329p/_static/notebooks/cs329p_notebook_eda.slides.html#/2">https://c.d2l.ai/stanford-cs329p/_static/notebooks/cs329p_notebook_eda.slides.html#/2</a></p><p>notebook:<a href="https://colab.research.google.com/drive/1zzuFXZQ0djOLZOzdQ4GNlZO-dZjdgTsv#scrollTo=ol9CO2GAzZnN">https://colab.research.google.com/drive/1zzuFXZQ0djOLZOzdQ4GNlZO-dZjdgTsv#scrollTo=ol9CO2GAzZnN</a></p><p>pandas基本是首选，数据要是几百G可选用别的框架更快，也可采样以后用pandas</p><p>matplotlib和十几年前matlab的用法比较像，seaborn在此基础上提供了更多的画法</p><p>svg分辨率高一点，不然默认分辨率属实是有点低。</p><p>推荐：<u>文本默认存成一个zip压缩文件</u>，现代工具可以直接读取使用：<code>data = pd.read_csv(&#39;house_sales.zip&#39;)</code><br>当然图片这种就没什么用，已经做了很好的压缩。使用<a href="https://arrow.apache.org/docs/python/feather.html"><code>feather</code>格式</a>，它比 CSV 读取速度更快，但使用更多磁盘空间。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'house_sales.zip'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'unicode'</span><span class="token punctuation">)</span>data<span class="token punctuation">.</span>to_feather<span class="token punctuation">(</span><span class="token string">'house_sales.ftr'</span><span class="token punctuation">)</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_feather<span class="token punctuation">(</span><span class="token string">'house_sales.ftr'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>data.drop(....,inplace = True)</code> 如果只用跑一次，直接操作内存可以省点内存。（只能跑一次xs）</p><p>要check它的数据的types，一般object就是pandas识别不了，或者不能转过去的类型，<u>数据类型转换也是清洗的一部分。</u></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#把代码列在这。</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'house_sales.zip'</span><span class="token punctuation">)</span>data<span class="token punctuation">.</span>shapedata<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#保留缺失值小于30%的列</span>null_sum <span class="token operator">=</span> data<span class="token punctuation">.</span>isnull<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>columns<span class="token operator">=</span>data<span class="token punctuation">.</span>columns<span class="token punctuation">[</span>null_sum <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>data<span class="token punctuation">.</span>dtypes<span class="token comment">#清理金钱列表，转成float类型，pandas的place自带正则表达式实现</span>currency <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> <span class="token string">'Listed Price'</span><span class="token punctuation">,</span> <span class="token string">'Tax assessed value'</span><span class="token punctuation">,</span> <span class="token string">'Annual tax amount'</span><span class="token punctuation">]</span><span class="token keyword">for</span> c <span class="token keyword">in</span> currency<span class="token punctuation">:</span>    data<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span>        <span class="token string">r'[$,-]'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span>        <span class="token string">r'^\s*$'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token comment">#清洗占地面积列表，转成同一单位的float</span>areas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Total interior livable area'</span><span class="token punctuation">,</span> <span class="token string">'Lot size'</span><span class="token punctuation">]</span><span class="token keyword">for</span> c <span class="token keyword">in</span> areas<span class="token punctuation">:</span>    acres <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Acres'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span>  <span class="token comment">#check字符串</span>    col <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">r'\b sqft\b|\b Acres\b|\b,\b'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">)</span>    col<span class="token punctuation">[</span>acres<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">43560</span>    data<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> coldata<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#基本统计值，从中能看出数据的很多问题，比如看极值，然后看一下这些统计值符不符合正常逻辑。</span><span class="token comment">#通过筛选看看你认为异常的有多少。</span>abnormal <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>areas<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>areas<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1e4</span><span class="token punctuation">)</span>data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token operator">~</span>abnormal<span class="token punctuation">]</span><span class="token builtin">sum</span><span class="token punctuation">(</span>abnormal<span class="token punctuation">)</span><span class="token comment">#画个直方图看看分布，一般对价格取个log，画的图视觉效果好，不会太奇怪，因为钱分布差距很大</span><span class="token comment">#插一句，沐神说再几千-几万那有个小峰值，可能是把出租的数据误爬了。</span>ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>histplot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'%.0e'</span><span class="token operator">%</span>a <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token number">10</span><span class="token operator">**</span>ax<span class="token punctuation">.</span>get_xticks<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#看一下房子有多少种类，后面的基本都是噪音，要后续清理的，比如同一种但多个名字。</span>data<span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token comment">#画一个种类-价格的密度分布图（指定kind为‘kde’），然后可以看到房子的类别显然和价格是挂钩的</span>types <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isin<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'SingleFamily'</span><span class="token punctuation">,</span> <span class="token string">'Condo'</span><span class="token punctuation">,</span> <span class="token string">'MultiFamily'</span><span class="token punctuation">,</span> <span class="token string">'Townhouse'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>displot<span class="token punctuation">(</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'Sold Price'</span><span class="token punctuation">:</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          <span class="token string">'Type'</span><span class="token punctuation">:</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            x<span class="token operator">=</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">'Type'</span><span class="token punctuation">,</span> kind<span class="token operator">=</span><span class="token string">'kde'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#观察种类-房子均价的箱型图，这种方法能比较好的观察不同分布的对比。</span>data<span class="token punctuation">[</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span> <span class="token operator">/</span> data<span class="token punctuation">[</span><span class="token string">'Total interior livable area'</span><span class="token punctuation">]</span>ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Type'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">,</span> fliersize<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#相当于x = d['Type']</span>ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#同样，查看地域对房子均价的影响，通过邮政编码划分地域。</span>d <span class="token operator">=</span> data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">'Zip'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isin<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Zip'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Zip'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>d<span class="token punctuation">,</span> fliersize<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span>ax<span class="token punctuation">.</span>get_xticklabels<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#查看相关系数矩阵！！！</span>_<span class="token punctuation">,</span> ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> <span class="token string">'Listed Price'</span><span class="token punctuation">,</span> <span class="token string">'Annual tax amount'</span><span class="token punctuation">,</span> <span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> <span class="token string">'Elementary School Score'</span><span class="token punctuation">,</span> <span class="token string">'High School Score'</span><span class="token punctuation">]</span>sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>data<span class="token punctuation">[</span>columns<span class="token punctuation">]</span><span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>annot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>cmap<span class="token operator">=</span><span class="token string">'RdYlGn'</span><span class="token punctuation">,</span> ax<span class="token operator">=</span>ax<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>亲自实验的小补充：一定要设好图的范围，不然可能一片空白</p><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252945.png" alt="image-20220423130707454" style="zoom:50%;" /><p>如果数据不干净，讲座数据清理；如果数据比较干净，但是不是你想要的格式，叫做数据变换；如果都没问题，但是对于模型训练比较困难，那就做特征提取。</p><p><strong>数据的错误</strong></p><p>无可避免，比如异常值，缺失值，还有语义上错误的数据，一般机器学习模型都对脏数据有一定的抵抗性，但你的模型不可避免地有精度的下降，以及拟合到错误分布的后果：用错误的数据训练出模型，用户使用后给你带了错误的反馈，如此迭代，错误累积。</p><p>工业上的问题就是：你没法获得如同学术数据集那样纯净的数据，也就没有一个比较好的性能参照，<u>你不知道你清理了数据以后，到底会不会有很好的提升。</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252605.png" alt="image-20220423131611257" style="zoom:50%;" /><p>一般的错误有：</p><p><u>数值越界，违反规则，违反模式（语法）</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252650.png" alt="image-20220423132036498" style="zoom:50%;" /><p>不同<em>错误举例</em>：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252318.png" alt="image-20220423133128510" style="zoom:50%;" /><p>可以设计很多规则，如果不满足，要么编写fix的逻辑，要么直接去掉。</p><p>这是个迭代的过程，一边看数据，一边总结规则。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252818.png" alt="image-20220423140116217" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252538.png" alt="image-20220423140729952" style="zoom:50%;" /><p>这俩都是比较一般的迭代过程，基本不用手写，<u>有很多工具提供了不错的GUI界面，可以供使用。</u>沐神推荐：</p><p>OpenRefine——开源桌面应用程序，用于清除数据并将其转换为其他格式，该活动通常称为数据整理。</p><p>Trifacta Wrangler——专为分析师设计，用于探索、转换和丰富原始数据为干净和结构化的格式。</p><p>当然每个工具都有局限性，必要时组合多个工具进行清理。</p><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><p>变换指的是，变换成<u>机器学习算法能用</u>的合适的数据类型。</p><p>沐神：一般来说广义的数据变形基本可以包括数据预处理的所有步骤，当然我们这里关注狭义的，也就是👇：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253166.png" alt="image-20220424190917121" style="zoom:30%;" /><p><strong>实数值</strong></p><p>机器学习是<u>数值敏感的</u>，如果不经过数值范围的调整，很容易遇上梯度爆炸和消失的问题，而且在没有先验知识的条件下，数值之间的不均衡就好像赋予了一些不公平的权重。</p><p>Z-score的效果是很不错的。</p><p>Log也很好，而且log上面的加减还能等价原始数值的乘除（这相当于是关注百分比的关系而不是绝对值得关系），当<u>更关注误差的相对值而不是绝对值时</u>尤其有用（比如money，之前那个房价问题），通常用于<u>比较大而且分布较广的正数</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253896.png" alt="image-20220424191805125" style="zoom: 33%;" /><p><strong>图片数据</strong></p><p>机器学习其实对低分辨率的图片做的还是挺好的（毕竟不像人是看个全局，ML都是一个一个像素看的），所以resize成比较小的尺寸，或者把中间的一块抠出来（知道边上是背景）这种既能节省存储空间，又能快速读取的方法是十分可取的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253145.png" alt="image-20220424192340770" style="zoom:33%;" /><p>前辈们通过教训明白，下采样确实会带来精度的下降（顺便提醒了我们一番debug的艰难），所以得权衡。</p><p>image whitening：图片中很多的像素取值没什么用，可以通过降维的方法，减小像素取值</p><p>图片放在一个一个文件里读的自然慢，如果都放在一个文件里然后指定特殊的格式那肯定就会快一些</p><p><strong>视频</strong></p><p>一般都是截取视频中你感兴趣的片段进行存储、训练。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253714.png" alt="image-20220424193234240" style="zoom:33%;" /><p>权衡：视频提供比图片好很多的压缩，但是代价是读取效率（包括解码以及视频算法常用的采样）就会变得很低。</p><p><strong>文本</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253647.png" alt="image-20220424194926716" style="zoom:50%;" /><p>lemmatization——词形还原，上图中系动词的代换是语法化，后面车那个是词根化。</p><p>词元化：词、字符、还有最近新起的子词（subwords）<u>子词可以用来处理很大的数据集</u>，生成一个相对较小的字典处理许多生僻词。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253656.png" alt="image-20220424195537957" style="zoom:50%;" /><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253534.png" alt="image-20220424205427062" style="zoom:33%;" /><p>深度学习其实没有改变大的流程，而是用不同结构的神经网络（按照需求设计，比如transformer）来替换掉人工抽取这个过程。</p><p>所以特征抽取和最后的线性层（模型）是一起学习的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253996.png" alt="image-20220424210005444" style="zoom:33%;" /><p>你的特征要让机器知道说有区分度，比如天按照工作日和周末区分就会知道人的表现会很不一样，但要是拿星期几来区分就徒增难度</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253433.png" alt="image-20220424210646289" style="zoom: 33%;" /><p>图片现在已经基本用不到手动，都用预训练的深度学习模型来整了</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253646.png" alt="image-20220424210906363" style="zoom:33%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你获取不了数据，而且生成都困难，那可能说明你这个问题不那么适合机器学习，因此就不要挣扎啦。长期迭代👇：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303755.png" alt="image-20220424211355145" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254431.png" alt="image-20220424211551417" style="zoom:33%;" /></p><p>但是这个滚雪球的过程你要随时监控做得够不够好，有没有走弯路。后续会讲</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254589.png" alt="image-20220424212649984" style="zoom:40%;" /><p>数据也要做版本处理，不仅仅是模型，数据也要做到版本回滚之类的操作。</p><p>还有数据的安全、用户的隐私这些东西，都在数据科学家的考虑范畴指内。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>自监督学习，标号是直接从数据里面生成的。比如word2vec、BERT</p><p>监督学习中的 Pretrain - Finetune 流程：我们首先从大量的<strong>有标签数据</strong>上进行训练，得到预训练的模型，然后对于新的下游任务（Downstream task），我们将学习到的参数进行迁移，在新的有标签任务上进行「微调」，从而得到一个能适应新任务的网络。</p><p>自监督的 Pretrain - Finetune 流程：首先从大量的<strong>无标签数据</strong>中通过 pretext 来训练网络，得到预训练的模型，然后对于新的下游任务，和监督学习一样，迁移学习到的参数后微调即可。所以自监督学习的能力主要由下游任务的性能来体现。</p><p>监督学习目前还是<u>工业界最主流的任务</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254700.png" alt="image-20220429210745479" style="zoom: 50%;" /><p>目前主要的监督学习分类</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254116.png" alt="image-20220429210819491" style="zoom:50%;" /><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>工业界可能用的最多的，而且结果还不错，不太需要调参，一般是第一选择，给你个对任务的直觉。</p><p>由于<strong>可解释</strong>，比较敏感的行业比如保险、银行业大量使用，经常需要解释。</p><p>模型非常不稳定，容易收到数据噪声的影响。过拟合（可用剪枝），从上到下判断，难以并行，性能低。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254774.png" alt="image-20220429211026515" style="zoom:50%;" /><p>提高稳定性👇</p><p>随机森林<u>一定要随机</u>，两种随机性：bagging（样本）、特征</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254725.png" alt="image-20220429211416307" style="zoom:50%;" /><p>boosting，有很多种，这里讲的是gradient的boosting</p><p>和recnet思想十分类似，<u>顺序而不是独立的</u>训练新的树来弥补差距。因此随机森林是投票或平均，这里是求和。</p><p>之所以叫gradient。。。是因为计算的残差相当于是对均方根误差不断做梯度下降。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254276.png" alt="image-20220429211924053" style="zoom:50%;" /><p><strong>线性模型</strong></p><p>之所以损失函数不用MSE用softmax+交叉熵，是因为MSE还要求你不正确的类的mse缩到够小，增加了额外的学习成本，而不是像softmax一样，只关心概率最大的类是正确的类就行。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>本节指的是<u>衡量最终已经训练好后的模型的好坏</u>，只跟你的超参数和采样的数据有关</p><p>我们要选用好一点的数据采样方法和好一点的超参数使模型泛化性更强。</p><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>一个模型的评估往往要通过<u>多个指标</u>来实现，而不是仅仅一个最简单的loss函数来实现。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254991.png" alt="image-20220429213940376" style="zoom:50%;" /><p>看一个例子：展现广告</p><p>虽然这是支持很多互联网公司的一个重要业务，但其实也就是个二分类问题。【愿意/不愿意点击】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254069.png" alt="image-20220429214200538" style="zoom:50%;" /><p>常见的用于分类问题的指标：accuracy、precision、recall、F1</p><p>• Accuracy: # correct predictions / # examples </p><p>• Precision: # True positive / # (True positive + False positive) </p><p>• Recall: # True positive / # Positive examples • Be careful of division by 0 </p><p>• F1: the harmonic mean of precision and recall: 2pr/(p + r）</p><p>很多时候广告更关心的是区分度，优化用户体验，什么的，广告领域常用的指标有个叫做AUC、ROC，如下图：</p><p>0.5是完全随即预测，0是完全预测反了，1是理论最好的情况。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254011.png" alt="image-20220504125406464" style="zoom: 67%;" /><p>当然还有很多商业上的指标：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254207.png" alt="image-20220504125851514" style="zoom:50%;" /><p>权衡：</p><p>对于一个模型，我们最关注的就是AUC，但是如果我们一味的提升AUC，就会harm很多商业指标。</p><p>没有什么太好的方法，最好还是你训练出一个模型，<u>实际部署到线上</u>关注一下你这些商业指标的变化。达标上线，不行就继续换模型</p><p>所以很多时候，不能光看论文、课程里提到的模型的指标，还得去关注商业指标。</p><p><strong>模型验证</strong></p><p>通常我们会用一个测试数据集上测量的误差近似模型的泛化误差。</p><p>我的评价是，不如吴恩达。。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254108.png" alt="image-20220504132529912" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303253.png" alt="image-20220504132705858" style="zoom: 47%;" /></p><h3 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h3><p><strong>Bagging</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254358.png" alt="image-20220504162802062" style="zoom:67%;" /><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bagging</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base_learner<span class="token punctuation">,</span> n_learners<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>learners <span class="token operator">=</span> <span class="token punctuation">[</span>clone<span class="token punctuation">(</span>base_learner<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_learners<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">:</span> examples <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> learner<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>examples<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>examples<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span> preds <span class="token operator">=</span> <span class="token punctuation">[</span>learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">]</span> <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用决策树做base-learner，那就是随机森林，里面还有个随机采样特征，此处未实现。</p><p>主要降低方差而不是偏差，改善了不稳定性，如果模型比较stable，基本没啥效果。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254392.png" alt="image-20220504164151123" style="zoom: 50%;" /><p>决策树就很适合bagging</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254771.png" alt="image-20220504164433511" style="zoom:50%;" /><p><strong>Boosting</strong></p><p>这个是降低偏差用的</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255819.png" alt="image-20220504165045510" style="zoom:67%;" /><p>就是在当前基础上，把训练不好的地方再拿出来，训练一个新的模型把它做好点，然后一直迭代下去。</p><p>AdaBoost是一个十分经典的，理论上也十分透彻的一个算法。 【李航的书上面有】</p><p>这里和之前那章讲的一样，还是gradient boosting</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255390.png" alt="image-20220504191402770" style="zoom:50%;" /><p>学习率如果调成1，非常容易过拟合。其实，学习一个$h_t$就是去拟合当前负梯度的方向，跟梯度下降基本是一样的。</p><p>当然此处用的是做回归的时候MSE的loss，其他问题的loss会不一样，理解意思就好。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">GradientBoosting</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base_learner<span class="token punctuation">,</span> n_learners<span class="token punctuation">,</span> learning_rate<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>learners <span class="token operator">=</span> <span class="token punctuation">[</span>clone<span class="token punctuation">(</span>base_learner<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_learners<span class="token punctuation">)</span><span class="token punctuation">]</span> self<span class="token punctuation">.</span>lr <span class="token operator">=</span> learning_rate <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> residual <span class="token operator">=</span> y<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">:</span> learner<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> residual<span class="token punctuation">)</span> residual <span class="token operator">-=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span> preds <span class="token operator">=</span> <span class="token punctuation">[</span>learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">]</span> <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来这代码还挺简单的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255322.png" alt="image-20220504193143230" style="zoom: 67%;" /><p>决策树算不得一个“弱模型”，但你可以限制最大深度，或者采样一些列来手动削弱它【让过拟合不那么严重】。</p><p>可以看到（左图）并没有过拟合（模型比较弱），随着n的增加，偏差在下降。当然学习率也要调好，不能太高。</p><p>但是毕竟是顺序训练，比较吃亏。大家都用的是：XGBoost或lightGBM，<u>算的快一点</u>。</p><p><strong>Stacking</strong></p><p>刷榜利器</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255643.png" alt="image-20220505090253634" style="zoom:33%;" /><p>bagging采样不同的数据训练同样的模型；stacking用同样的数据训练不同的模型</p><p>根据模型的不一样，特征提取可能有不同的选择。</p><p>如果某个模型加进来不能提升精度，或者特别贵，那就可能不考虑加咯。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255956.png" alt="image-20220505091117905" style="zoom:33%;" /><p>本来主要降低方差，引入多层以降低偏差。多层的stacking非常容易过拟合，相当于同一份数据训练多次。</p><p>需要很多手段避免过拟合：</p><p>如果每层用一部分数据，这样有点亏，也可以k折</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255011.png" alt="image-20220505091352416" style="zoom:33%;" /><p>由于每个模型都在没有参与训练的$1/k$数据上预测，然后把结果交给下一层，减缓了过拟合。但是还有一定程度。</p><p>更昂贵的降低过拟合：重复1，2步骤n次，每次把验证集的输出并成大小一致的数据集，取平均。。。进一步降低偏差。</p><p>每个小模型训练$k*n$次</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> autogluon<span class="token punctuation">.</span>tabular <span class="token keyword">import</span> TabularPredictorpredictor <span class="token operator">=</span> TabularPredictor<span class="token punctuation">(</span>label<span class="token operator">=</span>label<span class="token punctuation">)</span><span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train<span class="token punctuation">,</span> num_stack_levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> num_bag_folds<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255396.png" alt="image-20220505092637454" style="zoom:50%;" /><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>benchmark选择高质量工具包的初始参数，或者论文里的参数，当然论文里的参数一般绑定了某个数据集，但是有时候通用性不错。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255688.png" alt="image-20220505094121711" style="zoom:33%;" /><p>记得李宏毅的优化：Adam对超参数不那么敏感，容易调一些；SGD对超参数敏感，难调，但是调好了效果更好。</p><p>管理好你的调参日志：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255872.png" alt="image-20220505094723790" style="zoom:33%;" /><p>TensorBoard   和   weights&amp;bias 比较好的工具</p><p>环境：xs，李沐吐槽python很多库只管加兼容性，不考虑旧代码的可维护性，python本身也是如此。</p><p>代码、随机种子：如果随机性给你的结果抖动比较大，那可能出了问题，可能是数据、dropout、某些库带来的随机性。【可以ensembling、bagging】</p><p>总的来说复现实验也是很麻烦的事情</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255507.png" alt="image-20220505095939754" style="zoom:33%;" /><p>自动调参，可能比人来调参的成本低。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255654.png" alt="image-20220505100036409" style="zoom:33%;" /><p>超参数优化(HPO)、神经网络架构搜索(NAS)</p><h3 id="HPO"><a href="#HPO" class="headerlink" title="HPO"></a>HPO</h3><p>搜索空间</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255493.png" alt="image-20220505145604934" style="zoom:33%;" /><p>每加一个参数的几个选项，昂贵程度指数上涨。但也不能太小，不然搜的结果不行。</p><p>因此你要<u>根据经验选择比较合适的初始区间。</u></p><p>• HPO algorithms: Black-box or Multi-fidelity </p><p>​    • Black-box: treats a training job as a black-box in HPO: • Completes the training process for each trial </p><p>• Multi-fidelity: modifies the training job to speed up the search </p><p>​    • Train on subsampled datasets<br>​    • Reduce model size (e.g less #layers, #channels)<br>​    • Stop bad configuration earlier </p><p>关心的是超参数之间的重要程度排序，这个时候并不是在选具体参数数值，只要排序就好了</p><p>如果你不知道任务细节，而且任务不太大，也能用黑盒来算。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255301.png" alt="image-20220505150850833" style="zoom:40%;" /><p>模拟退火和遗传可见《最优化导论》</p><p><em>Grid Search</em>：穷举搜索，有可能顺序没选好，训半天提升不大，最后猛涨。</p><p><em>Random Search</em>：随机搜索，非常有效，没甚么idea就用这个，一般是用完现有资源，比如有两台机子，能跑一晚上，就先跑完看结果；或者看目前最好的结果，如果一段时间都没有变化，或变化不大就可以停了，因为是随机算法，后续再暴涨概率不大。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>config <span class="token operator">=</span> random_select<span class="token punctuation">(</span>search_space<span class="token punctuation">)</span>     train_and_eval<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token keyword">return</span> best_result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>贝叶斯优化</em>，目前还在快速发展，暂时用的不多。</p><p>如下图例子：横轴是搜索空间，纵轴是目标函数。怎么感觉插值能用在这</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255809.png" alt="image-20220505152522581" style="zoom:33%;" /><p>获取函数会选取：不那么置信而且预测效果可能比较好的点作为下个采样点。</p><p><u>权衡探索和开发</u>，找新的最优点，或在已有比较好的点附近看一看；其实很多ML算法(特别是迭代式的)都是这两者的权衡。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256902.png" alt="image-20220505154104922" style="zoom:33%;" /><p>刚开始接近随机搜索，而且这个过程是串行的，随即搜索是并行的。</p><p>现实生活中，大家还是用的随即搜索多一点。</p><p><em>Successive Halving</em>（连续减半）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256812.png" alt="image-20220507194327650" style="zoom: 67%;" /><p>通常n取大一点，比如100；m取小一点，比如1或2.</p><p>把更多的资源分配给更有潜力的！但是问题是n和m不太好取！</p><p><em>Hyperband</em></p><p>真正的在实际中<u>用得比较多的算法</u>，可以尝试！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256414.png" alt="image-20220507194623483" style="zoom:67%;" /><p>这样子，对n和m的取值就不那么敏感。</p><p>还有更多的其他思路的Multi-fidelity HPO。</p><p><u>总有一些超参数，不管放到哪里结果都不错</u>，可以去kaggle看比赛第一第二、或者论文里的超参数，都是你抄我我抄你。<br>如果你能找到，那超参数其实是一件很简单的事情！</p><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><p>Neural Architecture Search</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256767.png" alt="image-20220507200000893" style="zoom:67%;" /><p>最开始的work使用RL来整的，RL炼起来虽然强大，但是巨贵。</p><p>后面有一些工作来加速，后来有个工作叫做one-shot，是一种方法</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256997.png" alt="image-20220507200430990" style="zoom:50%;" /><p>通过学习，决定哪条路比较好，有点注意力机制的味道👇，后续还有很多工作进行改进。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256785.png" alt="image-20220507200703733" style="zoom: 67%;" /><p>Efficient Net的思想是，调结构不要一个一个调，要一起联动着调。比如之前说的，网络变深，通道就变长。</p><p>最终只用调整一个参数，也就是下文的$\phi$（与模型复杂度有关）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256012.png" alt="image-20220507201054729" style="zoom:50%;" /><p>最终结果很棒，这是大家发现的一个<u>简单但是实用</u>的方法！</p><p>NAS目前还在快速发展，有几个研究重点：</p><p>比如：你搜出来的东西是不是“可解释的”，搜出来效果特别好但是长得很奇怪，大家也不知道咋用</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256330.png" alt="image-20220507201722136" style="zoom:67%;" /><p>移动设备上的模型，得权衡精度、延迟、功耗等等。</p><h3 id="Deep-Network-Tuning"><a href="#Deep-Network-Tuning" class="headerlink" title="Deep Network Tuning"></a>Deep Network Tuning</h3><p>讲深度神经网络里一些共用的设计模式！</p><p>。。。批量和层归一化。残差连接。注意力机制。</p><p>(未完待续，等李沐老师继续更新！)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实用机器学习——课程：【20课时】关注DS的方方面面，很实际&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coentents&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Machine Learning topics that matter but are often skipped &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DL code笔记</title>
    <link href="https://darren-dong.com/2022/01/27/code/"/>
    <id>https://darren-dong.com/2022/01/27/code/</id>
    <published>2022-01-27T06:08:16.000Z</published>
    <updated>2022-05-09T04:47:30.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="李沐"><a href="#李沐" class="headerlink" title="李沐"></a>李沐</h2><p>tensorflow的tensor没有reshape，必须<code>tf.reshape(x,(3,4))</code> torch牛</p><p>tensorflow.random没有randn，得用normal</p><p>torch.tensor  对应  tf.constant + tf.Variable + tf.tensors</p><p>torch.arange() == tf.range()</p><p>查看变量：torch 比较简洁，但tensorflow可能方便点</p><p>torch tensor可直接修改  ；TensorFlow中的<code>constant</code>是不可变的，也不能被赋值。 TensorFlow中的<code>Variables</code>是支持赋值的可变容器。 请记住，<u>TensorFlow中的梯度不会通过<code>Variable</code>反向传播。</u></p><p>详细描述：<a href="https://tensorflow.google.cn/guide/autodiff?hl=zh-cn#1_%E4%BD%BF%E7%94%A8%E5%BC%A0%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%8F%98%E9%87%8F%E3%80%90%E7%9B%91%E8%A7%86%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%96%E6%B6%88%E7%9B%91%E8%A7%86%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%97%E5%87%BA%E7%9B%91%E8%A7%86%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%8D%E7%9B%91%E8%A7%86%EF%BC%8C%E3%80%91">https://tensorflow.google.cn/guide/autodiff?hl=zh-cn#1_%E4%BD%BF%E7%94%A8%E5%BC%A0%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%8F%98%E9%87%8F【监视常量，取消监视变量，列出监视变量，不监视，】</a></p><p>中间结果即使是tensor，也能打印</p><p>为了区分需要计算梯度信息的张量和不需计算梯度信息的张量，TF设置一种专门的数据类型用于支持梯度信息的记录：tf.Variable。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># A trainable variable</span>x0 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x0'</span><span class="token punctuation">)</span><span class="token comment"># Not trainable</span>x1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x1'</span><span class="token punctuation">,</span> trainable<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># Not a Variable: A variable + tensor returns a tensor.</span>x2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x2'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span>x0<span class="token operator">*</span>x0<span class="token comment">#也不行</span><span class="token comment"># Not a variable</span>x3 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202203181728409.png" alt="image-20220228090447692" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908937.png" alt="image-20220228090508655" style="zoom:40%;" /></p><p>如果不用assign，那就会从variable变成tensor</p><p>都提供  ~_like()提供同shape，都有<code>.shape</code>，都能用python的<code>len()</code>查看第0维</p><p>torch 切片就是原地操作   tf里assign能存参数，无明显原地操作法   torch的<code>_</code>inplace方法，不占用额外的内存</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908939.png" alt="image-20220228091117871" style="zoom:40%;" /><p>pytorch的<code>tensor(array)</code>不共享内存，<code>as_tensor</code>和<code>from_numpy</code>共享，就地操作也共享。</p><p>tensorflow 转换后的结果不共享内存。 这个小的不便实际上是<strong>非常重要</strong>的：当你在CPU或GPU上执行操作的时候， 如果Python的NumPy包也希望使用相同的内存块执行其他操作，你不希望停下计算来等它。</p><hr><h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a>Linear</h3><p>torch里var.T == tf里tf.transpose(var)</p><p>torch可以.clone，复制内存，tf 不行我擦，tf的成员变量真少，都是tf.xxx</p><p><code>torch: x.sum(axis = 0)   tf: tf.reduce_sum(x,axis = 0) </code> ==当然，torch也有torch.sum()这些操作==</p><p><code>torch: x.numel()    tf:tf.shape(x).numpy()</code></p><p>都用xx.norm(var)</p><p>torch.mv ==tf.linalg.matvec(A, x)        torch.mm == tf.matmul   torch.dot == tf.tensordot</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'figure.figsize'</span><span class="token punctuation">]</span> <span class="token operator">=</span> figsize <span class="token comment">#可以设置相当多的属性</span>axes<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#网格化</span>axes <span class="token operator">=</span> axes <span class="token keyword">if</span> axes <span class="token keyword">else</span> d2l<span class="token punctuation">.</span>plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#get current axes</span>plt<span class="token punctuation">.</span>cla<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法清除当前坐标轴，plt<span class="token punctuation">.</span>clf<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法清除当前图形，plt<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法关闭整个窗口。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式计算图 vs 显式计算图：<a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html">https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html</a></p><p><code>u = y.detach    u = tf.stop_gradient(y)</code></p><p>torch同一个计算图好像不能连续算两遍。tensorflow用的是磁带<code>tf.GradientTape</code>记录梯度，梯度不累加而是覆盖。</p><p>tensorflow也有trainable = true，如果是False，冻结的层在训练期间不会更新（无论是使用 <code>fit()</code> 进行训练，还是使用依赖于 <code>trainable_weights</code> 来应用梯度更新的任何自定义循环进行训练时）</p><p>由于tensorflow的梯度得另外存储，如<code>dw, db = g.gradient(l, [w, b])</code>，所以得在训练中存好了，交给优化算法读取并更新。<br>而torch直接在优化算法中用grad就能得到。但是torch在优化算法中要注意设置不进行梯度运算，并清零这一batch的梯度。</p><p><strong>读取数据集</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#布尔值is_train表示是否希望数据迭代器对象在每个迭代周期内打乱数据</span><span class="token comment">#torch</span><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils <span class="token keyword">import</span> data<span class="token keyword">def</span> <span class="token function">load_array</span><span class="token punctuation">(</span>data_arrays<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> is_train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""构造一个PyTorch数据迭代器"""</span>    dataset <span class="token operator">=</span> data<span class="token punctuation">.</span>TensorDataset<span class="token punctuation">(</span><span class="token operator">*</span>data_arrays<span class="token punctuation">)</span> <span class="token comment">#这次的数据是tensor格式，数据集用TensorDataset构造</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span>is_train<span class="token punctuation">)</span> <span class="token comment">#这个应该是通用的，改dataset就好。其实是True</span>batch_size <span class="token operator">=</span> <span class="token number">10</span>data_iter <span class="token operator">=</span> load_array<span class="token punctuation">(</span><span class="token punctuation">(</span>features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span> <span class="token comment">#迭代器的最终形式是dataloader</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token comment">#tensorflow</span><span class="token keyword">def</span> <span class="token function">load_array</span><span class="token punctuation">(</span>data_arrays<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> is_train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""构造一个TensorFlow数据迭代器"""</span>    dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>data_arrays<span class="token punctuation">)</span>    <span class="token keyword">if</span> is_train<span class="token punctuation">:</span>        dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span> <span class="token comment">#tensorflow没有loader的设定，都在数据集自定的实现上操作</span>    <span class="token keyword">return</span> datasetbatch_size <span class="token operator">=</span> <span class="token number">10</span>data_iter <span class="token operator">=</span> load_array<span class="token punctuation">(</span><span class="token punctuation">(</span>features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token comment">#迭代器的最后形式就是dataset</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>data_iter<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pytorch的网络是确定的，没有输入之前，就能直接访问各层的参数，并直接修改；tensorflow能指定每层的初始化方法，但只有在我们<strong>第一次尝试通过网络传递数据时才会进行真正的初始化</strong>。 请注意，因为参数还没有初始化，所以我们不能访问或操作它们。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">initializer <span class="token operator">=</span> tf<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>RandomNormal<span class="token punctuation">(</span>stddev<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_initializer<span class="token operator">=</span>initializer<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>loss = nn.MSELoss()</code> vs <code>loss = tf.keras.losses.MeanSquaredError()</code></p><p><code>trainer = torch.optim.SGD(net.parameters(), lr=0.03)</code> vs<br><code>trainer = tf.keras.optimizers.SGD(learning_rate=0.03)</code> </p><p>在每个epoch打印损失：向损失函数输入初始数据集和labels，而非训练用的shuffle过的数据。</p><p><strong>经典训练</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch <span class="token keyword">import</span> nnnet <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">)</span>num_epochs <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">,</span>y<span class="token punctuation">)</span>        trainer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        trainer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>l<span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>initializer <span class="token operator">=</span> tf<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>RandomNormal<span class="token punctuation">(</span>stddev<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_initializer<span class="token operator">=</span>initializer<span class="token punctuation">)</span><span class="token punctuation">)</span>loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>losses<span class="token punctuation">.</span>MeanSquaredError<span class="token punctuation">(</span><span class="token punctuation">)</span>trainer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>optimizers<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>learning_rate<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">)</span>num_epochs <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>        <span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>            l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> training<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>        grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>l<span class="token punctuation">,</span> net<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token comment">#参数传递也挺方便的</span>        trainer<span class="token punctuation">.</span>apply_gradients<span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>grads<span class="token punctuation">,</span> net<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>l<span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">%</span>matplotlib inline<span class="token keyword">from</span> IPython <span class="token keyword">import</span> displaydisplay<span class="token punctuation">.</span>set_matplotlib_formats<span class="token punctuation">(</span><span class="token string">'svg'</span><span class="token punctuation">)</span> <span class="token comment">#用更高精度的svg图片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>torchvision</code>包 包含了目前流行的数据集，模型结构和常用的图片转换工具。</p><p><code>torchvision.datasets</code>中包含了MNIST等6个？数据集</p><p><code>torchvision.transform</code>里有许多处理图片的方法、工具。</p><p><code>torchvision.models</code>y偶很多预训练模块。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908940.png" alt="image-20220228125050333" style="zoom:60%;" align = 'left'/><p>得到的mnist_train可以直接用来做dataset那个参数，X的shape是（batch，channels，height，width）</p><p>num_workers参数用来指定用几个进程读数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908941.png" alt="image-20220228125438225"></p><p>测试读入简单的tensor，4进程没问题，果然还是和内存有关。</p><p>imshow函数接收的图片格式：<br>    X变量存储图像，可以是浮点型数组、unit8数组以及PIL图像，如果其为数组，则需满足一下形状：<br>    (1) MN      此时数组必须为浮点型，其中值为该坐标的灰度；<br>    (2) MN*3  RGB（浮点型或者unit8类型）<br>    (3) MN*4  RGBA（浮点型或者unit8类型）</p><p><strong>可视化样本</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_fashion_mnist_labels</span><span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""返回Fashion-MNIST数据集的文本标签"""</span>    text_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'t-shirt'</span><span class="token punctuation">,</span> <span class="token string">'trouser'</span><span class="token punctuation">,</span> <span class="token string">'pullover'</span><span class="token punctuation">,</span> <span class="token string">'dress'</span><span class="token punctuation">,</span> <span class="token string">'coat'</span><span class="token punctuation">,</span>                   <span class="token string">'sandal'</span><span class="token punctuation">,</span> <span class="token string">'shirt'</span><span class="token punctuation">,</span> <span class="token string">'sneaker'</span><span class="token punctuation">,</span> <span class="token string">'bag'</span><span class="token punctuation">,</span> <span class="token string">'ankle boot'</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>text_labels<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> labels<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">show_images</span><span class="token punctuation">(</span>imgs<span class="token punctuation">,</span> num_rows<span class="token punctuation">,</span> num_cols<span class="token punctuation">,</span> titles<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""绘制图像列表"""</span>    figsize <span class="token operator">=</span> <span class="token punctuation">(</span>num_cols <span class="token operator">*</span> scale<span class="token punctuation">,</span> num_rows <span class="token operator">*</span> scale<span class="token punctuation">)</span>    _<span class="token punctuation">,</span> axes <span class="token operator">=</span> d2l<span class="token punctuation">.</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>num_rows<span class="token punctuation">,</span> num_cols<span class="token punctuation">,</span> figsize<span class="token operator">=</span>figsize<span class="token punctuation">)</span> <span class="token comment">#这个'_'就很离谱</span>    axes <span class="token operator">=</span> axes<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>ax<span class="token punctuation">,</span> img<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>axes<span class="token punctuation">,</span> imgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#沐神常用操作了。</span>        <span class="token keyword">if</span> torch<span class="token punctuation">.</span>is_tensor<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 图片张量</span>            ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># PIL图片</span>            ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>        ax<span class="token punctuation">.</span>axes<span class="token punctuation">.</span>get_xaxis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>        ax<span class="token punctuation">.</span>axes<span class="token punctuation">.</span>get_yaxis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> titles<span class="token punctuation">:</span>            ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> axes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读取数据集</strong></p><p>果然，不同的框架内置的数据集，组织方式也不一样啊。还有这俩框架的处理数据策略果然差挺远。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_data_fashion_mnist</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span>    trans <span class="token operator">=</span> <span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> resize<span class="token punctuation">:</span>        trans<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>resize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#先resize，再tosensor！！！！:star</span>    trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span>trans<span class="token punctuation">)</span> <span class="token comment">#torch对数据集的处理主要用transform实现</span>    mnist_train <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    mnist_test <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_train<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                            num_workers<span class="token operator">=</span>get_dataloader_workers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_test<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                            num_workers<span class="token operator">=</span>get_dataloader_workers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_iter<span class="token punctuation">,</span> test_iter <span class="token operator">=</span> load_data_fashion_mnist<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> X<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>    <span class="token keyword">break</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch<span class="token punctuation">.</span>float32 torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch<span class="token punctuation">.</span>int64<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">def</span> <span class="token function">load_data_fashion_mnist</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span>    mnist_train<span class="token punctuation">,</span> mnist_test <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>fashion_mnist<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 将所有数字除以255，使所有像素值介于0和1之间，在最后添加一个批处理维度，</span>    <span class="token comment"># 并将标签转换为int32。</span>    process <span class="token operator">=</span> <span class="token keyword">lambda</span> X<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">(</span>tf<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">,</span>                            tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>y<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int32'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    resize_fn <span class="token operator">=</span> <span class="token keyword">lambda</span> X<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">(</span>        tf<span class="token punctuation">.</span>image<span class="token punctuation">.</span>resize_with_pad<span class="token punctuation">(</span>X<span class="token punctuation">,</span> resize<span class="token punctuation">,</span> resize<span class="token punctuation">)</span> <span class="token keyword">if</span> resize <span class="token keyword">else</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">#函数里要同时处理所有吗</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>process<span class="token punctuation">(</span><span class="token operator">*</span>mnist_train<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>            batch_size<span class="token punctuation">)</span><span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>mnist_train<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>resize_fn<span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>process<span class="token punctuation">(</span><span class="token operator">*</span>mnist_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>            batch_size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>resize_fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#标签不用shuffle</span>train_iter<span class="token punctuation">,</span> test_iter <span class="token operator">=</span> load_data_fashion_mnist<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> X<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>    <span class="token keyword">break</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>dtype<span class="token punctuation">:</span> <span class="token string">'float32'</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>dtype<span class="token punctuation">:</span> <span class="token string">'int32'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pytorch  model.train() model.eval()【适用dev set和test】主要区别在BN和dropout</p><p><code>y_hat.type(y.dtype)</code>   vs   <code>tf.cast(y_hat, y.dtype)</code></p><p>交叉熵<code>nn.CrossEntropyLoss(reduction=&#39;none&#39;)</code> vs <code>tf.losses.sparse_categorical_crossentropy()</code></p><p>nn的损失函数有reduction参数共有三种选项’elementwise_mean’，’sum’和’none’。<br>‘elementwise_mean’为默认情况，表明对N个样本的loss进行求平均之后返回;<br>‘sum’指对n个样本的loss求和;<br>‘none’表示直接返回n分样本的loss，是一个<strong>向量</strong></p><blockquote><p>3.6里，有很牛的Animator和Accumulator，实现了很多nb代码。</p><p>还是直接去看吧<a href="https://zh-v2.d2l.ai/chapter_linear-networks/softmax-regression-scratch.html">https://zh-v2.d2l.ai/chapter_linear-networks/softmax-regression-scratch.html</a></p><p>求准确率：float（布尔代数）类的行为，👇实现列表每项更新，但是其实可以用向量化来处理。</p><p>不要把numpy的多维和dataframe的行列弄混了。。。</p><p><code>X_train = torch.cat([X_train, X_part], 0)</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>     self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>a <span class="token operator">+</span> <span class="token builtin">float</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>花哨索引：传入多个列表，每个列表代表相应维度的坐标，想想都方便欸。</p></blockquote><h3 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h3><p><code>torch.relu(x)/sigmoid/tan  vs  tf.nn.relu(x)/sigmoid/tan</code></p><p>torch的backward函数：如果参数retain_graph=true,就会每次运行时重新生成图。也就是说，每次 backward() 时，默认会把整个计算图free掉。一般情况下是每次迭代，只需一次 forward() 和一次 backward() , 前向运算forward() 和反向传播backward()是成对存在的，一般一次backward()也是够用的。</p><p>但是不排除，由于自定义loss等的复杂性，需要一次forward()，多个不同loss的backward()来累积同一个网络的grad来更新参数。</p><p>还有一个<code>grad_tensor</code>参数（第一个默认），一般和要求梯度的tensor大小一致，用来指定权重，暂时没用上。</p><p>Relu的简单实现：<code>lambda x:torch.max(x,torch.zeros_like(x))</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#关于维度，W是（input，output），计算时是matmul（X,W） input是X的特征维数，X的第0维是batch</span><span class="token comment">#这里有个处理，就是reshape来适配一下维度。即`torch.matmul(X.reshape((-1, W.shape[0])), W) + b`</span>num_inputs<span class="token punctuation">,</span> num_outputs<span class="token punctuation">,</span> num_hiddens <span class="token operator">=</span> <span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">256</span>W1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>    num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span>b1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>W2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>    num_hiddens<span class="token punctuation">,</span> num_outputs<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span>b2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_outputs<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>params <span class="token operator">=</span> <span class="token punctuation">[</span>W1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> W2<span class="token punctuation">,</span> b2<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">net</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>    X <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>    H <span class="token operator">=</span> relu<span class="token punctuation">(</span>X@W1 <span class="token operator">+</span> b1<span class="token punctuation">)</span>  <span class="token comment"># 这里“@”代表矩阵乘法</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>H@W2 <span class="token operator">+</span> b2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#tensorflow只用改输出，比torch赢一筹。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当它们被分配为模块属性时，它们会自动添加到其参数列表中，并将出现在例如<code>parameters()</code>迭代器中。分配张量没有这样的效果。这是因为人们可能想要在模型中缓存一些临时状态，例如 RNN 的最后一个隐藏状态。</p><p>如果没有这样的类<a href="https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html#torch.nn.parameter.Parameter"><code>Parameter</code></a>，这些临时人员也会被注册。</p><p>torch.tensor([1,2,3],requires_grad=True)的区别，这个只是将参数变成可训练的，并没有绑定在module的parameter列表中。</p><p>用在自定义块里。nn自带的网络的w，b都是parameter</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#权重衰减</span>。。。。    <span class="token comment"># 偏置参数没有衰减</span>    trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span><span class="token string">"params"</span><span class="token punctuation">:</span>net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span><span class="token string">'weight_decay'</span><span class="token punctuation">:</span> wd<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">#这是给第一层weight指定</span>        <span class="token punctuation">&#123;</span><span class="token string">"params"</span><span class="token punctuation">:</span>net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>bias<span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>lr<span class="token punctuation">)</span>    trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr <span class="token operator">=</span> lr<span class="token punctuation">,</span>weight_decay <span class="token operator">=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment">#多层</span>。。。。    <span class="token keyword">def</span> <span class="token function">train_concise</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">:</span>。。。。    net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>        <span class="token number">1</span><span class="token punctuation">,</span> kernel_regularizer<span class="token operator">=</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>regularizers<span class="token punctuation">.</span>l2<span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#L2正则化放在这</span>    net<span class="token punctuation">.</span>build<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#这算是指定输入参数吗。</span>。。。。<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token comment">#dropout</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment"># 在第一个全连接层之后添加一个dropout层</span>        nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">def</span> <span class="token function">init_weights</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">==</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">:</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>net<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>init_weights<span class="token punctuation">)</span><span class="token punctuation">;</span>net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment"># 在第一个全连接层之后添加一个dropout层</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout1<span class="token punctuation">)</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>torch.clamp()</code> vs <code>tf.clip_by_value()</code></p><p><a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/kaggle-house-price.html">Kaggle示例</a> 里好多可学的例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">numeric_features <span class="token operator">=</span> all_features<span class="token punctuation">.</span>dtypes<span class="token punctuation">[</span>all_features<span class="token punctuation">.</span>dtypes <span class="token operator">!=</span> <span class="token string">'object'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>indexall_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>    <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> x<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#DataFrame.dtypes 是 每一列的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tf里还有个``tf.Constant<code> tf好像把会降维的加了个</code>reduce_`前缀，便于区分，其实还是挺不错的。</p><p>使用tf.constant函数创建的随机权重参数在训练期间不会更新（即为常量参数）</p><h3 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h3><p>tensorflow如果不命名层/块的名字，那命名是按深度遍历的。</p><p><a href="https://zh-v2.d2l.ai/chapter_deep-learning-computation/model-construction.html">自定义块</a>其实就是自定义很多layer，然后调用__call__，在forward/call函数编写传播过程</p><p>还是看看原文吧，比如<code>net.add_models(&#39;name&#39;,block)</code>这些东西</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 我们需要给共享层一个名称，以便可以引用它的参数</span><span class="token comment"># tf.keras的表现有点不同。它会自动删除重复层。</span>shared <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    shared<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    shared<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment">#确保相同</span><span class="token keyword">print</span><span class="token punctuation">(</span>net<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> net<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>net<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> param<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#列出不重复的的</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> param<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#列出所有的（这是个OrdictedDict）</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Sequential<span class="token punctuation">(</span>  <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'0.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'0.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'0.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'0.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'4.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'4.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#share的层中，named_parameters不会count repeated的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Variable不同，parameter默认require_grad=True，当我们创建一个model时，<u>parameter会自动累加到Parameter 列表</u>中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch里用net<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>，以Ordicted<span class="token operator">-</span><span class="token builtin">dict</span>组织  参数叫weight 和 bias因为是字典，可以用   net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'2.bias'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data来组织也可以net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>，与<span class="token builtin">dict</span><span class="token punctuation">.</span>item结构类似。<span class="token keyword">print</span>（net）可以展示所有递归的结构PyTorch的nn<span class="token punctuation">.</span>init模块提供了多种预置初始化方法。用net<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span><span class="token comment">#内置初始化</span><span class="token keyword">def</span> <span class="token function">xavier</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">==</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">:</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">)</span>        <span class="token comment">#nn.init.normal_(m.weight, mean=0, std=0.01)</span>        <span class="token comment">#nn.init.zeros_(m.bias)</span>        <span class="token comment">#nn.init.constant_(m.weight, 42)</span>        <span class="token comment">#加上一些别的就是自定义了。比如m.weight.data *= m.weight.data.abs() >= 5</span>net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>xavier<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>tf里用<span class="token punctuation">.</span>layers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span>索引，参数叫kernel和bias  列表组织参数类型不是tensor，用 tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span><span class="token punctuation">)</span>可以转换成tensor也可以net<span class="token punctuation">.</span>get_weights<span class="token punctuation">(</span><span class="token punctuation">)</span> 得到参数列表，但没有名字net<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>只会展示最上层的，不会显示内部结构。TensorFlow在根模块和keras<span class="token punctuation">.</span>initializers模块中提供了各种初始化方法。通过各层的kernel_initializer和bias_initializer指定<span class="token comment">#自定义初始化</span><span class="token keyword">class</span> <span class="token class-name">MyInit</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>Initializer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        data<span class="token operator">=</span>tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>dtype<span class="token punctuation">)</span>        factor<span class="token operator">=</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span>        factor<span class="token operator">=</span>tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>factor<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token comment">#tensorflow不同数据类型不能直接做计算</span>        <span class="token keyword">return</span> data <span class="token operator">*</span> factor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#自定义层，那就要定义参数，实现前向传播</span><span class="token comment">#该层需要输入参数：in_units和units，分别表示输入数和输出数。</span><span class="token keyword">class</span> <span class="token class-name">MyLinear</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_units<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>in_units<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>units<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        linear <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data        <span class="token keyword">return</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>linear<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token comment">#tensorflow仅仅接收输出参数</span><span class="token keyword">class</span> <span class="token class-name">MyDense</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>units <span class="token operator">=</span> units    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X_shape<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#需要单独用build函数设定参数</span>        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> self<span class="token punctuation">.</span>add_weight<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'weight'</span><span class="token punctuation">,</span>            shape<span class="token operator">=</span><span class="token punctuation">[</span>X_shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>units<span class="token punctuation">]</span><span class="token punctuation">,</span>            initializer<span class="token operator">=</span>tf<span class="token punctuation">.</span>random_normal_initializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> self<span class="token punctuation">.</span>add_weight<span class="token punctuation">(</span>            name<span class="token operator">=</span><span class="token string">'bias'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>units<span class="token punctuation">]</span><span class="token punctuation">,</span>            initializer<span class="token operator">=</span>tf<span class="token punctuation">.</span>zeros_initializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        linear <span class="token operator">=</span> tf<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>linear<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一般数据结构：torch自带load和save，tf得用np的，还要指定.npy后缀。但是模型存储都类似：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'mlp.params'</span><span class="token punctuation">)</span>clone <span class="token operator">=</span> MLP<span class="token punctuation">(</span><span class="token punctuation">)</span>clone<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#这个两步，先load再加载。也有写model.pt的</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>net<span class="token punctuation">.</span>save_weights<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span>clone <span class="token operator">=</span> MLP<span class="token punctuation">(</span><span class="token punctuation">)</span>clone<span class="token punctuation">.</span>load_weights<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tensorflow什么都用层次封装，太麻烦了</p><h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>device 查看在哪个设备上，通用<span class="token keyword">def</span> <span class="token function">try_gpu</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""如果存在，则返回gpu(i)，否则返回cpu()"""</span>    <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'cuda:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">try_all_gpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""返回所有可用的GPU，如果没有GPU，则返回[cpu(),]"""</span>    devices <span class="token operator">=</span> <span class="token punctuation">[</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'cuda:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>             <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> devices <span class="token keyword">if</span> devices <span class="token keyword">else</span> <span class="token punctuation">[</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>X <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>device <span class="token operator">=</span> try_gpu<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Y <span class="token operator">=</span> X<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#copy副本到第三个GPU上，如果调用1，则不会复制新内存，返回本身。</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#为神经网络指定设备</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>net <span class="token operator">=</span> net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#单GPU</span><span class="token comment">#多GPU</span><span class="token comment">#train_batch的那个函数，计算损失的时候是串行的代码结构，此处依赖框架本身看能否在背后之行为并行操作。</span><span class="token comment">#GPU不变快有很多的原因，可能是data读起来就贼慢（可以用for loop遍历一遍数据看看时间）</span><span class="token comment">#还有可能没有打满GPU，通常做法是batch size到n倍（n个GPU），但是这样精度会变低，可以调大一点learning rate</span><span class="token comment"># 在多个GPU上设置模型</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>net<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>devices<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#网络放到0号上</span><span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>    trainer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>    l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    trainer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#pytorch中，网络被Dataparallel“包装”后，在前向过程会把输入tensor自动分配到每个显卡上。</span><span class="token comment">#而Dataparallel使用的是master-slave的数据并行模式，主卡默认为0号GPU，所以在进网络之前，只要移到GPU[0]就可以了。</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">def</span> <span class="token function">try_gpu</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""如果存在，则返回gpu(i)，否则返回cpu()"""</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>config<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>list_physical_devices<span class="token punctuation">(</span><span class="token string">'GPU'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'/GPU:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'/CPU:0'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">try_all_gpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""返回所有可用的GPU，如果没有GPU，则返回[cpu(),]"""</span>    num_gpus <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>config<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>list_physical_devices<span class="token punctuation">(</span><span class="token string">'GPU'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    devices <span class="token operator">=</span> <span class="token punctuation">[</span>tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'/GPU:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_gpus<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> devices <span class="token keyword">if</span> devices <span class="token keyword">else</span> <span class="token punctuation">[</span>tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'/CPU:0'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">with</span> try_gpu<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    X <span class="token operator">=</span> tf<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    Y <span class="token operator">=</span> X <span class="token comment">#相当于设置一个环境来操作，此处把X copy到0号GPU</span>    <span class="token comment">#为神经网络指定设备</span>strategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>MirroredStrategy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#多GPU</span>device_name <span class="token operator">=</span> device<span class="token punctuation">.</span>_device_name<span class="token comment">#单GPU</span>strategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>OneDeviceStrategy<span class="token punctuation">(</span>device_name<span class="token punctuation">)</span><span class="token keyword">with</span> strategy<span class="token punctuation">.</span>scope<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Conv"><a href="#Conv" class="headerlink" title="Conv"></a>Conv</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span>conv2d <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>    nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>AvgPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>AvgPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>28x28输进去在flatten会变成<span class="token number">16</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span>，这个输入要计算就非常离谱。<span class="token comment">#技巧——用单位输入确定输出</span>X <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token keyword">for</span> layer <span class="token keyword">in</span> net<span class="token punctuation">:</span>    X<span class="token operator">=</span>layer<span class="token punctuation">(</span>X<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>layer<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span><span class="token string">'output shape:\t'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    X <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> layer <span class="token keyword">in</span> net<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>layers<span class="token punctuation">:</span>    X <span class="token operator">=</span> layer<span class="token punctuation">(</span>X<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>layer<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> <span class="token string">'output shape:\t'</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span>conv2d <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> use_bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">net</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">,</span>                               padding<span class="token operator">=</span><span class="token string">'same'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>AvgPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>                               activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>AvgPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#tensorflow就很舒服</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$(\frac{n+2p-f}{s}+1)\times (\frac{n+2p-f}{s}+1)$ 不是整数就向下取整</p><p>pytorch训练结构和animator使用</p><p>不过tensorflow的训练是用自定义的<u>回调函数</u>配合<code>net.fit()</code>指定在每个epoch开始和结束时发生的事。</p><p>两个train结构，十分有==参考价值==：<a href="https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/lenet.html">https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/lenet.html</a></p><p>tensorflow<a href="https://blog.csdn.net/jpc20144055069/article/details/105383836">一般流程</a>，定义-&gt;net.build-&gt;net.compile-&gt;net.fit-&gt;net.evaluate</p><blockquote><p>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</p></blockquote><h4 id="Modern"><a href="#Modern" class="headerlink" title="Modern"></a>Modern</h4><p><strong>VGG</strong>块中，每个卷积层（数量是超参数）的输出都是一样的，而且(n-3+2)/1+1 = n，所以不改变大小，只在池化层减半然后通道翻倍。组织结构值得借鉴：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">vgg_block</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>    layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">)</span><span class="token punctuation">:</span>        layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span>                                kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        in_channels <span class="token operator">=</span> out_channels    layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>layers<span class="token punctuation">)</span><span class="token comment">#tensorflow不需要in_channels,padding可以使用预设的same</span><span class="token keyword">def</span> <span class="token function">vgg_block</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> num_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>    blk <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">)</span><span class="token punctuation">:</span>        blk<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>                                    padding<span class="token operator">=</span><span class="token string">'same'</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    blk<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>MaxPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> blk<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>conv_arch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#五个块</span><span class="token keyword">def</span> <span class="token function">vgg</span><span class="token punctuation">(</span>conv_arch<span class="token punctuation">)</span><span class="token punctuation">:</span>    conv_blks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    in_channels <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># 卷积层部分</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span> <span class="token keyword">in</span> conv_arch<span class="token punctuation">:</span>        conv_blks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>vgg_block<span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span><span class="token punctuation">)</span>        in_channels <span class="token operator">=</span> out_channels<span class="token comment">#这一步:star</span>    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>        <span class="token operator">*</span>conv_blks<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment"># 全连接层部分</span>        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>out_channels <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>net <span class="token operator">=</span> vgg<span class="token punctuation">(</span>conv_arch<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NiN</strong>——设计上借鉴了Alex_Net</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nin_block</span><span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> strides<span class="token punctuation">,</span> padding<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> strides<span class="token punctuation">,</span> padding<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#这个有默认顺序的。</span>        nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>    nin_block<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nin_block<span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nin_block<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#这有个Dropout</span>    <span class="token comment"># 标签类别数是10</span>    nin_block<span class="token punctuation">(</span><span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#输出通道数10为类别数。</span>    nn<span class="token punctuation">.</span>AdaptiveAvgPool2d<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#（1，1）是高宽消到1</span>    <span class="token comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span>    nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#Output：</span>Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">]</span><span class="token punctuation">)</span>MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">)</span>MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Dropout output shape<span class="token punctuation">:</span>        torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>AdaptiveAvgPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Flatten output shape<span class="token punctuation">:</span>        torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GoogLeNet 抄参数：<a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p><p>批量规范化层在”训练模式“（通过小批量统计数据规范化）和“预测模式”（通过数据集统计规范化）中的功能不同。 在训练过程中，我们无法得知使用整个数据集来估计平均值和方差，所以只能根据每个小批次的平均值和方差不断训练模型。 而在预测模式下，可以根据整个数据集精确计算批量规范化所需的平均值和方差。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">batch_norm</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> moving_mean<span class="token punctuation">,</span> moving_var<span class="token punctuation">,</span> eps<span class="token punctuation">,</span> momentum<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 通过is_grad_enabled来判断当前模式是训练模式还是预测模式</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>is_grad_enabled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差</span>        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> moving_mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>moving_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">assert</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。</span>            <span class="token comment"># 这里我们需要保持X的形状以便后面可以做广播运算</span>            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment"># 训练模式下，用当前的均值和方差做标准化</span>        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span>        <span class="token comment"># 更新移动平均的均值和方差</span>        moving_mean <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_mean <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> mean        moving_var <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_var <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> var    Y <span class="token operator">=</span> gamma <span class="token operator">*</span> X_hat <span class="token operator">+</span> beta  <span class="token comment"># 缩放和移位</span>    <span class="token keyword">return</span> Y<span class="token punctuation">,</span> moving_mean<span class="token punctuation">.</span>data<span class="token punctuation">,</span> moving_var<span class="token punctuation">.</span>data<span class="token keyword">class</span> <span class="token class-name">BatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># num_features：完全连接层的输出数量或卷积层的输出通道数。</span>    <span class="token comment"># num_dims：2表示完全连接层，4表示卷积层</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> num_dims<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> num_dims <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>beta <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 非模型参数的变量初始化为0和1</span>        self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果X不在内存上，将moving_mean和moving_var,因为不是parameters，得手动弄。</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>device <span class="token operator">!=</span> X<span class="token punctuation">.</span>device<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_var<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        <span class="token comment"># 保存更新过的moving_mean和moving_var</span>        Y<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> batch_norm<span class="token punctuation">(</span>            X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>gamma<span class="token punctuation">,</span> self<span class="token punctuation">.</span>beta<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span>            self<span class="token punctuation">.</span>moving_var<span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>          <span class="token comment">#得注意eps的值，可能会造成影响，不同框架也不一样。</span>        <span class="token keyword">return</span> Y<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>BatchNorm1d<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>BatchNormalization<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Activation<span class="token punctuation">(</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Residual</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>                 use_1x1conv<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>                               kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>                               kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> use_1x1conv<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>                                   kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>bn1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bn2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        Y <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>bn1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        Y <span class="token operator">=</span> self<span class="token punctuation">.</span>bn2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">:</span>            X <span class="token operator">=</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        Y <span class="token operator">+=</span> X        <span class="token keyword">return</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>Y<span class="token punctuation">)</span>    <span class="token comment">#结构    </span>b1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                   nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                   nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">resnet_block</span><span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> num_residuals<span class="token punctuation">,</span>                 first_block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    blk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_residuals<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> first_block<span class="token punctuation">:</span>            blk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Residual<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>                                use_1x1conv<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            blk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Residual<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> blkb2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> first_block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#b1减半了两次，这里就不减半</span>b3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b4 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b5 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><p><strong>目标检测</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#Augmentation</span>d2l<span class="token punctuation">.</span>set_figsize<span class="token punctuation">(</span><span class="token punctuation">)</span>img <span class="token operator">=</span> pil<span class="token punctuation">.</span>Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'../img/cat1.jpg'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment">#水平翻转</span>transforms<span class="token punctuation">.</span>RandomVerticalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#垂直</span>transforms<span class="token punctuation">.</span>RandomRotation<span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ratio<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#最终大小，像素范围，宽高比</span>transforms<span class="token punctuation">.</span>ColorJitter<span class="token punctuation">(</span>brightness<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> contrast<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> saturation<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment">#亮度、对比度、饱和度、色调</span>transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#随机裁剪</span>transforms<span class="token punctuation">.</span>CenterCrop<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#中心裁剪</span>transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#更多的https://blog.csdn.net/comway_Li/article/details/96138551</span>train_augs <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>     transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test_augs <span class="token operator">=</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>     transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span>is_train<span class="token punctuation">,</span>transform<span class="token operator">=</span>augs<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>dataloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span>                    shuffle<span class="token operator">=</span>is_train<span class="token punctuation">,</span> num_workers<span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">#模仿👇就能在线生成多张啦</span><span class="token keyword">def</span> <span class="token function">apply</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> aug<span class="token punctuation">,</span> num_rows<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> num_cols<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    Y <span class="token operator">=</span> <span class="token punctuation">[</span>aug<span class="token punctuation">(</span>img<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_rows <span class="token operator">*</span> num_cols<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Fine tuning</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用RGB通道的均值和标准差，以标准化每个通道</span>normalize <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token number">0.485</span><span class="token punctuation">,</span> <span class="token number">0.456</span><span class="token punctuation">,</span> <span class="token number">0.406</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0.229</span><span class="token punctuation">,</span> <span class="token number">0.224</span><span class="token punctuation">,</span> <span class="token number">0.225</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#如果选择的模型里有BatchNormalization，就不用这个</span>train_augs <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#随机裁剪成224，</span><span class="token comment">#👆默认值scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333)</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    normalize<span class="token punctuation">]</span><span class="token punctuation">)</span>test_augs <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#测试时大小标准化。</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>CenterCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    normalize<span class="token punctuation">]</span><span class="token punctuation">)</span>finetune_net <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>resnet18<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>finetune_net<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>finetune_net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>in_features<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#还能直接拿到输入输出shape,直接print改结构</span>nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>finetune_net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#注意最后的fc层在optim中设置10倍的学习率。</span><span class="token keyword">def</span> <span class="token function">train_fine_tuning</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> num_epochs<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>                      param_group<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    train_iter <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>        os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>train_augs<span class="token punctuation">)</span><span class="token punctuation">,</span>        batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    test_iter <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>        os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>test_augs<span class="token punctuation">)</span><span class="token punctuation">,</span>        batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span>    devices <span class="token operator">=</span> d2l<span class="token punctuation">.</span>try_all_gpus<span class="token punctuation">(</span><span class="token punctuation">)</span>    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span>reduction<span class="token operator">=</span><span class="token string">"none"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> param_group<span class="token punctuation">:</span> <span class="token comment">#单独改learning_rate</span>        params_1x <span class="token operator">=</span> <span class="token punctuation">[</span>param <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">if</span> name <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"fc.weight"</span><span class="token punctuation">,</span> <span class="token string">"fc.bias"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'params'</span><span class="token punctuation">:</span> params_1x<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                                   <span class="token punctuation">&#123;</span><span class="token string">'params'</span><span class="token punctuation">:</span> net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token string">'lr'</span><span class="token punctuation">:</span> learning_rate <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                lr<span class="token operator">=</span>learning_rate<span class="token punctuation">,</span> weight_decay<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">,</span>                                  weight_decay<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>    d2l<span class="token punctuation">.</span>train_ch13<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> test_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> trainer<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span>                   devices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这一块基本都是用C++、cuda实现，不然效率太低，而且会有大量的tricks，小细节太多</strong></p><p>所以尽量用别人<u>已经成熟</u>的包。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入参数boxes可以是长度为4的张量，也可以是形状为（，4）的二维张量，其中是边界框的数量。</span>set_index方法，可以使用现有列设置单索引和复合索引 https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>cnblogs<span class="token punctuation">.</span>com<span class="token operator">/</span>cgmcoding<span class="token operator">/</span>p<span class="token operator">/</span><span class="token number">13691142.</span>htmlreset_index，重置DataFrame的索引，并使用默认索引。如果DataFrame具有MultiIndex，则此方法可以删除一个或多个级别遍历 https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>delftstack<span class="token punctuation">.</span>com<span class="token operator">/</span>zh<span class="token operator">/</span>howto<span class="token operator">/</span>python<span class="token operator">-</span>pandas<span class="token operator">/</span>how<span class="token operator">-</span>to<span class="token operator">-</span>iterate<span class="token operator">-</span>through<span class="token operator">-</span>rows<span class="token operator">-</span>of<span class="token operator">-</span>a<span class="token operator">-</span>dataframe<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>pandas<span class="token operator">/</span>tensor<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token comment">#插入维度</span><span class="token comment">#一次next返回一个batch[0]==图像，batch[1]==labels</span>labels的shape<span class="token operator">==</span><span class="token punctuation">[</span>batch_size<span class="token punctuation">,</span>num_box<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token comment">#5是[种类,左上x,y,右下x,y]/也有可能是左上+高宽</span>imgs <span class="token operator">=</span> <span class="token punctuation">(</span>batch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#把通道维挪到最后，牛啊</span><span class="token comment">#返回的锚框变量Y的形状是（批量大小，锚框的数量，4) 很丧心病狂，但是大家都用这个方法。（我没看懂它的生成）</span>torch<span class="token operator">/</span>np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span><span class="token punctuation">)</span>函数常用于生成二维网格，比如图像的坐标点。torch<span class="token punctuation">.</span>stack是在新维度堆叠torch<span class="token punctuation">.</span>repeat是复制后拼接，torch<span class="token punctuation">.</span>repeat_interleave是直接复制 https<span class="token punctuation">:</span><span class="token operator">//</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>weixin_42516475<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">117199456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把我看傻了：<a href="https://zh-v2.d2l.ai/chapter_computer-vision/anchor.html">https://zh-v2.d2l.ai/chapter_computer-vision/anchor.html</a> 太难理解了这数据。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908942.png" alt="image-20220320165125841" style="zoom: 50%;" /><p><strong>SSD</strong></p><p>设目标类别的数量为q。这样一来，锚框有q+1个类别，其中0类是背景。 </p><p>特征图的高和宽是h和w，每个单元生成a个锚框，共需对hwa个锚框进行分类。</p><p>使用全连接层作为输出，很容易导致模型参数过多。 回忆 <a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/nin.html#sec-nin">7.3节</a>一节介绍的使用卷积层的通道来输出类别预测的方法， 单发多框检测采用同样的方法来降低模型复杂度。输出通道数为$a(q+1)$，其中索引为$i(q+1)+j（0≤j≤q）$的通道代表了索引为$i$的锚框有关类别索引为$j$的预测</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#类别预测层</span><span class="token keyword">def</span> <span class="token function">cls_predictor</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors<span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors <span class="token operator">*</span> <span class="token punctuation">(</span>num_classes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                     kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#边界框预测层</span><span class="token keyword">def</span> <span class="token function">bbox_predictor</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把通道、高和宽全部合并，就可以不用为每个分辨率单独配置loss啥的，计算十分方便高效。</p><p>损失函数用L1，因为可能偏差特别大</p><hr><p><strong>语义分割</strong></p><p>要实现RGB和VOC的相互map其实用python实现是比较慢的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#@save</span><span class="token keyword">def</span> <span class="token function">voc_rand_crop</span><span class="token punctuation">(</span>feature<span class="token punctuation">,</span> label<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""随机裁剪特征和标签图像"""</span>一定得同步    rect <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">.</span>get_params<span class="token punctuation">(</span>        feature<span class="token punctuation">,</span> <span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#返回bounding box</span>    feature <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>crop<span class="token punctuation">(</span>feature<span class="token punctuation">,</span> <span class="token operator">*</span>rect<span class="token punctuation">)</span><span class="token comment">#按照框去crop</span>    label <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>crop<span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token operator">*</span>rect<span class="token punctuation">)</span><span class="token comment">#同样的操作得对label执行</span>    <span class="token keyword">return</span> feature<span class="token punctuation">,</span> labelimgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    imgs <span class="token operator">+=</span> voc_rand_crop<span class="token punctuation">(</span>train_features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> train_labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>imgs <span class="token operator">=</span> <span class="token punctuation">[</span>img<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> img <span class="token keyword">in</span> imgs<span class="token punctuation">]</span><span class="token comment">#一般画的时候得把channel放到最后。</span>d2l<span class="token punctuation">.</span>show_images<span class="token punctuation">(</span>imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> imgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>VOCS数据集的图片大小很多不一致的。<span class="token comment">#resize是个问题，很多像素是由插值得到的，但是label不能插值</span><span class="token comment">#所以图片分割都用crop size，然后移除掉尺寸小于随机裁剪所指定的输出尺寸的图像</span><span class="token comment"># 打印第一个小批量的形状会发现：与图像分类或目标检测不同，这里的标签是一个三维数组。</span>feature<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">)</span>label<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">)</span>，loss的时候要连续两次<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Recurrent"><a href="#Recurrent" class="headerlink" title="Recurrent"></a>Recurrent</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">read_time_machine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""将时间机器数据集加载到文本行的列表中"""</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>d2l<span class="token punctuation">.</span>download<span class="token punctuation">(</span><span class="token string">'time_machine'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        lines <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'[^A-Za-z]+'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>lines <span class="token operator">=</span> read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#token词元是文本的基本单位 如果字符串是token，还得学词是怎么构成的</span><span class="token keyword">def</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> token<span class="token operator">=</span><span class="token string">'word'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""将文本行拆分为单词或字符词元"""</span>    <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">'word'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>    <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">'char'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'错误：未知词元类型：'</span> <span class="token operator">+</span> token<span class="token punctuation">)</span>                <span class="token comment">#将训练集中的所有文档合并在一起，对它们的唯一词元进行统计， 得到的统计结果称之为语料（corpus）。 然后根据每个唯一词元的出现频率，为其分配一个数字索引。</span><span class="token keyword">class</span> <span class="token class-name">Vocab</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""文本词表"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> min_freq<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> reserved_tokens<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> tokens <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> reserved_tokens <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            reserved_tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 按出现频率排序</span>        counter <span class="token operator">=</span> count_corpus<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token comment">#预处理一下，能输入多种结构</span>        self<span class="token punctuation">.</span>_token_freqs <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                   reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment"># 未知词元的索引为0</span>        self<span class="token punctuation">.</span>idx_to_token <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'&lt;unk>'</span><span class="token punctuation">]</span> <span class="token operator">+</span> reserved_tokens        self<span class="token punctuation">.</span>token_to_idx <span class="token operator">=</span> <span class="token punctuation">&#123;</span>token<span class="token punctuation">:</span> idx                             <span class="token keyword">for</span> idx<span class="token punctuation">,</span> token <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">#字典解析！！！？？？</span>        <span class="token comment">#把读到的加进去，太cool了这代码。</span>        <span class="token keyword">for</span> token<span class="token punctuation">,</span> freq <span class="token keyword">in</span> self<span class="token punctuation">.</span>_token_freqs<span class="token punctuation">:</span>            <span class="token keyword">if</span> freq <span class="token operator">&lt;</span> min_freq<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">if</span> token <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">.</span>append<span class="token punctuation">(</span>token<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">[</span>token<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#定义后能用索引来变换</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>tokens<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#单个token</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">.</span>get<span class="token punctuation">(</span>tokens<span class="token punctuation">,</span> self<span class="token punctuation">.</span>unk<span class="token punctuation">)</span><span class="token comment">#如果没找到就返回未知——‘0’</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">to_tokens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> indices<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>indices<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">[</span>indices<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">for</span> index <span class="token keyword">in</span> indices<span class="token punctuation">]</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">unk</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 未知词元的索引为0</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">token_freqs</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_token_freqs<span class="token keyword">def</span> <span class="token function">count_corpus</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""统计词元的频率"""</span>    <span class="token comment"># 这里的tokens是1D列表或2D列表，如果是元组就不展平，比如zip弄出的二元组列表</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将词元列表展平成一个列表</span>        tokens <span class="token operator">=</span> <span class="token punctuation">[</span>token <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span><span class="token comment">#神马神奇操作！！！</span>    <span class="token keyword">return</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token comment">#整合</span><span class="token keyword">def</span> <span class="token function">load_corpus_time_machine</span><span class="token punctuation">(</span>max_tokens<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""返回时光机器数据集的词元索引列表和词表"""</span>    lines <span class="token operator">=</span> read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span>    tokens <span class="token operator">=</span> tokenize<span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">)</span>    vocab <span class="token operator">=</span> Vocab<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span>    <span class="token comment"># 因为时光机器数据集中的每个文本行不一定是一个句子或一个段落，</span>    <span class="token comment"># 所以将所有文本行展平到一个列表中</span>    corpus <span class="token operator">=</span> <span class="token punctuation">[</span>vocab<span class="token punctuation">[</span>token<span class="token punctuation">]</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span>    <span class="token keyword">if</span> max_tokens <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        corpus <span class="token operator">=</span> corpus<span class="token punctuation">[</span><span class="token punctuation">:</span>max_tokens<span class="token punctuation">]</span>    <span class="token keyword">return</span> corpus<span class="token punctuation">,</span> vocabcorpus<span class="token punctuation">,</span> vocab <span class="token operator">=</span> load_corpus_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#n元语法实现</span>tokens <span class="token operator">=</span> d2l<span class="token punctuation">.</span>tokenize<span class="token punctuation">(</span>d2l<span class="token punctuation">.</span>read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 因为每个文本行不一定是一个句子或一个段落，因此我们把所有文本行拼接到一起</span>corpus <span class="token operator">=</span> <span class="token punctuation">[</span>token <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span><span class="token comment">#语料库，为了简便处理成单列表</span>vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>corpus<span class="token punctuation">)</span>bigram_tokens <span class="token operator">=</span> <span class="token punctuation">[</span>pair <span class="token keyword">for</span> pair <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>corpus<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>bigram_vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>bigram_tokens<span class="token punctuation">)</span>bigram_vocab<span class="token punctuation">.</span>token_freqs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>trigram_tokens <span class="token operator">=</span> <span class="token punctuation">[</span>triple <span class="token keyword">for</span> triple <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>corpus<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>trigram_vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>trigram_tokens<span class="token punctuation">)</span>trigram_vocab<span class="token punctuation">.</span>token_freqs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token comment">#读取长序列数据，不能总像之前一样读取整个进来，当序列变得太长而不能被模型一次性全部处理时， 我们可能希望拆分这样的序列方便模型读取。而且之前那种方式，数据冗余很大，一个数据点可能被用到了好几次。</span><span class="token comment">#我们可以从随机偏移量开始划分序列， 以同时获得覆盖性（coverage）和随机性（randomness）。 下面，我们将描述如何实现随机采样（random sampling）和 顺序分区（sequential partitioning）策略。</span><span class="token comment">#参数batch_size指定了每个小批量中子序列样本的数目， 参数num_steps是每个子序列中预定义的时间步数。</span><span class="token keyword">def</span> <span class="token function">seq_data_iter_random</span><span class="token punctuation">(</span>corpus<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""使用随机抽样生成一个小批量子序列"""</span>    <span class="token comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span>    corpus <span class="token operator">=</span> corpus<span class="token punctuation">[</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token comment"># 算出子序列的个数（去尾），减去1，是因为我们需要考虑标签（比子序列偏移一个序列）</span>    num_subseqs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> num_steps    <span class="token comment"># 长度为num_steps的子序列的起始索引</span>    initial_indices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_subseqs <span class="token operator">*</span> num_steps<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 在随机抽样的迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span>    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>initial_indices<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">data</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 返回从pos位置开始的长度为num_steps的序列</span>        <span class="token keyword">return</span> corpus<span class="token punctuation">[</span>pos<span class="token punctuation">:</span> pos <span class="token operator">+</span> num_steps<span class="token punctuation">]</span><span class="token comment">#每个batch可以读进多少个子序列。没处理好，最后丢掉了几个子序列。。</span>    num_batches <span class="token operator">=</span> num_subseqs <span class="token operator">//</span> batch_size     <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> batch_size <span class="token operator">*</span> num_batches<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 在这里，initial_indices包含子序列的随机起始索引</span>        initial_indices_per_batch <span class="token operator">=</span> initial_indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span> i <span class="token operator">+</span> batch_size<span class="token punctuation">]</span>        X <span class="token operator">=</span> <span class="token punctuation">[</span>data<span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> initial_indices_per_batch<span class="token punctuation">]</span>        Y <span class="token operator">=</span> <span class="token punctuation">[</span>data<span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> initial_indices_per_batch<span class="token punctuation">]</span> <span class="token comment">#最多预测t个长度。</span>        <span class="token keyword">yield</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>Y<span class="token punctuation">)</span>  <span class="token comment">#如果是连续的可以拿到更多的空间信息，允许我们做出更长的序列出来，这代码太强了</span><span class="token keyword">def</span> <span class="token function">seq_data_iter_sequential</span><span class="token punctuation">(</span>corpus<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""使用顺序分区生成一个小批量子序列"""</span>    <span class="token comment"># 从随机偏移量开始划分序列</span>    offset <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span>    <span class="token comment">#划分直接以batch_size为单位，batch里的子序列逻辑相连。算出最终取多少个tokens</span>    num_tokens <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span> <span class="token operator">-</span> offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> batch_size<span class="token punctuation">)</span> <span class="token operator">*</span> batch_size    Xs <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>corpus<span class="token punctuation">[</span>offset<span class="token punctuation">:</span> offset <span class="token operator">+</span> num_tokens<span class="token punctuation">]</span><span class="token punctuation">)</span>    Ys <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>corpus<span class="token punctuation">[</span>offset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> offset <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> num_tokens<span class="token punctuation">]</span><span class="token punctuation">)</span>    Xs<span class="token punctuation">,</span> Ys <span class="token operator">=</span> Xs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Ys<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    num_batches <span class="token operator">=</span> Xs<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">//</span> num_steps    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps <span class="token operator">*</span> num_batches<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>        X <span class="token operator">=</span> Xs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> i <span class="token operator">+</span> num_steps<span class="token punctuation">]</span>        Y <span class="token operator">=</span> Ys<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> i <span class="token operator">+</span> num_steps<span class="token punctuation">]</span>        <span class="token keyword">yield</span> X<span class="token punctuation">,</span> Y        <span class="token keyword">class</span> <span class="token class-name">SeqDataLoader</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""加载序列数据的迭代器"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">,</span> max_tokens<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> use_random_iter<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>data_iter_fn <span class="token operator">=</span> d2l<span class="token punctuation">.</span>seq_data_iter_random        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>data_iter_fn <span class="token operator">=</span> d2l<span class="token punctuation">.</span>seq_data_iter_sequential        self<span class="token punctuation">.</span>corpus<span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>load_corpus_time_machine<span class="token punctuation">(</span>max_tokens<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_steps <span class="token operator">=</span> batch_size<span class="token punctuation">,</span> num_steps    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data_iter_fn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>corpus<span class="token punctuation">,</span> self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_steps<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">load_data_time_machine</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span>  <span class="token comment">#@save</span>                           use_random_iter<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> max_tokens<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""返回时光机器数据集的迭代器和词表"""</span>    data_iter <span class="token operator">=</span> SeqDataLoader<span class="token punctuation">(</span>        batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">,</span> max_tokens<span class="token punctuation">)</span>    <span class="token keyword">return</span> data_iter<span class="token punctuation">,</span> data_iter<span class="token punctuation">.</span>vocab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>深层：<code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</code>其实就是加了个num_layer</p><p>双向：<code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=True)</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#我们每次采样的小批量数据形状是二维张量： （批量大小，时间步数）。 </span><span class="token comment">#one_hot函数将这样一个小批量数据转换成三维张量， 张量的最后一个维度等于词表大小（len(vocab)）。 </span>X <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>F<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>X<span class="token punctuation">.</span>T<span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape —— torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#我们经常转换输入的维度，以便获得形状为 （时间步数，批量大小，词表大小）的输出。 这将使我们能够更方便地通过最外层的维度， 一步一步地更新小批量数据的隐状态。</span><span class="token keyword">def</span> <span class="token function">grad_clipping</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""裁剪梯度"""</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>        params <span class="token operator">=</span> <span class="token punctuation">[</span>p <span class="token keyword">for</span> p <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> p<span class="token punctuation">.</span>requires_grad<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        params <span class="token operator">=</span> net<span class="token punctuation">.</span>params    norm <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>grad <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> params<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> norm <span class="token operator">></span> theta<span class="token punctuation">:</span>        <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>            param<span class="token punctuation">.</span>grad<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*=</span> theta <span class="token operator">/</span> norm<span class="token comment">#简洁实现</span>num_hiddens <span class="token operator">=</span> <span class="token number">256</span>rnn_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span>state <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#隐藏层数，批量大小，隐藏单元数</span>X <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>num_steps<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Y<span class="token punctuation">,</span> state_new <span class="token operator">=</span> rnn_layer<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token comment">#Y的shape和X是一样的;state_new和state是一样的</span><span class="token comment">#RNN的输入输出https://blog.csdn.net/Fantine_Deng/article/details/111356280</span><span class="token comment">#@save</span><span class="token comment">#rnn_layer只包含隐藏的循环层，我们还需要创建一个单独的输出层。</span><span class="token keyword">class</span> <span class="token class-name">RNNModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""循环神经网络模型"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rnn_layer<span class="token punctuation">,</span> vocab_size<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>RNNModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> rnn_layer        self<span class="token punctuation">.</span>vocab_size <span class="token operator">=</span> vocab_size        self<span class="token punctuation">.</span>num_hiddens <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>hidden_size        <span class="token comment"># 如果RNN是双向的（之后将介绍），num_directions应该是2，否则应该是1</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>bidirectional<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>num_directions <span class="token operator">=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>linear <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>num_directions <span class="token operator">=</span> <span class="token number">2</span>            self<span class="token punctuation">.</span>linear <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_hiddens <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        X <span class="token operator">=</span> F<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>T<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span><span class="token comment">#input的shape：(num_steps, batch_size, len(vocab))</span>        X <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>        Y<span class="token punctuation">,</span> state <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token comment">#y的shape：(时间步数，批量大小,隐藏单元数)</span>        <span class="token comment"># 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数)</span>        <span class="token comment"># output形状是(时间步数*批量大小,词表大小)。</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>linear<span class="token punctuation">(</span>Y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Y<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> output<span class="token punctuation">,</span> state    <span class="token keyword">def</span> <span class="token function">begin_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> device<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rnn<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># nn.GRU以张量作为隐状态</span>            <span class="token keyword">return</span>  torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>                                 batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span>                                device<span class="token operator">=</span>device<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># nn.LSTM以元组作为隐状态</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>                self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>                batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span>                    torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>                        self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>                        batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>num_inputs <span class="token operator">=</span> vocab_sizegru_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>GRU<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span><span class="token operator">//</span>lstm_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span>lstm_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> num_layers<span class="token punctuation">)</span><span class="token comment">#最后一个是隐藏层数</span>model <span class="token operator">=</span> d2l<span class="token punctuation">.</span>RNNModel<span class="token punctuation">(</span>gru_layer<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>d2l<span class="token punctuation">.</span>train_ch8<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>gru_cell <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>GRUCell<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span>    kernel_initializer<span class="token operator">=</span><span class="token string">'glorot_uniform'</span><span class="token punctuation">)</span>gru_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>gru_cell<span class="token punctuation">,</span> time_major<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    return_sequences<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_state<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>device_name <span class="token operator">=</span> d2l<span class="token punctuation">.</span>try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_device_namestrategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>OneDeviceStrategy<span class="token punctuation">(</span>device_name<span class="token punctuation">)</span><span class="token keyword">with</span> strategy<span class="token punctuation">.</span>scope<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    model <span class="token operator">=</span> d2l<span class="token punctuation">.</span>RNNModel<span class="token punctuation">(</span>gru_layer<span class="token punctuation">,</span> vocab_size<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span>d2l<span class="token punctuation">.</span>train_ch8<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> strategy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#RNN的训练</span><span class="token comment">#当使用顺序分区时， 我们只在每个迭代周期的开始位置初始化隐状态。 由于下一个小批量数据中的第个子序列样本 与当前第个子序列样本相邻， 因此当前小批量数据最后一个样本的隐状态， 将用于初始化下一个小批量数据第一个样本的隐状态。 这样，存储在隐状态中的序列的历史信息 可以在一个迭代周期内流经相邻的子序列。 然而，在任何一点隐状态的计算， 都依赖于同一迭代周期中前面所有的小批量数据， 这使得梯度计算变得复杂。 为了降低计算量，在处理任何一个小批量数据之前， 我们先分离梯度，使得隐状态的梯度计算总是限制在一个小批量数据的时间步内。</span><span class="token comment">#当使用随机抽样时，因为每个样本都是在一个随机位置抽样的， 因此需要为每个迭代周期重新初始化隐状态</span><span class="token comment">#@save</span><span class="token keyword">def</span> <span class="token function">train_epoch_ch8</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">,</span> device<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""训练网络一个迭代周期（定义见第8章）"""</span>    state<span class="token punctuation">,</span> timer <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> d2l<span class="token punctuation">.</span>Timer<span class="token punctuation">(</span><span class="token punctuation">)</span>    metric <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Accumulator<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 训练损失之和,词元数量</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> Y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>        <span class="token keyword">if</span> state <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> use_random_iter<span class="token punctuation">:</span>            <span class="token comment"># 在第一次迭代或使用随机抽样时初始化state</span>            state <span class="token operator">=</span> net<span class="token punctuation">.</span>begin_state<span class="token punctuation">(</span>batch_size<span class="token operator">=</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment"># state对于nn.GRU是个张量（即不参与更新）</span>                state<span class="token punctuation">.</span>detach_<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># state对于nn.LSTM或对于我们从零开始实现的模型是个张量</span>                <span class="token keyword">for</span> s <span class="token keyword">in</span> state<span class="token punctuation">:</span>                    s<span class="token punctuation">.</span>detach_<span class="token punctuation">(</span><span class="token punctuation">)</span>        y <span class="token operator">=</span> Y<span class="token punctuation">.</span>T<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        y_hat<span class="token punctuation">,</span> state <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>updater<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Optimizer<span class="token punctuation">)</span><span class="token punctuation">:</span>            updater<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            grad_clipping<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            updater<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            grad_clipping<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 因为已经调用了mean函数</span>            updater<span class="token punctuation">(</span>batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        metric<span class="token punctuation">.</span>add<span class="token punctuation">(</span>l <span class="token operator">*</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> math<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>metric<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#@save</span><span class="token keyword">def</span> <span class="token function">train_ch8</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> device<span class="token punctuation">,</span>              use_random_iter<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""训练模型（定义见第8章）"""</span>    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    animator <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Animator<span class="token punctuation">(</span>xlabel<span class="token operator">=</span><span class="token string">'epoch'</span><span class="token punctuation">,</span> ylabel<span class="token operator">=</span><span class="token string">'perplexity'</span><span class="token punctuation">,</span>                            legend<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'train'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xlim<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> num_epochs<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 初始化</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>        updater <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        updater <span class="token operator">=</span> <span class="token keyword">lambda</span> batch_size<span class="token punctuation">:</span> d2l<span class="token punctuation">.</span>sgd<span class="token punctuation">(</span>net<span class="token punctuation">.</span>params<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>    predict <span class="token operator">=</span> <span class="token keyword">lambda</span> prefix<span class="token punctuation">:</span> predict_ch8<span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> net<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> device<span class="token punctuation">)</span>    <span class="token comment"># 训练和预测</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        ppl<span class="token punctuation">,</span> speed <span class="token operator">=</span> train_epoch_ch8<span class="token punctuation">(</span>            net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">,</span> device<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'time traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            animator<span class="token punctuation">.</span>add<span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ppl<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'困惑度 </span><span class="token interpolation"><span class="token punctuation">&#123;</span>ppl<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>speed<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string"> 词元/秒 </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">str</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'time traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>机器翻译和</p><h4 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器-解码器"></a>编码器-解码器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#机器翻译的数据集是由源语言和目标语言的文本序列对组成的。 因此，我们需要一种完全不同的方法来预处理机器翻译数据集， 而不是复用语言模型的预处理程序。</span><span class="token keyword">def</span> <span class="token function">preprocess_nmt</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""预处理“英语－法语”数据集"""</span>    <span class="token keyword">def</span> <span class="token function">no_space</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> prev_char<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#空格的好处是切词的时候能把标点切成一个词</span>        <span class="token keyword">return</span> char <span class="token keyword">in</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">',.!?'</span><span class="token punctuation">)</span> <span class="token keyword">and</span> prev_char <span class="token operator">!=</span> <span class="token string">' '</span>    <span class="token comment"># 使用空格替换不间断空格，对utf-8的半角空格什么的都换成空格。</span>    <span class="token comment"># 使用小写字母替换大写字母</span>    text <span class="token operator">=</span> text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\u202f'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\xa0'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 在单词和标点符号之间插入空格</span>    out <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">' '</span> <span class="token operator">+</span> char <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> no_space<span class="token punctuation">(</span>char<span class="token punctuation">,</span> text<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> char           <span class="token keyword">for</span> i<span class="token punctuation">,</span> char <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token comment">#机器翻译中，我们更喜欢单词级词元化 （最先进的模型可能使用更高级的词元化技术）每个词元要么是一个词，要么是一个标点符号。</span><span class="token keyword">def</span> <span class="token function">tokenize_nmt</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> num_examples<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""词元化“英语－法语”数据数据集"""</span>    source<span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#换行符分样本</span>        <span class="token keyword">if</span> num_examples <span class="token keyword">and</span> i <span class="token operator">></span> num_examples<span class="token punctuation">:</span>            <span class="token keyword">break</span>        parts <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span><span class="token comment">#制表符分语言</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parts<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            source<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            target<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> source<span class="token punctuation">,</span> target还是看原文吧：https<span class="token punctuation">:</span><span class="token operator">//</span>zh<span class="token operator">-</span>v2<span class="token punctuation">.</span>d2l<span class="token punctuation">.</span>ai<span class="token operator">/</span>chapter_recurrent<span class="token operator">-</span>modern<span class="token operator">/</span>machine<span class="token operator">-</span>translation<span class="token operator">-</span><span class="token keyword">and</span><span class="token operator">-</span>dataset<span class="token punctuation">.</span>html<span class="token comment">#编码器和解码器，NotImplementedError有点cool，shi'pe</span><span class="token keyword">class</span> <span class="token class-name">Encoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""编码器-解码器架构的基本编码器接口"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Encoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> NotImplementedError        <span class="token keyword">class</span> <span class="token class-name">Decoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""编码器-解码器架构的基本解码器接口"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Decoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">init_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#用于将编码器的输出（enc_outputs）转换为编码后的状态。</span>        <span class="token keyword">raise</span> NotImplementedError    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#X是额外的输入</span>        <span class="token keyword">raise</span> NotImplementedError        <span class="token keyword">class</span> <span class="token class-name">EncoderDecoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""编码器-解码器架构的基类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> encoder<span class="token punctuation">,</span> decoder<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>EncoderDecoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>encoder <span class="token operator">=</span> encoder        self<span class="token punctuation">.</span>decoder <span class="token operator">=</span> decoder<span class="token comment">#在前向传播中，编码器的输出用于生成编码状态， 这个状态又被解码器作为其输入的一部分。</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_X<span class="token punctuation">,</span> dec_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        enc_outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>enc_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>        dec_state <span class="token operator">=</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>init_state<span class="token punctuation">(</span>enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>dec_X<span class="token punctuation">,</span> dec_state<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>seq to seq太难了，看原文吧：<a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html">https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#decoder最后</span> <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 输出'X'的形状：(batch_size,num_steps,embed_size)</span>        X <span class="token operator">=</span> self<span class="token punctuation">.</span>embedding<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 广播context，使其具有与X相同的num_steps</span>        context <span class="token operator">=</span> state<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#相当于对每个时间步，都加了一个c初始化</span>        X_and_context <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        output<span class="token punctuation">,</span> state <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>X_and_context<span class="token punctuation">,</span> state<span class="token punctuation">)</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># output的形状:(batch_size,num_steps,vocab_size)</span>        <span class="token comment"># state[0]的形状:(num_layers,batch_size,num_hiddens)</span>        <span class="token keyword">return</span> output<span class="token punctuation">,</span> state    <span class="token keyword">class</span> <span class="token class-name">MaskedSoftmaxCELoss</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""带遮蔽的softmax交叉熵损失函数"""</span>    <span class="token comment"># pred的形状：(batch_size,num_steps,vocab_size)</span>    <span class="token comment"># label的形状：(batch_size,num_steps)</span>    <span class="token comment"># valid_len的形状：(batch_size,)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pred<span class="token punctuation">,</span> label<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span><span class="token punctuation">:</span>        weights <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>label<span class="token punctuation">)</span>        weights <span class="token operator">=</span> sequence_mask<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>reduction<span class="token operator">=</span><span class="token string">'none'</span>        unweighted_loss <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>            pred<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token comment">#pytorch要求把那个softmax处理的那个维度放中间，可能for 效率</span>        weighted_loss <span class="token operator">=</span> <span class="token punctuation">(</span>unweighted_loss <span class="token operator">*</span> weights<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> weighted_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#带批量矩阵乘法</span>X <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Y <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>bmm<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">.</span>shape <span class="token operator">==</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#torch的rand函数和sort函数</span>n_train <span class="token operator">=</span> <span class="token number">50</span>  <span class="token comment"># 训练样本数</span>x_train<span class="token punctuation">,</span> origin_seq <span class="token operator">=</span> torch<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n_train<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>   <span class="token comment"># 排序后的训练样本</span>x_traintensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0840</span><span class="token punctuation">,</span> <span class="token number">0.1345</span><span class="token punctuation">,</span> <span class="token number">0.3510</span><span class="token punctuation">,</span> <span class="token number">0.5656</span><span class="token punctuation">,</span> <span class="token number">0.8183</span><span class="token punctuation">,</span> <span class="token number">0.9208</span><span class="token punctuation">,</span> <span class="token number">1.1907</span><span class="token punctuation">,</span> <span class="token number">1.3527</span><span class="token punctuation">,</span> <span class="token number">1.4449</span><span class="token punctuation">,</span>        <span class="token number">1.5247</span><span class="token punctuation">,</span> <span class="token number">1.5696</span><span class="token punctuation">,</span> <span class="token number">1.7349</span><span class="token punctuation">,</span> <span class="token number">1.8324</span><span class="token punctuation">,</span> <span class="token number">1.8558</span><span class="token punctuation">,</span> <span class="token number">1.8864</span><span class="token punctuation">,</span> <span class="token number">1.9879</span><span class="token punctuation">,</span> <span class="token number">2.0112</span><span class="token punctuation">,</span> <span class="token number">2.0115</span><span class="token punctuation">,</span>        <span class="token number">2.0157</span><span class="token punctuation">,</span> <span class="token number">2.1903</span><span class="token punctuation">,</span> <span class="token number">2.2141</span><span class="token punctuation">,</span> <span class="token number">2.2400</span><span class="token punctuation">,</span> <span class="token number">2.3800</span><span class="token punctuation">,</span> <span class="token number">2.4314</span><span class="token punctuation">,</span> <span class="token number">2.5796</span><span class="token punctuation">,</span> <span class="token number">2.6966</span><span class="token punctuation">,</span> <span class="token number">2.7665</span><span class="token punctuation">,</span>        <span class="token number">2.8231</span><span class="token punctuation">,</span> <span class="token number">2.9374</span><span class="token punctuation">,</span> <span class="token number">3.0170</span><span class="token punctuation">,</span> <span class="token number">3.0468</span><span class="token punctuation">,</span> <span class="token number">3.1662</span><span class="token punctuation">,</span> <span class="token number">3.2001</span><span class="token punctuation">,</span> <span class="token number">3.2120</span><span class="token punctuation">,</span> <span class="token number">3.2182</span><span class="token punctuation">,</span> <span class="token number">3.2420</span><span class="token punctuation">,</span>        <span class="token number">3.5141</span><span class="token punctuation">,</span> <span class="token number">3.5614</span><span class="token punctuation">,</span> <span class="token number">3.5880</span><span class="token punctuation">,</span> <span class="token number">3.6311</span><span class="token punctuation">,</span> <span class="token number">3.7026</span><span class="token punctuation">,</span> <span class="token number">3.8288</span><span class="token punctuation">,</span> <span class="token number">4.3208</span><span class="token punctuation">,</span> <span class="token number">4.3390</span><span class="token punctuation">,</span> <span class="token number">4.5670</span><span class="token punctuation">,</span>        <span class="token number">4.6363</span><span class="token punctuation">,</span> <span class="token number">4.6682</span><span class="token punctuation">,</span> <span class="token number">4.7314</span><span class="token punctuation">,</span> <span class="token number">4.7663</span><span class="token punctuation">,</span> <span class="token number">4.9927</span><span class="token punctuation">]</span><span class="token punctuation">)</span>origin_seqtensor<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span>        <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形状详见<a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-scoring-functions.html">10.3</a>加性注意力。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#查询、键和值的形状为（批量大小，数量（如n个q），特征大小），经过转换后👇</span><span class="token comment">#queries的形状：(batch_size，查询的个数，1，num_hidden)</span><span class="token comment">#key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span><span class="token comment">#queires和key被处理成scores 形状：(batch_size，查询的个数，“键-值”对的个数)</span><span class="token comment">#values的形状：(batch_size，“键－值”对的个数，值的维度)</span><span class="token comment">#返回的结果是torch.bmm(scores,values) scores还得经历掩码softmax和dropout，输出的形状为（批量大小，查询的步数，值的维度）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="李宏毅"><a href="#李宏毅" class="headerlink" title="李宏毅"></a>李宏毅</h2><p>HW1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">device <span class="token operator">=</span> <span class="token string">'cuda'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>config <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'seed'</span><span class="token punctuation">:</span> <span class="token number">5201314</span><span class="token punctuation">,</span>      <span class="token comment"># Your seed number, you can pick your lucky number. :)</span>    <span class="token string">'select_all'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>   <span class="token comment"># Whether to use all features.</span>    <span class="token string">'valid_ratio'</span><span class="token punctuation">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span>   <span class="token comment"># validation_size = train_size * valid_ratio</span>    <span class="token string">'n_epochs'</span><span class="token punctuation">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>     <span class="token comment"># Number of epochs.            </span>    <span class="token string">'batch_size'</span><span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>     <span class="token string">'learning_rate'</span><span class="token punctuation">:</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span>                  <span class="token string">'early_stop'</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>    <span class="token comment"># If model has not improved for this many consecutive epochs, stop training.     </span>    <span class="token string">'save_path'</span><span class="token punctuation">:</span> <span class="token string">'./models/model.ckpt'</span>  <span class="token comment"># Your model will be saved here.</span><span class="token punctuation">&#125;</span><span class="token comment">#tensorboard</span><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterwriter <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"runs2"</span><span class="token punctuation">)</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span>comment<span class="token operator">=</span><span class="token string">"this_is_ex_version"</span><span class="token punctuation">)</span><span class="token comment">#只能用默认的runs，会在子文件夹名字后面加comment</span><span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Loss/train'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">,</span>new_style<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment">#会分一个Loss区，里面俩张图</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Loss/test'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">,</span>new_style<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Accuracy/train'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Accuracy/test'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#默认runs/</span>r <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#会生成ab_sinx/xcosx/tanx三个文件夹,会划到ab区的一张图里</span>    writer<span class="token punctuation">.</span>add_scalars<span class="token punctuation">(</span><span class="token string">'ab'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'xsinx'</span><span class="token punctuation">:</span>i<span class="token operator">*</span>np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token string">'xcosx'</span><span class="token punctuation">:</span>i<span class="token operator">*</span>np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token string">'tanx'</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span>load_ext tensorboard<span class="token operator">%</span>tensorboard <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>路径，如果打开了没有子文件夹的文件夹，event名字是'<span class="token punctuation">.</span><span class="token comment">#直方图、等例子直接查文档吧：https://pytorch.org/docs/stable/tensorboard.html</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">#生成1000个随机数</span>    writer<span class="token punctuation">.</span>add_histogram<span class="token punctuation">(</span><span class="token string">'distribution centers'</span><span class="token punctuation">,</span> x <span class="token operator">+</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        <span class="token keyword">import</span> csv<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">def</span> <span class="token function">save_pred</span><span class="token punctuation">(</span>preds<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">''' Save predictions to specified file '''</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>        writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>        writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'tested_positive'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> p <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">:</span>            writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> p<span class="token punctuation">]</span><span class="token punctuation">)</span>model <span class="token operator">=</span> My_Model<span class="token punctuation">(</span>input_dim<span class="token operator">=</span>x_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>config<span class="token punctuation">[</span><span class="token string">'save_path'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>preds <span class="token operator">=</span> predict<span class="token punctuation">(</span>test_loader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> device<span class="token punctuation">)</span> save_pred<span class="token punctuation">(</span>preds<span class="token punctuation">,</span> <span class="token string">'pred.csv'</span><span class="token punctuation">)</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;李沐&quot;&gt;&lt;a href=&quot;#李沐&quot; class=&quot;headerlink&quot; title=&quot;李沐&quot;&gt;&lt;/a&gt;李沐&lt;/h2&gt;&lt;p&gt;tensorflow的tensor没有reshape，必须&lt;code&gt;tf.reshape(x,(3,4))&lt;/code&gt; torch牛&lt;/</summary>
      
    
    
    
    <category term="DL" scheme="https://darren-dong.com/categories/DL/"/>
    
    
  </entry>
  
  <entry>
    <title>李沐-动手学深度学习</title>
    <link href="https://darren-dong.com/2021/12/20/%E6%9D%8E%E6%B2%901/"/>
    <id>https://darren-dong.com/2021/12/20/%E6%9D%8E%E6%B2%901/</id>
    <published>2021-12-20T07:08:21.000Z</published>
    <updated>2022-05-09T05:20:01.251Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【如今，工程远远走在了理论的前面，但迟早会有一天有人提出新的理论框架来解释它】</strong></p><p><a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/index.html">https://zh-v2.d2l.ai/chapter_attention-mechanisms/index.html</a></p><p><a href="https://d2l.ai/chapter_natural-language-processing-pretraining/index.html">https://d2l.ai/chapter_natural-language-processing-pretraining/index.html</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Welcome！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505790.jpeg" alt="Snipaste_2022-01-07_18-46-44" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505791.png" alt="image-20220107185027758" style="zoom:50%;" /></p><p>机器学习更关心计算，统计学习更关心模型。深度学习比机器学习更加计算。</p><p>李沐说大企业主要分这三类:</p><p>领域专家了解一些机器学习，但更看重怎么用模型辅助自己的专业知识。</p><p>数据科学家关注怎么处理数据成模型可用的数据（特征工程），还有构造模型，把领域专家的认知翻译成机器学习的任务。</p><p>数据科学家vsAI：数据科学家俩条路，一个是研究很多领域，研究怎么得到模型；深的走就是成为领域研究很深的人，即AI专家</p><p>可解释性略谈：人是不是可理解这个模型；它为什么工作；什么时候不工作；怎样会出现偏差之类的。</p><p>深度学习的一个关键优势是它<u>不仅取代了传统学习管道末端的浅层模型，而且还取代了劳动密集型的特征工程过程。</u><br>此外，通过取代大部分特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多界限，为解决各种问题提供了一套统一的工具。</p><h3 id="调参术"><a href="#调参术" class="headerlink" title="调参术"></a><em>调参术</em></h3><p><strong>原则</strong>：首先保证你的模型足够大，参数够多，保证了有前途，再通过各种手段降低模型容量避免过拟合。</p><p>李沐：实际中调参其实没有那么重要，不建议过度调参，这可能会overfit到目前的数据，实际场景中你可能会有越来越多的数据。（除非竞赛）</p><p>较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</p><p>当你调到一个比较好的参数点时，可以上下修改一下，如果结果剧烈波动，可能就调在了噪音上，泛化性不好。</p><p>少量高质量数据，可能有个百倍的换算。</p><p>通常来说准确率还是个比较主观的东西，你也不能知道你收集这个数据能达到多高准确，只要用户用的好。 用户心理可能有个阈值，低于它，体验就会很差，高过它，够用就行了。</p><p>选模型可以参考：<a href="https://cv.gluon.ai/model_zoo/detection.html">https://cv.gluon.ai/model_zoo/detection.html</a> 选择性能比较合适的，每个领域都有一些模型。</p><hr><p>选损失函数：通过研究函数形状、梯度形状，尤其离原点远近对比来分析损失函数特性</p><p>交叉熵是一个<strong>衡量两个概率分布之间差异</strong>的很好的度量，它测量给定模型编码数据所需的比特数。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061849327.png" alt="image-20220222193812191" style="zoom: 25%;" /><p>绿：似然函数  蓝：损失函数  橙：导数</p><p>Huber结合了L1和L2范数，既不会在数值较大处使得梯度过大，也不会在较小处产生不稳定的突变。</p><p>全连接最好是<u>慢慢的减少每层的大小</u>，压小会损失信息，但有时候先压小一些再扩张可以deal with overfitting【靠手感哈哈】</p><p>激活函数的种类相对别的超参数没那么重要。</p><p>batch太小不适合并行来最大利用计算资源，太大会导致内存消耗（跑不了），浪费时间。但是batchsize较小时会带来噪音，噪音对神经网络是好事情，<u>有助于其泛化性</u>。</p><p>一般在没有足够多数据的时候，都使用K-折交叉验证。【深度学习用的不多，传统的用的多】</p><p><u>数据比例要结合真实情况，要是是因为采集而失衡，就要通过修改权重等手段处理。</u></p><hr><p>模型复杂性由什么构成是一个复杂的问题。 一个模型是否能很好地泛化取决于很多因素。 例如，具有更多参数的模型可能被认为更复杂， 参数有更大取值范围的模型可能更为复杂。 通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂</p><p><strong>模型容量</strong>：拟合各种函数的能力，高容量可以记住更多的数据【主要因素：参数个数，参数值的取值范围】</p><p><strong>数据复杂度</strong>：也很难衡量，一种直观的感觉和相对的，一些影响因素：</p><p>样本个数；每个样本的元素个数；时间、空间结构；多样性</p><blockquote><p>泛化性和灵活性之间的这种基本权衡被描述为<em>偏差-方差权衡</em>（bias-variance tradeoff）。 线性模型有很高的偏差：它们只能表示一小类函数。 然而，这些模型的方差很低</p><p>深度神经网络位于偏差-方差谱的另一端。 与线性模型不同，神经网络并不局限于单独查看每个特征，而是学习<em>特征之间的交互</em></p><p>即使我们有比特征多得多的样本，深度神经网络也有可能过拟合。</p><p>深度网络的泛化性质令人费解，而<strong>这种泛化性质的数学基础仍然是悬而未决的研究问题。</strong> </p></blockquote><hr><p>随机初始化⽅法，对于中等难度的问题，这种⽅法通常很有效</p><p>初始化⽅案的选择在神经⽹络学习中起着举⾜轻重的作⽤，它对保持数值稳定性⾄关重要。此外，这些初始化⽅案的选择可以与⾮线性激活函数的选择有趣的结合在⼀起。我们选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快。糟糕选择可能会导致我们在训练时遇到梯度爆炸或梯度消失。</p><p>不必过度迷信初始化，只要一开始不出问题，初始化是不太会影响后面的问题的。</p><p>Adam优化器的主要吸引力在于它<u>对初始学习率不那么敏感</u>。</p><p>如果预测的值的范围很大，RMSE 会被一些大的值主导。即使你很多小的值预测准了，但是有一个非常大的值预测的不准确，RMSE 就会很大。 先取 log 再求 RMSE（RMLSE），可以稍微解决这个问题。RMSE 一般对于固定的平均分布的预测值才合理。</p><hr><h4 id="Conv"><a href="#Conv" class="headerlink" title="Conv"></a>Conv</h4><p>核大小比较重要，填充一般取默认的，步幅取决于你的模型复杂度要控制在什么程度</p><p>步幅和填充是网络架构的一部分，我们选择某个网络比如“Resnet”，它就告诉了你该如何设置这些</p><blockquote><p>一般很少手写神经网络，都用经典的，Resnet有个系列，除非你的输入特别不一样</p><p>网络结构设计中也有很多因素要平衡，而且，网络结构其实没有想象那么重要。</p><p>一般work里都是参考经典的网络做架构。</p></blockquote><p>汇聚（pooling）层，它具有双重⽬的：降低卷积层对位置的敏感性，同时降低对空间降采样表⽰的敏感性。</p><p>【现在池化层用的越来越少了，李沐：以前池化也用来降低计算量，现在需求小，而数据增强和池化层降低敏感性的功能重复了。】</p><p>大图片只能用CNN，MLP和CNN都能用就用简单的MLP试试，<em>调的动就用简单的MLP</em>。</p><p>加入全局池化层，<u>降低了模型复杂度，提高了泛化性，但是收敛会变慢</u>，原来的全连接层比较复杂，强大了，能很快的收敛拟合。</p><p><strong>Batch</strong>归一化含几重噪音，因为标准偏差的缩放和减去均值带来的额外噪音。所以类似于dropout，Batch归一化有轻微的正则化效果，你可以将<u>Batch归一化和dropout一起使用</u>，如果你想得到dropout更强大的正则化效果。</p><p>应用了较大的mini-batch，比如说，你用了512而不是64，通过应用较大的mini-batch会减少了噪音，减少正则化效果。</p><p>不要把Batch归一化当作正则化。好处是可以加速收敛，学习率可以调大一些，但一般不改变模型精度。</p><p>先跟着内存调batch size（增加直到每秒处理样本数不再增大），再调学习率，框架都差不多，epoch调大点，多了就停下。</p><p>==验证集准确度波动较大，一般是learning-rate的原因==，batchsize小，你lr就不能太大。<br>【从泛化性考虑，batch-size小，你一次更新的随机噪声多，就不能一次走太远。】</p><p>学习率对均值和方差敏感。</p><p>batch-norm和不断地调学习率有异曲同工之处，但是学习率不知道哪里调大哪里调小，不如BN方便。</p><p><strong>微调</strong></p><p>成员变量<code>output</code>的参数是随机初始化的，通常需要更高的学习率才能从头开始训练。 假设<code>Trainer</code>实例中的学习率为η，我们将成员变量<code>output</code>中参数的学习率设置为10η。</p><p>找pretrained的model时也得找相应领域的，判断癌症的就找医学领域的sei。</p><p>微调对学习率不敏感，可以选一个比较小的就行了，比如沐神用的1e^-5</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p><strong>矩阵计算（求导）</strong></p><p>亚导数，将导数拓展到不可微，便于计算机处理</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505793.png" alt="image-20220109191041840" style="zoom:50%;" /><p>这个是分子布局法，在x是标量时有体现。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061850566.png" alt="image-20220221200301199" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061850084.png" alt="image-20220221200600219" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091302041.png" alt="image-20220221200705937" style="zoom:25%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091302470.png" alt="image-20220221200943848" style="zoom:30%;" /><p>虽然用不到，但得大概明白<u>形状是咋变化</u>的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309303.png" alt="image-20220221201551897" style="zoom:33%;" /><p>机器学习不关心p的问题，只关心np问题，所以不必纠结最优解，大部分情况也不是凸函数:joy:</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505795.png" alt="image-20220110175306257" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505796.png" alt="image-20220110175318506" style="zoom:25%;" /></p><p>上面两个例子是向量、矩阵求导的例子</p><hr><p>【<strong>计算图</strong>】</p><p>在框架中，我们用的是自动求导【<strong>计算图</strong>】。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505797.png" alt="image-20220109200357064" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505798.png" alt="image-20220109200610990" style="zoom:25%;" /></p><p>显式构造需要自己定义中间变量等。隐式则会根据你的计算流程【包括python控制流】自动生成计算图，不用操心。</p><p>Pytorch用的是隐式构造（更慢），tensorflow和数学上都用的是显式构造。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505799.png" alt="image-20220109204358173" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505800.png" alt="image-20220109204643611" style="zoom:25%;" /></p><p>反向传播是拿内存换时间，因为需要存储正向的中间结果！果然时空不可兼得。【这也是内存爆炸祸源】</p><p>一般深度学习里很少用向量函数求导，都是<strong>标量求导</strong>，所以需要用sum函数处理后，再进行backward（）；如果维数特别多，求导后会变成非常巨大的张量矩阵，因此loss（）函数也常设置为标量。<br>虽然支持高维向量求导，但是很慢，而且一般用不到。</p><p><u>需要反向传播的数值要为浮点型,不可以为整数</u></p><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>绝对值和平方损失没太大的区别，一开始用平方是因为方便求导。</p><p>损失除以n变成平均是防止样本规模影响学习率的调整，不然又多一个超参数，还不正交。</p><p>样本大小不是批量的整数倍：丢弃、从下一个epoch补全、更改除数。</p><p>确认你读数据的速度要比模型训练的快，这是个常见的性能瓶颈。</p><h4 id="SoftMax"><a href="#SoftMax" class="headerlink" title="SoftMax"></a>SoftMax</h4><blockquote><p>通过将softmax和交叉熵结合在一起，可以避免反向传播过程中可能会困扰我们的数值稳定性问题。</p><p>因为softmax公式里的exp和交叉熵公式里的log可以相互抵消，避免做log和exp运算时出现inf和Nan</p><p>我们没有将softmax概率传递到损失函数中， 而是在交叉熵损失函数中传递未规范化的预测，并同时计算softmax及其对数， 这是一种类似<a href="https://en.wikipedia.org/wiki/LogSumExp">“LogSumExp技巧”</a>的聪明方式。</p></blockquote><p>Mnist手写数字识别（10类）          ImageNet自然物体分类（1000类）</p><p>从回归到多类分类——无校验比例：要求预测的最大可能选择比其他的有显著差距</p><p>从回归到多类分类——校验比例：就是多项逻辑斯蒂，也称softmax，输出的是匹配的概率。</p><blockquote><p>如果把熵$H(P)$想象为“知道真实概率的人所经历的惊异程度”，那么什么是交叉熵？交叉熵<em>从</em>$P$<em>到</em>$Q$，记为$H(P, Q)$。</p><p>你可以把交叉熵想象为“主观概率为$Q$的观察者在看到根据概率$P$生成的数据时的预期惊异”。<br>当$P=Q$时，交叉熵达到最低。在这种情况下，从$P$到$Q$的交叉熵是$H(P, P)= H(P)$。</p><p>简而言之，我们可以从两方面来考虑交叉熵分类目标：<br>（i）最大化观测数据的似然；（ii）最小化传达标签所需的惊异。</p></blockquote><p>sofxmax输入是向量，再把图片拉长成向量时会损失许多空间信息，而卷积神经网络则不会。</p><p><code>.numel()</code>直接获取tensor中元素个数</p><p>定义了展平层（flatten），来调整网络输入的形状<code>nn.Flatten()</code>第零维度保留，其他全部压到第一维。</p><p><code>net.apply(f)</code>深度优先遍历并应用这个函数。</p><p>默认的误差其实是softlabel，把正确的那一类概率记作0.9，其他的是$\frac{1}{n-1}$，这样就有逼近的可能，而不是要趋于无穷。</p><p>可以认为logistic是softmax的二分类特例。</p><p>代码中有部分冗余，因为pytorch版本或历史原因！</p><p>在<code>net.eval()</code>测评模式下，就不会算梯度相关的东西了，效率更好</p><h4 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>感知机其实等价于使用批量大小为1的梯度下降，而损失函数为<br>$$<br>l(y,x,w) = max(0,-y\langle w,x \rangle)<br>$$<br>当年发现感知机不能拟合XOR，是“第一次AI寒冬”，导致很多人转行哈哈，但后来有了多层感知机。【多个线性结合】</p><p>【深度学习在2014之前好像都是旧东西重命名哈哈哈】</p><blockquote><ul><li>figsize: 指定figure的宽和高，单位为英寸</li><li>dpi: 指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80, 1英寸等于2.5cm, A4 纸是 21*30cm的纸张</li></ul></blockquote><p>最好是慢慢的减少每层的大小，压小会损失信息，但有时候<u>先压小一些再扩张可以deal with overfitting</u>【没有太多科学，靠手感哈哈】</p><p><code>torch.relu()/sigmoid()/tanh()</code></p><p>沐神：所以不用SVM用mlp，其实是因为效果不好可以很容易换到CNN、RNN，代码结构变动小很多。</p><p>SVM对超参数不敏感，而且更容易优化，用起来更简单，有很漂亮的数学理论。现在也好，但是MLP改代码实在方便。<br>SVM在参数较多时，计算麻烦，还有可调性不强</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303771.png" alt="image-20220222225022487"></p><p>这俩效果能近似，但是左边的不好学，容易over fitting，右边的就叫“深层”，而且数量之上是指数倍增的。</p><p>激活函数的种类相对别的超参数没那么重要。</p><p>要保持鲁棒性，数据受干扰时，结果分类应该不变，这也是个很重要的问题。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>由于泛化是机器学习中的基本问题， 许多数学家和理论家毕生致力于研究描述这一现象的形式理论。<br>在<a href="https://en.wikipedia.org/wiki/Glivenko%E2%80%93Cantelli_theorem">同名定理（eponymous theorem）</a>中， 格里文科和坎特利推导出了训练误差收敛到泛化误差的速率。<br>在一系列开创性的论文中， <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory">Vapnik和Chervonenkis</a> 将这一理论扩展到更一般种类的函数。 这项工作为统计学习理论奠定了基础。</p><p>在接下来的章节中，我们将讨论因违背独立同分布假设而引起的问题。</p><p><strong>原则</strong>：首先保证你的模型足够大，参数够多，保证了有前途，再通过各种手段降低模型容量避免过拟合。</p><p>一般在没有足够多数据的时候，都使用K-折交叉验证。【深度学习用的不多哈哈，传统的用的多】</p><p>K折三种做法：选出的超参数在整个数据集全部重算；或者把最好的所有的模型拿下来，以后就用这个算，结果取均值【模型稳定性好】；要么就选其中的一个，比如最好的模型。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304281.png" alt="image-20220223130221812" style="zoom:50%;" /><p>模型复杂性由什么构成是一个复杂的问题。 一个模型是否能很好地泛化取决于很多因素。 例如，具有更多参数的模型可能被认为更复杂， 参数有更大取值范围的模型可能更为复杂。 通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂</p><p><strong>模型容量</strong>：拟合各种函数的能力，高容量可以记住更多的数据【<u>主要因素：参数个数，参数值的取值范围</u>】</p><p>VC维：统计学习理论的核心思想</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304368.png" alt="image-20220223131106065" style="zoom:50%;" /><p><strong>数据复杂度</strong>：也很难衡量，一种直观的感觉和相对的，一些影响因素：</p><p>样本个数；每个样本的元素个数；时间、空间结构；多样性</p><p>这个总结，揭露了更深的理论。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304195.png" alt="image-20220223131305180" style="zoom:50%;" /><p>我们很难比较本质上不同大类的模型之间（例如，决策树与神经网络）的复杂性。 就目前而言，一条简单的经验法则相当有用： 统计学家认为，能够轻松解释任意事实的模型是复杂的， 而表达能力有限但仍能很好地解释数据的模型可能更有现实用途。</p><blockquote><p>沐神：神经网络的最大优点是——它更像一种<strong>语言</strong>。可编程性特别好，能解决的问题也很多<br>CNN、RNN通过更好的结构辅助网络更方便的训练出数据的模式，所以是尽量用神经网络的方法去描述数据的特性！【比如CNN是为了告诉神经网络，我觉得这个数据有空间信息】</p><p>很多经典的论文一开始找的理由都是错的。</p><p>艺术：我不知道为什么，但这样做好看。神经网络就有50%是艺术xs</p></blockquote><p>整个工科其实背后逻辑差不多。不如就学现在流行的东西【现在是深度学习】，以不变应万变。</p><p>将随机森林结合进深度学习比较少，参数不好传。</p><p><u>数据要结合真实情况，如果符合现实情况，那比例如何都没问题，要是是因为采集而失衡，就要通过修改权重等手段处理。</u></p><h4 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h4><p>常用的控制过拟合的方法【即缩减每个参数的取值范围以减小模型容量】。L2正则，dropout都是</p><p>最离谱就是直接强行约束$||w||^2 \leq \theta$，但不怎么用，用的是等价形式——L2正则。</p><p>命名原因，在更新参数时w相当于多乘了个参数$(1-\eta \lambda)$</p><p>因为数据中存在噪音，在学习的时候会增加参数的震荡？所以学到的参数可能比实际的偏大，加入罚项拉回来？反正就那个意思</p><h4 id="dropout【暂退法】"><a href="#dropout【暂退法】" class="headerlink" title="dropout【暂退法】"></a>dropout【暂退法】</h4><p><u>效果一般比权重衰减更好。但只能用在全连接层</u>【注意每一次丢弃的结果是不一样的，不是永久丢弃，是暂退】</p><p>思想来自随机森林，但是从实验上来看，起到的作用和正则很像而非投票。</p><p>泛化性和灵活性之间的这种基本权衡被描述为<em>偏差-方差权衡</em>（bias-variance tradeoff）。 线性模型有很高的偏差：它们只能表示一小类函数。 然而，这些模型的方差很低</p><p>深度神经网络位于偏差-方差谱的另一端。 与线性模型不同，神经网络并不局限于单独查看每个特征，而是学习<em>特征之间的交互</em></p><p>即使我们有比特征多得多的样本，深度神经网络也有可能过拟合。</p><p>深度网络的泛化性质令人费解，而<strong>这种泛化性质的数学基础仍然是悬而未决的研究问题。</strong> </p><p>经典泛化理论认为，为了缩小训练和测试性能之间的差距，应该以简单的模型为目标。 简单性以较小维度的形式展现</p><p>简单性的另一个角度是平滑性，即函数不应该对其输入的微小变化敏感。<br>$$<br>\begin{aligned}<br>h’ =<br>\begin{cases}<br>    0 &amp; \text{ 概率为 } p \<br>    \frac{h}{1-p} &amp; \text{ 其他情况}<br>\end{cases}<br>\end{aligned}<br>$$<br>此模型期望不变。</p><p>在代码实现中有个效率技巧：<u>做乘法（用掩码）比用索引（比如布尔）来的快</u>，用一个float把布尔矩阵转成0.0，1.0矩阵。</p><p>dropout效果又好又好调，mlp现在用的越来越少了。</p><p>learning rate主要对期望、方差敏感。</p><h4 id="数值稳定性"><a href="#数值稳定性" class="headerlink" title="数值稳定性"></a>数值稳定性</h4><p>现在<strong>tanh</strong>函数在所有场合都优于<strong>sigmoid</strong>函数，但这俩再绝对值大时梯度消失，除非二分类，就在输出用一个，不然还是relu。</p><p>由于计算性能需要，一般GPU用16位浮点数，也就是[6e^-5,6e^4]</p><p>爆炸和消失的问题是在反传的过程中发生的</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309646.png" alt="image-20220223190716900" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309500.png" alt="image-20220223190922252" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309569.png" alt="image-20220223191357540" style="zoom:30%;" /></p><p><strong>权重初始化</strong></p><p>随机初始化⽅法，对于中等难度的问题，这种⽅法通常很有效</p><p>初始化⽅案的选择在神经⽹络学习中起着举⾜轻重的作⽤，它对保持数值稳定性⾄关重要。此外，这些初始化⽅案的选择可以与⾮线性激活函数的选择有趣的结合在⼀起。我们选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快。糟糕选择可能会导致我们在训练时遇到梯度爆炸或梯度消失。</p><p>深度学习框架通常实现十几种不同的启发式⽅法。此外，参数初始化⼀直是深度学习基础研究的热点领域。其中包括专⻔⽤于参数绑定（共享）、超分辨率、序列模型和其他情况的启发式算法。例如，Xiao等⼈演示了通过使⽤精心计的初始化⽅法 [Xiao et al., 2018]，可以⽆须架构上的技巧而训练10000层神经⽹络的可能性。</p><p>==Xavier==：沐神从均值和方差不变推导，得出了不可兼得，所以折中。</p><p>每层的W初始化<br>$$<br>\left(-\sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}, \sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}\right)<br>$$</p><p>模型一炸，准确率就变成50%左右了哈哈</p><p>沐神：虽然深度学习对数学要求比较低，但你还是得学，不然很多东西做不了，理解不了，光会写代码也没用。</p><p>高维损失的“可视化”，目前虽然有一些工作，但还比较原始。</p><p>数值被压缩到某个区间，数学上是不会影响到模型的表达性的，因为是总体的偏移。</p><p>不必过度迷信初始化，只要一开始不出问题，初始化是不太会影响后面的问题的。</p><p>pytorch<em>默认初始化</em>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> init<span class="token comment">#define the initial function to init the layer's parameters for the network</span><span class="token keyword">def</span> <span class="token function">weigth_init</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span><span class="token punctuation">:</span>        init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">)</span><span class="token punctuation">:</span>        m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fill_<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span><span class="token punctuation">:</span>        m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">)</span>        m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分布偏移"><a href="#分布偏移" class="headerlink" title="分布偏移"></a>分布偏移</h4><p>首先，一旦模型开始根据鞋类做出决定，顾客就会理解并改变他们的行为。 不久，所有的申请者都会穿牛津鞋，而信用度却没有相应的提高。 总而言之，机器学习的许多应用中都存在类似的问题： 通过将基于模型的决策引入环境，我们可能会破坏模型。</p><p>协变量偏移、标签便宜、概念偏移。</p><p>在另一些情况下，标签偏移和协变量偏移假设可以同时成立。 例如，当标签是确定的，即使𝑦导致𝐱，协变量偏移假设也会得到满足。 有趣的是，在这些情况下，<u>使用基于标签偏移假设的方法通常是有利的</u>。 这是因为这些方法倾向于包含看起来像标签（通常是低维）的对象， 而不是像输入（通常是高维的）对象。</p><p>当分布变化缓慢并且模型没有得到充分更新时，就会出现更微妙的情况： <em>非平稳分布</em>（nonstationary distribution）</p><p><strong>偏移纠正</strong></p><p>在相应的假设条件下，可以在测试时检测并纠正协变量偏移和标签偏移。在测试时，不考虑这种偏移可能会成为问题。</p><p>概念偏移很难用原则性的方式解决。 例如，在一个问题突然从“区分猫和狗”偏移为“区分白色和黑色动物”的情况下， 除了从零开始收集新标签和训练，别无妙方。 幸运的是，在实践中这种极端的偏移是罕见的。 相反，通常情况下，概念的变化总是缓慢的。 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304391.png" alt="image-20220224222149316" style="zoom: 80%;" /><p>标签偏移的一个好处是，如果我们在源分布上有一个相当好的模型， 那么我们可以得到对这些权重的一致估计，而不需要处理周边的其他维度。 在深度学习中，输入往往是高维对象（如图像），而标签通常是低维（如类别）。</p><p>为了估计目标标签分布，我们首先采用性能相当好的现成的分类器（通常基于训练数据进行训练）， 并使用验证集（也来自训练分布）计算其混淆矩阵。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304004.png" alt="image-20220224223318620" style="zoom:80%;" /><p><strong>环境</strong></p><p>在某些情况下，环境可能会记住自动操作并以令人惊讶的方式做出响应。在构建模型时，我们必须考虑到这种可能性，并继续监控实时系统，并对我们的模型和环境以意想不到的方式纠缠在一起的可能性持开放态度。</p><p>环境变化的速度和方式在很大程度上决定了我们可以采用的算法类型。 例如，如果我们知道事情只会缓慢地变化， 就可以迫使任何估计也只能缓慢地发生改变。 如果我们知道环境可能会瞬间发生变化，但这种变化非常罕见， 我们就可以在使用算法时考虑到这一点。 当一个数据科学家试图解决的问题会随着时间的推移而发生变化时， 这些类型的知识至关重要。</p><blockquote><p><em>伦理</em></p><p>最后，重要的是，当你部署机器学习系统时， 你不仅仅是在优化一个预测模型， 而你通常是在提供一个会被用来（部分或完全）进行自动化决策的工具。 这些技术系统可能会通过其进行的决定而影响到每个人的生活。</p><p>从考虑预测到决策的飞跃不仅提出了新的技术问题， 而且还提出了一系列必须仔细考虑的伦理问题。 如果我们正在部署一个医疗诊断系统，我们需要知道它可能适用于哪些人群，哪些人群可能无效。 忽视对一个亚群体的幸福的可预见风险可能会导致我们执行劣质的护理水平。 此外，一旦我们规划整个决策系统，我们必须退后一步，重新考虑如何评估我们的技术。 在这个视野变化所导致的结果中，我们会发现精度很少成为合适的衡量标准。 </p><p>通常，在建模纠正过程中，模型的预测与训练数据耦合的各种机制都没有得到解释， 研究人员称之为“<strong>失控反馈循环</strong>”的现象。 此外，我们首先要注意我们<u>是否解决了正确的问题</u>。 比如，预测算法现在在信息传播中起着巨大的中介作用， 个人看到的新闻应该由他们喜欢的Facebook页面决定吗？ 这些只是你在机器学习职业生涯中可能遇到的令人感到“压力山大”的道德困境中的一小部分。</p></blockquote><h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h3><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>事实证明，研究讨论“⽐单个层⼤”但“⽐整个模型小”的<strong>组件</strong>更有价值。例如，在计算机视觉中⼴泛流⾏的ResNet-152架构就有数百层，这些层是由<u>层组（groups of layers）【==块==】的重复模式</u>组成。这个ResNet架构赢得了2015年ImageNet和COCO计算机视觉⽐赛的识别和检测任务 [He et al., 2016a]。⽬前<u>ResNet架构仍然是许多视觉任务的⾸选架构</u>。在其他的领域，如⾃然语⾔处理和语⾳，层组以各种重复模式排列的类似架构现在也是普遍存在。</p><p><code>Sequential</code>类使模型构造变得简单， 允许我们组合新的架构，而不必定义自己的类。 然而，并不是所有的架构都是简单的顺序架构。 当需要更强的灵活性时，我们需要定义自己的块，自定义计算。，我们⼀直在通过net(X)调⽤我们的模型来获得模型的输出。这实际上是<code>net.__call__(X)</code>的简写</p><p>在实现我们自定义块之前，我们简要总结⼀下每个块必须提供的基本功能：</p><ol><li>将输⼊数据作为其前向传播函数的参数。</li><li>通过前向传播函数来⽣成输出。请注意，输出的形状可能与输⼊的形状不同。例如，我们上⾯模型中的<br>第⼀个全连接的层接收⼀个20维的输⼊，但是返回⼀个维度为256的输出。</li><li>计算其输出关于输⼊的梯度，可通过其反向传播函数进⾏访问。通常这是⾃动发⽣的。</li><li><em>存储</em>和访问前向传播计算所需的参数。</li><li>根据需要<em>初始化</em>模型参数。</li></ol><p>只要继承<code>nn.Module</code>，我们的实现只需要提供我们⾃⼰的构造函数（Python中的<code>__init__</code>函数）和前向传播函数。不必担⼼反向传播函数或参数初始化.</p><p>块的⼀个主要优点是它的<strong>多功能</strong>性。我们可以⼦类化块以创建<em>层</em>（如全连接层的类）、<em>整个模型</em>（如上⾯的MLP类）或具有中等复杂度的<em>各种组件</em>。</p><p>每个Module都有⼀个<code>_modules</code>属性？以及为什么我们使⽤它而不是⾃⼰定义⼀个Python列表？简而⾔之，<code>_modules</code>的主要优点是：在模块的参数初始化过程中，系统知道在``_modules`字典中查找需要初始化参数的<u>子块</u>。</p><p>【可以嵌套】</p><h3 id="Conv-1"><a href="#Conv-1" class="headerlink" title="Conv"></a>Conv</h3><p>在图片里找模式的<strong>原则</strong>（启发了卷积）：</p><p>平移不变性，模型在图片任何位置，得到的结果应该一致。</p><p>局部性，只需要局部的信息就能判断。</p><p>卷积核则满足，参数与位置信息i，j无关；而卷积核只关注周围的几个元素。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304495.png" alt="image-20220227094450729" style="zoom:50%;" align = 'left'/><p>卷积核较小，层数较深类似每层参数较少的MLP，也是同样的好处。</p><p>很少用偶数的卷积核。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309135.png" alt="image-20220227102952944" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309017.png" alt="image-20220227103317837" style="zoom:50%;" /></p><p><strong>加法重载</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304581.png" alt="image-20220227104454262"></p><p>核大小比较重要，填充一般取默认的，步幅取决于你的模型复杂度要控制在什么程度</p><p>步幅和填充是网络架构的一部分，我们选择某个网络比如“Resnet”，它就告诉了你该如何设置这些</p><blockquote><p>一般很少手写神经网络，都用经典的，Resnet有个系列，除非你的输入特别不一样</p><p>网络结构设计中也有很多因素要平衡，而且，网络结构其实没有想象那么重要。</p><p>一般work里都是参考经典的网络做架构。</p></blockquote><p>机器学习本质上是个极端的压缩、泛化的过程。</p><p>3x3卷积用的多，因为10层3x3差不多等于5、6层5x5，但是因为这个计算量是平方增长，所以3x3快很多。</p><p>【简单的，就算效果差一点，才能通用】</p><blockquote><p>没有深度学习的时候，需要很多人力的成本调参，调出来效果不好还得换数据，又得人清洗。</p><p>深度学习用计算为代价替代了这些成本，总体来看其实成本是下降的，所以才得以流行。</p></blockquote><p>输入通道和输出通道其实没有太多相关性，输出通道数是架构的一部分。</p><p>不同通道的卷积核大小一致是<u>为了计算</u>上的好处。</p><p>【平时简单调试一下就用notebook就好，大型的采用Pycharm】</p><p>3d卷积效果比2d稍好一点点，但是计算复杂度高很多，主要用在视频。</p><p>$(\frac{n+2p-f}{s}+1)\times (\frac{n+2p-f}{s}+1)$ 不是整数就向下取整</p><p><strong>池化层</strong></p><p>我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含⼀只猫呢？”），所以我们最后⼀层的神经元应该对整个输⼊的全局敏感。通过逐渐聚合信息，⽣成越来越粗糙的映射，最终实现学习全局表⽰的⽬标，同时将卷积图层的所有优势保留在中间层。</p><p>当检测较底层的特征时（例如 6.2节中所讨论的边缘），我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄⿊⽩之间轮廓清晰的图像X，并将整个图像向右移动⼀个像素，即Z[i, j] =X[i, j + 1]，则新图像Z的输出可能⼤不相同。而在现实中，随着拍摄⻆度的移动，任何物体⼏乎不可能发⽣在同⼀像素上。即使⽤三脚架拍摄⼀个静⽌的物体，由于快⻔的移动而引起的相机振动，可能会使所有物体左右移动⼀个像素（除了⾼端相机配备了特殊功能来解决这个问题）。</p><p>汇聚（pooling）层，它具有双重⽬的：降低卷积层对位置的敏感性（比如3x3，那就允许你的局部特征在高宽上移动俩像素，仍能识别到该模式【与<em>感受野</em>有关】），同时降低对空间降采样表⽰的敏感性。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304202.png" alt="image-20220227141658569" style="zoom:50%;" /><p>从语义上看，池化放在卷积后，降低敏感性。</p><p>【现在池化层用的越来越少了，李沐：以前池化也用来降低计算量，现在需求小，而<u>数据增强和池化层降低敏感性的功能重复</u>了。】</p><p>【<u>尽量不要调用python本身的函数，慢到怀疑人生</u>，但是自带的数据结构内存有优化，可以列表搞好再转成tensor】</p><h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><p><strong>LeNet</strong></p><p> 1989</p><p>:star: <u>核心思想——不断把（空间信息）长宽压缩到越来越长的通道里，最后MLP训练出输出，未来基本都是这个思想。</u></p><p>直观理解：假设输入输出高宽不变，通常不会动通道数。假设输入输出高宽都减半，通道会加一倍。【空间压缩了，把提取的信息在更多的通道存下来】</p><p>背模型的参数意义不大，要理解是做压缩操作的思想和模式。</p><p>直观理解：本来一个像素识别一个低级特征，压缩到一堆通道后一个像素就能识别一个类别（高级特征）。</p><p>大图片只能用CNN，MLP和CNN都能用就用简单的MLP试试，<em>调的动就用简单的MLP</em>。</p><blockquote><p>通常来说准确率还是个比较主观的东西，你也不能知道你收集这个数据能达到多高准确，只要用户用的好。 用户心理可能有个阈值，低于它，体验就会很差，高过它，够用就行了。</p></blockquote><p><em>时序领域，没有很好的数据集。</em></p><p>迁移学习并不用很大的数据集。</p><hr><p><strong>AlexNet</strong></p><p>2012之前流行的是 kernels 核方法，有优美的理论支撑，SVM不用调参哈哈。</p><p>还有几何学，不断做物理假设，研究地球的规律，但是深度学习做的比他们更好，还有特征工程。</p><blockquote><p>吴恩达是说小规模数据分不出差距，神经网络在大规模数据上有优势，异曲同工吧！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304353.png" alt="image-20220227201740031" style="zoom:60%;" align = 'left'/><p>计算能力的增长超过了数据的增长。</p><p>90年代，用的还是神经网络，模型比较小，比较便宜；</p><p>2000年的时候核方法是主流，简单，有理论支撑，能找到核方法的核；</p><p>现在深度学习又是主流，因为计算超过了数据（GPU的兴起），可以构造更深的网络结构，用计算量换取精度。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304808.png" alt="image-20220227202614151" style="zoom:50%;" align = 'left'/>“更深更大的LeNet”：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310913.png" alt="alexnet" style="zoom: 67%;" /></p><p>2012年，AlexNet赢了2012ImageNet竞赛。          </p><p>创新点：<u>丢弃法，Relu的使用，MaxPooling</u>（取值大，梯度大，更好训练）</p><p>【由此开启了CNN学习特征而非人工特征的时代，省力高效，更加普适】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304506.png" alt="image-20220227203023302" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310438.png" alt="image-20220227203654546" style="zoom:50%;" /></p><p>卷积对位置敏感，那就数据增强（<strong>非常重要</strong>），让你不能记住所有数据。AlexNet在训练时增加了大量的图像增强数据，如翻转、裁切和变色。 这使得模型更健壮，更大的样本量有效地减少了过拟合</p><p>GPU beats CPU：首先，功耗往往会随时钟频率呈二次方增长。 对于一个CPU核心，假设它的运行速度比GPU快4倍，你可以使用16个GPU内核取代，那么GPU的综合性能就是CPU的16×1/4=416×1/4=4倍。 其次，GPU内核要简单得多，这使得它们更节能。 此外，深度学习中的许多操作需要相对较高的内存带宽，而GPU拥有10倍于CPU的带宽。</p><p>Fashion-MNIST图像的分辨率（28×2828×28像素）低于ImageNet图像。 为了解决这个问题，我们将它们增加到224×224224×224（通常来讲这不是一个明智的做法，但我们在这里这样做是为了有效使用AlexNet架构）</p><blockquote><p>Lenet太小以至于难以利用GPU资源，Alexnet相对好一点，所以虽然计算量差了200倍，但速度只差了20倍</p></blockquote><p>ImageNet仍是当下使用最常用的</p><p>现在已经比较成熟，CV新的model难搞，但是落地的demo做的人很多，好做一些。</p><p><u>resize要保持高宽比</u>，一般短边为基线，然后拿出中间的；或随机取5、6个短x短的</p><hr><p><strong>VGG</strong></p><p>神经网络更深更大自然更好，但是如何组织才能有效的实现呢，太多全连接层太贵，</p><p>AlexNet证明深层神经网络卓有成效，但它没有提供一个通用的模板来指导后续的研究人员设计新的网络。 在下面的几个章节中，我们将介绍一些常用于设计深层神经网络的启发式概念。</p><p>与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加抽象。研究人员开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式。</p><p>通过使用<u>循环和子程序</u>，可以很容易地在任何现代深度学习框架的代码中实现这些重复的架构。</p><p>新思想：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304409.png" alt="image-20220301170502335"></p><p><em>学术界一派对另一派的打压。</em></p><hr><p><strong>NiN</strong></p><p>AlexNet和VGG对LeNet的改进主要在于如何扩大和加深这两个模块。然而，如果使用了全连接层，可能会完全放弃表征的空间结构。 <em>网络中的网络</em>（<em>NiN</em>）提供了一个非常简单的解决方案：在每个像素的通道上分别使用多层感知机。</p><p>而且1x1能增加非线性性，因为block里有ReLU函数。</p><blockquote><p>1x1卷积核，又称为网中网（Network in Network）</p></blockquote><p>现在已经不怎么流行了。</p><p>但是最近那个用MLP代替CNN，以及当年的用CNN代替MLP（参数比较少）的思想其实是类似的。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310201.png" alt="image-20220301182209058" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310257.png" alt="image-20220301182551558" style="zoom:67%;" /></p><p>NiN和AlexNet之间的一个显著区别是NiN<strong>完全取消了全连接层</strong>。<br>全连接存在的问题：参数量过大，降低了训练的速度，且很容易过拟合<br>相反，NiN使用一个NiN块，其输出通道数等于标签类别的数量。最后放一个<em>全局平均汇聚层</em>（global average pooling layer）（gap），生成一个对数几率 （logits）。NiN设计的一个优点是，它显著减少了模型所需参数的数量。然而，在实践中，这种设计有时会增加训练模型的时间。</p><p>大量1x1卷积会拖慢运行速度，这个一般，后来google更好地使用了这个卷积。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310515.png" alt="img"></p><p>python做service十分容易，写个for loop就行了。</p><p>【深度神经网络结构里都没有softmax，因为那个是<strong>放在train时的loss里的不是放在网络结构</strong>里的。】</p><p><u>加入全局池化层，降低了模型复杂度，提高了泛化性，但是收敛会变慢，原来的全连接层太强大了，能很快的收敛。</u></p><p>预测函数实现的时候，记得把<u>原始labels copy到GPU上</u>，才能计算并做预测；同时<u>预测结果要拿回CPU</u>，与其他的计算。</p><hr><p><strong>GoogLeNet</strong></p><p>GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。 这篇论文的一个重点是<u>解决了什么样大小的卷积核最合适的问题</u>。 本文的一个观点是，有时使用不同大小的卷积核组合是有利的。我们省略了一些为稳定训练而添加的特殊特性，现在有了更好的训练方法，这些特性不是必要的。</p><p>《致敬LeNet》——但是其实一点关系都没有，我感觉他们就是皮了，正好le一样吧。设计灵感参考了NiN</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310648.png" alt="image-20220301193115974" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310903.png" alt="image-20220301193708210" style="zoom:50%;" /></p><p>xs，作者从来都没说过这些通道数怎么来的，可能是氪金氪出来的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310427.png" alt="image-20220301193811093" style="zoom:40%;" align = 'left'/><blockquote><p>ps:</p><p>FLOPS：注意全大写，是floating point operations per second的缩写，意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。</p><p>FLOPs：注意s小写，是floating point operations的缩写（s表复数），意指浮点运算数，理解为计算量。可以用来衡量算法/模型的复杂度。</p><p>注意在深度学习中，我们用的是FLOPs，也就是说计算量，即用来衡量算法/模型的复杂度。</p></blockquote><p>一个Stage是高宽减半。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310570.png" alt="image-20220301194340374" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310532.png" alt="image-20220301194400972" style="zoom:60%;" /></p><p>都是把高宽先减下去，然后通道数拉上去便于后面计算，不然计算量太大了。<br>【更小的卷积层，高宽保留的比Alex还是多一点，能支持后续更深的Network】</p><p>v2使用了batch normalization  v3修改了Inception块， v4使用残差连接。</p><p>v3现在还是很常用，精度不差太多，运算速度也还行。</p><p>写这个网络真麻烦。。。虽然结构确实挺好理解，以后还是copy吧。 trick is more important</p><hr><h4 id="Modern"><a href="#Modern" class="headerlink" title="Modern"></a>Modern</h4><p><strong>Batch Norm</strong></p><p>对于很深的层，这个应该是不可或缺的，效果很好。</p><blockquote><p>吴恩达：</p><p><strong>Batch</strong>归一化减少了输入值改变的问题，它的确使这些值变得更稳定，神经网络的之后层就会有更坚实的基础。即使使输入分布改变了一些，它会改变得更少。它<strong>减弱了前层参数的作用与后层参数的作用之间的联系</strong>，它使得网络每层都可以自己学习，稍稍独立于其它层，有助于加速整个网络的学习。</p><p><strong>Batch</strong>归一化含几重噪音，因为标准偏差的缩放和减去均值带来的额外噪音。这里的均值和标准差的估计值也是有噪音的，所以类似于<strong>dropout</strong>，<strong>Batch</strong>归一化有轻微的正则化效果，因为给隐藏单元添加了噪音，这迫使后部单元不过分依赖任何一个隐藏单元，类似于<strong>dropout</strong>，它给隐藏层增加了噪音，因此有轻微的正则化效果。因为添加的噪音很微小，所以并不是巨大的正则化效果，你可以将<u><strong>Batch</strong>归一化和<strong>dropout</strong>一起使用</u>，如果你想得到<strong>dropout</strong>更强大的正则化效果。</p><p>也许另一个轻微非直观的效果是，如果你应用了较大的<strong>mini-batch</strong>，对，比如说，你用了512而不是64，通过应用较大的<strong>min-batch</strong>，你减少了噪音，因此减少了正则化效果，这是<strong>dropout</strong>的一个奇怪的性质，就是应用较大的<strong>mini-batch</strong>可以减少正则化效果。</p><p>说到这儿，我会把<strong>Batch</strong>归一化当成一种正则化，这确实不是其目的，但有时它会对你的算法有额外的期望效应或非期望效应。但是==不要==把<strong>Batch</strong>归一化当作正则化，把它当作将你归一化隐藏单元激活值并加速学习的方式，我认为正则化几乎是一个意想不到的副作用。</p></blockquote><p> <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311879.png" alt="image-20220301211525342" style="zoom: 45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311921.png" alt="image-20220301211832235" style="zoom:63%;" /></p><p>请注意，我们在方差估计值中添加一个小的常量ϵ&gt;0，以确保我们永远不会尝试除以零</p><p><u>对于卷积和全连接的类比，一个像素是1x通道数，可以看成一个样本，通道数=特征维数，样本数=batch*h*w</u></p><p><u>所以1x1全连接类比全连接就很好理解了。</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311028.png" alt="image-20220301212736604" style="zoom:50%;" /><p>因为你每次是随机取样，当前的均值和方差相当于随机的。</p><p>好处是可以<u>加速收敛</u>，学习率可以调大一些，但一般不改变模型精度。</p><p>xavier是初始化，是数值一开始不要炸；BN是在模型训练的whole过程，增加==噪音==。</p><p>BN仍然难以解释，但已经被证明是一种不可或缺的方法。它<u>适用于几乎所有图像分类器</u>，并在学术界获得了数万引用。</p><p><u>先跟着内存调batch size（增加直到每秒处理样本数不再增大），再调学习率，框架之间都差不多，epoch调大点，多了就停下。</u></p><hr><p><strong>ResNet</strong></p><p>只有当较复杂的函数类包含较小的函数类时，我们才能确保提高它们的性能。 对于深度神经网络，如果我们能将新添加的层训练成<em>恒等映射</em>（identity function）f(x)=xf(x)=x，新模型和原模型将同样有效。 同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。【通常不会让模型变坏，如果下降了，那就令g(x)为0，直接映射x】</p><p>残差网络的核心思想是：每个附加层都应该更容易地<u>包含原始函数作为其元素之一</u>。 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311526.png" alt="image-20220302090850372" style="zoom:50%;" /><p>一般用rescnet 34就行了，resnet 152一般用来刷榜。。。实际不怎么用</p><p>精度更高的其实都是resnet变种。</p><p>乘法变加法，防止梯度出问题。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311458.png" alt="image-20220302101927140" style="zoom: 33%;" /><h3 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a><em>hardware</em></h3><p>一台服务器可以支持多个GPU，高端服务器最多支持8个GPU。更典型的数字是工程工作站最多4个GPU，这是因为热量、冷却和电源需求会迅速增加，超出办公楼所能支持的范围。对于更大的部署，云计算（例如亚马逊的<a href="https://aws.amazon.com/ec2/instance-types/p3/">P3</a>和<a href="https://aws.amazon.com/blogs/aws/in-the-works-ec2-instances-g4-with-nvidia-t4-gpus/">G4</a>实例）是一个更实用的解决方案。</p><p>由于Python中的全局解释器锁（GIL），CPU的<u>单线程性能</u>在我们有4-8个GPU的情况下可能很重要。所有的条件都是一样的，这意味着核数较少但时钟频率较高的CPU可能是更经济的选择。</p><p>GPU性能主要是以下三个参数的组合：</p><ol><li><strong>计算能力</strong>。通常我们追求32位浮点计算能力。16位浮点训练（FP16）也进入主流。如果你只对预测感兴趣，还可以使用8位整数。最新一代图灵GPU提供4-bit加速。不幸的是，目前训练低精度网络的算法还没有普及。</li><li><strong>内存大小</strong>。随着你的模型变大或训练期间使用的批量变大，你将需要更多的GPU内存。检查HBM2（高带宽内存）与GDDR6（图形DDR）内存。HBM2速度更快，但成本更高。</li><li><strong>内存带宽</strong>。只有当你有足够的内存带宽时，你才能最大限度地利用你的计算能力。如果使用GDDR6，请追求宽内存总线。</li></ol><p>在每个系列中，价格和性能大致成比例。Titan因拥有大GPU内存而有相当的溢价。然而，较新型号具有更好的成本效益</p><p><em>提高CPU利用率</em></p><p>V：L1 cache: 3 cycles   L2 cache: 11 cycles  L3 cache: 25 cycles   Main Memory: 100 cycles</p><p>cpu达不到理论计算能力，很大可能是内存访问太慢了。<u>行为样本比列块</u>。。因为CPU是按行存储，速度差距蛮大的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311686.png" alt="image-20220302122045303" style="zoom:50%;" /><p>intelCPU使用了超线程，就是一个物理核变成几个虚拟核，告诉你的是虚拟的。</p><p>但是对于计算机密集型，超线程没什么用，因为它们共享寄存器。超线程对于几个不同的任务比较有用。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311033.png" alt="image-20220302141025208" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311658.png" alt="image-20220302141629821" style="zoom:50%;" /></p><p><u>向量化</u>（c = a+b）这种写法，非常容易并行，能很好地利用CPU的多核</p><p><em>提高GPU利用率</em></p><p>GPU如果内存带宽跟不上，很难跑满，你得去内存里面拿数据，然后进行计算。<br>所以GPU在运算和带宽上做的很大，代价是内存大不了。而且<u>显存都是高带宽的，很贵，比CPU的贵多了</u>，所以在这上面扣。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312177.png" alt="image-20220302142457918" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312509.png" alt="image-20220302143021719" style="zoom:50%;" /></p><p>神经网络得够大，<u>特征不到几千维</u>，都打不满。<br>控制语句打比方，一个判断，几千个线程得停下来等（现在有改善，只停一组核，但还是很亏）</p><p>因为带宽限制，CPU和GPU少点互传；因为<strong>同步的开销</strong>，<u>最好一次传完</u>，别一会传一下【可视化和计算loss占用的很少没事】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312959.png" alt="image-20220302143509772" style="zoom:50%;" /><p>一般GPU就用来打游戏哈哈，放视频都用不上。<u>要做好高性能，硬件很重要，编译器同等重要</u>，CUDA就投入很多资源。最难的是软件，编译器，和你的生态。</p><p>核数和频率与功耗有很大关系。</p><p>在深度学习框架内部，对GPU的运算也有很多优化，参数的顺序都是有讲究的，甚至会内部格式化后再参与计算。</p><p>计算量发展是指数型的，如果什么东西被发现有效，大家会拼命往上堆。</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312336.png" alt="image-20220302150601418" style="zoom:67%;" /><p>沐神：分久必合，合久必分。硬件增长是线性的，任务确是log增长，在任务超过硬件时，很多人会去做“专用”，比如领域专用，分布式，定制。而任务不是无穷无尽的，ImageNet 100w也够了，等硬件追上来，大家又去做通用的了。</p></blockquote><p>python的multiprocessing做的很拉跨，不如<a href="https://numba.pydata.org/">numba</a>   go的分布式和这里的分布式理论上有差距，不太适合高性能。<br>每个语言都有自己的特性，用的人群是有特征的，go都是做网页的那些人，不会关注高性能计算。</p><p>要复现论文，80%的论文不能复现，而且作者得把细节写出来，得理解每一句话，有时候会放论文，是很细节，很锻炼能力的事情。</p><p>硬件和软件不一样，技术细节不能公布和讨论（TPU公布了）</p><hr><p><strong>More Chips</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319636.png" alt="image-20220302144247435" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312741.png" alt="image-20220302155127372" style="zoom: 50%;" /></p><p>但是你要是指令用不到那么多计算，那就浪费掉了。</p><p>华为用了大量的FPGA，比如路由器，因为不像专用ASIC一样不可更新，其更新换代可以通过烧录进行。</p><p><em>专用</em></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312527.png" alt="image-20220302155616213" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312901.png" alt="image-20220302160240458" style="zoom: 43%;" /></p><p>Nvidia盈利：游戏卡赚不了几个钱，但是你学会怎么开发后，到公司里，公司得买server啥的，贼贵，盈利90%</p><p>TPU这样的专用芯片，就能省下很多钱。大家都造ASIC是因为不用实现通用，就能省下很多的精力，造的难度骤降，而且便宜。</p><p>但可能会担心2，3年做出来，应用已经不火了。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312868.png" alt="image-20220302161225020" style="zoom:50%;" align = 'left'/><p>TPU还是用tensorflow跑比较好，pytorch的<a href="https://github.com/pytorch/xla">xla</a>也支持，但是沐神说毕竟不是原生的。</p><blockquote><p><u>对于云和数据中心，功耗不是大问题，电费不是一个机房的大头，3年才多少钱，还比不上设备换代。</u></p><p>芯片一代用个2，3年就可以啦。</p><p>网络设计，首先还是考虑了硬件的能力，所以papers也得fit到硬件上，==软硬是鸡生蛋，蛋生鸡，相互影响==。<br>比如TPU内存特别大，而且算全连接层很好，所以transformer在TPU上能很好run，它的发明也是受到TPU很大的影响。</p><p>很多手机厂商号称的ASIC其实是个DSPxs</p><p>如果框架：真开源，其实不用担心，只要框架间还在竞争没用垄断，就不用担心，因为付费损失的是开发者。<br>框架相对来说比较简单？？？我感觉沐神在凡尔赛。</p></blockquote><p><strong>单机多卡并行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312615.png" alt="image-20220302181533510" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312237.png" alt="image-20220302181601661" style="zoom:40%;" /></p><p>模型并行难优化一些，而且可能有些机器空闲。数据并行性能会变差，因为矩阵变小了，能用的进程↓</p><p>显存优化是很难的啦，靠的是框架，pytorch做的还行。</p><p>==验证集准确度波动较大，一般是learning-rate的原因==，batchsize小，你lr就不能太大。</p><p>batch-norm和不断地调学习率有异曲同工之处，但是学习率鬼知道哪里调大哪里调小，不如BN方便。</p><p>如果不同GPU性能不一样，最好算好性能差，按倍率分配任务，最好同时算完并行度好一些，涉及同步机制。</p><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><p>所有机器都能读取样本，数据放在分布式文件结构上。</p><p>通常有多个worker，每个worker可能有好几个GPU</p><p>还有多个参数服务器，<u>每个服务器存了模型的一部分参数，每次worker都是向所有服务器要</u>。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312164.png" alt="image-20220302205418348" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313175.png" alt="image-20220302205725151" style="zoom:50%;" /></p><p>尽量少在机器之间通信，尽量本地。</p><p>大致流程：</p><ul><li>每个计算服务器读取小批量的一块。</li><li>然后worker进一步将数据切分到每个GPU上</li><li>每个worker从参数服务器拿到参数，复制到每个GPU上</li><li>将所有GPU上的梯度求和，在本地做all-reduce，然后把加起来的发出去。（减少通讯次数）</li><li>每个参数服务器对梯度求和，并更新参数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313202.png" alt="image-20220302210605348" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313315.png" alt="image-20220302210728489" style="zoom:45%;" /></p><p>$t_1$和batch-size正相关，但是$t_2$不会，因为发送的是参数，为了防止被通信阻碍，选择合适的batch使$t_1$直观上比$t_2$大20%~30%好</p><p>取max函数是因为通讯和计算是可以并行的，算一个发一个哈哈类似这种。</p><p>但是增加了以后会导致收敛变慢，所以需要更多的epoch。。。所以如果过度，反而会浪费时间，涉及到<strong>权衡</strong>的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313155.png" alt="image-20220302212847324" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313800.png" alt="image-20220302213015960" style="zoom: 45%;" /></p><p>异步的通讯开销会变低。</p><p>单机内部用模型并行，一般跨机器都用数据并行</p><p>data parralel是一种并行模式，之前讲的是这种模式怎么用于单机和分布式</p><p>【沐神：假设分类的类别数是n，那么batch不要超过10*n、20*n，不过很多时候你没那么多GPU哈哈，一般是：GPU尽量加batch，然后看有多少机器，加到没有增益就算了。剩下的跑别的，也不需要全部用上。】</p><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><p><strong>Augmentationi</strong></p><p>不是一件太便宜的事情，多开几个num_workers快（取决于CPU），但是windows有问题。。</p><p>训练集尽可能地模拟部署时的实际应用场景是提高模型泛化性的好方法。需要人工判断。</p><p>一般是<strong>随机的</strong>增强，<strong>在线生成</strong>，然后利用新的来训练，当然只是在训练的时候用。</p><p>上下翻转不比左右翻转，得考虑到现实中，房子、猫什么的就不能上下吧。。。当然躺着的猫也是可以上下转的。</p><p>切割：随机高宽比（不能太离谱，比如取值范围[3/4,4/3]）、随机大小(有限制)、随机位置，但是形状大小要一致。</p><p>颜色：色调、饱和度、明亮度。一般取值在[0.5,1.5]之间。</p><blockquote><p><strong>对比度：</strong><br>是画面黑与白的比值，也就是从黑到白的渐变层次。比值越大，从黑到白的渐变层次。比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富。</p><p><strong>亮度：</strong><br>亮度指照射在景物或图像上光线的明暗程度。</p><p><strong>色调：</strong><br>色调指的是一幅画中画面色彩的总体倾向，是大的色彩效果</p><p><strong>饱和度：</strong><br>饱和度是指色彩的鲜艳程度，也称色彩的纯度。取决于该色中含色成分和消色成分（灰色）的比例。含色成分越大，饱和度越大</p></blockquote><p>imgaug 👈 提供了一堆类似的变化。你觉得他有用，是要从<u>部署的可能性</u>出发的</p><p>有时候你数据增强后，测试精度可能比训练精度还高，不过仔细调整后训练精度还是会慢慢上来的。</p><p><u>原始图片多 $\neq$ 多样性好</u>，还是得分析实际部署的分布。</p><p>图片增广需要大概人工看一下效果，图片增广的均值很多不变的。</p><p>马赛克：是一种遮挡，因为神经网络识别的绝大部分是纹理，特征（部位），而不是像人类一样总体识别比如一只猫</p><p>沐神也不知道为啥mix-up增广有用，但效果挺好的</p><p>图神经网络训练很难，落地挺让人头疼</p><h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>CV中对深度学习来讲最important的技术（迁移学习这一大类中的一种算法）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313307.png" alt="image-20220303111214593" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313893.png" alt="image-20220303111342590" style="zoom:40%;" /></p><p>初始化最后一个分类层。【只能手动提取，嫌麻烦也可以不用，一般用的不多】</p><p>成员变量<code>output</code>的参数是随机初始化的，通常需要更高的学习率才能从头开始训练。 假设<code>Trainer</code>实例中的学习率为η，我们将成员变量<code>output</code>中参数的学习率设置为10η。</p><p>找pretrained的model时也得找相应领域的，判断癌症的就找医学领域的sei。</p><p>微调对学习率不敏感，可以选一个比较小的就行了，比如沐神用的e^-5</p><p>而且，这个pretrained的模型一旦弄出来，并不是只用于单任务，它实际是抽取特征，可以用到各类任务（分类、预测。。）</p><p>torchvision比较经典，但是更新不快。</p><h4 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h4><p>很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。 在计算机视觉里，我们将这类任务称为<em>目标检测</em>（object detection）或<em>目标识别</em>（object recognition）。</p><p>相比于图像分类，其实客户更关心的还是图像识别。</p><p>图片分类中一定有个主体，但是目标检测里面可能有多个物体，而且还要找出位置。</p><p><strong>数据集格式</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313367.png" alt="image-20220319190238756" style="zoom: 33%;" align = 'left'/><p>所以每行可能6个值。</p><p> 输入参数<code>boxes</code>可以是长度为4的张量，也可以是形状为（n，4）的二维张量，其中n是边界框的数量。</p><p>目标检测领域没有像MNIST和Fashion-MNIST那样的小数据集。 为了快速测试目标检测模型，我们收集并标记了一个小型数据集。</p><p>无人车不仅仅是视觉，还有许多3D检测器，精度非常高。</p><blockquote><p>首先采集一点数据出来，手标个几十几百张，然后用fine tuning训练一个模型。再用它去预测接下来很多图片，把预测不那么置信的（概率比较低的）拿出来重新标一下，重新迭代。可能最后标个几千张。但如果更高的工业需求就找人吧</p></blockquote><p>几百张数据，如果能找到<u>比较类似的预训练</u>模型，其实已经不错了</p><p>一般我们喜欢用 ImageNet 来做网络的预训练，主要有两点，一方面 ImageNet 是图像领域里有超多事先标注好训练数据的数据集合，分量足是个很大的优势，量越大训练出的参数越靠谱；另外一方面因为 ImageNet 有 1000 类，类别多，算是通用的图像数据，跟领域没太大关系，所以通用性好，预训练完后哪哪都能用，是个万金油。分量足的万金油当然老少通吃，人人喜爱。</p><hr><p>目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边界从而更准确地预测目标的<em>真实边界框</em>（ground-truth bounding box）。 </p><p>不同的模型使用的区域采样方法可能不同。 这里我们介绍其中的一种方法：以每个像素为中心，生成多个缩放比和宽高比（aspect ratio）不同的边界框。 这些边界框被称为<strong>锚框</strong>（anchor box）【目前更为主流】</p><p>预测每个锚框中是否含有关注的物体，if True，预测从该锚框到真实边缘框的偏移。</p><p>每个锚框是个训练样本，每个锚框要么标注成背景（nothing），要么关联一个真实边缘框，可能生产一堆锚框，导致大量的负样本</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313809.png" alt="image-20220319215317086" style="zoom:40%;" /><p>这种赋予标号的方法👆是一种常用做法。这样每个边缘框都分到一个锚框。其他都是负样本。（具体模型可能有不同方法）</p><p>NMS用于预测时去掉冗余。常用的是每一类内部处理，当然也有全部拿到一起处理的</p><p>由于锚框的引入，算法复杂度远远大于图像分类。实现起来麻烦的要死。</p><hr><h5 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h5><p>R-CNN是奠基性工作 SSD YOLO 【都是基于锚框的，非锚框的工作比较新】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313917.png" alt="image-20220320184459559" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313352.png" alt="image-20220323173530928" style="zoom: 50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313884.png" alt="image-20220323173602452" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313672.png" alt="image-20220323180110311" style="zoom:50%;" /></p><p>R-CNN（速度很慢）包括以下四个步骤：</p><ol><li>对输入图像使用<em>选择性搜索</em>来选取多个高质量的提议区域 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#uijlings-van-de-sande-gevers-ea-2013">Uijlings et al., 2013]</a>。这些提议区域通常是在多个尺度下选取的，并具有不同的形状和大小。每个提议区域都将被标注类别和真实边界框。</li><li>选择一个预训练的卷积神经网络，并将其在输出层之前截断。将每个提议区域变形为网络需要的输入尺寸，并通过前向传播输出抽取的提议区域特征。</li><li>将每个提议区域的特征连同其标注的类别作为一个样本。训练多个<u>SVM</u>对目标分类，其中每个支持向量机用来判断样本是否属于某一个类别。</li><li>将每个提议区域的特征连同其标注的边界框作为一个样本，训练<u>线性回归模型</u>来预测真实边界框。</li></ol><hr><p>R-CNN的主要性能瓶颈在于，对每个提议区域，卷积神经网络的前向传播是独立的，而没有共享计算。 由于这些区域通常有重叠，独立的特征抽取会导致重复的计算。<em>Fast R-CNN</em> [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#girshick-2015">Girshick, 2015]</a>对R-CNN的主要改进之一，是<u>仅在整张图象上</u>执行卷积神经网络的前向传播。</p><ol><li>与R-CNN相比，Fast R-CNN用来提取特征的卷积神经网络的输入是整个图像，而不是各个提议区域。此外，这个网络通常会参与训练。设输入为一张图像，将卷积神经网络的输出的形状记为$1×c×h_1×w_1$。</li><li>假设选择性搜索生成了n个提议区域。这些形状各异的提议区域在卷积神经网络的输出上分别标出了形状各异的兴趣区域。然后，这些感兴趣的区域需要进一步抽取出形状相同的特征（比如指定高度h2和宽度w2），以便于连结后输出。为了实现这一目标，Fast R-CNN引入了<em>兴趣区域汇聚层</em>（RoI pooling）：将卷积神经网络的输出和提议区域作为输入，输出连结后的各个提议区域抽取的特征，形状为n×c×h2×w2。</li><li>通过全连接层将输出形状变换为n×d，其中超参数d取决于模型设计。</li><li>预测n个提议区域中每个区域的类别和边界框。更具体地说，在预测类别和边界框时，将全连接层的输出分别转换为形状为n×q（q是类别的数量）的输出和形状为n×4的输出。其中预测类别时使用softmax回归。</li></ol><p>ROI：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314923.png" alt="image-20220323131456293" style="zoom:30%;" /><p><em>Faster R-CNN</em> [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#ren-he-girshick-ea-2015">Ren et al., 2015]</a>提出将选择性搜索替换为<em>区域提议网络</em>（region proposal network），从而减少提议区域的生成数量，并保证目标检测的精度。模型的其余部分保持不变。【先做个大概的预测，再做精准的预测】</p><p>区域提议网络的计算步骤如下：</p><ol><li>使用填充为1的3×3的卷积层变换卷积神经网络的输出，并将输出通道数记为c。这样，卷积神经网络为图像抽取的特征图中的每个单元均得到一个长度为c的新特征。</li><li>以<strong>特征图的每个像素</strong>为中心，生成多个不同大小和宽高比的锚框并标注它们。</li><li>使用锚框中心单元长度为c的特征，分别预测该锚框的二元类别（含目标还是背景）和边界框。</li><li>使用非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测边界框即是兴趣区域汇聚层所需的提议区域。</li></ol><p>【但是即使是Faster，也还是挺慢的】</p><p>Mask R-CNN用于标注了像素级位置的情况，其他不变，双线性插值。ROI pooling换成ROI align，可以切像素，然后加权算。便于像素级别预测。在无人车领域用的比较多</p><p><strong>这一系列，处理速度慢，精度高，内存占用高</strong> 目标检测比图片分类贵很多。</p><hr><p>现在SSD（Single Shot MultiBox Detector）用的不那么多</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314592.png" alt="image-20220323182032493" style="zoom: 67%;" /><p>常用ResNet</p><p>可以设计基础网络，使它输出的高和宽较大。 这样一来，基于该特征图生成的锚框数量较多，可以用来检测尺寸较小的目标。<br>接下来的每个多尺度特征块将上一层提供的特征图的高和宽缩小（如减半），特征图中每个单元在输入图像上的感受野变得更广阔。</p><p>速度比较快，精度比较低。单神经网络，一次过。</p><p><u>SSD没有人继续做细节更新，但实现十分简单，启发了后续工作。而且可以用python，之前的R-CNN用python实现都难。</u></p><blockquote><p>多尺度</p><p>更低维度的空间分辨率较高，但是更局部；更高维度的空间分辨率较低，但是看到全局。</p><p>在不同的stage都做目标检测，这就是多尺度</p></blockquote><hr><p>You Only Look Once</p><p>追求速度</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314997.png" alt="image-20220323183220189" style="zoom: 33%;" align = 'left'/><p>为了防止一个框中有多个物体时被漏掉，每个锚框预测B个。。</p><p>YOLO v3时，作者跑路了，然后由他的合作者接手了。加入了聚类算法，统计你数据集中检测物体的大小规律，生成针对的锚框</p><blockquote><p>李沐：YOLO v3算是特别差的论文哈哈</p><p>非锚框的技术目前的发展也很迅速，什么基于像素的预测什么的（FCN）</p></blockquote><p>YOLO 系列相对于RCNN精度差了一些，但是速度提高到了和SSD类似的地步（5、6倍）</p><hr><p>对于OCR这种识别的物体特别小的，一般选择分辨率很高的图片，用R-CNN（精度较高）处理。</p><p>车牌识别已经很成熟了。</p><blockquote><p>卷积、激活函数、池化组合。。。更像一门计算机语言</p><p>Attention更关注全局，CNN关注局部，这些被沐神比作流派:joy: 。。。哎老中医了，也没有好的总结。</p></blockquote><p>NMS在GPU很难跑，一堆iteration比来比去。</p><p>当特征图的长宽比较小时，size一般比较大，反之比较小。</p><p>特别大的图片，SSD不那么适合。还是RCNN分开两次比较合适，或者YOLO，不管多大，锚框都不会很多。</p><p>多个loss加权相加，可以先画出来看看，然后拉到一个数量级上。</p><p>NMS的实现有许多加速的细节，不过那都是cuda干的事情了</p><p><u>目标检测的fine tuning一般是用图片分类的CNN模型，而cls_predict 和bbox_predict 都是随机初始化的。</u></p><p>pytorch也实现了，不过内部是调用的C++的代码。</p><p>嵌入式最好用YOLO。</p><p>很难公平的比较两个不一样的架构谁好谁坏，因为里面有很多tricks，最后表现的是整体的精度。最后就变成你喜欢哪个用哪个。</p><h4 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h4><p>常见的数据格式是VOC和COCO</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314372.png" alt="image-20220324131324548" style="zoom:50%;" /><p>历史久远了，比如聚类，把像素聚在一起，给一个label。</p><p>语义分割属于有监督学习。应用：背景虚化、路面分割。</p><p>还有一个<strong>实例分割</strong>，不仅分割类，还检测每个实例，相当于是目标检测的进阶版。</p><p>（数据集很贵，因为很难标，所以相对数据集不大，但是无人车挺多，因为大家都不缺钱。）</p><p>更精细的语义分割，比如狗的头、身体什么的，可能存在二义性的问题，有个技术叫<strong>关键点识别</strong>。</p><p>假设目标框旋转，可以画一个大框圈出来（图像处理也有提到）</p><p>人是个比较简单的物体，做起来的难点是人的光照，形状是很容易做语义分割的。这一块能找到很好pretrained的model</p><p>3D做语义分割反而会简单很多？三维卷积</p><p>自动驾驶有几十、上百个模型一起作用，语义分割主要做路面分割，目标检测（3d）主要测前车和行人和距离、速度。</p><hr><p><strong>转置卷据</strong></p><p>一般卷积不会增大输入的高宽、太大的padding是不可取的，转置卷积可以。</p><p>对于语义分割，如果高宽一直减小，最后就做不了像素级别的输出了。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314195.png" alt="image-20220325104510887" style="zoom:50%;" align = 'left'/><p>这里的填充指的是输出结果的外围被视为填充，所以去掉。</p><p>卷积是为了识别local的模式，转置有点难以理解哈哈哈，可以说是特征放大？</p><p>转置卷积只还原了形状，并没有还原输出的那个值。</p><p>再谈形状：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314042.png" alt="image-20220325114326602" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314542.png" alt="image-20220325114427564" style="zoom:50%;" /></p><hr><p>FCN 全连接卷积神经网络时深度学习做语义分割的奠基性工作。</p><p>所以现在用的不多。但是思想比较简单</p><p>全卷积网络先使用卷积神经网络抽取图像特征，然后通过1×1卷积层将通道数变换为类别个数，最后在 <a href="https://zh-v2.d2l.ai/chapter_computer-vision/transposed-conv.html#sec-transposed-conv">13.10节</a>中通过转置卷积层将特征图的高和宽变换为输入图像的尺寸。模型输出与输入图像的高和宽相同，且最终输出通道包含了该空间位置像素的类别预测。</p><p>最后一层前加一个1x1卷积层把通道个数减一减，方便运算，这个操作<u>舍弃精度追求速度。</u></p><p>一般，用来放大的转置卷积层的<u>初始化采用双线性插值</u>，效果上相当于把图片放大了两倍。</p><p>UNet用了更多的层，还有许多其他工作。</p><hr><h4 id="风格迁移"><a href="#风格迁移" class="headerlink" title="风格迁移"></a>风格迁移</h4><p>没有什么商业价值，大家也就玩一玩。GAN的商业价值虽然在提升，但仍然整体不大</p><p>滤波器能改变照片的颜色风格，从而使风景照更加锐利或者令人像更加美白。但一个滤波器通常只能改变照片的某个方面。如果要照片达到理想中的风格，你可能需要尝试大量不同的组合。这个过程的复杂程度不亚于模型调参。</p><p>同样讲的是奠基性的工作，基于CNN</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314506.png" alt="image-20220325200424010" style="zoom: 67%;" /><p>越靠近输入层，越容易抽取图像的细节信息；反之，则越容易抽取图像的全局信息。 </p><p>为了避免合成图像过多保留内容图像的细节，我们选择VGG较靠近输出的层，即<em>内容层</em>，来输出图像的内容特征。 我们还从VGG中选择不同层的输出来匹配局部和全局的风格，这些图层也称为<em>风格层</em>。</p><p><code>style_layers, content_layers = [0, 5, 10, 19, 28], [25]</code></p><p>用统计信息来表征风格，那么<u>各阶统计量的差异</u>可用来衡量loss【统计直方图包含高阶信息，Gram和协方差有两阶】</p><p>假设该输出的样本数为1，通道数为c，高和宽分别为h和w，我们可以将此输出转换为矩阵X，其有c行和hw列。 这个矩阵可以被看作是由c个长度为hw的向量x1,…,xc组合而成的。其中向量$x_i$代表了通道i上的风格特征。</p><p>在这些向量的<em>格拉姆矩阵</em>XX⊤∈Rc×c中，i行j列的元素xij即向量xi和xj的内积。它表达了通道i和通道j上风格特征的相关性。我们用这样的格拉姆矩阵来表达风格层输出的风格。 需要注意的是，当hw的值较大时，格拉姆矩阵中的元素容易出现较大的值。 此外，格拉姆矩阵的高和宽皆为通道数c。 为了让风格损失不受这些值的大小影响，格拉姆矩阵除以矩阵中元素的个数，即chw</p><p><em>全变分去噪</em>（total variation denoising） 假设xi,j表示坐标(i,j)处的像素值，降低全变分损失</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314283.png" alt="image-20220325202643645"></p><p>能够尽可能使邻近的像素值相似。</p><blockquote><p>格拉姆矩阵可以看做feature之间的偏心协方差矩阵（即没有减去均值的协方差矩阵），在feature map中，每个数字都来自于一个特定滤波器在特定位置的卷积，因此每个数字代表一个特征的强度，而Gram计算的实际上是两两特征之间的相关性，哪两个特征是同时出现的，哪两个是此消彼长的等等。</p></blockquote><p>风格转移的损失函数是内容损失、风格损失和总变化损失的加权和。 通过调节这些权重超参数，我们可以权衡合成图像在保留内容、迁移风格以及去噪三方面的相对重要性。</p><p>在风格迁移中，合成的图像是训练期间<strong>唯一</strong>需要更新的变量。因此，我们可以定义一个简单的模型<code>SynthesizedImage</code>，并将合成的图像视为模型参数。模型的前向传播只需返回模型参数即可。</p><p>可以初始化为风格图片或内容图片。</p><p>训练大图片的小技巧：先把原图片缩小，训练一下，再放大继续训练，甚至切割分别训练</p><p><strong>后来用GAN来做这个事情，不用每次都训练</strong></p><h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><h4 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h4><p>房价预测：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">https://www.kaggle.com/c/house-prices-advanced-regression-techniques</a></p><p>直观地说，我们标准化数据有两个原因： 首先，它方便优化。 其次，因为我们不知道哪些特征是相关的， 所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大。</p><p><u>pandas的dataframe，如果索引中不用切片用单个数字，此时选的是列，方便却容易混淆。</u></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> out<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span> → Tensor      <span class="token operator">|</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token keyword">if</span> x_i <span class="token operator">&lt;</span> <span class="token builtin">min</span>y_i <span class="token operator">=</span> <span class="token operator">|</span> x_i<span class="token punctuation">,</span> <span class="token keyword">if</span> <span class="token builtin">min</span> <span class="token operator">&lt;=</span> x_i <span class="token operator">&lt;=</span> <span class="token builtin">max</span>      <span class="token operator">|</span> <span class="token builtin">max</span><span class="token punctuation">,</span> <span class="token keyword">if</span> x_i <span class="token operator">></span> <span class="token builtin">max</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果预测的值的范围很大，RMSE 会被一些大的值主导。这样即使你很多小的值预测准了，但是有一个非常大的值预测的不准确，RMSE 就会很大。 相应的，如果另外一个比较差的算法对这一个大的值准确一些，但是很多小的值都有偏差，可能 RMSE 会比前一个小。先取 log 再求 RMSE(就是)，可以稍微解决这个问题。RMSE 一般对于固定的平均分布的预测值才合理。</p><blockquote><p>框架的<em>延后初始化</em>（defers initialization）， 即直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小。</p><p>在以后，当使用卷积神经网络时， 由于输入维度（即图像的分辨率）将影响每个后续层的维数， 有了该技术将更加方便。 现在我们在编写代码时无须知道维度是什么就可以设置参数， 这种能力可以大大简化定义和修改模型的任务。 接下来，我们将更深入地研究初始化机制。</p></blockquote><p>如果【数据区间比较大，且全为正数】，可以用log，再做均值初始化可以压缩到很好的区间。</p><p>在设备（CPU、GPU和其他机器）之间传输数据比计算慢得多。 这也使得并行化变得更加困难，因为我们必须等待数据被发送（或者接收）， 然后才能继续进行更多的操作。 这就是为什么拷贝操作要格外小心。</p><p>CPU，GPU注意降温，不要超过80</p><p><u>把GPU的性能留给前向、反向运算，前面的操作在CPU完成。</u></p><p>GPU使用60%都已经不算低了。CNN可能更高，容易dao80-90%</p><p>Adam对初始学习率相对不敏感。</p><p>𝐾折交叉验证往往对多次测试具有相当的稳定性。 然而，如果我们尝试了不合理的超参数，我们可能会发现验证效果不再代表真正的误差。</p><p><u>较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</u></p><p>可以用少量的数据找到超参数的大致范围，然后在整个数据集上跑几轮找到精确的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314823.png" alt="img" style="zoom: 33%;" /><p>automl真的可能取代20%的调参，但是这还是得学习。80%：分析哪些数据对目标有用，搜集数据，清理数据。。。</p><p>你的价值体现在automl不能做的，你要做的更好，学习的知识是指数增长的。</p><p>世界变得很快，得要学会理论和实践的范式和能力。</p><p><u>当你调到一个比较好的参数点时，可以上下修改一下，如果结果剧烈波动，可能就调在了噪音上，泛化性不好。</u></p><p>李沐：<u>实际中调参其实没有那么重要（竞赛除外），精度还可以就行，因为数据在不断变化。</u></p><p>随时思考，如何成长——李沐的梯度下降</p><h4 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h4><p>树叶分类：<a href="https://www.kaggle.com/c/classify-leaves/data">https://www.kaggle.com/c/classify-leaves/data</a></p><p>少量高质量数据，可能有个百倍的换算。</p><p>所以不建议过度调参，这可能会overfit到目前的数据，实际场景中你可能会有越来越多的数据。（除非竞赛）</p><p>w = w-lr*w.grad 这样按照python的，左边是一个新的变量，没有attach gradient，梯度计算出问题。</p><p>机器学习老中医，深度学习炼丹哈哈哈哈哈。</p><h4 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h4><p>cifar-10图像识别：<a href="https://www.kaggle.com/c/cifar-10">https://www.kaggle.com/c/cifar-10</a></p><p>torchvision的更新没那么快，但是也不错。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#读了一个csv文件</span><span class="token keyword">def</span> <span class="token function">read_csv_labels</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""读取fname来给标签字典返回一个文件名"""</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        lines <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment"># 跳过文件头行(列名)</span>    tokens <span class="token operator">=</span> <span class="token punctuation">[</span>l<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token keyword">for</span> l <span class="token keyword">in</span> lines<span class="token punctuation">]</span><span class="token comment">#每行是一个列表</span>    <span class="token keyword">return</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> label<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> label <span class="token keyword">in</span> tokens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#转换成一个字典以供方便使用</span>labels <span class="token operator">=</span> read_csv_labels<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'trainLabels.csv'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#&#123;'1': 'frog', '2': 'truck', '3': 'truck',....&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用的是最简单的图片数据集组织格式，也就是imagefolder这个iterator，因此需要我们提前分好数据。</p><p><a href="https://www.cnblogs.com/wanghui-garcia/p/10649364.html">组织imagefolder的格式和其索引结构</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">copyfile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> target_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""将文件复制到目标目录"""</span>    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>target_dir<span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    shutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> target_dir<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">reorg_train_valid</span><span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> valid_ratio<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""将验证集从原始的训练集中拆分出来"""</span>    <span class="token comment"># 训练数据集中样本最少的类别中的样本数,这个Counter好用</span>    n <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>labels<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 验证集中每个类别的样本数</span>    n_valid_per_label <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>n <span class="token operator">*</span> valid_ratio<span class="token punctuation">)</span><span class="token punctuation">)</span>    label_count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> train_file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        label <span class="token operator">=</span> labels<span class="token punctuation">[</span>train_file<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">#获得文件名对应的标签</span>        fname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">,</span> train_file<span class="token punctuation">)</span><span class="token comment">#获得路径</span>        copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>                                     <span class="token string">'train_valid'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> label <span class="token keyword">not</span> <span class="token keyword">in</span> label_count <span class="token keyword">or</span> label_count<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n_valid_per_label<span class="token punctuation">:</span>            copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>                                         <span class="token string">'valid'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>            label_count<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">=</span> label_count<span class="token punctuation">.</span>get<span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>                                         <span class="token string">'train'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> n_valid_per_label<span class="token keyword">def</span> <span class="token function">reorg_test</span><span class="token punctuation">(</span>data_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""在预测期间整理测试集，以方便读取"""</span>    <span class="token keyword">for</span> test_file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        copyfile<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">,</span> test_file<span class="token punctuation">)</span><span class="token punctuation">,</span>                 os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">,</span>                              <span class="token string">'unknown'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#scheduler是对学习率的调整，沐神说比较好的是cos，👇这个用的挺多。</span>scheduler <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>lr_scheduler<span class="token punctuation">.</span>StepLR<span class="token punctuation">(</span>trainer<span class="token punctuation">,</span> lr_period<span class="token punctuation">,</span> lr_decay<span class="token punctuation">)</span>在完成一个迭代的训练后要加上 scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#重新训练，将pred放到cpu上，以及编制索引提交</span>net<span class="token punctuation">,</span> preds <span class="token operator">=</span> get_net<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>train<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_valid_iter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> wd<span class="token punctuation">,</span> devices<span class="token punctuation">,</span> lr_period<span class="token punctuation">,</span>      lr_decay<span class="token punctuation">)</span><span class="token keyword">for</span> X<span class="token punctuation">,</span> _ <span class="token keyword">in</span> test_iter<span class="token punctuation">:</span>    y_hat <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    preds<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sorted_ids <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_ds<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sorted_ids<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'id'</span><span class="token punctuation">:</span> sorted_ids<span class="token punctuation">,</span> <span class="token string">'label'</span><span class="token punctuation">:</span> preds<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> train_valid_ds<span class="token punctuation">.</span>classes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'submission.csv'</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>沐神：这其实是一个比较蠢的办法，因为copy了一大坨图片两次，数据如果多一点那就是很大量的复制，浪费空间和时间。在实际中通常自己写个classdata （没听清）iterator，而图片不需要动。</p><p>但如果图片数量不大，其实挺推荐，因为简单，而且方便鼠标点进去自己查看，很多框架都支持这样的组织方式。</p><p>lr-decay会让你的精度提高一些比如0.7-&gt;0.75，但不会有非常显著的提升</p><p>SGD本身就做了很强的正则，有很多噪音在里面，所以很稳定。</p><hr><h4 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h4><p>ImageNet-Dog分类：<a href="https://www.kaggle.com/c/dog-breed-identification">https://www.kaggle.com/c/dog-breed-identification</a></p><p>学术数据集注重的是通用性，业务注重客户关注的实用性。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#冻结参数，以及Sequential的使用特性。</span><span class="token keyword">def</span> <span class="token function">get_net</span><span class="token punctuation">(</span>devices<span class="token punctuation">)</span><span class="token punctuation">:</span>    finetune_net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#这应该是定义了lei</span>    finetune_net<span class="token punctuation">.</span>features <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>resnet34<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># 定义一个新的输出网络，共有120个输出类别</span>    finetune_net<span class="token punctuation">.</span>output_new <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 将模型参数分配给用于计算的CPU或GPU</span>    finetune_net <span class="token operator">=</span> finetune_net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 冻结参数</span>    <span class="token keyword">for</span> param <span class="token keyword">in</span> finetune_net<span class="token punctuation">.</span>features<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        param<span class="token punctuation">.</span>requires_grad <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> finetune_net<span class="token comment">#train里面也要改</span>trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">(</span>param <span class="token keyword">for</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>                               <span class="token keyword">if</span> param<span class="token punctuation">.</span>requires_grad<span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>lr<span class="token punctuation">,</span>                              momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> weight_decay<span class="token operator">=</span>wd<span class="token punctuation">)</span><span class="token comment">#经典evaluate</span><span class="token keyword">def</span> <span class="token function">evaluate_loss</span><span class="token punctuation">(</span>data_iter<span class="token punctuation">,</span> net<span class="token punctuation">,</span> devices<span class="token punctuation">)</span><span class="token punctuation">:</span>    l_sum<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">for</span> features<span class="token punctuation">,</span> labels <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>        features<span class="token punctuation">,</span> labels <span class="token operator">=</span> features<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>features<span class="token punctuation">)</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>        l_sum <span class="token operator">+=</span> l<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        n <span class="token operator">+=</span> labels<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>l_sum <span class="token operator">/</span> n<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次输出用的是softmax（题目要求的输出格式），这样可以研究top-5，即正确样本在不在预测前五里。</p><p>一般对于十分复杂，类别非常多的数据集（标号长得一样），大家更关心top-5.</p><p>老中医的丹方：先resize到256，再中心剪裁到224.</p><p>专家调参是非线性，靠手气哈哈，一般效率比机器调参要高一些。但还是得比较成本。</p><blockquote><p>从长远趋势来看，最后肯定是机器自动调参的。</p></blockquote><p>目前你还是可以练练调参，是个手艺活，能加深理解。没有特别好的系统学习方案，慢慢积累</p><p>trick不是长久的。</p><h3 id="Recurrent"><a href="#Recurrent" class="headerlink" title="Recurrent"></a>Recurrent</h3><p>到目前为止我们默认数据都来自于某种分布， 并且所有样本都是独立同分布的 （independently and identically distributed，i.i.d.）。 然而，大多数的数据并非如此。 例如，文章中的单词是按顺序写的，如果顺序被随机地重排，就很难理解文章原始的意思。</p><p>两种方案：</p><ol><li>通常做马尔可夫假设的自回归，仅关注定长的过去信息，可用之前的技术实现。</li><li>潜变量自回归，研究两个模型，如何根据上一个输入$x_{t-1}$和之前的时序信息$h_{t-1}$得到现在的时序信息$h_t$，以及如何用现在的$h_t$加上上一个输入$x_{t-1}$得到最新的预测$x_t$(这里引出了因果推理 casual - inference)</li></ol><p>第一种方案沐神用MLP做了演示，给定四个输入，看看不同步数的预测：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314579.png" alt="image-20220303180220223" style="zoom:50%;" align = 'left'/><p>可以看到，即使是简单的函数（sinx），预测未来也很难。事实是由于<u>错误的累积</u></p><p>隐变量是个真实存在的东西，只是没有被观察到。潜变量包括了隐变量，但也可能真的不存在，比如聚类的类信息，是现实不存在的，怎么改进sensor都观察不到。</p><p>$\tau$的选择，有一些平滑的衰减方法。因果分析最近在统计界和机器学习界都挺火的。</p><p>RNN也能记住所有的序列，而且比MLP更强大，但这不见得是一件很好的事情</p><p>可以把时序信息，看作是一维的信息量，1-D卷积也能用，效果不见得比RNN差</p><hr><p>中文分词是非常不容易的哈哈，曾经NLP里中文分词也是一大块。比较好的开源有jieba</p><p><strong>文本预处理</strong></p><p>一篇文章可以被简单地看作是一串单词序列，甚至是一串字符序列。 现实中的文档集合可能会包含数十亿个单词。</p><ol><li>将文本作为字符串加载到内存中。</li><li>将字符串拆分为词元（如单词和字符）。<em>词元</em>（token）是文本的基本单位</li><li>建立一个词表（vocab），将拆分的词元映射到数字索引。<br>我们先将训练集中的所有文档合并在一起，对它们的唯一词元进行统计， 得到的统计结果称之为<em>语料</em>（corpus）。 然后根据每个唯一词元的出现频率，为其分配一个数字索引。 很少出现的词元通常被移除，这可以降低复杂性。<br>另外，语料库中不存在或已删除的任何词元都将映射到一个特定的未知词元“<unk>”。 我们可以选择增加一个列表，用于保存那些被保留的词元， 例如：填充词元（“<pad>”）； 序列开始词元（“<bos>”）； 序列结束词元（“<eos>”）。</li><li>将文本转换为数字索引序列，方便模型操作。</li></ol><p>训练集和测试时用的vocab必须是同一个。</p><p><strong>文本序列</strong></p><p><em>语言模型</em>（language model）的目标是估计序列的联合概率  P(x1,x2,…,xT)</p><p>例如，只需要一次抽取一个词元xt∼P(xt∣xt−1,…,x1)，一个理想的语言模型就能够基于模型本身生成自然文本。 </p><p>从这样的模型中提取的文本 都将作为自然语言（例如，英语文本）来传递。 只需要基于前面的对话片断中的文本， 就足以生成一个有意义的对话。 显然，我们离设计出这样的系统还很遥远， 因为它需要“理解”文本，而不仅仅是<u>生成语法合理</u>的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314548.png" alt="image-20220328102425591"></p><p>尽管如此，语言模型依然是非常有用的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315751.png" alt="image-20220303203413886" style="zoom:50%;" /><p>训练数据集中，词的概率可以根据<u>给定词的相对词频</u>来计算。一种（稍稍不太精确的）方法是统计单词“deep”在数据集中的出现次数， 然后将其除以整个语料库中的单词总数。 这种方法效果不错，特别是对于频繁出现的单词。</p><p>但对于稍长的单词对，以及不常见的单词，情况将会变得很糟，即使 用了拉普拉斯平滑。该模型仅简单统计看到的单词的频率，想根据上下文调整这类模型其实是相当困难的。 最后，长单词序列大部分是没出现过的， 因此一个模型如果只是简单地统计先前“看到”的单词序列频率， 那么模型面对这种问题肯定是表现不佳的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315828.png" alt="image-20220303204705061" style="zoom:50%;" /><p>比如二元语法，1000个词，那就存1000*1000个可能性。。。这会带来内存的问题，但是计算复杂度直接降为$O(t)$</p><p>二元和三元<u>用的还是非常多的</u>！！一般语料库几十G….几百G【因为满足👇，节省了很多内存】</p><p>词频特征：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315420.png" alt="image-20220303215942551" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315080.png" alt="image-20220303220408876" style="zoom:50%;" /></p><p>词表中n元组的数量并没有那么大，这说明语言中存在相当多的结构， 这些结构给了我们应用模型的希望。</p><p>很多n元组很少出现，这使得拉普拉斯平滑非常不适合语言建模。 作为代替，我们将使用基于深度学习的模型 RNN</p><p>sequence sample 的时间跨度T取决于对一句话建模还是一段话建模。<strong>16，32，</strong>64，128都有，再长也能到512，我肯定到不了。不是每个模型都能支撑那么大的，取决于模型复杂的，还有一些线上的参数。</p><p><u>【一个发现：batch中的数据是并行的，在RNN有了显式体现，顺序分区时，每个batch的第一个序列是连续的，第一个和第二个和其他则没有关系，有点离谱】</u></p><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>输出发生在观察之前。</p><p>困惑度👇：一个更好的语言模型应该能让我们更准确地预测下一个词元。 因此，它应该允许我们在压缩序列时花费更少的比特。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315451.png" alt="image-20220303225344681" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315813.png" alt="image-20220303225734197" style="zoom: 25%;" /></p><p>这里的g是所有层的梯度放在一起。通过这样做，我们知道梯度范数永远不会超过θ， 并且更新后的梯度<u>完全与g的原始方向对齐</u>。 </p><p>它还有一个值得拥有的副作用， 即<u>限制任何给定的小批量数据（以及其中任何给定的样本）对参数向量的影响</u>， 这赋予了模型一定程度的<u>稳定性</u>。 梯度裁剪提供了一个快速修复梯度爆炸的方法， 虽然它并不能完全解决问题，但它是众多有效的技术之一。</p><p>困惑度的最好的理解是“下一个词元的实际选择数的调和平均数”。这使得不同长度的文档的性能具有了可比性。 我们看看一些案例：</p><ul><li>在最好的情况下，模型总是完美地估计标签词元的概率为1。 在这种情况下，模型的困惑度为1。</li><li>在最坏的情况下，模型总是预测标签词元的概率为0。 在这种情况下，困惑度是正无穷大。</li><li>在基线上，该模型的预测是词表的所有可用词元上的均匀分布。 在这种情况下，困惑度<u>等于词表中唯一词元的数量</u>。 事实上，如果我们在没有任何压缩的情况下存储序列， 这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的下限， 而任何实际模型都必须超越这个下限。</li></ul><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315914.png" alt="image-20220303230115244" style="zoom: 33%;" /><p>transformer出来以后NLP这块飞速进步，现在各大厂家在刷transomer的pretrained模型。</p><p>多模态：发现transfomer既能做image也能做文本，用一个大模型直接一起搞了。</p><p>视频tracking是一个非常成熟的领域，做的非常好了，不需要太多RNN的东西，倒是那些小波滤波器用的比较多</p><p>一般RNN的序列都是随机取，RNN不足以记住太长的序列，一般100以内。这个样本撑不起来单词</p><p>高频字符低采样是？</p><p><strong>完全计算</strong></p><p>这样的计算非常缓慢，并且可能会发生梯度爆炸， 因为初始条件的微小变化就可能会对结果产生巨大的影响。 也就是说，我们可以观察到类似于蝴蝶效应的现象， 即初始条件的很小变化就会导致结果发生不成比例的变化。 这对于我们想要估计的模型而言是非常不可取的。 毕竟，我们正在寻找的是能够很好地泛化高稳定性模型的估计器。 因此，在实践中，这种方法几乎从未使用过。</p><p><strong>截断时间步</strong></p><p>这会带来真实梯度的<em>近似</em>， 只需将求和终止为∂ht−τ/∂wh。 在实践中，这种方式工作得很好。 它通常被称为截断的通过时间反向传播 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#jaeger-2002">Jaeger, 2002]</a>。 这样做导致该模型主要侧重于短期影响，而不是长期影响。 这在现实中是可取的，因为它会将估计值偏向更简单和更稳定的模型。</p><p>虽然<u>随机截断</u>在理论上具有吸引力， 但很可能是由于多种因素在实践中并不比常规截断更好。 首先，在对过去若干个时间步经过反向传播后， 观测结果足以捕获实际的依赖关系。 其次，增加的方差抵消了时间步数越多梯度越精确的事实。 第三，我们真正想要的是只有短范围交互的模型。 因此，模型需要的正是截断的通过时间反向传播方法所具备的轻度正则化效果。</p><p><strong>反向传播</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315874.png" alt="image-20220304214915339" style="zoom: 67%;" /><p>该例子👇，激活函数实用恒等映射。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315422.png" alt="image-20220304214953302" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315068.png" alt="image-20220304215023669" style="zoom: 50%;" />此处可见一斑，出现了W的$T-i$次幂，容易发生数据不稳定<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315310.png" alt="image-20220304215125426" style="zoom:50%;" /></p><h4 id="Modern-1"><a href="#Modern-1" class="headerlink" title="Modern"></a>Modern</h4><p>梯度异常在实践中的意义：</p><ul><li>我们可能会遇到这样的情况：早期观测值对预测所有未来观测值具有非常重要的意义。 考虑一个极端情况，其中第一个观测值包含一个校验和， 目标是在序列的末尾辨别校验和是否正确。 在这种情况下，第一个词元的影响至关重要。 我们希望有某些机制能够在一个记忆元里存储重要的早期信息。 如果没有这样的机制，我们将不得不给这个观测值指定一个非常大的梯度， 因为它会影响所有后续的观测值。</li><li>我们可能会遇到这样的情况：一些词元没有相关的观测值。 例如，在对网页内容进行情感分析时， 可能有一些辅助HTML代码与网页传达的情绪无关。 我们希望有一些机制来<em>跳过</em>隐状态表示中的此类词元。</li><li>我们可能会遇到这样的情况：序列的各个部分之间存在逻辑中断。 例如，书的章节之间可能会有过渡存在， 或者证券的熊市和牛市之间可能会有过渡存在。 在这种情况下，最好有一种方法来<em>重置</em>我们的内部状态表示。</li></ul><p><strong>GRU</strong></p><p>门控循环单元与普通的循环神经网络之间的关键区别在于： 后者支持隐状态的门控。 这意味着模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态。</p><p>重置门（reset gate）和更新门（update gate）。 我们把它们设计成(0,1)(0,1)区间中的向量， 这样我们就可以进行<u>凸组合</u>。 </p><ul><li>Reset 是看要不要reset旧状态；有助于捕获序列中的<u>短期</u>依赖关系。允许我们控制“可能还想记住”的过去状态的数量；</li><li>Update是看目前的状态要不要用候选的隐状态update，还是不变。有助于捕获序列中的<u>长期</u>依赖关系。更新门将允许我们控制新状态中有多少是旧状态的副本。用tanh作激活函数是当时relu还没出来哈哈</li></ul><p>虽然矩阵乘法比RNN多三倍，但性能没有降低太多，可以通过大量并行打高GPU</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315696.png" alt="image-20220328154138256" style="zoom:43%;" />$$\begin{split}\begin{aligned}\mathbf{R}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xr} + \mathbf{H}_{t-1} \mathbf{W}_{hr} + \mathbf{b}_r),\\\mathbf{Z}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xz} + \mathbf{H}_{t-1} \mathbf{W}_{hz} + \mathbf{b}_z),\\\tilde{\mathbf{H}}_t = \tanh(\mathbf{X}_t \mathbf{W}_{xh} + \left(\mathbf{R}_t \odot \mathbf{H}_{t-1}\right) \mathbf{W}_{hh} + \mathbf{b}_h),\\\mathbf{H}_t = \mathbf{Z}_t \odot \mathbf{H}_{t-1}  + (1 - \mathbf{Z}_t) \odot \tilde{\mathbf{H}}_t.\end{aligned}\end{split}\\$$<hr><p><strong>LSTM</strong></p><p>Hinton和LSTM作者一直有矛盾</p><p>LSTM的很多设计，其实大家也不知道为什么，那就不纠结了，反正效果挺好的。</p><p>深度循环神经网络使用多个隐藏层来获得更多非线性信息。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315698.png" alt="image-20220328180244249" style="zoom:60%;" /><p>输入门$I_t$控制采用多少来自候选记忆元的新数据， 而遗忘门$F_t$控制保留多少过去的 记忆元</p><p>所以LSTM有<u>两个隐变量</u>：记忆元和隐状态<br>$$<br>\begin{split}\begin{aligned}<br>\mathbf{I}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xi} + \mathbf{H}</em>{t-1} \mathbf{W}_{hi} + \mathbf{b}<em>i),\<br>\mathbf{F}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xf} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{hf} + \mathbf{b}<em>f),\<br>\mathbf{O}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xo} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{ho} + \mathbf{b}<em>o),\<br>\tilde{\mathbf{C}}<em>t = \text{tanh}(\mathbf{X}<em>t \mathbf{W}</em>{xc} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{hc} + \mathbf{b}_c),\<br>\mathbf{C}_t = \mathbf{F}<em>t \odot \mathbf{C}</em>{t-1} + \mathbf{I}_t \odot \tilde{\mathbf{C}}_t\<br>\mathbf{H}_t = \mathbf{O}_t \odot \tanh(\mathbf{C}_t).<br>\end{aligned}\end{split}<br>$$<br>上面$C_t$范围可以做的比较大，没有数值限制，所以再用一次tanh化到正负一间保证H一直在正负一。</p><p>RNN GRU LSTM，其实<u>区别就在于怎么更新隐状态H</u></p><p>文本远远多于图片，也是目前的主流交互方式，NLP整体找工作很好找，比如文本分类、tag，summarization<br>但是文本翻译已经很成熟了。</p><h4 id="RNN-pro"><a href="#RNN-pro" class="headerlink" title="RNN pro"></a>RNN pro</h4><p><strong>深度RNN</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315617.png" alt="image-20220328182237893" style="zoom: 50%;" /><p><code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</code>加个num_layers就行了</p><p><strong>双向RNN</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315713.png" alt="image-20220328183730393" style="zoom:50%;" /><p>双向RNN非常不适合做推理，几乎不能预测下一个词，因为要同时看到上下文。</p><p>所以主要应用是对句子做特征提取。比如语音等你一句话说完，翻译后来回扫一扫确认语义给你。</p><p><code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=True)</code></p><p>正向和反向没有权重这一说，是用concat连在一起的平级参数。</p><hr><h4 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h4><p><strong>机器翻译</strong></p><p>语言模型是自然语言处理的关键， 而<em>机器翻译</em>是语言模型最成功的基准测试。 因为机器翻译正是将输入序列转换成输出序列的 <em>序列转换模型</em>（sequence transduction）的核心问题。 序列转换模型在各类现代人工智能应用中发挥着至关重要的作用</p><p><em>机器翻译</em>（machine translation）指的是 将序列从一种语言自动翻译成另一种语言。在使用神经网络进行端到端学习的兴起之前， 统计学方法在这一领域一直占据主导地位。</p><p>神经网络机器翻译方法，强调的是端到端的学习。  </p><blockquote><p>在机器翻译中，我们更喜欢单词级词元化 （最先进的模型可能使用更高级的词元化技术）其中每个词元要么是一个词，要么是一个标点符号。</p><p>机器翻译数据集由语言对组成， 因此我们可以分别为源语言和目标语言构建两个词表。 使用单词级词元化时，词表大小将明显大于使用字符级词元化时的词表大小。<br>为了缓解这一问题，这里我们将出现次数少于2次的低频率词元 视为相同的未知（“<unk>”）词元。<br>除此之外，我们还指定了额外的特定词元， 例如在小批量时用于将序列填充到相同长度的填充词元（“<pad>”）， 以及序列的开始词元（“<bos>”）和结束词元（“<eos>”）。 这些特殊词元在自然语言处理任务中比较常用。</p><p>语言模型中的序列样本都有一个固定的长度， 无论这个样本是一个句子的一部分还是跨越了多个句子的一个片断。 这个固定长度是由 <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html#sec-language-model">8.3节</a>中的 <code>num_steps</code>（时间步数或词元数量）参数指定的。<br>为了提高计算效率，我们仍然可以通过<em>截断</em>（truncation）和 <em>填充</em>（padding）方式实现一次只处理一个小批量的文本序列。 假设同一个小批量中的每个序列都应该具有相同的长度<code>num_steps</code>， 那么如果文本序列的词元数目少于<code>num_steps</code>时， 我们将继续在其末尾添加特定的“<pad>”词元， 直到其长度达到<code>num_steps</code>； 反之，我们将截断文本序列时，只取其前<code>num_steps</code> 个词元， 并且丢弃剩余的词元。这样，每个文本序列将具有相同的长度， 以便以相同形状的小批量进行加载。</p><p>我们将特定的“<eos>”词元添加到所有序列的末尾， 用于表示序列的结束。 当模型通过一个词元接一个词元地生成序列进行预测时， 生成的“<eos>”词元说明完成了序列输出工作。</p><p>此外，我们还记录了每个文本序列的长度， 统计长度时排除了填充词元， 在稍后将要介绍的一些模型会需要这个长度信息。</p></blockquote><hr><p>:star2:</p><p>最近几年影响比较深的对模型的抽象。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316498.png" alt="image-20220328192320663" style="zoom: 27%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316770.png" alt="image-20220328192352169" style="zoom:27%;" /></p><p>设计一个包含两个主要组件的架构： </p><p>第一个组件是一个<em>编码器</em>（encoder）： 它接受一个<u>长度可变</u>的序列作为输入， 并将其转换为具有<u>固定形状</u>的编码状态。【注意，实现的时候，encoder的输出enc_ouputs就是RNN的输出，<u>在decoder的初始化中，将这个转成编码后的状态。</u>】    编码器通过选定的<u>函数$q$</u>， 将所有时间步的隐状态转换为==上下文变量$c$==。后文用的上下文变量是<u>最后时间步的最后一层的隐状态。</u></p><p> 第二个组件是<em>解码器</em>（decoder）： 它将固定形状的编码状态映射到长度可变的序列。 在每个时间步都会将输入 （例如：在前一时间步生成的词元）和编码后的状态 映射成当前时间步的输出词元。【后文中，在seq2seq里，encoder的output被扔掉，最后的state用来初始化decoder；在attention中，就用上了output】</p><p>这被称为<em>编码器-解码器</em>（encoder-decoder）架构。编码器的输出用于生成编码状态， 这个状态又被解码器作为其输入的一部分。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316488.png" alt="image-20220328192511963" style="zoom:50%;" /><hr><p><strong>序列到序列学习（seq2seq）</strong></p><p>遵循编码器－解码器架构的设计原则， 循环神经网络编码器使用长度可变的序列作为输入， 将其转换为固定形状的隐状态。 换言之，输入序列的信息被<em>编码</em>到循环神经网络编码器的隐状态中。 </p><p>为了连续生成输出序列的词元， 独立的循环神经网络解码器是基于输入序列的编码信息 和输出序列已经看见的或者生成的词元来预测下一个词元。 </p><p>训练decoder时，知道真正的输出，所以预测错了某个，还是拿正确的输入到下一个。【<em>强制教学</em>】</p><p>预测的时候，得把源句子tokenize后丢进encoder和decoder转一圈，依次取输出的值，state喂到下一个去，区别是decoder阶段，是拿你当前的预测输入到下一个去。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316899.png" alt="image-20220328193657017" style="zoom:67%;" /><p>两个特定的设计： 首先，特定的“<bos>”表示序列开始词元，它是解码器的输入序列的第一个词元。 其次，使用循环神经网络编码器<strong>最终</strong>的隐状态来初始化解码器的隐状态，因此<u>编码器可以是双向</u>，只关心最终。</p><p>在其他一些设计中 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#cho-van-merrienboer-gulcehre-ea-2014">Cho et al., 2014b]</a>， 如 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html#fig-seq2seq">图9.7.1</a>所示， 编码器最终的隐状态在每一个时间步都作为解码器的输入序列的一部分。</p><p>最终架构如下：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316534.png" alt="image-20220328194342920" style="zoom:60%;" /><blockquote><p><em>嵌入层</em>（embedding layer） 来获得输入序列中每个词元的特征向量。 嵌入层的权重是一个矩阵， 其行数等于输入词表的大小（<code>vocab_size</code>）， 其列数等于特征向量的维度（<code>embed_size</code>）。 对于任意输入词元的索引i， 嵌入层获取权重矩阵的第i行（从0开始）以返回其特征向量。 </p><p>维度保持不变，只是把索引变成了索引对应的特征向量，1维变成embed_size维</p><p><a href="https://blog.csdn.net/qq_39540454/article/details/115215056">https://blog.csdn.net/qq_39540454/article/details/115215056</a></p></blockquote><p><em>评价标准</em></p><p>预测的句子可能和实际句子长度不同，如何衡量。</p><p>BLEU（bilingual evaluation understudy） 最先是用于评估机器翻译的结果， 但现在它已经被广泛用于测量许多应用的输出序列的质量。 原则上说，对于预测序列中的任意n元语法（n-grams）， BLEU的评估都是这个n元语法是否出现在标签序列中。<br>$$<br>\exp\left(\min\left(0, 1 - \frac{\mathrm{len}<em>{\text{label}}}{\mathrm{len}</em>{\text{pred}}}\right)\right) \prod_{n=1}^k p_n^{1/2^n},<br>$$<br>1-xxx那项是惩罚过短的预测；最后$p_n$的幂是给长匹配更高的权重。</p><p>最好的结果是1。</p><p>word2vec已经没什么人用了，都用BERT。</p><p>seq2seq可以用纯transformer实现，但是潮流而已，说不定到时候RNN又更好了。</p><p><strong>束搜索</strong></p><p>贪心搜索是效率最高的，但是可能不是最优的。穷举在计算上不可行。beam search是折中。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316499.png" alt="image-20220328212245438" style="zoom:50%;" /><p>除了第一步，后续还是贪心。 它有一个超参数，名为<em>束宽</em>（beam size）k。 在时间步1，我们选择具有最高条件概率的k个词元。 这k个词元将分别是k个候选输出序列的第一个词元。 在随后的每个时间步，基于上一时间步的k个候选输出序列， 我们将继续从k|Y|个可能的选择中 挑出具有最高条件概率的k个候选输出序列。</p><p>我们会得到六个候选输出序列： （1）A；（2）C；（3）A,B；（4）C,E；（5）A,B,D；（6）C,E,D。</p><p>我们选择其中条件概率乘积最高的序列作为输出序列,但是得惩罚长序列，取log转成负的，免得只选短的，这也是权衡。<br>$$<br>\frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}\mid \mathbf{c}) = \frac{1}{L^\alpha} \sum_{t’=1}^L \log P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \mathbf{c}),<br>$$</p><p>L是最终候选序列的长度， α通常设置为0.75。</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>注意⼒机制解决了困扰统计学⼀个多世纪的问题：如何在不增加可学习参数的情况下增加系统的记忆和复杂性。</p><p>研究⼈员通过使⽤只能被视为可学习的指针结构，找到了⼀个优雅的解决⽅案。不需要记住整个⽂本序列（例如⽤于固定维度表⽰中的机器翻译），所有需要存储的都是指向翻译过程的<u>中间状态的指针（查询）</u>。这⼤⼤提⾼了⻓序列的准确性，因为模型在开始⽣成新序列之前不再需要记住整个序列。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>意识的聚集和专注使灵长类动物能够在复杂的视觉环境中将注意力引向感兴趣的物体，例如猎物和天敌。 只关注一小部分信息的能力对进化更加有意义</p><p><em>双组件</em>（two-component）<strong>框架</strong></p><p>非自主性提示（非随意）是基于环境中物体的突出性和易见性。不由自主地引起人们的注意。【卷积、全连接、池化】<br>自主性提示（随意）去辅助选择时，受试者的主观意愿推动，选择的力量也就更强大。</p><p>自主性提示称为<em>查询</em>（query）。 给定任何查询，注意力机制通过<em>注意力汇聚</em>（Attention Pooling） 将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。 在注意力机制中，这些感官输入被称为<em>值</em>（value）。 更通俗的解释，<u>每个值都与一个<em>键</em>（key）配对</u>， 这可以想象为感官输入的非自主提示。设计注意力汇聚， 以便给定的查询（自主性提示）可以与键（非自主性提示）进行匹配， 这将引导得出最匹配的值（感官输入）。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316974.png" alt="image-20220325210900151" style="zoom:50%;" /><p>理解键值对的思想。注意力机制的设计有许多替代方案。 例如，我们可以设计一个不可微的注意力模型， 该模型可以使用强化学习方法 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#mnih-heess-graves-ea-2014">Mnih et al., 2014]</a>进行训练。</p><p><strong>注意力汇聚</strong></p><p>Nadaraya-Watson 核回归</p><p>历史的这个<strong>高斯核回归</strong>是一种不错的注意力汇聚方式。</p><p>思想：如果一个键xi越是接近给定的查询x， 那么分配给这个键对应值yi的注意力权重就会越大， 也就“获得了更多的注意力”。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316992.png" alt="image-20220325210245930" style="zoom: 28%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316229.png" alt="image-20220325210416156" style="zoom:33%;" /></p><p>如果要参数化，就加入w：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316022.png" alt="image-20220325210715625" style="zoom:25%;" /></p><p>w可以控制你最终的曲线的平滑程度，不那么平滑有利于拟合。</p><p>在带参数的注意力汇聚模型中， 任何一个训练样本的输入都会和除自己以外的所有训练样本的“键－值”对进行计算， 从而得到其对应的预测输出。</p><p>查询和键之间的交互形成了注意力汇聚， 注意力汇聚<u>有选择地聚合了值（感官输入）以生成最终的输出</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317436.png" alt="image-20220325214835848" style="zoom:60%;" /><p><strong>评分函数</strong></p><p>将高斯核指数里面的部分（$-\frac{1}{2}(x-x_i)^2$）视为<em>注意力评分函数</em>（attention scoring function）， 简称<em>评分函数</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317055.png" alt="image-20220325221459365" style="zoom:50%;" /><p>查询q和键$k_i$的注意力权重（标量） 是通过注意力评分函数a 将两个向量映射成标量， 再经过softmax运算得到的<br>$$<br>\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q}, \mathbf{k}_i)) = \frac{\exp(a(\mathbf{q}, \mathbf{k}<em>i))}{\sum</em>{j=1}^m \exp(a(\mathbf{q}, \mathbf{k}_j))} \in \mathbb{R}.<br>$$<br>拓展到多维，则query、key、value<u>可以有不同的shape</u>，关键是a怎么设计</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317564.png" alt="image-20220325223039120" style="zoom:40%;" /><p>两种常见分数计算（多维）：</p><ul><li><p>相同长度，计算效率更高，缩放点积注意力，直接做内积然后除以向量长度的开方【好处是不用学习任何东西，唯一超参数是dropout】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317693.png" alt="image-20220412190141947" style="zoom: 80%;" /></li><li><p>任意长度，加性注意力，合并起来进入一个单输出单隐藏层的MLP：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317332.png" alt="image-20220325223335333" style="zoom:70%;" /></li></ul><p>注意力分数是query和key的相似度，注意力权重是分数的softmax结果，normalize过的</p><p>masked_softmax是根据语义来的，比如根据前面的预测，那后面的输入就不考虑。</p><p><u>把这套方法用在不同领域其实就是 如何定义、设置query、key、value的过程</u>，不同的领域中形式会大不相同。</p><h4 id="例子seq2seq"><a href="#例子seq2seq" class="headerlink" title="例子seq2seq"></a>例子seq2seq</h4><p>seq2seq（序列到序列可<em>不局限于文本</em>）还可用于语音和文字之间的转换，chatbot之类的。</p><p>我们经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。</p><p>如果不是所有输入词元都相关，模型将仅对齐（或参与）输入序列中与当前预测相关的部分。这是通过将上下文变量视为注意力集中的输出来实现的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317660.png" alt="image-20220329182816505" style="zoom:40%;" /><p>基于字母的一些语言，（英语、法语）什么的，大概率是词一一对应的。</p><p>因此希望在翻译时能更<u>关注对应位置</u>的词，而不是像之前一样只输入一个最后的隐状态。</p><p><strong>Bahdanau注意力</strong>的架构（对比）：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317383.png" alt="image-20220412192135684"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318026.png" alt="image-20220329184054820" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318386.png" alt="image-20220329183723549" style="zoom:60%;" /></p><ul><li>编码器对每个词的输出同时作为Key和Value，本身作为值，而又与查询“比较距离”，参与权重计算。</li><li>解码器RNN对上一个词的预测作为query，比方说上个预测的词是Hello，作为query拿到编码器中对key进行匹配，找到Hello附近的那一圈词，分配更高的注意力权重。【用RNN输出而不是embedding输入是因为<u>RNN的输出在一个语义空间里</u>】</li><li>注意力的输出替代了上下文c，与embedding的输入合并进入解码器的RNN层</li></ul><p>其他的和之前的seq2seq没差别。</p><h4 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h4><p>【是不是因为query和key长度一样，<u>所以都是用内积而不是加性注意力</u>】</p><p>它指的不是Target和Source之间的Attention机制，而是Source<u>内部元素之间或者Target内部元素之间发生的Attention机制</u>，也可以理解为Target=Source这种特殊情况下的注意力计算机制。<strong>Q=K=V</strong>。只需要在Source处进行对应的<u>矩阵操作</u>，用不到Target中的信息。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318498.png" alt="img" style="zoom:67%;" /><p>attention和self attention 其具体计算过程是一样的，只是计算对象发生了变化而已。</p><p>我们经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。 那么怎么用<u>注意力机制对序列进行编码</u>呢</p><p>有了注意力机制之后，我们将词元序列输入注意力池化中， 以便同一组词元<u>同时充当查询、键和值</u>。 具体来说，每个查询都会关注<em>所有</em>的键－值对并生成一个注意力输出。</p><p>由于查询、键和值来自同一组输入，因此被称为 <em>自注意力</em>（self-attention）</p><p>自注意力机制相对注意力机制而言，减少了对外部信息的依赖，更擅长捕捉数据或特征的<u>内部相关性</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318599.png" alt="image-20220329214801078" style="zoom: 45%;" /><p>其中$f$就是之前讨论过的<u>注意力汇聚（也可称为池化）函数</u></p><hr><p>序列长度是n，输入和输出的通道数量都是d，CNN里的k是卷积核大小。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318975.png" alt="image-20220329214900057" style="zoom: 40%;" /><p>并行度是说你的输出可以并行地接着运算，有利于GPU发挥实力。顺序操作会妨碍并行计算，而任意的序列位置组合之间的路径越短，则能更轻松地学习序列中的远距离依赖关系。</p><p>RNN路径长，无法并行，有些针对RNN的修改增加了计算量，但也增加了并行度，结果时间可能并没有增加。路径长说明前面的词元要传递信息给最后的词元要跨越很长的距离，这样<u>不便于长期记忆，但是对整个序列的记忆比较好</u>，擅长序列性的。</p><p>自注意力，在序列比较长时，计算量是指数增长的，因为每次都要回去看一整个序列。相对的，其并行度就非常好，所以像TPU这种大型矩阵乘法的硬件，支持的就非常好。还有在比较长的序列时，路径永远为1，可以轻松抓取很远的信息。所以抛开计算，自注意力<u>很适合处理长文本</u>。</p><p>所以基于注意力的算起来特别贵。比CNN贵多了，可能会达到几千个GPU一起算。</p><p><strong>位置编码</strong></p><p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的， 而自注意力则因为并行计算而放弃了顺序操作，因此失去了位置信息 。（输入随便打乱位置，最终输出的位置跟随变化，但是内容没有影响。）</p><p>解决方法：为了使用序列的顺序信息，我们在<u>输入</u>表示中添加 <em>位置编码</em>（positional encoding）来注入绝对的或相对的位置信息。 </p><p>有意思的是，它不是把信息加到模型里，这会有各种问题（比如RNN那种，并行度一下就低了），而是加到了输入里。</p><p>行号$i$，列号$j$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318674.png" alt="image-20220330110116125" style="zoom:50%;" /><p>在位置嵌入矩阵P中， <u>行代表词元在序列中的位置，列代表位置编码的不同维度</u>。 在下面的例子中，我们可以看到位置嵌入矩阵的第6列和第7列的频率高于第8列和第9列。 第6列和第7列之间的偏移量（第8列和第9列相同）是由于正弦函数和余弦函数的交替。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318844.png" alt="image-20220330110716374" style="zoom:50%;" /><p>所以，相当于对每个样本、维度加上一点不一样的值，让模型去分辨这个细微的东西来学到时序，挺奇怪的。</p><p>好处是不改变模型，也不改变数据大小，坏处是你的模型可能认不出来:joy:</p><p>沿着编码维度单调降低的频率与绝对位置信息的<u>关系</u>（<em>大致理解</em>）：</p><p>通过计算机的二进制编码解释，例子中维度是3维，每个数字、每两个数字和每四个数字上的比特值 在第一个最低位、第二个最低位和第三个最低位上分别交替。    然后<u>前面的维度频率慢，后面的维度频率快</u>（第一维01010101）由于输出是浮点数，因此此类连续表示比二进制表示法更节省空间。 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318163.png" alt="image-20220330112128687" style="zoom:50%;" /><p>之所以使用sin、cos函数，是因为这样编码的是<em>相对位置信息</em>。投影矩阵和你的i也就是样本位置无关，但是和你的维度有关。对于任何确定的<u>位置偏移δ</u>，位置i+δ处 的位置编码可以<u>线性投影位置i处的位置编码</u>来表示。</p><p>因为我们学的都是这个w，所以他会学到相对的信息，而不是绝对的信息</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318782.png" alt="image-20220330113233357" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318271.png" alt="image-20220412204409955" style="zoom:60%;" /></p><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#vaswani-shazeer-parmar-ea-2017">Vaswani et al., 2017]</a>。尽管transformer最初是应用于在文本数据上的序列到序列学习，但现在已经推广到<u>各种现代的深度学中</u>，例如语言、视觉、语音和强化学习领域。</p><p>从transformer开始，取名越来越fancy了，包括bert什么的。</p><p>基于编码器-解码器架构来处理序列对。<br>但跟使用注意力的seq2seq不同，transformer是纯基于注意力的。</p><blockquote><p>Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为sublayer）。第一个子层是<em>多头自注意力</em>（multi-head self-attention）汇聚；第二个子层是<em>基于位置的前馈网络</em>（positionwise feed-forward network）。<br>在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出。每个子层都采用了<em>残差连接</em>（residual connection）。在transformer中，对于序列中任何位置的任何输入x∈Rd，都要求满足sublayer(x)∈Rd，以便残差连接满足x+sublayer(x)∈Rd。在残差连接的加法计算之后，紧接着应用<em>层规范化</em>（layer normalization）。<br>因此，输入序列对应的每个位置，transformer编码器都将输出一个d维表示向量。</p><p>Transformer解码器也是由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<em>编码器－解码器注意力</em>（encoder-decoder attention）层。<br>在编码器－解码器注意力中，<u>查询</u>来自前一个解码器层的输出，而<u>键和值</u>来自整个编码器的输出。<br>在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<em>掩蔽</em>（masked）注意力保留了<em>自回归</em>（auto-regressive）属性，确保<u>预测仅依赖于已生成的输出词元</u>。【还有一种decoder是NAT（Non-autoregressive），李宏毅有介绍】</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318141.png" alt="image-20220330125329726" style="zoom:50%;" /><p>编码器和解码器的第一个蓝块（注意力块）是self-attension，但是解码器上面那个是普通的attention用来接收编码器的输出。</p><p><strong>多头注意力</strong></p><p>当给定相同的查询、键和值的集合时， 我们希望模型可以基于相同的注意力机制学习到不同的行为， 然后将不同的行为作为知识组合起来， 捕获序列内<u>各种范围的依赖关系</u>。（例如，短距离依赖和长距离依赖关系）<br>因此，允许注意力机制组合使用查询、键和值的不同 <em>子空间表示</em>（representation subspaces）可能是有益的。</p><p>我们可以用独立学习得到的h组不同的 <em>线性投影</em>（linear projections）来变换查询、键和值。 然后，这h组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这h个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。 </p><p>首先通过全连接层，把你映射到（可能低一点的）dimension，对于输出的n个注意力，在特征维度concat起来，再用一个$W_o$变换</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318837.png" alt="image-20220330123028745" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318388.png" alt="image-20220330123016522" style="zoom:40%;" /></p><p>不过，比如在解码器对序列中的一个元素输出时，不应该考虑该元素后面的元素，可以通过掩码来实现。（也就是计算$x_i$输出时，假装当前序列长度为$i$）</p><p><em>基于位置的前馈网络</em></p><p>说白了还是一个全连接，（batch_size，序列的长度，dimension）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318635.png" alt="image-20220330130650343" style="zoom:50%;" /><p>模型应该与n（序列长度）无关，可以处理任意长度的，所以不能处理成一个特征。</p><p>对序列中的每个元素（$x_i$是长度为dimension的向量）作用两个全连接层（输出了又换回来）。</p><p>FFN的作用应该就是提供更多的非线性和学习能力。草，我懂了，其实就是一个跟维度n无关的全连接。</p><p><em>Add &amp; norm</em></p><p>add就是加上一个残差连接。norm是层归一化，但是不能用之前说的那个batch normalization，因为序列长度n会变。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318861.png" alt="image-20220412211608697" style="zoom:30%;" /><p>可见，batch norm是选每个（通道内的）所有batch的元素进行归一化。<br>Layer是一个batch内部，自己把多个特征的元素一起归一化。这样稳定性，<u>不会因为n而发生很大变化</u>。</p><p><em>信息传递</em></p><p>编码器和解码器的第一个蓝块（注意力块）是self-attension，但是解码器上面那个是普通的attention用来接收编码器的输出。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319646.png" alt="image-20220412212412605" style="zoom:33%;" /><p>编码器和解码器的输出因此一般都是一样的，一是为了简单，二是为了对称。</p><p><em>预测</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319897.png" alt="image-20220412212634022" style="zoom:33%;" /><p>预测的时候就不再像训练的时候并行的了，需要一个个顺序的预测，因为要用到之前的预测值。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319798.png" alt="image-20220412212827629" style="zoom:33%;" /><p>transformer本身还好，只是bert那些鬼东西难算。</p><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319924.png" alt="image-20220504095017854" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319216.png" alt="image-20220504095327879" style="zoom:29%;" /></p><p>原本输入分src和tar，分别进encoder和decoder，现在只剩encoder，就要修改修改。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319800.png" alt="image-20220504095411426" style="zoom:32%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319725.png" alt="image-20220504100052544" style="zoom: 32%;" /></p><p>encoder是双向的，可以看到前和后，抽取比较好的特征。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319527.png" alt="image-20220504104316858" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319157.png" alt="image-20220413110151727" style="zoom:50%;" /><p>  <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319171.png" alt="image-20220302104957284" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319356.png" alt="image-20220302105027404" style="zoom:33%;" />  机器学习和深度学习提取的特征不太一样，不一定深度学习提取的就是最好的（跟数据量和模型都有关），是<strong>互补</strong>关系。<br> 代码不是都和数学原理有关，还有很多tricks。现实生活中tabula数据比图片用的yao多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;【如今，工程远远走在了理论的前面，但迟早会有一天有人提出新的理论框架来解释它】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh-v2.d2l.ai/chapter_attention-mechanisms/index.html&quot;&gt;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数学感悟</title>
    <link href="https://darren-dong.com/2021/12/10/%E6%95%B0%E5%AD%A6%E6%84%9F%E6%82%9F/"/>
    <id>https://darren-dong.com/2021/12/10/%E6%95%B0%E5%AD%A6%E6%84%9F%E6%82%9F/</id>
    <published>2021-12-10T08:34:23.000Z</published>
    <updated>2022-05-10T05:18:18.056Z</updated>
    
    <content type="html"><![CDATA[<p>数学是一门计算的学问，不断组合现有结论达到 ”巧妙计算“，但当技巧穷尽，还有一门研究如何暴力计算的数值分析，这需要借助计算机，而机器学习依靠的就是这些。</p><p><strong>许多内容是个人直觉感悟，可能有错</strong></p><p>纯粹数学：不顾与现实的几何，单单研究数学本身，以数论为主体。</p><p>计算数学 研究的是如何在找不到公式解的情况下（比如超越方程）找到近似解，而数值分析就是研究如何用计算机来完成这一过程，是计算数学的主体部分。</p><p>包括矩阵计算【数值线性代数】</p><p>线代是研究【线性】的学科，因为人类在线性领域研究颇深。而矩阵是线代的一种表示工具。</p><p>矩阵经过发展，形成了独立的数学分支——矩阵论。</p><p>具体数学是教你如何把一个实际问题一步步演化为<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/1376909">数学模型</a>，然后通过计算机解决它，特别着重于算法分析方面。算法偏向于将理论转变为高效的程序。【我才懒得搞这个。。卷死了】</p><p>微积分：解决了无穷小的定义问题，严谨的用极限来分析计算问题。</p><p>数学分析是分析学的基础，包括了微积分，又拓展了级数、复数和更多的函数域。</p><p>泛函分析：研究对象是函数构成的空间，看作无限维向量空间的解析几何和数学分析。</p><p>拓扑 是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的<strong>位置关系而不考虑它们的形状和大小</strong>。</p><p>统计学是通过搜索、整理、分析、描述数据等手段，以达到推断所测对象的本质，甚至预测对象未来的一门综合性科学。分为描述统计和推断统计，代表了完成统计的两个过程。这也是类似心理学的，结合了大量的领域知识。有几分估算，有些玄幻。。。变魔术。</p><p>数理统计以概率论为基础，研究大量随机现象变化规律的一种方法。精准</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>reflection = 2projection - I</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002323702.png" alt="image-20210923002323702" style="zoom:67%;" />分解怎么分的</p></li><li><p>连续求偏导，af/ax * af/ay</p></li></ol><p>理论可以分学派，但是这只是由基本假设不同而探索的不同路径，对于理论家们，只是选择了一个方向继续研究而已，而不是什么党派斗争。</p><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><ol><li><p>所谓极限，强调的是存在性，只要极限存在，那么不论你需要多高的收敛精度，总能做到。</p></li><li><p>导数只能研究一维，微分可以研究更高维度的</p></li><li><p>泰勒是对函数更高层导数的拟合。</p></li><li><p>反常和级数收敛是找到“无限中的有限”</p></li><li><p>对二元函数来讲，z=f(x,y)三维空间中的一个曲面，<strong>在某点可微意味着在该点有唯一切平面</strong>，也就是说平面上通过该点的所有曲线有切线，且所有切线共面。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-4d7351677207685ef8751c9ac200e4e3_720w.jpg" alt="v2-4d7351677207685ef8751c9ac200e4e3_720w"></p><p>因此有可微-&gt;偏导存在 + 函数连续</p><p>而可微的充分条件：每个正交方向上的偏导数都在小邻域内存在连续，则是因为<strong>正交基线性组合</strong>可以铺满整个空间（二元方程就是二维空间），确保能完成超平面的效果。</p></li><li><p>输入参数（几元）每多一个，反向传播就提高几倍效率，因为节省了重复计算。</p></li><li><p>导数除了理解为”趋势“，还可以理解为”权重“，在F（x,y,z）的求隐函数例子中，x，y，z相互之间的导数与对整体F偏导有关，这里就反映了权重的关系，谁的权重大，对整体的影响就大。</p><p>比如：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-6fd72844899de59141cede582df9aa9b_720w.jpg" alt="v2-6fd72844899de59141cede582df9aa9b_720w"></p><p>假如，Fx/Fy比较大，证明x影响大，所以dy/dx大，代表x能替换更多的dy。负号是因为那一点是固定的，每多一点x，就要减少那么多y才能维持不变。</p></li><li><p>【人们好像默认选用<strong>正交</strong>的参数或基底】，而方向导数就是线性组合正交基来表示任意方向。</p></li><li><p>我是这样理解高阶泰勒的，这其实就是多了个链式法则，从低纬度一步一步组合到最高的维度，根据链式法则来穷尽所有的组合，因为每一步都要考虑不同正交基间的相互影响。而这种线性组合的穷尽，当然用线性代数里面的矩阵比较好表示一些，也就是黑塞矩阵</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li><p>曲线求的是切线和法平面，用的是导数，</p><p>曲面求的是切平面和法线，用的是偏导数。</p></li><li></li></ol><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ol><li><p>分布列对于随机变量的每个取值给出对应的概率。它对应的是X的值也就是值域而不是x的定义域</p><p>卧槽，我发现诡异的地方了。。。x在这里是X的取值，而不是基本事件的定义域。。。tmd</p><p>在概率论里面，“随机变量”好像才是第一层。。。而它本身就是一个映射规则很奇怪的函数、、</p></li><li><p>各种定律乱七八糟的，其实还不就那几个思想：</p><p>分组（全概率），序贯（乘法定理），条件就是选取更小的样本空间然后继续分组，贝叶斯就是部分/整体。独立性要区分。。玄学。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-37387c56c6d1740aedab256f1081fced_1440w.jpg" alt="img"></p><p>独立性和条件独立性并没联系。</p><p>两两独立和相互独立也没关系。这个独立非常玄学。它根本没用普通的数学关系表示出来，<code>因为数学不能刻画现实的所有逻辑</code>，哪怕是离散数学，也只能刻画部分而已。</p><ol><li>全期望 P92，【无条件平均（期望）可由条件平均（条件下的期望）再求平均得到】</li><li>连续和离散贝叶斯 P160</li><li>重期望法则 P195 条件期望的期望 = 无条件期望（全期望的另一版本）</li><li>全方差法则 P199 总方差可分为 组内方差平均数 + 各组间的方差（有物竞那味了）【这俩可用来化简】<br>理论依据：估计$E[X|Y]$ 与 估计误差$E[X|Y]-X$ 相互独立</li><li>矩母函数（变换）是对概率（分布律/概率密度函数）的另一种表述，不太直观，单解决某些类型的数学计算很方便<br>$M_X(s) = E(e^{sX})$ 矩母函数是参数为s的函数。即矩母函数作用于一个函数得到一个新的函数。<br>$M_Y(s) = E(e^{s(aX+b)}) =e^{sb}E(e^{saX}) = e^{sb}M_X(sa)$   标准正态分布$M_Y(s) = e^{s^2/2}$   一般$M_X(s) = e^{(\sigma^2s^2/2)+\mu s}$<br>$M_X(0) = 1$          $\displaystyle \lim_{s\rightarrow -\infin}M_X(s) = P(X=0)$</li><li>独立随机变量和与矩母  和的矩母为随机变量矩母之积 P207  常见分布矩母函数表 P208-209</li><li><u>随机数个</u> 相互独立随机变量之和的 均值、方差、矩母</li></ol><p><strong>随机过程</strong><br>是处理包含时间以及数据序列的概率模型。<br>序列中的每个数据都视为一个随机变量，简单地说，随机过程就是遗传（有限或无限）随机变量序列。<br>特征：强调过程中产生的数据序列之间的相关关系、对整个过程的长期均值感兴趣、刻画边界事件的似然或概率<br>种类繁多，本书仅讨论：到达过程、马尔可夫过程</p><ul><li>到达过程：“到达”特性是否发生，研究<u>相邻到达时间是相互独立的随机变量</u>的模型，根据服从几何、指数分为伯努利、泊松过程。</li><li>马尔可夫过程：未来数据演化与历史数据有概率相关结构，但假设未来数据只依赖当前数据，与过去数据无关，技术十分成熟。</li></ul><p>与伯努利相比，泊松是连续时间轴上的到达过程。其性质见269         </p><table><thead><tr><th></th><th>泊松</th><th>伯努利</th></tr></thead><tbody><tr><td>到达时间</td><td>连续</td><td>离散</td></tr><tr><td>到达次数分布(<em>可加</em>)</td><td>泊松(参数为$\lambda \tau$)</td><td>二项</td></tr><tr><td>相邻到达时间分布(<em>独立、无记忆</em>)</td><td>指数</td><td>几何</td></tr><tr><td>到达率</td><td>$\lambda/$单位时间</td><td>$p/$每次试验</td></tr><tr><td>第k次到达的时间</td><td>埃尔朗\伽玛分布 P272</td><td>帕斯卡分布 P261</td></tr></tbody></table><p>到达次数随机变量是相邻到达时间随机变量之和：$Y_k = T_1+…+T_k$</p><p>P262 伯努利过程的分裂与合并，仍是伯努利，$pq\ p(1-q)\ (p+q-pq)$    </p><p>P274 泊松过程分裂合并类似，$\lambda p$  $\lambda_1+\lambda_2$ </p><p>P277 随机数个独立随机变量和的性质。</p><p>随机插入悖论，由于插入时，插入不同区间的概率不同，进行修正。泊松过程将区间修正为二阶埃尔朗分布，其他过程也会有影响。</p><p>马尔可夫模型中，未来会依赖过去，影响归结为对<em>状态</em>的影响，变量取值有限。<br>马尔可夫模型哪里都有，包含了几乎所有的动力模型，状态随时间变化具有不确定性。同分<em>离散、连续</em></p></li></ol><h2 id="线代和矩阵论"><a href="#线代和矩阵论" class="headerlink" title="线代和矩阵论"></a>线代和矩阵论</h2><p>线性代数最让人陶醉的是，它非常自然的引出了多维空间的概念，即使我们想象不出来。由于科学研究中的非<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/9857200">线性模型</a>通常可以被近似为<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B">线性模型</a>，使得线性代数被广泛地应用于自然科学和社会科学中。<a href="https://baike.baidu.com/item/%E9%9D%9E%E7%BA%BF%E6%80%A7">非线性</a>的问题极为困难，我们并没有足够多的通用的性质和定理用于求解具体问题。如果能够把非线性的问题化为线性的，这是我们一定要走的方向！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-736ecb905966099feac5e943e365aa6f_r.png" alt="v2-736ecb905966099feac5e943e365aa6f_r"></p><p>还有什么能比这更牛逼的图？</p><ol><li><p>Ax = b   A作用于x，x默认是一列，对A的各列进行线性组合得到向量b</p><p>也可以理解为，n维的向量，经过空间变化（A），得到m维对应的结果b</p><p>这是线代的基石（为什么不用行？因为约定向量是按列的，所以这样更有意义）</p></li><li><p>矩阵乘法也很好解释，投影到的空间作为下一个变换的输入空间必须同维度</p></li><li><p>为什么行变换不改变结果？</p><p>我觉得是因为一个向量的各个正交维度是等价的，不管怎么调换顺序，正交带来的对称性是不会被打破的。</p><p>而不同特征间组合相当于构建新特征？仍不能由原有的单个特征表出，保留了无关，而在现实问题中，如果要这样操作，就要用学长说的标准化，化为同一量纲。</p></li><li><p>四种方法：</p><ul><li>硬算，左行*右列，一个一个傻傻的算</li><li>左行*右边整个  /   右列*左边整个（我喜欢这个）</li><li>左列*右行，用很多相同大小的秩一矩阵求和。</li></ul></li><li><p>线性代数主要以运算为主，比如矩阵的四则运算、行列式的计算、特征值和特征向量的计算等。 而矩阵论主要以变换为主，它利用线性代数知识，描述线性变换，并提出了特殊变换，如正规变换、酉变换等。</p></li><li><p>A B 可逆，A+B不一定可逆，但是AB可逆，我感觉，如果可逆，代表该变换是同维度变换，充斥整个空间的所有可能，AB相当于连续进行两次这样的变换，因此仍是可逆的。</p></li><li><p>LU分解，一开始分出的是L逆 + U，把L逆取逆后得到的L中（逆的基本矩阵E操作顺序是反的）是从下层开始操作的，因为不会有从上层操作而带来的”干扰项“。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210920221007667.png" alt="image-20210920221007667"></p></li><li><p>梳理一下，求Ax = b有高斯消元和LU分解；</p><p>求Ax = 0，通过给自由变量挨个设1，找到特解。通过设自由变量均为0找到特解。。</p></li><li><p>With rank one, Ax  =  0 is easy to understand. That equation u( v T x)  =  0 leads us to v T x = 0. All vectors x in the nullspace must be orthogonal to v in the row space.</p></li><li><p>U  tells which columns are combinations of earlier columns (pivots are missing). Then R tells us what those combinations are.</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921004243300.png" alt="image-20210921004243300"></p><p>今天终于能总结理解了。</p><p>r = m &lt; n的时候，肥矮，零空间有除了零向量以外的向量，且列空间 = 整个空间，一定有解且有无穷解。</p><p>r = n &lt; m的时候，瘦高，列向量张成的子空间处于更大的空间中，因此b可能落不到子空间里，可能无解，零空间也没别的，最多一个解。</p><p>r &lt; n,r &lt; m 的时候，零空间一定有别的，列空间小于整个空间，所以要么无解，要么无穷解。</p><p>r = m = n 的时候天选之子，只有唯一解。相当于是在研究的整个空间内进行自己到自己的的变换，输入，输出都在整个空间，因此也具有传递性。</p><p>能投影出b的x必定有唯一的一部分来自行空间，配上零空间的任意部分，第五版的图画得好啊</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921095341752.png" alt="image-20210921095341752" style="zoom:10%;" /><p><strong>顺便提一个结论，空间变换降维的过程是不可逆的，可逆一定是同维。</strong></p><p>列秩 = 行秩，用到的结论是基变换（至少在这里）不改变无关的性质。等后面学了基再看吧。</p></li><li><p>矩阵加减，各个维度相加减，既有新开拓的，又有归零降维的。因此秩应该处于|r1|+|r2|</p><p>到 | |r1| - |r2| |之间吧</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921105413893.png" alt="image-20210921105413893"></p><p><strong>A T  A (nxn) is invertible if and only if  A  has linearly independent columns.</strong></p><p>A 是 rectangular ，一定不可逆，不然哪里需要求近似解，</p><p>这不是正规方程吗！A表示输入，后面仨 + y就是正规方程，乘起来就是投影，这就是”最小二乘“的几何学表示，代数学表示就是梯度下降令导数均为0.</p><p>When Ax= b has no solution, multiply by A T  and solve (A T  A)x= (A T) b</p><p>Ax = b = p+e  其中p落在列空间，e落在左零空间，当无解时，移除e，Ax`  = p必然可解。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921111608466.png" alt="image-20210921111608466" style="zoom: 67%;" /><p>当列不独立时，零空间有除了零向量以外的向量，这时候投影条件无助于找到最小二乘法的直线，要用到伪逆，这时候x` 有多个解，伪逆会选出x最小的解。。。</p><p>最小二乘还可适用于非线性方程和傅里叶级数等。</p></li><li><p>正交矩阵变换并不会影响长度（IIQx ll  =  ll x ll  for every vector x.）,最标准的基，带来最标准的影响。因此对计算非常有利，计算机尽可能采用正交矩阵。</p><p>此时最小二乘：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921142337398.png" alt="image-20210921142337398"></p><p>p = Q QT b，若更进一步，Q是方阵，那b = p，直接消干净了。</p></li><li><p>克拉默法则，给出了我们一个用行列式写出nxn线性方程组解的简便方法，<strong>有重要的理论意义</strong>，但是计算量很大，所以就是用来理论研究推导的嘛。。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921165546210.png" alt="image-20210921165546210"></p></li><li><p>特征值和特征向量引出了新的领域，当我们不再观察单个状态，引入连续的变化后，我们更关注保持不变的东西——特征，这大大简化了各方面的复杂度（比如A^10000）。</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921171846620.png" alt="image-20210921171846620" style="zoom: 67%;" /><p>Markov matrix：Each column of P adds to 1 (property)</p><p>Its largest eigenvalue is λ  =  1，so others are generally disappearing</p></li><li><p>当进行行变换时，特征值一般会改变，因为特征值虽然刻画的是不变量，但可能是几个不好的基糅杂在一起，而不是像单个基一样分开来，所以好像有个感觉上的“牵连作用”？(待定)</p></li><li><p>相似性，说明的是不同基下的同一个变换/图形，而对角矩阵其实是因为变换到了特征向量为基的坐标系下，除去了干扰，彻底把特征值暴露出来。</p><p>Cx = λx. Then BCB- 1  has the same eigenvalue λ with the new eigen­vector Bx</p><p>因为这转换到了B基的空间，自然也要把原来的特征向量左乘B转过来。</p></li><li><p>当代数重数 &gt; 几何重数时，可能是巧合导致某几个方向上λ值相等。</p><p>也有可能是因为这几个方向重叠了，对应（A-λI矩阵不可逆，所以转换后降维了）而重叠的情况下我们就少了几个特征向量（被压缩），这就是解释。</p></li><li><p>uk = A^k *u0  求这种问题</p><p>思路是把U0表示为特征向量的线性组合，然后分开研究不同向量k次迭代后的值，再组合起来，过程中组合系数不变。</p><p>系数为 c  =   X-1 u0 这样就组合成了u0（当然比较少的时候也能直接看出来）</p><p>然后左乘对角阵的k次方，这是应用k次迭代的特征值到每一个c上得到新的系数，</p><p>最后再组合起来<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210922131057114.png" alt="image-20210922131057114"></p><p>就完成了。</p></li><li><p>也可以运用在将常系数微分方程转化为线性组合。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210922150411993.png" alt="image-20210922150411993" style="zoom: 33%;" /><p>只适用于常微分方程 就是 dy/du = Cu这种，</p></li><li><p>对称矩阵时最重要的矩阵，在线代理论和应用上。</p><p><code>它具有n个实特征值，而且有n个正交的特征向量，也必然能被对角化，而且对角化的形式是特征向量矩阵归一化夹着特征值矩阵。</code></p><p>对称矩阵的列空间和行空间是一样的，因此零空间也同时垂直列空间。</p><p>【证明用的是数学里的谱定理和几何、物理里的主轴定理（特征向量指向椭圆的主轴）】</p><p>而且那个X矩阵这个时候是一个正交矩阵Q，不过注意要选择合适的长度，使得每个向量length = 1</p></li><li><p>正定矩阵的性质让它更加特殊！但是这并不意味着稀少，它是许多应用的核心。</p><p>有一个结论👇因为：显然xT(S+T)x分解后的和恒&gt;0，而对称矩阵相加仍然对称。</p><p>If S and T are symmetric positive definite, so is S  +  T.</p><p><strong>可逆和可对角化并没有必然联系。</strong></p><p><code>ATA一定是对称、半正定、可对角化的，如果A还是列满秩，那么ATA一定是可逆、正定的。</code></p><p>对称矩阵可逆的充要条件是n个实特征值不包含0.</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923000916235.png"></p><p>strang给出了三种分解方式，我没看懂A1是怎么做到的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002323702.png" alt="image-20210923002323702" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002335728.png" alt="image-20210923002335728" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002405224.png" alt="image-20210923002405224" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002233967.png" alt="image-20210923002233967" style="zoom:67%;" /></li><li><p>主轴定理：</p><p>特征向量指向椭圆的主轴，而且大的特征值对应了短轴。因为半轴是取1/根号下λ</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923004958881.png" alt="image-20210923004958881"></p><p>如果有个特征值是负的，那椭圆就变成双曲线了。。。hyperbola，两个特征值均负无实数解。</p><p>如果S是nxn的，那么这个就是超椭圆。</p></li><li><p>正交矩阵 矩阵转置 = 矩阵的逆，先从行空间投向列空间，再投回来。 ATA= I啥都不变</p><p>那么普通矩阵可逆呢。必然可逆，因为是从原空间投向原空间，但为啥不等于 I 呢，是因为第一次只投到列空间，没有左零空间的部分（而且零空间的被吞掉了），所以往回投的时候定义域缩窄了。那么正交矩阵是没有零空间和左零空间的，完全可逆。</p></li><li><p>SVD</p><p>图像压缩有两种方案，提前选基【傅里叶等】和适应性选基【SVD等】</p><p><strong>图像一般是满秩的，但是有很多特征值非常小的可舍弃</strong>，</p><p>但是有几个问题，一般图像的特征向量不是正交；而且要分解成U,V俩矩阵，这就是SVD能做的。</p><p>U和V一定是酉矩阵【即正交矩阵】，因为特征值被抽取出来到 Σ 里了，<a href="https://zhuanlan.zhihu.com/p/29846048">简易证明</a></p><p>（当A是正定或半正定时特征值分解就相当于是对角化。）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924100929032.png" alt="image-20210924100929032">也就是行空间的v投影到列空间的u上，而且系数是σ。</p><p>而且σ1 - σr都是正的，因为Ar 满足列满秩，所以ArTAr一定正定，所以特征值都正，开方也正。而紧接着说明了剩下的u和r因为空间的性质，自动正交于列空间和行空间的u 、v，因此Av = uσ 适用于所有的。也说明了对于形状任意，秩情况任意的矩阵，奇异值分解都成立。</p><p>相对于对细小变化做出反应的特征值，奇异值对此并不敏感，因为其本质——分解成秩一矩阵。并不会关注细小的变化，而新增的小秩一矩阵自然会分配小奇异值，影响并不大。</p><p>类比S = ATA 的对角化</p><p>A和S的秩相等，λ = σ2  vi = S的特征值qi。 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924105359042.png" alt="image-20210924105359042" style="zoom: 67%;" /><p>然后递归的进行这个过程，可以证明这两条式子其实是一样的。</p><p>证明用到了瑞利xxx，可见P376页。</p><p>那么λ和σ事实上是如何计算的呢？直接暴算多项式（n = 10000+）就太离谱了。。</p><ul><li><p>首先要尽可能多搞点0出来，还不能改变任意的σ和λ，这通过巧妙的对角化方法实现。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091507660.png" alt="image-20210924110736701" style="zoom:67%;" /><p>这样既不改变值，又能用不对称的Q1和Q2操纵矩阵。细节在11节。</p></li><li><p>LAPACK提供的受欢迎的方式使用简单的正交矩阵Q来拟合 QT S Q = 特征值对角阵，近似解。</p></li></ul></li><li><p>主成分分析</p><p>S = AAT/(n-1)  样本协方差矩阵，其中对角线是方差，其他是协方差，A要进行均值化处理</p><p>令 T （trace）= σ1^2 +σ2^2 …………，则σ1^2 / T 就代表了重要比例。当比例足够时就可以舍弃后面的。</p><p>在这里也同时解决了正交距离最小化，而不是一般最小二乘法的垂直距离。 </p><p>我们将aj分解到组成他的u1，u2上，<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924150625604.png" alt="image-20210924150625604"></p><p>左边的是固定的，当我们在PCA中选择u1作为基，左边第一项最大，则第二项最小，而第二项正是所谓的正交距离，也就是aj落在正交于最优直线的垂线的分量。</p><p>当然在处理现实数据时，如果规模是个问题，还要用相关矩阵。统计和线代关系密切。</p></li><li><p>伪逆真是方便A+ = VΣ+UT</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925164019077.png" alt="image-20210925164019077"></p><p>这俩👆是因为投影的时候清除了了垂直的分量。</p></li><li><p>Are all linear transformations from V  =  R n to W  =  R m  produced by matrices?</p><p>The answer is yes! This is an approach to linear algebra that doesn’t start with<br>matrices. We still end up with matrices-after we choose an input basis and output basis.</p><p>Transformations have a language of their own. For a matrix, the column space contains all outputs  Av.  The nullspace contains all inputs for which  Av  = 0<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925214411053.png" alt="image-20210925214411053"></p><p>我们只要知道了一组基的变换情况，我们就知晓了变换的一切。</p></li><li><p>达到一种变换T有很多矩阵，我们希望能找到最好的那种（对角）</p><p>线性变换中，把输入向量用vj组合，然后对每个组合进行T变换，再组合起来就是核心idea。</p><p>当基变换时，T（v） = v的矩阵就不再是 I 了，而是👇，这样相当于用新基W表示完全相同的向量</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925220326553.png" alt="image-20210925220326553"></p><p><u>虽然每家教材的形式都不一样，但其实说的都是同一件事啊。</u>感觉这种把V用W表示出来才更直观！</p><p>新基下的坐标 = B *原基下的坐标。</p><p>变换矩阵A构造如下：</p><p>对每个vi，我们用T（vi）将它进行变换，然后用output空间的新基表示出来，</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925222409088.png" alt="image-20210925222409088" style="zoom:67%;" /><p>然后这些系数就成为空间变换矩阵A的第一列。</p><p>当我们选择特征向量作为我们的基时，这个所谓的A就是<strong>特征值矩阵</strong>。</p></li></ol><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ol><li><p>Diagonally dominant matrices are invertible</p><p>即aii &gt; Σaij (i ≠ j)</p></li><li><p>LU分解中，<strong>A行首的0由L继承，列首的0由U继承</strong>，可以省下计算步骤</p><p>这样既可以省下计算步骤，又可以直观记录我们高斯消元的过程。关键是这是预处理。</p><p>Solve  Le  =  b  and then solve  Ux  =  e</p><p>对称矩阵的L和U是对称的（LDU），所以不用存两遍。</p><p>一般用PA = LU（提前置换好） 而不是 A = L1P1U1</p></li><li><p>函数空间F是无限维度的，他的子集P或Pn是幂函数空间</p></li><li><p>正交矩阵（包括旋转、置换、反射矩阵），逆 = 转置，</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921141238244.png" alt="image-20210921141238244"></p><p><strong>把u方向的向量转成 -u</strong></p></li><li><p>QR分解法是<strong>三种将矩阵分解的方式之一</strong>。这种方式，把矩阵分解成一个正交矩阵与一个上三角矩阵的积。QR分解经常用来解线性最小二乘法问题。QR分解也是特定特征值算法即QR算法的基础。</p><p>A T  A = (QR)T QR = R T Q T QR = R T  R</p><p>The least squares equation  A T  Ax  =A T  b  simplifies to  R T  Rx  =  R T  Q T  b.<br>Then finally we reach  Rx  =  Q T  b: good.   x = R-1 QT b</p><p>这样就不用求解Ax = b，直接回代 👆，非常快，最大的消耗在mn2的乘法（分解QR）。</p></li><li><p>The determinant is a linear function of each row separately (all other rows stay fixed).</p></li><li><p>Markov matrix: Each column of P adds to 1, so , 1 is an eigenvalue.</p><p>Pis singular, so,   0 is an eigenvalue.(其实0特征值对应的特征向量fills in nullspace)</p><p>【别和特征向量fill in A-λI 的零向量空间弄混，而且因为x一定有非零解，所以绝对det = 0】</p><p>P  is symmetric, so its eigenvectors ( 1, 1) and ( 1, -1) are perpendicular.</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921173824970.png" alt="image-20210921173824970" style="zoom:67%;" /><p>对于相同的特征向量，有 reflection= 2(projection) - I</p></li><li><p>当2x2矩阵有一个0特征值的时候，每个A-λI的每行都来自一个行向量(a,b)，而对应的特征向量就是(b,-a)</p></li><li><p>A and B share the same  n  independent eigenvectors if and only if  AB =  BA.</p></li><li><p>实数特征值让特征向量伸缩，而虚数让其旋转</p><p>对称矩阵只有实数特征值，反称矩阵只有虚数特征值。</p></li><li><p>注意，可逆性和可对角化没有关系。可对角化需要的是独立的n个特征向量，可逆性关注特征值为不为0。</p></li><li><p>线性变换可以用基 * A来表示。</p><p>过渡矩阵一定可逆，<strong>一个线性变换在不同的基下是相似的</strong>，这也暗含了其实是同一个空间的两组基。</p><p>我们也可以用奇异值分解来完成这个</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925233750506.png" alt="image-20210925233750506"></p><p>这时称作：isometric 等距，而不是相似。</p><p>这里的B就是原基到bi基的过度矩阵。👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925234616036.png" alt="image-20210925234616036"></p></li><li><p>Jordan会构造广义特征向量，而这些特征向量依附于共享特征值的 真特征向量：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925235638367.png" alt="image-20210925235638367"></p><p>这是为了尽可能地接近对角化！</p><p>同时还有个结论，当矩阵拥有相同的Jordan型时他们相似，没有例外。</p></li><li><p>好基：离散值是向量，连续值是函数。它们可能不能对角化A，但是对应用数学里的很多重要矩阵，它们能达到接近的效果，更重要的是它们直接选定，无需计算。</p><p>傅里叶基，λ^n = 1 ，作用是对角化了n阶置换矩阵。Px = λx，P^2x = λ^2 x。而且适用于P。。P^n 的线性组合的所有矩阵。但是</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210926094412910.png" alt="image-20210926094412910"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210926095326158.png" alt="image-20210926095326158"></p><p>其中，傅里叶基因其周期性而特别适用于周期性的</p><p>其中6是将幂级数进行正交化的结果，7是将x对应三角函数以便使用快速傅里叶变换。</p></li><li></li></ol><p>​    </p><h2 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h2><h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>考虑修正计算C=C+AB，这比赋值计算更典型。</p><p>这好几种矩阵相乘的形式虽然在数学上等价，但事实证明，由于不同矩阵乘法的内存开销不同，计算表现上会有巨大差异。</p><p>点积：行*列</p><p>saxpy：<strong>y</strong> = a <strong>x</strong></p><p>gaxpy: <strong>y</strong> = <strong>Ax</strong> </p><p>外积：列*行</p><p>作者从最基础的点积、saxpy、gaxpy，搭建矩阵行列划分、冒号、外积，最终将矩阵乘法分解成点积、saxpy、外积等形式。</p><p>i，j，k的六种排列应该<strong>从内向外依次固定其他变量来理解</strong>。</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>考虑算法的运算量和存储量。</p><p>利用好三角矩阵、对角矩阵、带状矩阵、对称矩阵和置换矩阵的性质，可以节省许多。</p><p>引入带状矩阵“思想”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数学是一门计算的学问，不断组合现有结论达到 ”巧妙计算“，但当技巧穷尽，还有一门研究如何暴力计算的数值分析，这需要借助计算机，而机器学习依靠的就是这些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;许多内容是个人直觉感悟，可能有错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;纯粹数学：不顾与现实的几</summary>
      
    
    
    
    <category term="Math" scheme="https://darren-dong.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>DS-Source</title>
    <link href="https://darren-dong.com/2021/09/08/DS-Source/"/>
    <id>https://darren-dong.com/2021/09/08/DS-Source/</id>
    <published>2021-09-08T03:08:21.000Z</published>
    <updated>2021-09-08T03:14:42.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据科学资源"><a href="#数据科学资源" class="headerlink" title="数据科学资源"></a>数据科学资源</h1><p>存放一些DS学习的资源</p><p>[toc]</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h3><ul><li><p>各类统计年鉴</p><p><a href="http://www.stats.gov.cn/tjsj./ndsj/">中国统计年鉴 </a>基本有中国历年各方面的所有数据</p></li><li><p>统计数据库</p><p><a href="https://www.un.org/zh/databases/#stats">联合国数据库</a></p></li><li><p>统计学领域论文或书籍中的数据集</p></li><li><p>政府网站</p><p><a href="https://data.stats.gov.cn/">中国数据集</a></p><p><a href="https://www.data.gov/">美国数据集</a></p><p><a href="https://data.gov.in/">印度数据集</a></p><p><a href="https://data.gov.uk/">英国数据集</a></p></li><li><p>其他</p><p>R包中的数据集，比如women、mtcars</p><p>开放数据搜索引擎，如<a href="https://marketplace.namara.io/">namara</a></p></li></ul><h3 id="企业提供"><a href="#企业提供" class="headerlink" title="企业提供"></a>企业提供</h3><p><a href="https://archive.ics.uci.edu/ml/index.php">加州大学欧文分校机器学习库</a></p><p><a href="https://www.cs.toronto.edu/~delve/data/datasets.html">Delve数据库</a></p><p><a href="https://registry.opendata.aws/">Amazon Web Services(AWS) datasets</a></p><p><a href="https://cloud.google.com/bigquery/public-data">Google Datasets</a> 里面也有商用的数据库</p><p><a href="http://research.google.com/youtube8m/">Youtube labeled</a></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210609194754.png" alt="image-20210609194747163"></p><hr><p><a href="https://data.nasa.gov/">NASA</a></p><p><a href="https://data.worldbank.org.cn/">世界银行</a> 免费并公开获取世界各国的发展数据.</p><h3 id="门户网站"><a href="#门户网站" class="headerlink" title="门户网站"></a>门户网站</h3><p><a href="https://dataportals.org/">列出了全世界许多开放数据库</a></p><p><a href="https://opendatamonitor.eu/frontend/web/index.php?r=dashboard/index">各国开放数据集集成</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research">机器学习数据库大集成！！</a></p><p><a href="https://www.reddit.com/r/datasets/">论坛提供的数据库</a></p><h3 id="竞赛平台"><a href="#竞赛平台" class="headerlink" title="竞赛平台"></a>竞赛平台</h3><p><a href="https://www.kaggle.com/datasets">Kaggle</a> 提供一个数据搜索引擎</p><p><a href="https://kdd.org/">KDD Cups</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://data.world/">Data world</a> 有很多公开数据集，很方便管理协作，提供许多数据管理工具的API</p><p><a href="https://marketplace.namara.io/">namara数据搜索引擎</a></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><a href="https://www.tableau.com/products/desktop">Tableau</a></p><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul><li><p>数据科学语言</p><p>python、R、Scala、Clojure、Haskell</p></li><li><p>NoSQL工具</p><p>NoSQL、MongoDB、Couchbase、Cassandra</p></li><li><p>传统数据库/数据仓库</p><p>SQL、RDMS、DW、OLAP</p></li><li><p>大数据计算工具</p><p>HadoopHDFS&amp;MapReduce、Spark、Storm</p></li><li><p>大数据管理、存储、查询</p><p>HBase、Pig、Hive、Impala、Cascalog</p></li><li><p>数据采集、聚合、传递</p><p>Webscraper、Flume Avro、Sqoop、Hume</p></li><li><p>数据挖掘</p><p>Weka、KNIME、RapidMiner、SciPy、Pandas</p></li><li><p>数据统计分析</p><p>SAS、SPSS、Matlab</p></li></ul><h2 id="论坛、平台"><a href="#论坛、平台" class="headerlink" title="论坛、平台"></a>论坛、平台</h2><p><a href="https://www.kaggle.com/">Kaggle</a></p><p><a href="https://kdd.org/">KDD 数据挖掘、数据科学和分析社区</a></p><p><a href="https://www.drivendata.org/">Driven Data</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据科学资源&quot;&gt;&lt;a href=&quot;#数据科学资源&quot; class=&quot;headerlink&quot; title=&quot;数据科学资源&quot;&gt;&lt;/a&gt;数据科学资源&lt;/h1&gt;&lt;p&gt;存放一些DS学习的资源&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习实战</title>
    <link href="https://darren-dong.com/2021/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"/>
    <id>https://darren-dong.com/2021/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/</id>
    <published>2021-09-08T02:21:25.000Z</published>
    <updated>2022-05-09T03:04:02.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><p><a href="https://github.com/Darren-greenhand/handson-ml2">仓库地址</a></p><p>本书内容广博，不仅介绍了传统ML，还用sklearn演示了端到端训练实例。</p><p>尤其对DL进行了深入探讨，涵盖强化学习、利用TF/Keras构建和训练神经网络</p><h2 id="ML"><a href="#ML" class="headerlink" title="ML"></a>ML</h2><h3 id="1-前置补充"><a href="#1-前置补充" class="headerlink" title="1. 前置补充"></a>1. 前置补充</h3><ul><li>在机器学习里，属性是一种数据类型，而特征取决于上下文，通常意味着<strong>属性+值</strong>(很多人混淆)</li><li>一些回归算法和可用于分类任务，反之亦然。比如逻辑回归可以输出“属于某个给定类别的概率”，可用于分类</li><li>无监督应用：<ul><li>聚类</li><li>异常检测、新颖性检测</li><li>可视化、降维（可先用降维减少数据维度，再提供给别的算法）</li><li>关联规则学习</li></ul></li><li>比起在线学习，批量学习也可以适应变化，但是需要<strong>重新训练全新的系统</strong>，成本高</li><li>在线学习也可以用于超大数据集，因为超出了一台计算机的主存储器的数据</li><li>基于实例（相似度），和基于模型(我看到的好像都是这个)的学习</li><li>特征工程 vs 端到端学习</li><li>正则化实质是约束模型，限制变化范围，降低复杂度。</li><li>测试验证：保持验证、交叉验证</li><li>没有免费的午餐：<strong>如果你对数据绝对没有假设，那么就没有理由更偏好某个模型</strong>，必须得有假设，然后只评估部分合理的模型。</li></ul><h3 id="2-端到端的机器学习项目"><a href="#2-端到端的机器学习项目" class="headerlink" title="2.端到端的机器学习项目"></a>2.端到端的机器学习项目</h3><p>假设你是一个房地产公司最近雇佣的数据科学家，你会经历：</p><ol><li>观察大局</li><li>获得数据</li><li>从数据探索和可视化中获得洞见</li><li>机器学习算法的数据准备</li><li>选择并训练模型</li><li>微调模型</li><li>展示解决方案</li><li>启动、监控和维护模型</li></ol><p>（使用真实数据，详情见我的另一篇博文：<a href="https://darren-dong.com/2021/09/08/DS-Source/">DS资源</a>）</p><h4 id="观察大局"><a href="#观察大局" class="headerlink" title="观察大局"></a>观察大局</h4><p><strong>附录B，记录了一个数据科学项目的大致流程以供参考</strong></p><p>流水线：一个序列的数据处理组件称为一个数据流水线。在机器学习系统中非常普遍。</p><p>组件通常异步进行，组件间很独立，连接只有数据仓库。Robustness++，但需要适当的监控。</p><ol><li><p>问老板业务目标，公司期望如何使用该模型，如何从中获益才是重要问题：</p><p>这决定怎么设定问题，选择什么算法，通过什么方式评估模型性能，花多少精力来进行调整</p></li><li><p>问老板当前的解决方案（可能存在），当作建议、参考，获得洞察</p></li><li><p>开始设计系统，回答框架问题：有无监督/强化、分类/回归、批量/在线</p></li><li><p>选择性能指标：</p><ul><li><p>RMSE 均方根误差          欧几里得范数  L2</p></li><li><p>MAE   平均绝对误差      曼哈顿范数      L1   </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/67120415">范数的定义</a></p><p><strong>指标越高越关注大值而不是小值</strong>，这就是为何RMSE比MAE对异常值更敏感</p></li></ul></li><li><p>检查假设，与数据流水线上下游团队沟通。</p></li></ol><p>获取数据（数据库），可以编写shell脚本来辅助</p><p>通过查看数据描述、部分数据，简单可视化来了解数据</p><h4 id="创建测试集"><a href="#创建测试集" class="headerlink" title="创建测试集"></a>创建测试集</h4><p><strong>在简单了解数据后，创建测试集</strong>（有点奇怪），因为大脑容易过拟合<strong>（数据窥探偏误）</strong>：</p><p>浏览数据，跌入某个看似有趣的测试数据模式，选择某个特殊的模型，估计结果过于乐观，但其实泛化能力一般。</p><p>所以要在没有进一步了解的时候创建测试集，有一些方法，比如用标签确定哪些是选出来的测试集，有时候要用纯随机，有时候要分层抽样。</p><p>这一步没有想象中的简单，而很多人忽视了它创建的时机。</p><h4 id="从数据探索和可视化中获得洞见"><a href="#从数据探索和可视化中获得洞见" class="headerlink" title="从数据探索和可视化中获得洞见"></a>从数据探索和可视化中获得洞见</h4><p>现在把测试集放在一边不要碰，只关注训练集。如果训练集太大，可以抽样一个<strong>探索集</strong></p><p>xs，通过设置透明度更好的看清密度</p><p>我们的大脑擅长从图片中发现模式，但这需要你玩转可视化的参数。</p><p>先试试寻找不同特征之间的相关性，既包括线性，也有非线性并可视化出来康康，有许多函数可以实现这一步</p><p>中间省略众多有趣的方法</p><p>最后我们应该尝试各种属性的组合，创建新属性（我感觉吴恩达教的更好），再检测一下相关性等指标。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>这个过程应该编写函数而不是手动操作：</p><ul><li>以便在任何数据集上轻松重现</li><li>可以逐渐建立起转换函数库，在以后的项目中重用</li><li>可以在实时系统中用函数转换新的数据，在输入给算法</li><li>可以轻松尝试多种转换方式，比较效果。</li></ul><p>回到干净的训练集，进行数据清理，处理文本和分类属性的时候用到了独热码</p><hr><p>ps：sklearn的API设计规则非常好，原则如下：</p><ul><li>一致性：所有对象共享一个简单的界面</li><li>估算器：能够根据数据集对某些参数进行估算</li><li>转换器：可以转换数据集</li><li>预测器：能够基于一个给定的数据集进行预测</li><li>检查：所有估算器的超参数都可以通过公共实例变量直接方位（例如imputer.strategy）</li><li>防止类扩散：数据集被表示为Numpy数组或Scipy稀疏矩阵，超参数只是普通的Python字符串或数值</li><li>构成：现有的构建尽最大可能重用</li><li>合理的默认值</li></ul><hr><p>而尽管sklearn提供了许多有用的转换器，你仍然需要为一些注入自定义清理操作或组合特定属性等任务编写自己的转换器。</p><p><strong>而sklearn依赖鸭子类型编译，而不是继承</strong>。</p><p>这些数据准备步骤的执行越自动化，你自动尝试的组合也就越多，从而有更大的可能找到一个重要的组合并节省大量时间。</p><p><strong>最重要也最需要应用到数据上的转换就是特征缩放</strong>，（仅用于拟合训练集）</p><p>两种常用方法：最小-最大缩放（归一化）、   标准化</p><p>前者是减去最小值然后除以（最大-最小），收缩到0—1，当然也可以更改</p><p>后者是减去平均值然后除以方差，<strong>标准化没有特定范围，但是受异常值的影响更小。</strong></p><p><strong>转换流水线</strong>（后来补充）</p><p>通过Pipeline类来支持，方法与最终的估算器方法相同。</p><p>如果要用于多列，可以用Column-Transformer，他与pandas DataFrame 一起使用时效果很好。</p><hr><h4 id="选择和训练模型"><a href="#选择和训练模型" class="headerlink" title="选择和训练模型"></a>选择和训练模型</h4><p>完成了前面的步骤后，事情现在变得比想象中容易很多。</p><p>别忘了使用<strong>交叉验证</strong>来更好地评估：</p><ul><li>可以将训练集分为较小的训练集和验证集，然后加以训练</li><li>也可以使用sklearn的K-折交叉验证功能。（更偏向于使用效用函数而不是使用成本函数）</li></ul><p>在深入某些算法之前，应该<strong>尝试一遍各种机器学习算法的其他模型</strong>（不同内核的支持向量机，神经网络。。）</p><p>但是别花太多时间调整超参数，我们的目的是<strong>筛选出几个（2~5）个有效的模型</strong>，每一个尝试的模型都应该妥善保管，以及对应的超参数和训练过的参数，以及交叉验证的评分和实际检测的结果。</p><p>可以用Python的pickle模块或joblib库来保存模型。</p><h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>有了有效模型的候选列表，现在进行微调。</p><p>你可以手动调整超参数直到找到一组不错的组合。。非常枯燥乏味，耗时间</p><p>你也可以用sklearn的GridSearchCV替你搜索，如果不知道超参数怎么赋值，可以先尝试10的连续次幂</p><p>当然也可以把它用在数据准备的步骤，还可以用来自动寻找处理问题的最佳方法。</p><p><strong>网格搜索👆</strong>是一项模型超参数（即需要预先优化设置而非通过训练得到的参数）优化技术，常用于优化三个或者更少数量的超参数，本质是一种穷举法。</p><p>但是如果超参数搜索的方法较大，建议使用<strong>随机搜索</strong>。</p><p>还有集成方法，组合方法往往比单一的模型更好。。。。。最后通过测试集评估系统。、</p><p>还是小心吴恩达说的那个问题，不要拼命调调超参数让测试集结果好看，这可能会使其“适应测试集”。。。</p><h4 id="启动！监控与维护"><a href="#启动！监控与维护" class="headerlink" title="启动！监控与维护"></a>启动！监控与维护</h4><p>预启动：展示解决方案（学了什么、什么有用、基于什么假设、系统的限制），记录所有的事情，通过可视化和故事化制作漂亮的演示文档。</p><p>你可以部署到服务器，通过web来让用户调用，但更流行的策略是将模型部署到云上：用joblib保存模型上传到Google Cloud Storage（GCS），然后转到Google Cloud AI Platform并创建一个新的模型版本，指向GCS文件。</p><p>你还要编写监控代码以定期检查系统的实时性能，在降低时触发警报，因为数据会过时，会腐朽。</p><p>各种层面，甚至包括相机的图像清晰度、格式变化，还有人们的偏好变化。。。</p><p>但是确定模型的性能并不总是可行的，你可能需要人工分析。。。反正建立一个监控系统和相关流程，包括如何定义故障以及如何做准备。</p><p>这个工作量甚至比构建和训练模型多得多。。你还要定期更新数据集并定期重新训练模型（数据发展），最好自动化：</p><ul><li>自动定期收集数据并标记（如聘用人工标注者）</li><li>编写脚本来训练模型并自动调微超参数。</li><li>编写脚本在更新的测试集上评估新旧模型，性能好则自动部署，差就调查原因。</li></ul><p>做好版本管理（包括每个版本的数据集），以防新模型故障时需要回滚</p><h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h3><p>终于了解完了大概流程，有些麻烦，但不出所料，让我们正式进入学习吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习实战&quot;&gt;&lt;a href=&quot;#机器学习实战&quot; class=&quot;headerlink&quot; title=&quot;机器学习实战&quot;&gt;&lt;/a&gt;机器学习实战&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Darren-greenhand/handson-m</summary>
      
    
    
    
    <category term="ML" scheme="https://darren-dong.com/categories/ML/"/>
    
    
    <category term="python" scheme="https://darren-dong.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>概率（课内）笔记</title>
    <link href="https://darren-dong.com/2021/08/26/%E6%A6%82%E7%8E%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://darren-dong.com/2021/08/26/%E6%A6%82%E7%8E%87%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-26T03:08:21.000Z</published>
    <updated>2022-05-10T05:19:01.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>What is Probability theory and Mathematical Statistics</strong></p><p>生活中的现象根据是否可事前预言，分为<u>确定性现象和非确定性现象</u>。<br>在非确定性现象中有一类很重要的现象:随机现象</p><p>随机现象的性质：</p><ul><li>各个结果出现的可能性大小不依人们的主观意志转移</li><li>试验的结果不止一个，即每次试验的结果可能不同——结果的不确定性。</li><li>进行大量重复观察时，可观察出出现各种结果呈现某种规律——统计规律性</li></ul><p>概率论与数理统计— <u>研究随机现象的统计规律性</u>的一门数学学科</p></blockquote><blockquote><p>概率统计、随机过程以及概率图模型，三位一体、一脉相承的结合起来，一步步掌握其中的核心思想。概率统计是基础，随机过程和概率图模型作为拓展和深化。</p><p>概率统计看《概率导论》</p><p>概率思想、随机变量、统计推断、随机过程、采样理论、概率模型。</p><p>在机器学习算法的修炼道路中，<a href="https://www.zhihu.com/search?q=%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1790318156%7D">概率图模型</a>和随机过程对很多同学而言是一个巨大的拦路虎。</p></blockquote><h3 id="一些杂感"><a href="#一些杂感" class="headerlink" title="一些杂感"></a>一些杂感</h3><ol><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-37387c56c6d1740aedab256f1081fced_1440w.jpg" alt="img" style="zoom:33%;" /><p>事件关系可用文氏图，概率就不行了。。独立性</p></li><li><p>伯努利是一次实验，二项是重复多次进行伯努利实验后成功的次数，几何是第一次成功是第几次。</p></li><li><p>《概率导论》的分布列就是考试的分布律，有$P{X=x_i}=p_i$，概率导论这个形式更好看$p_{X}(x_i)$</p><p>$P{X=x_i,Y =y_j}=p_{ij}$以及概率导论的$p_{X,Y}(x_i,y_j)$</p></li><li><p>独立同分布的随机变量的加权和的均值和方差的公式 是 <code>样本均值作为随机变量的期望的估计</code> 的统计过程的理论基础</p></li><li><p>一般连续变量相对于离散变量的优势：除了刻画细致和精确外，连续随机变量模型可以利用<strong>有力的分析工具</strong>解决概率的计算问题。更重要的是它可以做到离散随机变量做不到的：<code>刻画某些随机现象的本质。</code></p></li><li><p>指数变量的核心性质：$X$超过某个值的概率，随着这个值的增加而 <strong>指数递减</strong>$P(X\geq a) = e^{-\lambda a}$</p></li><li><p>线性变化下，随机变量的正态性保持不变。标准正态分布的 $F$ 写作 $\Phi$</p></li><li><p>泊松、二项、正态具有<strong>可加性</strong>，加的是$\lambda$和$n$，$\mu、\sigma^2$</p></li><li><p>注意一些分布信息，还有随机变量的函数，自带定义域信息。。。</p></li><li><p>所谓简答题，给出简单的例子说明他为什么能这样做,要给出定理的条件，然后说明这个例子具有相应的性质来满足条件</p></li><li><p>乘法公式，本就是描述在概率论里如何刻画乘法关系，刻画连续的关系，加法公式也是类似，乘法、加法的本质是不变的，<u>变的只是在概率论里的形式</u>。而这要分两种情况，相乘的变量是否独立。不独立就是条件形式。</p></li><li><p>$P(A_1\cup A_2\cup A_3) = P(A_1\cup \overline{A_1}A_2\cup \overline{A_1}\ \overline{A_2}A_3) = P(A_1) + P(\overline{A_1})P(A_2|\overline{A_1}) + …$ </p></li></ol><hr><h3 id="基本概率论"><a href="#基本概率论" class="headerlink" title="基本概率论"></a>基本概率论</h3><p><em>随机试验</em>：对随机现象所进行的观察和实验，可在相同条件下重复进行、事先可明确知道所有可能结果，且不可预言出现何结果。</p><p>随机试验的每一个可能发生也可能不发生的事情为<em>随机事件</em>，简称事件.</p><p><em>基本事件</em> 在一次试验中必发生一个且仅发生一个的最简单事件.</p><p>全体基本事件的对应元素所组成的集合称为试验的样本空间样本空间的元素称为<em>样本点</em>.</p><p>$A-B = A\overline{B}$</p><p><strong>概率</strong>是对随机事件发生可能性大小的一个客观度量</p><p>概率是通过公理化定义的。非负、规范、可列可加、单调。<br>概率公理化单调性：</p><p>若$A \subset B$，则$ P(A)\leq P(B)$，且$P(B-A) = P(B) -  P(A)$<br>因此<u>$P(A - B)=P(A-AB) = P(A)  - P(AB)$</u>  并且 $P(A-B) = P(A\cup B)-P(B)$</p><p><em>随机变量</em></p><p>取值由随机试验的结果来确定；取各数值的可能性大小有确定的统计规律性</p><p>它可以完整地描述试验结果，从而可用<u>量化分析方法</u>来研究随机现象的统计规律性。</p><p>概率为0的事件不一定是不可能事件，为1不一定是必然事件（因为连续型变量）</p><hr><p><code>联合分布函数F</code></p><p>$F(x,y) = P{X\leq x,Y\leq y}$，包括了右端点</p><p>$F_X(x) = \underset{y\rightarrow \infty}{lim}F(x,y)$</p><p>单调不降；右连续；非负有界$0\leq F(x,y)\leq 1$；</p><p>$F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)=P{x1\leq x\leq x2,y1\leq y\leq y2}$</p><p>$P{X = x} = F(x) - F(x-0)$ 其他情况为0</p><p>:star: 对称分布的分布函数有：$F(-x) = 1-F(x)$<br>      上侧分位数$u_\alpha$：$F(u_\alpha) = 1-\alpha$</p><p> $\displaystyle F_X(x)=\int_{-\infty}^{x}\int_{-\infty}^{y}f(u,v)dudv=\int_{-\infty}^{x}f_X(u)du$</p><p><code>联合分布列p——离散</code></p><p>$P{X = x_i,Y = y_j} = p_{ij}$</p><p>$P{Y = y_j} = \displaystyle\sum_{i=1}^{\infty}p_{ij}$</p><p>九宫格划分空间（离散型），分类求F</p><p><code>联合分布密度f——连续</code></p><p>联合概率密度函数包含了所有关于（$X,Y$）的取值概率的信息，包括相互依赖的信息。</p><p>$f(x,y) \geq 0$ 处处成立</p><p>$\displaystyle\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(u,v)dudv = 1$</p><p>对$G \sub R^2$</p><p>$P{(x,y)\in G}=\underset{G}{\iint_{}^{}}f(x,y)d\sigma$</p><p>$f_X(x)=\displaystyle\int_{-\infty}^{+\infty}f(x,y)dy$</p><p>$f_X(x) = F^{‘}_X(x)$   </p><p>二维正态随机变量边缘分布仍为正态。<br>可由二维联合概率密度完全确定边缘概率密度，反之不行。X,Y独立分布的充要条件是$\rho = 0$</p><h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a><strong>独立</strong></h4><ul><li><p>定义：任意x,y有$P{X\leq x,Y\leq y} = P{X\leq x}P{Y\leq y}$</p><p>​            即 $F(x,y)=F_X(x)F_Y(y)$</p></li><li><p>定理：$P{X= x_i,Y= y_j} = P{X= x_i}P{Y= y_j}$（离散） 是独立的<strong>充要条件</strong></p><p>​            连续：$f(x,y)=f_X(x)f_Y(y)$ <u>在平面上除去“面积”为零的集合后成立，而不是平面上均成立。</u></p></li></ul><p>大题就分别得到左右两侧，然后看相等否。</p><p><code>条件分布率</code></p><p>$P{Y= y_j |X= x_i}=\frac{p_{ij}}{p_{i.}}$</p><p><code>条件概率密度</code></p><p>$f_{Y|X}{y|x}=F^{‘}_{Y|X}{y|x}=\frac{f(x,y)}{f_X(x)}$</p><p>如果是一个具体时间，那么$f_{Y|A}(x)=\frac{f_X(x)}{P(X\in A)}$</p><p>$\displaystyle f_{X}(x) = \int_{-\infty}^{+\infty}f_Y(y)f_{X|Y}{x|y}dy$联合、边缘、密度相互关联</p><p>在X = c 条件下，随机事件${a&lt;Y\leq b}$的条件概率：</p><p>$\displaystyle P{a&lt;Y\leq b |X=c}=\int_{a}^{b}f_{Y|X}(y|c)dy$</p><p>求离散随机变量的函数及其分布律P83</p><p>列表得出可能的值，填上分布律。</p><p>离散卷积公式，二项式和泊松的可加性。</p><p>求连续随机变量的函数及其概率密度P85</p><p>此时，y相当于未定的常数，要进行讨论。</p><ul><li><p>分布函数法，先利用原来的fx，求得Fy，再求导得fy、</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211019111029124.png" alt="image-20211019111029124" style="zoom: 33%;" align = 'left'/></li><li><p>公式法，只适用于<u>全局严格单调</u>的函数y = g(x)。</p></li></ul><hr><p><em>随机变量的函数的数学期望：</em></p><blockquote><p>数学期望存在的条件：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027941.png" alt="image-20211231220305870" style="zoom: 33%;" /></blockquote><p>定理4.1.1 设 Y 是随机变量X的函数Y=g(X)，g(x)为连续函数</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027943.png" alt="image-20211231215343557" style="zoom: 33%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027944.png" alt="image-20211231215442901" style="zoom:33%;"/></p><p>:star: 二维时，$E(X) = \displaystyle \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}xf(x,y)dxdy = \int_{-\infty}^{\infty}xf_X(x)dx$</p><p>$E(x)$具有线性性、而相互独立时$E(XY)=E(X)E(Y)$</p><p>方差定义：$D(X) = E[X-E(X)]^2$；标准差$\sigma(X) = \sqrt{D(X)}$</p><p>常用计算公式：$D(X) = E(X^2) - [E(X)]^2$</p><p>$D(X\pm Y)=D(X)+D(Y)\pm 2cov(X,Y)$，独立时，$cov(X,Y)=0$</p><p>协方差定义：$cov(X,Y) =E{[X-E(X)][Y-E(Y)]}$</p><p>对称性、齐性 $cov(aX,aY) = abcov(X,Y)$     $cov(X,c) =0$<br>可加性$cov(X_1+X_2,Y)=cov(X_1,Y)+cov(X_2,Y)$</p><p>相关系数$\rho_{xy} = \frac{cov(X,Y)}{\sqrt{D(X)D(Y)}} = \frac{E(X_1X_2)-E(X_1)E(X_2)}{\sqrt{D(X)D(Y)}}$ ，是量纲为1的量，衡量 <em>线性</em> 相关关系。<br>$|\rho_{xy}| = 1 \leftrightarrow$X、Y线性相关，即Y =AX+b</p><p><strong>相互独立（更本质）一定不相关$(\rho = 0)$，反之不成立（除了二维正态里的X,Y，但是两个普通的正态分布不算）。</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027945.png" alt="image-20220102190758627" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027946.png" alt="image-20220101105817621" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027948.png" alt="image-20220101105951275" style="zoom:33%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027949.png" alt="img" style="zoom:67%;" align = 'left'/><p>矩：更一般的数字特征。【只考统计部分要用得到的】</p><p>可以证明，若随机变量的高阶矩存在，则低阶矩一定存在。</p><p>多维正态随机变量【不考】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027950.png" alt="image-20220101103918453" style="zoom: 80%;" align = 'left'/><p>希望不考：随机变量$(X_1,X_2,…,X_n)$的线性变换$BX$（B是个mxn矩阵），服从m维正态分布$N(Bu,BCB^T)$</p><hr><p>大数定律和中心极限定理是<u>独立随机变量序列</u>的部分极限定理。</p><p>切比雪夫理解：$P{|X-E(X)|\geq\varepsilon} \leq\frac{D(X)}{\varepsilon^2}$ 和 $$P{|X-E(X)|\leq\varepsilon} \geq1-\frac{D(X)}{\varepsilon^2}$$</p><p><u>随机变量的取值偏离均值一定范围的概率上界，正比于方差（方差越大分布越广），反比于给定的范围。</u></p><p>可用来证明依概率收敛。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027951.png" alt="image-20220101124820047" style="zoom: 50%;" /></p><p><strong>大数</strong>：取一个序列的随机变量平均，以及均值的平均。<br><u>刻画了随机变量序列，分布的中心收敛于均值之和，描述的是【聚散】</u></p><ul><li><p>切比雪夫：相互独立，期望、方差均存在，方差一致有界。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\sum_{i=1}^nX_i -\frac{1}{n}\sum_{i=1}^nE(X_i)|&lt;\varepsilon} =1$</p></li><li><p>独立同分布：独立同分布，期望、方差存在。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i -\mu|&lt;\varepsilon} =1$</p></li><li><p>辛钦：独立同分布，期望存在。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i -\mu|&lt;\varepsilon} =1$</p></li><li><p>伯努利：$\displaystyle \lim_{ n\to \infin}P{|\frac{m}{n} -p|&lt;\varepsilon} =1$</p></li></ul><p><strong>中心</strong>：找到一个（独立同分布）的序列，均落在某一范围。<br><u>实质是刻画了相互独立的某些随机变量序列，其和的分布随样本增多而收敛于正态分布。描述的是【形态】</u></p><p>（不是所有序列都满足该条件的！！）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027952.png" alt="image-20220101130110785" style="zoom: 43%;" /><p>独立同分布中心定理（相互独立同分布，期望、方差存在，用$n\mu$和$\sqrt{n}\sigma$替换式子里的两项。）</p><p>D-L中心极限定理：（二项分布时，用$np$和$\sqrt{np(1-p)}$替换式子里的两项）</p><h3 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h3><p>研究如何以有效的方式<u>收集和整理</u>随机数据</p><p>研究如何合理地<u>分析随机数据从而作出科学的推断</u> (称为统计推断).</p><blockquote><p><strong>弄清楚样本量和总体的统计量的符号和定义！不然老是混淆。</strong></p><p><em>总体参数</em>（ML里的期望分布）</p><p>数学期望：$\mu$ = $E(X)$</p><p>方差：$\sigma^2 = D(X) =\mu_2 =\gamma_2 - \gamma_1^2 $</p><p>$k$ 阶原点矩：$\gamma_k = E(X^k)\ (k = 1,2,…)$</p><p>$k$ 阶中心矩：$\mu_k = E{[X-E(X)]^k}\ (k = 1,2,…)$</p><p><em>样本统计量</em>（ML里的经验分布）</p><p>样本均值：$\overline{X}=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i$</p><p>样本方差：$S^2=\frac{1}{n-1}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2 = \frac{n}{n-1}M_2$    其中有$M_2 =A_2 - A_1^2$</p><p>样本k阶原点矩：$A_k=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i^k$</p><p>样本k阶中心矩：$M_k=\frac{1}{n}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^k$</p></blockquote><p><strong>总体</strong>是具有相应概率分布的随机变量。 比如总体$X$，则随机变量X的概率分布就是总体分布。</p><p><strong>样本</strong>是在保证每个个体有同等机会被抽出时，抽出的一部分个体。是<u>一组随机变量</u>，如$X_1,X_2…X_n$。</p><p><em>样本值不是确定的！只确定了样本容量</em></p><p><strong>简单随机样本</strong>：每个$X_i$均与$X$<u>同分布</u>，每个$X_i$均<u>相互独立</u>。这是简化的情况，便于研究和考试。</p><p><strong>统计量</strong>是样本的函数【<u>因此研究的是该样本组的性质</u>】，是<u>随机变量</u>且<em>不含未知参数</em>。</p><p><strong>抽样分布</strong>——统计量的分布，虽然难求，但是正态总体中常用的统计量分布已经有了较完整的结果。</p><p>我们从总体抽取样本，对这组样本算我们关心的样本的统计量，然后研究这个统计量满足怎样的分布。</p><p><em>卡方分布</em>$\chi^2(n)$</p><p>$E = n,D = 2n$；可加性；n&gt;45时，$\chi^2_\alpha(n) \approx n+u_\alpha\sqrt{2n}$</p><p>当样本量为1时，$X^2 = \chi^2(1)$</p><p><em>T分布</em>$T \sim t(n)$</p><p>对称性 $t_{1-\alpha}(n) = -t_\alpha(n)$ n&gt;45 近似服从$N(0,1)$分布</p><p><em>F分布</em>$F\sim F(n_1,n_2)$</p><p>$\frac{1}{F}\sim F(n_2,n_1)$       $F_{1-\alpha}(n_1,n_2) = \frac{1}{F_\alpha(n_2,n_1)}$</p><p><strong>抽样分布定理</strong>，（虽然只有正态），告诉了我们一些结论，即<u>正态分布抽样后部分统计量的分布是怎样的</u>，我们可以在此基础上加以组合，得到符合三大分布的分布。【给了样本均值、方差的分布，给了一个“样本方差联合分布”、给了两组正态样本的分布、】</p><p>这些结论，都来自<strong>正态分布</strong>的样本，右边俩还要求<em>相互独立</em>。不然一般分布的很难求出来</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027953.png" alt="image-20220101143237485" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027954.png" alt="image-20220101144340867" style="zoom:30%;" /></p><p>推导过程在P151</p><p>理解上侧分位数：$P(x&gt;,u_\alpha) = \alpha$      $F(\mu_\alpha) = 1-\alpha$<br>那些带下标的下标，比如$t_\alpha$都指的是令右边的面积为$\alpha$的点。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027955.png" alt="image-20220101151559917" style="zoom:33%;" /></p><hr><p>参数估计是统计推断的基本问题之一。有了样本分布定理，就可以进行统计推断了。</p><p><strong>点估计</strong></p><p>利用样本，对每一个未知参数 $\theta_i$，按一定的优化原则<strong>构造一个统计量</strong> $\hat{\theta}_i(X_1,…,X_n)$ ！作为对参数 $\theta_i$ 的估计，<strong>称为估计量</strong></p><p>当样本值确定后，带入统计量，就能得到具体数值 $\hat{\theta}_i(x_1,…,x_n)$即估计值。</p><p><em>矩估计</em>：</p><p><strong>以样本矩直接作为相应总体矩的估计，样本矩的函数作为相应总体矩同一函数的估计</strong></p><p>（由辛钦大数定理知样本矩依概率收敛于总体矩，这也是李航那本书的经验收敛于期望吧。）。</p><p>基本假设：总体X分布为$f(x;\theta_1,…,\theta_m)$，<u>各阶矩均存在</u>。</p><p><em>如果题目没给矩，那就先算总体的各阶矩 = xxx，然后再反过来表示。</em>【也可以用$\overline{X}$】</p><p>对总体方差的矩估计$M_2$ = $\frac{n-1}{n}\cdot S^2$并不是无偏估计。$\mu = \gamma_1\ 、\sigma^2 =\gamma_2-\gamma_1^2$ 可以分别直接用$\overline{X}$和$M_2$替换。</p><p>有如泊松分布的情况，一个参数$\lambda$有两个不同矩估计，原则：<u>估计量的优良性标准，一般选用低阶矩</u></p><p><em>最大似然估计法——MLE</em></p><p>有些分布不存在的数学期望，自然不存在高阶矩，而最大似然是重要而普适的。</p><p><strong>按照最大可能性的准则进行推断，把<u>已经发生的事件，看成最可能出现的事件，认为有最大的概率</u>。</strong><br>如果是求某个分布的参数估计，就按照分布律/概率密度来求似然函数。【样本不会出现在概率为0的地方，无需讨论。】</p><blockquote><p>给定输出x时，关于参数θ的似然函数L(θ|x)（在数值上）等于给定参数θ后变量X的概率：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/1e572150cc607eb32fd3fa77c8865919.svg" alt="img">=$\displaystyle\prod_{i=1}^n f(x_i;\theta_1,\theta_2,…,\theta_m)$</p><p>他们其实都表示“<strong>可能性</strong>”的大小，但是一个是已知结果，研究参数的情况，表示对参数的估计；一个是已知参数，研究结果随机变量的情况，研究概率。就像一个二元函数一样，只不过要对输入的参数分两类。</p><p>似然函数的主要用法在于<u>比较它相对取值</u>，虽然这个数值本身不具备任何含义。</p><p>一般形式上是样本组的联合概率密度函数。</p></blockquote><p>写出似然函数<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027956.png" alt="image-20220101155125680" style="zoom:33%;" />，取对数，然后对每个参数求偏导，求解似然方程组。</p><ul><li>似然方程组的解不唯一，要进一步判定哪个是最大值点</li><li>似然函数关于参数导数不存在时，无法得到似然方程组，要用<strong>定义</strong>【找到使得L最大的一组参数】来求解。</li></ul><p>最终将参数<u>用估计值</u>$x_1,x_2…x_n$（有时需假设）来表示，然后再<u>替换成用相应的估计量</u>$X_1,…,X_n$表示。</p><ul><li>矩法估计参数比较简单,但有信息量损失；极大似然估计法精确度高，但运算较复杂</li><li>运用两种方法得出的结果不一定相同，哪怕只用一种方法也可能得出多个结果</li></ul><p><strong>无偏性：$E(\hat{\theta}) = \theta$ 对θ的所有取值成立，实际意义是无系统误差。</strong>(考的概率大)</p><p>有效性：$D(\hat{\theta})$对θ的所有取值尽可能小</p><p>相合性：设$\hat{\theta}_n =\hat{\theta}_n(X_1,X_2,…,X_n)$，对θ的所有取值，依概率收敛于θ<br>可以证明，在较为一般的情况下，矩估计、MLE得到的估计量都是相合估计量。</p><h4 id="枢轴"><a href="#枢轴" class="headerlink" title="枢轴"></a>枢轴</h4><p>首先满足置信度$1-\alpha$，然后尽量缩小区间长度，也就是提高精度。</p><p>不光是记住对应的枢轴变量，更要理解推导出置信区间的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027957.png" alt="image-20220101170041958" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027958.png" alt="image-20220101170123565" style="zoom:50%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027959.png" alt="image-20211202090349096" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027960.png" alt="image-20211202091529763" style="zoom:33%;" /><p>结合抽样分布定理理解。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027961.png" alt="image-20211202091549607" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027962.png" alt="image-20220101185539648" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027963.png" alt="image-20220101185658773" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027964.png" alt="image-20211208202236252" style="zoom: 67%;" /></p><p>格式里不要忘了写查表得，在置信度为xxx下，置信区间为，，，，<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027965.png" alt="image-20220103202615404" style="zoom:50%;" /></p><p>对于单侧，将一个端点换位无穷，另一个端点的$\frac{\alpha}{2}$换成$\alpha$</p><p>而在<strong>假设检验</strong>，我们从另一个角度分类，从各类参数出发构造检验。</p><p>对均值估计，已知方差，则都是标准正态。</p><p>对均值估计，未知方差，则都是$t$分布【均值差估计时，假设若是$\mu_1-\mu_2=0$记得带入消掉】</p><p>对方差估计，都是卡方分布</p><p>对方差之比检验，是$F$分布</p><p><strong>步骤</strong>：作出假设（由题意需假设检验）、构造检验统计量（要写，当$H_0$成立时）、确定拒绝域（原假设的拒绝域为）、对$H_0$判断。（已知，，，，，查表得。。判断。。因此拒绝/结束$H_0$，即认为）</p><p>工艺题，<strong>保守原则</strong>，总是讲$H_0$设为想证明的结论的反面，然后否定$H_0$，比如猜测$\mu_1&gt;\mu_2$<br>就假设$H_0:\mu_1 \leq \mu_2,H_1:\mu_1 &gt; \mu_2$，再等价成$H_0:\mu_1 = \mu_2$，再否定它。<br>拒绝域是$t&gt;t_{\alpha}$，这样记：与$H_1$条件中同号      反之同理，关键是$H_1$</p><p>$\mu_1 - \mu_2$未知$\sigma_1\ \sigma_2$，需要先检验$H_0:\sigma_1 = \sigma_2$如果方差不相等，不在考虑范围内。相等则两样本t检验法</p><hr><p>回归分析和方差分析是数理统计中应用价值很大的两类方法，共同点是研究变量之间的关系。</p><p>回归分析着重寻求变量值近似的函数关系。研究相关关系（存在联系，但没达到可以相互确定的程度）</p><p>$Y = \mu(x_1,x_2,…,x_k)+\xi$</p><p>通常要求随机误差满足：$E(\xi) = 0,D(\xi) = \sigma^2 = E(\xi^2) = E[Y - \mu(x_1,x_2,…,x_k)]^2$<br>即均值为0，方差存在。方差实际是回归函数近似因变量Y的均方误差。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027966.png" alt="image-20220102130707096" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027967.png" alt="image-20220102130717305" style="zoom:35%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027968.png" alt="image-20220102130951882" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027969.png" alt="image-20220102131215823" style="zoom:40%;" /></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong>课本</strong></p><p>​        记得先假设事件，如 A = {}。公式也有分，比如<u>全概率公式、贝叶斯</u>得写出来（由xxx得：列公式=代数字）</p><p>P11 古典概型是全概率和贝叶斯的基础。 例1.2.3 到1.2.5</p><p>P18 条件概率例题 例1.3.4</p><p>P19 例1.3.5  1.3.6 连续乘法 1.3.7</p><p>P21 全概率解题结构，要强调xxx构成样本空间得划分。 P23 例1.3.12/13贝叶斯公式。</p><p>P46 2.2.8 9 10 泊松分布（因为n较大，p较小，可认为X近似服从参数为$\lambda = np = ?$得泊松分布，于是 <u>先列出二项分布的式子，再约等于泊松的式子</u>） </p><p>P56 2.3.9 正态分布</p><p>P70 例3.1.6 概念题【注意第四问，<u>设了一个u和v</u>，而不是用原来的x，y】 3.1.7 在求边缘概率密度时要分区间</p><p>​        证明相互不独立时，找一个区间就好，一般找那个二维的非零区间。</p><p>P78 3.3.1条件分布率 3.3.2</p><p>P80 <strong>例3.3.3</strong> 注意边缘概率密度范围是一维的，条件概率是二维的。第二问：<u>求条件概率要先求出条件概率密度再积分。</u></p><p>​        例3.3.4 算联合概率时范围确定。（<u>条件分布率的范围表示时把后面那个变量视为常数</u>，有积分那味道了）</p><p>P83-84 离散型随机变量的函数、分布律  先列出函数的可能取值，再列式求和。【二项、泊松、正态】有可加性</p><p>P86 求连续随机变量的函数及其概率密度（此时，要对y的范围进行讨论，但最终y要取满R）但最终进行求导时不变（除了合并）</p><p>P88-93 例3.4.8利用公式法，注意x，y范围是一一对应的。</p><p>​         三大特殊分布。和分布，如果X，Y是相互独立的，可以拆成边缘分布律乘积。<br>​            例3.4.12 转到x，z平面，确定积分限。    例3.4.13 转到y，z平面，确定积分限。（这个独立的话也可以拆）<br>​            通过这俩例子也能看到题给条件是联合概率/边缘概率时分别如何处理。</p><p>P107 例 4.1.7 4.1.8   二维随机变量的联合函数的方差</p><p>P131 切比雪夫例子</p><p>P136-138 中心极限定理例子</p><p>P151 推导$S_w$的过程，好好掌握，免得暴雷。</p><p>P158 矩估计，一般是利用E和D的式子来连接。还有$E(X^2)$</p><p>P160-161 对于某种分布的情况，似然函数借助分布律/概率密度进行构造。</p><p>很有可能考无偏性，其实是考察对E、D性质的掌握，看学解历年真题</p><p>P169-173 几种枢轴变量</p><p>P175 单侧置信区间，一定要写 **若$H_0$立，检验统计量…..          故在显著性水平0.05下接受$H_ 0$ **</p><hr><p><strong>课件</strong></p><p>1.3 例9 10 11 12(解法2) 14 15</p><p>1.4  全概率、贝叶斯 例5 例6 例8 9贝叶斯要算出全部的再比较</p><p>2.1 最后 例3 例4（右连续）</p><p>2.3 例6 指数分布，最后一题正态</p><p>3.1 例3.1.5 </p><p>3.3 条件分布率 例1 <u>例3</u> <strong>例4</strong> 根据边缘概率的区间，对条件概率分段（因为条件概率也是二维的，需要二维约束）。</p><p><strong>3.4</strong> 例3.4.7，一个自定义的分段随机变量的函数，<u>画图来讨论范围</u>。第二问用定义来做。3.4.8-最后，多练练。</p><p>4.1 下面练习$X,Y \sim N(0,\frac{1}{2})$，则$E(|X-Y|)=\sqrt{\frac{2}{\pi}}$<br>        例4.1.7 4.1.8 利用数学期望的性质（主要是可加性）进行问题求解。【尤其是4.1.8的分解方式，保持独立、一致】</p><p>​        例4.2.3 进一步求$|X-Y|$的方差。</p><p>4.3 例4.3.4 求cov，转了一层  4.3.6（算一堆均值）</p><p>​        例4.3.7 利用了E D Cov的性质，挺不错</p><p>5.1 例5.1.2 5.1.3 将题给的数转化成$E(X)$的形式，凑出切比雪夫形式。</p><p>5.2 例5.2.2-5.2.4  5.2.3的设变量方式值得学习</p><p>6.2 6.2.4 6.2.5 类似的推导，用U,V来描述过程。</p><p><u>7.1 例7.1.2（最后超牛） 7.1.3 7.1.4 最后那个均匀的处理。【极大似然格式，掌握好】</u></p><p>8.1 最后一题，二项分布结合假设检验</p><p>8-2 研究正常男、女红细胞X2，要假设随机变量，</p><p>4-5习题课</p><p>11 停车次数</p><p>8 求类似的<u>一般不用切比雪夫，用中心极限定理</u>。还有后面的车间机床</p><p>求 X  和Y 的联合分布指的是求联合分布律或密度</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027970.png" alt="image-20220102194707428" style="zoom:33%;" />设新变量$e^{X_k}$，算出均值为2，用辛钦大数定律。</p><p>6-9习题课</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027971.png" alt="image-20220102193744173" style="zoom:33%;" /><p>最后5道选择挺有意思。</p><p><strong>历年真题</strong></p><p>第一套：第三题、<u>似然估计题</u>（如果似然函数的分布律/分布函数是一个常数，那就要分析取值范围，一般取x的俩极值）</p><p>第二套：还是狗日的<strong>第三题</strong>，第四题这种处理，先变成大正态，同乘同除处理。最后回归，如果题目没给均值，同乘n</p><p><strong>作业册</strong></p><p>P11、13、15最下面 </p><p>P22_11、13、15、16、19、23（离散结合连续）题</p><p>P32_10、11</p><p>P37_6、7、8</p><p>P40_3、5、6 先确定统计量的分布，或处理后确定分布</p><p>P44_4、6</p><p>P59_12</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;What is Probability theory and Mathematical Statistics&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生活中的现象根据是否可事前预言，分为&lt;u&gt;确定性现象和非确定性现象&lt;/u&gt;。&lt;br&gt;在非确</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>集表象以求真</title>
    <link href="https://darren-dong.com/2021/08/22/%E9%80%86%E6%B0%B4%E8%A1%8C%E8%88%9F/"/>
    <id>https://darren-dong.com/2021/08/22/%E9%80%86%E6%B0%B4%E8%A1%8C%E8%88%9F/</id>
    <published>2021-08-22T06:08:16.000Z</published>
    <updated>2022-05-09T09:13:01.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集表象以求真"><a href="#集表象以求真" class="headerlink" title="集表象以求真"></a>集表象以求真</h2><p>境界不够，无从辩驳</p><ol><li><p>大多数人所谓的思考，不过是在重复过去的偏见</p></li><li><p>寻找初心，清楚所需，分辨主次，是人这一生最重要的事，看似最简单，实则最难。任何一个觉得自己差不多能做到的人，都绝对没做到。我做不到，所以我每过一段时间要思考这个问题，要强化认识。更何况，世界在变化，我也会变化</p></li><li><p>人只有从高处俯视，才能选对正确的道路</p></li><li><p>我有种错觉，他在大多数情况下只是个普通人，普通到不能在普通的人。但是，他总能在关键的时候，变得不普通。我感觉，他不是天才，但他总能在特别的领域和特别的时间，无限接近天才。</p></li><li><p>这种完全符合人类需求和历史趋势的商品，永远不可能赔钱，最多是传播速度快慢而已</p></li><li><p>适当展示力量，胜过遮遮掩掩</p></li><li><p>没有必然的成功，只有必然的收获。法斯特将军所谓的幸运，是凭借一步一步的收获，抓住了机会。不幸运的人，不是没有机会，而是没有足够多的收获。成功是外求，收获是内求</p></li><li><p>你现在可以选择两种思考方式，一种是目标思维，我们只关注有益于目标的事情，不关注其他。遇到阻碍，我们把‘解决障碍’当作目标，一切无益于解决障碍的事情，都不考虑。一种，就像你现在的思考方式，总是去想那些与目标无关的事，本质上，你在逃避.</p></li><li><p>其实每个人都有更多的选择，只是大多数时候，我们放弃最好的选择。不过，每个选择，都是当下最好的。</p></li><li><p>雪崩之下，没有一片雪花是无辜的</p></li><li><p>再睿智的目光，也只能看到前方，再狭隘的视线，也可能看到智者的盲区。</p></li><li><p>大人们做事最恶毒，而孩子们说话最恶毒</p></li><li><p>贵族的特权，与生俱来；贵族的责任，自始至终</p></li><li><p>力量越大，责任越大，这句话不是保护别人，是自己。是为了避免自己失控。责任并不是约束，就像衣服并不是为了阻挡我们，是保护。</p></li><li><p>将自己举到高处的人，也预留出跌落的距离</p><p>  因蒙他人荣耀而获得的特权，也必将因放弃承担责任而失去</p></li><li><p>确实。金钱的确与罪恶有关，但带来罪恶的不是金钱，而是人。</p></li><li><p>因为，我们容易被表层目标吸引，忘记探索深层目标，也就永远解决不了问题</p></li><li><p>我喜欢和聪明人交往，因为我不用考虑他们的自尊</p><p>  这句话并不是说不尊重他人，而是在说，真正的聪明人，在做任何事的时候，都明白‘自己要做什么’，而不是把次要的脸面、尊严和情绪等等放在首要位置，凡是把这些元素放在首要位置的人，连最基本的主次都分不清，自然无法成为聪明人。而另一个意义是，一旦我们和分不清主次轻重的人交流，我们为了交流更顺畅，就不得不考虑其他因素，从而让自己付出更多的沟通成本，而世界上大部分的沟通成本，都在阻挠人类进步。当然，另一方面来说，另一种聪明的人，会掌握沟通的方式，降低沟通成本，也就是利用别人的情绪、尊严和虚荣的弱点，掌握主动，获益。</p></li><li><p>这让我意识到，反对传播知识的人，维护的不是知识本身；反对白化病患者的人，维护的不是人，而是他们的‘旧日的正确“</p></li><li><p>一个有强大学习能力的人，在小时候可以这么说，但成年之后，不会把核心放在有没有好老师教、有没有好的父母关爱、有没有好的环境熏陶、有没有好的过去，而是把核心回归自身，去追寻自己想要的一切，自己去培养想成为的自己</p></li><li><p>当一个人相信自己看到的就是真实的时候，那么制作这段真实的人，就已经成了他的主宰</p></li><li><p>是的，很多人内心邪恶，却没有犯罪，这样的人，你不能说他是好人，但他绝对不是坏人。</p><p>很多人内心带着挣扎与忏悔，却做了坏事，他以为自己没得选，只想做个好人，但本质上，却就是一个坏人。</p></li><li><p>“就是字面意思，我们做出了某些选择，就代表我们也放弃了某些选择。</p><p>如果我们要因为放弃的选择而自责，那我们以后永远无法做出选择。”</p></li><li><p>信息差，不见得就是你知道的比别人多，有时候只要能够改变信息的对错，就能够瞒天过海</p></li><li><p>人的一生，穷的时候基本都是拿面子换钱，有钱了就拿钱买面子</p></li><li><p>所以人类啊……其实给予他们一个堕落的环境，他们堕落起来大概比谁都痛快。</p></li><li><p>对外人包容，对亲近的人刻薄。用百分之四十的谎言来覆盖百分之七十的生活。对一个事物的爱似乎是有极限的，一旦想要去爱着某个新生的事与人，就必须从过往的事与人里抽离出一部分爱。小心翼翼却又狂妄自大。另外……无法互相理解，且脆弱，容易死亡</p></li><li><p>这个世间有很多的故事，原本很简单明朗，其中曲折与狗血，就是两个字——不说。所以做人有时候……也没有那么麻烦。不过是坦荡，坦诚，坦白罢了。</p></li><li><p>身在这个环境里，他无力改变，只能融入，但他一直还记得，自己为什么要进入这个环境，所以无论什么时候，他始终没有放弃，自己应该做的事情</p></li><li><p>人做出每一种行为，都有背后的逻辑与动力在支撑。</p><p>  他们看起来只是这简单的行为无法做到，但实际上是行为背后的逻辑与动力出问题了。</p><p>  机械零件的缺损与燃料的不足，都会导致运转不灵。</p><p>  可怜的是，很多人能够理解机械，却理解不了同类</p></li><li><p>如果你现在感觉很难过，很累的话，那我们就什么都不要理了。我们现在就回家，好好的吃个饭，洗个澡，再睡上一觉。别的一切，都跟我们没有什么关系。我们不需要一直背负着这些东西啊，能好好的活着就很好了。我们凭什么不能让自己更轻松些呢</p><p>我还是有点不甘心,因为，事情不该是这个样子的,既然不对，那就让事情回到他应该有的轨迹吧</p></li><li><p>受害者不完美，不同获得你完美的同情，加害者也不完美，不能承受你完美的愤怒。这么一个不完美的世界里，又怎么装得下你那份完美的正义感</p><p>真要审判，那就按着统一的标准，一视同仁的去审判所有人，这才叫公平，但是当你们只能审判比你们弱小的人时，就默认了会放过所有比你们强大的人，也放过了一批虽然做了错事，但却从来不认为自己错了的人，你们的公平，已经打了折扣，便不再是公平</p><p>无法审判所有人的审判，本来就应该是被审判的</p></li><li><p>你不必自责，即便不是百分之百的善意，做了一些善良的事情，也是值得感谢的。就如即便没有抱着歹意，但对别人造成了伤害的也要受到惩罚。</p></li><li><p>人生是无需后悔的，就像是复杂的数据经过精密的计算也只会有一个结果，把如今的自己投放到了曾经的过去，在当时的具体数据之下，自己做出来的，也是一样的选择。</p><p>感知、情绪、欲望、认识、本能、记忆，才是决定一切的数据。</p></li><li><p>生与死的真谛，不在于生，也不在于死，不在于它的状态，而是……它转变的那个过程。</p></li><li><p>你到底爱的是汉德，还是爱的是希望做一个健全儿子的父亲的你自己</p></li><li><p>大时代下，他的领悟，他的痛苦，一文不值，无人问津</p></li><li><p>只是踩着父母的肩，见识了父母未曾见过的繁华</p></li><li><p>天予不取，反受其咎。 时至不迎，反受其殃</p></li><li><p>只记得坚持，却忘记了为何坚持</p></li><li><p>受国之垢，是谓社稷主。受国不祥，是为天下王</p></li><li><p>一朝英雄拔剑起，又是苍生十年劫</p></li><li><p><a href="https://www.slkj.org/c/28647.html">日出扶桑一丈高，人间万事细如毛</a>。<a href="https://www.slkj.org/c/28648.html">野夫怒见不平处，磨损胸中万古刀</a>。</p></li><li><p>看见天才失败，堕入尘埃，对于失败者来说，固然会有一时的爽感，但是看见天才不努力，挥霍自己的天赋，才是最让失败者揪心的</p></li><li><p>追求真理的生物，和追求存在的生物……前者根基于后者之上，它是后者的进化和衍生。</p></li><li><p>人可以犯错，但不能将错误装饰成‘必要的正确’。</p></li><li><p>智慧诞生，不是为了遵循规则和宿命，去遵循他人应允的‘未来’，而是为了追寻‘更好的未来’，‘更多可能的改变’。</p></li><li><p>牺牲，是捷径！</p></li><li><p>是因为我们选择了这条道路，这条道路才能成为大道，而并非是大道成就了我们，选择了我们</p></li><li><p>【审判的要素，并不是仇恨，首先是因为爱。因为爱所有良善的人，所以才要去惩戒所有为恶的人。】</p></li><li><p>沉默。唯有沉默是最高的轻蔑。提出质疑，就是因为认可了对方一部分的道理，所以才会有欲望去询问，纠正，质疑和抬杠。</p></li><li><p>因为众生一直都在反抗这个世界，一直都在同命运战斗，所以被称为圣皇的男人才会有勇气，一直坚持继续战斗下去。</p></li><li><p>质疑和反抗本身就比答案还重要，因为答案也只是暂时的，一切都会革新，改变，追求完美的答案本身，就是一个不完美的想法</p></li><li><p>革新本身是正确的，但是没有任何一种革新是绝对正确的，任何不了解当地客观情况，不与实际相结合的革新，都不是真正的革新，而是一种恶，一种名为傲慢，自以为‘正确’，所以便强行要求其他人‘改变’的恶。</p><p>  真正的革新，需要积累经验，观察现实。需要根据每一地，每一群人，每一个社会，文明和世界各不相同的情况，进行各不相同，各具特色的革新。</p><p>  所以，革新一开始，就不能是完美无瑕的。它的的确确有着缺漏，错误，和不完善的地方，所以才需要去改正，变革，修复，去见原本错误的地方，修补成正确的。</p></li><li><p>当最强者确定了自己的理想，整个世界中不存在另外一个人去反驳，质疑，挑衅他，只能任由他施为，做‘正确’的事情之时，那么整个世界就会只剩下一个声音，所有的梦想，欲望，乃至于意志，都会被最强者扭曲。</p><p>  这就是扼杀了无数未来和希望，乃至于可能性的‘极度邪恶’！</p><p>而保持独立，就是强者的特权</p></li><li><p>每个人类个体的存在都有意义？？随着技术的进步，这一概念最终将有明确的对错吗？</p></li><li><p>它就是最大的伤害，最大的欺压，最大的不公和压迫，最强最恶的正义和善良。【永恒秩序】</p></li><li><p>扎根于已经存在的万事万物之上，承认欢笑，也承认苦难，相较于昨日的‘更完美’。这就是革新的真意，革新从来都不否认错误，而是承认错误，加以改正。</p></li><li><p>旧文明把人变成神……而新文明，我们想要让神变成人。</p></li><li><p>生命没有任何意义，存在的理由只能自己去追寻和坚信</p></li><li><p>如果说，一切的‘美好表象’，反而令人脚步停滞在原地，无法向前探索的话……那么毁灭，反倒是一种赐福</p></li><li><p>引领而不强制，交流而不命令——所有人心中皆有革新的种，我只需要将其点燃，催发，而不是拔苗助长。</p></li><li><p>爱并非是单纯的，单方面的付出。爱也是一种攻击，一种强大的力量</p></li><li><p>思想会破碎，会腐朽，但却是不会畏惧痛苦的</p></li><li><p>苍天何辜？受此佶问<br>【好人一样是人，凭什么就得一路顺风万事如意？好人就得占尽所有好处，不能受半点苦，也不能遭半点罪？】</p><p>  【这才不是天理，这只是一厢情愿，自以为是】</p></li><li><p>做很多工作，从事很多行业，应聘很多岗位，都需要考证，都需要过关，就像是考驾照一样，你得被确认自己技术过关，交通法规认知熟悉，还得让你上路去开，看看你是否能经得起考验<br>但是当父母，不需要考证。</p></li><li><p>孤独的人，甚至会对对手报以憧憬。</p></li><li><p>姜望在心里把这名字默念了几遍，也好像把某种责任，系在了道心上。</p></li><li><p>为众人抱薪者，不可使其冻毙于风雪！</p></li><li><p>我从来没有在我们佑国，见到过这么天才的修士。”</p><p>  “我在想。”他说：“像这样的天才，若给他机会成长起来。难道不能够成为佑国的擎天之柱吗？难道不足以守护佑国吗？”</p><p>  赵苍眼皮微抬，淡淡道：“有比他更天才的，但是都没有机会成长，都战死了。”</p><p>  他补充道：“在护国圣兽出现之前。”</p></li><li><p>在这个世界上，无论什么人，什么事物，哪怕一块焦炭，一张废纸，都有他的用法。可靠有可靠的用法，不可靠有不可靠的用法</p></li><li><p>每个人一生当中都会在某个阶段拥有至交好友或者闺蜜，可再过一段时间呢？很可能就不是了</p></li><li><p>女人的一生中，需要亲友爱人。而男人的一生中，亲友爱人可有可无，但惟独不能缺少对手。</p></li><li><p>人千方百计的学习，来认知世界，知晓规则，就是要利用规则。若是被规则牵绊，反而因为自身所学而束手束脚，这才是真正的悲剧。</p></li><li><p>所谓的信誉，都是狗屁，不过是利益小，打动不了内心罢了。”</p></li><li><p>这个世界上，总会有一群“老”人。他们四处兜售着社会的经验，把他人的理想当做幻想，把他人的热情当做轻狂，把他人的坚持当做桀骜。他们常在教训后辈中，寻找自己的存在感和优越感。</p></li><li><p>爱慕虚荣的人，都会变得愚蠢。他们常常为了虚无的美丽，而默默忍受痛楚，放弃真正应该追求的东西。”</p></li><li><p>生死是世间最大的公平</p></li><li><p>生活不易，就如逆水行舟，不进则退。</p></li><li><p>我平生最看不起那些承受不了困惑和痛苦，就把思考的权力拱手让人的懦夫</p></li><li><p>没有伞的孩子，必须努力奔跑。</p></li><li><p>慈不掌兵、义不养财、善不为官、情不立事、仁不从政</p></li><li><p>有的时候，你的价值，是敌人赋予你的</p></li><li><p>未经他人苦，莫劝他人善</p></li><li><p>“敌强我弱，只有先退一步，才有腾挪的空间。”</p></li><li><blockquote><p>“剑是用来杀死敌人的，这是剑最质朴的道理。”</p><p>　　“你想说，你杀的都是该杀之人”</p><p>　　“不，没有任何人，生来应当死在剑下。”</p><p>　　“身为剑客，不必问杀了谁，但问救了谁。”</p></blockquote></li><li><p>当你相信命运的时候，命运就会替你做主。</p></li><li><blockquote><p>“命运没有给他们退路，但给了我，如此而已。”</p><p>　　“假若你也没有退路呢？”</p><p>　　“那就不退。”</p></blockquote></li><li><p>“在杀人这件事上，任何巧合都是拙劣的布置，只会让老手发笑。</p></li><li><p>对于一个故事来说，当最引人注目的矛盾消失之时，故事便到了结束的时候。</p></li><li><p>学成文武艺，货于帝王家</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集表象以求真&quot;&gt;&lt;a href=&quot;#集表象以求真&quot; class=&quot;headerlink&quot; title=&quot;集表象以求真&quot;&gt;&lt;/a&gt;集表象以求真&lt;/h2&gt;&lt;p&gt;境界不够，无从辩驳&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大多数人所谓的思考，不过是在重复过去的偏见&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="others" scheme="https://darren-dong.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>跨学科通识课</title>
    <link href="https://darren-dong.com/2021/08/09/%E8%B7%A8%E5%AD%A6%E7%A7%91%E9%80%9A%E8%AF%86%E8%AF%BE/"/>
    <id>https://darren-dong.com/2021/08/09/%E8%B7%A8%E5%AD%A6%E7%A7%91%E9%80%9A%E8%AF%86%E8%AF%BE/</id>
    <published>2021-08-09T05:47:56.000Z</published>
    <updated>2022-05-09T03:01:39.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨学科通识"><a href="#跨学科通识" class="headerlink" title="跨学科通识"></a>跨学科通识</h1><p><strong><a href="https://www.bilibili.com/cheese/play/ep6902">视频地址</a></strong></p><p>所长林超自阅读查理芒格观点后得出的感悟。本课程信奉 <strong>实用主义</strong></p><p>现实生活中的挑战并不是按照大学学科划分的，但每种学科，都为我们解决问题提供了重要的思维模型</p><p>本课程将介绍约22个学科和120个常见思维模型，以及部分应用：</p><p>热力学、函数、工程学、<strong>复杂性科学</strong>、系统论、信息论、会计学、概率论、金融学、生物学、投资学、社会学、管理学、物理学、脑科学、认知心理学、历史学、语言学、逻辑学、经济学、营销学、哲学</p><p> <strong>大多数人的一生都喜欢用一个单薄的知识结构解决所有问题，这是专业化带来的狭隘思维</strong></p><hr><p>像我这样的人才:laughing:（bushi），就应该逐步构建自己的知识体系，哈哈我就是这样做的，我在大一接触了应用数学、博弈论、经济学、投资学、心理学、信息论、运筹学，但是学习方法不对，我需要的不是变成所有领域的专家，而是专精一两门（数据科学+经济学），然后学到其他学科的思考模型，先拿林超大大的课试试水。</p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140718.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140824.png"  style="zoom: 33%;" /><p>20-35岁是人生的黄金时间，抓住啊！</p><h2 id="一、熵与热力学"><a href="#一、熵与热力学" class="headerlink" title="一、熵与热力学"></a>一、熵与热力学</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>S = k * lnW  也可以说熵正比于微状态数</p><p>可能性大 = 熵高 = 混乱程度高</p><p>这个世界上混乱才是常态，有序需要<strong>刻意营造</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142123.png"  style="zoom: 25%;" /><p>熵增定律</p><p>封闭系统，与外界隔绝，随时间推移趋于混乱。</p><p>趋于有序的方法</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142524.png"  style="zoom: 25%;" /><p>只要它能正确的做好这两件事，就能使事物变得更加有序。</p><hr><p><strong>应用：思维决策层</strong></p><p>在”脑子里放一个小人“，判断该不该继续思考数量繁多而无序的念头，就能让思维变得有序，这相当于是在正常人的思维输入输出模型里面又加了一个决策层啊！果然方法论决定对外界的反馈，厉害。</p><hr><p>耗散结构</p><p>感知和选择需要信息和能量，封闭系统变成开放系统，吸收外界的能量和信息</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142944.png"  style="zoom:33%;" /><p>流水不腐就是一个耗散结构，人体也是，耗散结构是一个动态平衡体，变化又保持一个平衡状态。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143434.png"  style="zoom:33%;" /><h3 id="运转策略"><a href="#运转策略" class="headerlink" title="运转策略"></a><strong>运转策略</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143513.png"  style="zoom: 33%;" /><p>ps:虽然很多人都是这么做的，但是却没有总结成结论，没有总结成结论，运用的时候就会无效思考，心生犹豫，但若是作为一条公理、定理，一项判断决策，那就非常有价值了！</p><p><strong>人们应该把焦点全部放在蓝色部分的因，接纳红色的因，而不是因为红色的果而感到自责，反而阻止了身体继续排出熵。所以鸡汤里面的依靠决心和自责什么的假大空的，其实就是抓错了重点。</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143954.png"  style="zoom:25%;" /><p>我们改变不了整体系统，但我们可以改变 <strong>感知+选择</strong> 这件事</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144227.png"  style="zoom: 33%;" /><p>有些人会困在先天的家庭环境带来的红色的果里，有些人会找到铁饭碗，陷入封闭系统里，这个世界充满辩证法，耗散里的选择才是最关键的，如果落实到具体做法，请看👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144756.png"  style="zoom:50%;" /><p>逐渐的，两种模式都会形成坚固的闭环。B模式总会伴随痛苦，反人性，充满困难。</p><p>工程学告诉我们如何拆解困难，化为一件件小事，轻松KO。</p><h2 id="二、工程学"><a href="#二、工程学" class="headerlink" title="二、工程学"></a>二、工程学</h2><p>很多人知难而退，其实是知的不够</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809162445785.png"  style="zoom:50%;" /><p>工程学的细分专业非常多：生物、农业、分子、土木、软件、森林。。。</p><p>这节课将提炼共通的重要方法论：<strong>行胜于言、分解结构、量化、列清单、取舍</strong></p><h3 id="行胜于言"><a href="#行胜于言" class="headerlink" title="行胜于言"></a><strong>行胜于言</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809163834216.png"  style="zoom: 33%;" /><p>风口思维找到大方向，高风险，看准下手。</p><p>工程思维就喜欢看得见摸得着的，能清楚看清收益回报，也能付出实践的。</p><p>我个人还是更喜欢风口思维，因为确实难以忍受搬砖的枯燥，但找对风口后，要见成效确实得搬砖┭┮﹏┭┮</p><p><strong>激励</strong>来源：</p><p>要联系到后面讲的生理学：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164237881.png"  style="zoom:33%;" /><p>内啡肽更长更持久，更有益身心健康，显然搬砖是后者。</p><p>人们往往习惯了多巴胺型快乐，它让人兴奋，但持续时间短，消散时会带来失落等负面情绪。</p><p>曾经物质不丰富，一般是一连串的内啡肽小快乐才等来一次多巴胺型大快乐。</p><p>但如今大刺激唾手可得，导致恶性循环👇：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164639424.png"  style="zoom:33%;" /><p>真正公式：</p><p><strong>日常搬砖获得内啡肽型愉悦感，达到了成功再允许自己激发一些多巴胺型的快乐，彻底放松一次</strong></p><p><strong>要是没有达到成果，那就忍着，这才是良性循环</strong></p><h3 id="工程分解结构"><a href="#工程分解结构" class="headerlink" title="工程分解结构"></a>工程分解结构</h3><p>把任意问题拆解，是工程学最核心的思维。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165010342.png"  style="zoom:33%;" /><p>这也有一项孪生能力：focus</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165516146.png" style="zoom:50%;" /><p>focus like a laser, not like a flash</p><p>无限分解，直到找到抓手，从想-&gt;做就在那一瞬间，在脑科学里就是从一个新脑区的边缘神经元开始激活整个。</p><p>既见树木、也见森林</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170229459.png" alt="image-20210809170229459" style="zoom: 67%;" /><hr><p><strong>应用：接触全新学科</strong></p><p>找到该领域最权威的教材，读目录，建框架</p><ul><li>读目录，查清所有不会的术语</li><li>推敲概念之间的关系，建立宏观全局框架</li></ul><p>这是知的部分，全局了解也是非常重要的。</p><hr><p>这才是知行合一，我就是那种喜欢看全局，然后分解不到位，最后懒得搬砖的人哈哈哈</p><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170731986.png" alt="image-20210809170731986" style="zoom:50%;" /><p>一开始只想到房租、售价等几个变量</p><p>开始叙事，通过”讲故事“一步步推衍：</p><p>从开张开始，需要品牌，装修，开工后要培训，设备，原料。。。。</p><p>最后进行数学运算。</p><p>有两种厉害的商业思维分析框架，后面会讲：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171033121.png" alt="image-20210809171033121" style="zoom:50%;" /><p>这件事其实非常简单，更何况我可是数学大佬。</p><p><strong>OKR模型</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171243197.png" alt="image-20210809171243197" style="zoom:67%;" /><p>竖直分解目标，水平量化目标，案例：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171352398.png" alt="image-20210809171352398" style="zoom: 50%;" /><p>这也为行动力提高打下了坚实的基础！</p><h3 id="清单思维"><a href="#清单思维" class="headerlink" title="清单思维"></a>清单思维</h3><p>对应to do list 和 time schedule</p><p>非常简单，但极其有用</p><p>列出来有利于</p><ul><li>确定优先级</li><li>让人专注，有利于“聚焦”。</li><li>利于推敲，找到不严谨的地方</li><li>节省脑资源！！（我就因为这个当年开始列清单的，记得难受死了</li></ul> <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191126647.png" alt="image-20210809191126647" style="zoom:50%;" /><p>to do表和时间表就像一个事情的两个维度，一个以任务为核心一个以时间为核心，推荐飞书表</p><h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><p>对大多数人来说，难度更多在 <strong>舍</strong></p><p>一般最多选两样。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191611562.png" alt="image-20210809191611562"></p><p>工程思维：便宜+快  （反完美主义，反本能的</p><p>艺术思维：好</p><h2 id="三、系统论"><a href="#三、系统论" class="headerlink" title="三、系统论"></a>三、系统论</h2><p>可以用来分析公司？</p><p>工程思想是拆分的还原论，那么这里就是整体论</p><p>观点：如果不着眼于系统，只改变局部，最终可能总被系统拉回来，比如一个闭环系统👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812003721985.png" alt="image-20210812003721985" style="zoom:33%;" /><p> 系统论相当于是呈现这些“飞轮”的机制，让我们从整体把握这个逻辑</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a><strong>系统</strong></h3><p>很多实体通过相互 <strong>联系</strong> 形成了一个有运作规律的整体</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005240164.png" alt="image-20210812005240164" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005306703.png" alt="image-20210812005306703" style="zoom:33%;" /></p><p><strong>要素</strong></p><p>+ 正信息  正能量  资产</p><p>-  负信息  负能量  负债    负信息是让世界变得更加混乱的信息，如谎言、谣言</p><p><strong>关系</strong></p><p>+ 加强  - 减弱</p><p><strong>四种循环</strong></p><p>正要素+正关系 = 良性循环</p><p>负要素+正关系 = 恶性循环</p><p>负要素+负关系 = 贤者时刻（纠错）</p><p>正要素+负关系 = 回归平庸（后两个都是均值回归）</p><p>滞后效应</p><p><strong>负循环</strong></p><p>因果分析法，<strong>找到</strong>生活中的负循环</p><p>利用杠杆解，主要矛盾</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812010338719.png" alt="image-20210812010338719" style="zoom:33%;" /><p>复杂的模型（混沌），如果能找到关键变量，便能牵一发动全身，彻底重构整个系统</p><hr><p><strong>建立仪式！</strong></p><p>所谓仪式，一旦开始，剩下的步骤就不需要控制，利用惯性执行</p><p>这可以尽可能地减少我们大脑的意识消耗。</p><hr><p>建立良性循环</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011007405.png" alt="image-20210812011007405" style="zoom:33%;" /><p>我也要建立对自己的信任！</p><p><strong>均值回归</strong>，人是难以突破社会的。。。我跳出了这个圈子，所以我认识的人还是有点少、、、</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011253657.png" alt="image-20210812011253657" style="zoom:33%;" /><p>我大概会抛弃回报公平吧，回报什么的没啥意思。</p><p>草，滞后效应，我现在熬夜会搞得以后难受。。。。哎呀好气</p><p>价值投资！也是滞后效应，这就是“确定性啊”</p><h3 id="储蓄池"><a href="#储蓄池" class="headerlink" title="储蓄池"></a><strong>储蓄池</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011807899.png" alt="image-20210812011807899" style="zoom:50%;" /><p>保护自己的缓冲地带</p><p>一个人何以扛过滞后效应，凭借的是</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011901249.png" alt="image-20210812011901249" style="zoom: 50%;" /><p>有储蓄机制的系统，也是一个有非常大适应力的系统。</p><p>这也引出好系统的三大特性：</p><ol><li>鲁棒性，可以<strong>建立模拟攻击（跳出舒适圈</strong></li><li>自组织，不依靠外部指令，按照某种内在规则自动自发地形成有序结构的一种现象(人体)</li><li>层次性，子系统，递归，封装思想（刚才的仪式</li></ol><h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>函数是这个世界上最美妙的事物之一。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812012642329.png" alt="image-20210812012642329" style="zoom: 80%;" /><p>对大部分人来说，二号区是最方便的，实用而且简单直观</p><p>教科书为了严谨才把定义搞得那么抽象。函数重要的能力是可视化</p><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><h4 id="高特纳曲线"><a href="#高特纳曲线" class="headerlink" title="高特纳曲线"></a><strong>高特纳曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813094417037.png" alt="image-20210813094417037" style="zoom: 50%;" /><p><strong>不要高估短期能发生的变化</strong></p><p><strong>不要低估长期能发生的变化</strong></p><p>这是由神经科学的人性曲线和物性曲线（逻辑斯蒂函数（sigmoid））叠加构成的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095148856.png" alt="image-20210813095148856" style="zoom:33%;" /><p>而逻辑斯蒂增长就是由指数增长+环境阻力构成的那个物种曲线hhh</p><h4 id="倒U曲线"><a href="#倒U曲线" class="headerlink" title="倒U曲线"></a><strong>倒U曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095346101.png" alt="image-20210813095346101" style="zoom:50%;" /><p>可以用在生命机能等诸多现象中</p><p>正余弦函数——波动，周期</p><p>指数函数，跨过某个拐点，就开始起飞。</p><p>对数函数，玻璃顶的存在。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101214895.png" alt="image-20210813101214895" style="zoom: 50%;" /><p>这只是个大概。</p><h2 id="五、脑科学"><a href="#五、脑科学" class="headerlink" title="五、脑科学"></a>五、脑科学</h2><p>又称神经科学，作为几乎所有研究人类行为的基础学科</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101722891.png" alt="image-20210813101722891" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101844649.png" alt="image-20210813101844649" style="zoom:50%;" /><p>爬行脑是很难主管调节的，比如褪黑素得用化学药物，是生存本能。</p><p>所谓的刻意练习，就是利用人类脑对哺乳脑的驯化过程</p><p>新皮质四大脑区：</p><p>额叶、顶叶、</p><h3 id="额叶"><a href="#额叶" class="headerlink" title="额叶"></a>额叶</h3><p>最核心区域，智慧所在</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102929814.png" alt="image-20210813102929814" style="zoom:33%;" /><p>分好几个区：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103133065.png" alt="image-20210813103133065" style="zoom:33%;" /><p>ps: 布洛卡区和威尔尼克区就是语言中枢。</p><p>前额叶皮质是非常关键的部分，掌管诸多功能，最重要的是 <strong>社交和自控、专注</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102334506.png" alt="image-20210813102334506" style="zoom:50%;" /><p>实际上这个距离就是自控和延迟满足，但如今人们的自控能力发展较慢，取而代之的是高维信息处理能力变强，所以人们自控力要在30岁左右才达到巅峰</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103419281.png" alt="image-20210813103419281" style="zoom:33%;" /><p>镜像神经元</p><p>负则模仿能力和社交能力，还有共情能力，还有音乐。</p><p>分布在前运动皮质和初级运动皮层。向下直接连着脑干、脊椎。</p><p>还分布在布洛卡区。所以语言和音乐学习的捷径就是浸泡在大环境里面模仿别人，而不是考试。。</p><p>顶叶</p><p>负则统筹和协调，空间想象力</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103936139.png" alt="image-20210813103936139" style="zoom:50%;" /><p>颞叶：语言理解，面部识别，洞察力，观察细节。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104113191.png" alt="image-20210813104113191" style="zoom:33%;" /><p>枕叶：完全用于视觉</p><hr><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>发现人类大脑里处理视觉的区域特别多！可视化yyds</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104345656.png" alt="image-20210813104345656" style="zoom:50%;" /><p>依次激发更多的脑区！！</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104325285.png" alt="image-20210813104325285" style="zoom: 33%;" /><p>单纯语言沟通效率是很低的。</p><h3 id="哺乳脑"><a href="#哺乳脑" class="headerlink" title="哺乳脑"></a>哺乳脑</h3><p>（女发达）<strong>边缘系统</strong>：长期记忆、情绪管理、<strong>嗅觉</strong>（跟这些有关，所以体香很重要）、性唤醒</p><p>（女尤其发达）<strong>扣带回区域</strong>：情感、焦虑、痛苦、自我调节、负面想象</p><p><strong>杏仁核</strong>：恐惧、愤怒、兴奋、战或逃</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104933864.png" alt="image-20210813104933864" style="zoom: 50%;" /><p>因此恐惧会抑制人类脑，再聪明也得服从本能，战或逃取决于过去的经历和基因。</p><p>可以通过训练，用经验告诉杏仁核不必恐惧，选择战而不是逃。</p><p>（商家最爱）<strong>基底神经节</strong>：操作技巧、习惯养成、奖赏系统、上瘾系统</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813105502624.png" alt="image-20210813105502624" style="zoom:33%;" /><p>这个核是消费关键。</p><h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><p>刻意选择，不断重复。</p><p>就像是不同脑区的神经元链接，多次重复刺激以后形成坚固的道路</p><p>但关键步骤要放慢速度，可能调度更多的脑区观察这个过程。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813110129493.png" alt="image-20210813110129493" style="zoom:33%;" /><p>所以贴标签是不可取的。</p><h2 id="六、复杂性科学"><a href="#六、复杂性科学" class="headerlink" title="六、复杂性科学"></a>六、复杂性科学</h2><p>还原论或还原主义（英语：Reductionism，又译化约论），是一种哲学思想，认为复杂的系统、事物、现象可以将其化解为各部分之组合来加以理解和描述。</p><p>在哲学上，还原论是一种观念，它认为某一给定实体是由更为简单或更为基础的实体所构成的集合或组合；或认为这些实体的表述可依据更为基础的实体的表述来定义。” 还原论方法是经典科学方法的内核，将高层的、复杂的对象分解为较低层的、简单的对象来处理；世界的本质在于简单性。</p><p>复杂性科学兴起于20世纪80年代的复杂性科学，是系统科学发展的新阶段，也是当代科学发展的前沿领域之一。复杂性科学的发展，不仅引发了自然科学界的变革，而且也日益渗透到哲学、人文社会科学领域。复杂性科学为什么会赢得如此盛誉，并带给科学研究如此巨大的变革呢？主要是因为复杂性科学在<strong>研究方法论上的突破和创新</strong>。在某种意义上，甚至可以说复杂性科学带来的首先是一场方法论或者思维方式的变革。</p><ol><li>它只能通过研究方法来界定，其度量标尺和框架是<strong>非还原</strong>的研究方法论</li><li>它不是一门具体的学科，而是分散在许多学科中，是学科互涉的</li><li>它力图打破传统学科之间互不来往的界限，寻找各学科之间的相互联系、相互合作的统一机制</li><li>它力图打破从<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E5%8A%9B%E5%AD%A6">牛顿力学</a>以来一直统治和主宰世界的线性理论，抛弃<a href="https://baike.baidu.com/item/%E8%BF%98%E5%8E%9F%E8%AE%BA">还原论</a>适用于所用学科的梦想</li><li>它要创立新的理论框架体系或范式，应用新的思维模式来理解自然界带给我们的问题</li></ol><p>复杂性科学是指以复杂性系统为研究对象，以超越还原论为方法论特征，以揭示和解释复杂系统运行规律为主要任务，以提高人们认识世界、探究世界和改造世界的能力为主要目的的一种“学科互涉”(inter—disciplinary)的新兴科学研究形态。</p><p><u>某学者定义：运用跨学科方法，研究不同复杂系统中的<strong>涌现</strong>行为和<strong>统一性规律</strong></u></p><p>《复杂》 入门必读</p><p>《规模》 研究增长</p><p>《系统论》  系统论入门</p><hr><h3 id="复杂系统"><a href="#复杂系统" class="headerlink" title="复杂系统"></a>复杂系统</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174046214.png" alt="image-20210815174046214" style="zoom:33%;" /><ol><li>大量个体聚集</li><li>个体间的运作相对简单，但是叠加后产生群体的复杂行为</li><li>能通过不断进化，对环境产生适应性</li></ol><p>关键词：聚集，进化，适应性，涌现</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174524772.png" alt="image-20210815174524772" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174958056.png" alt="image-20210815174958056" style="zoom:33%;" /><p>这样简单的三条原则不断循环后，就能发挥超凡的作用。</p><p>这就是单体简单-&gt;群体智慧。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815190757944.png" alt="image-20210815190757944" style="zoom:33%;" /><h3 id="聚焦"><a href="#聚焦" class="headerlink" title="*聚焦"></a>*聚焦</h3><p>四段论：</p><ol><li><p>清理念头</p><p>整理、列出思绪，保证自己没有牵挂心无旁骛</p></li><li><p>忘我聚焦</p><p>进入超高效状态持续2个小时，完成大部分任务</p></li><li><p>刻意休息</p><p>只能玩，强迫自己玩，比如半个小时</p></li><li><p>惯性工作</p><p>接着大体完成的脉络继续，由于之前的基础，可以低能耗的工作。</p></li></ol><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>这里讲的是工程学里的迭代，尤其是软件开发里的敏捷开发。</p><p>找到自己的最小内核，一层一层递归、累加、迭代，最终涌现成为传奇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192540335.png" alt="image-20210815192540335" style="zoom: 25%;" /><p>在3.0才找到拐点，我们要抱着正确的心理预期，不是每一次迭代都能升级。</p><p><strong>精益创业</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192654391.png" alt="image-20210815192654391" style="zoom:25%;" /><p><strong>适应性</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192932647.png" alt="image-20210815192932647" style="zoom:33%;" /><p>过犹不及。。彻底失败</p><h2 id="七、认知心理学"><a href="#七、认知心理学" class="headerlink" title="七、认知心理学"></a>七、认知心理学</h2><p>认知心理学（cognitive psychology），20 世纪 50 年代中期在西方兴起的一种心理学思潮和研究方向。广义指研究人类的高级心理过程，主要是认识过程，如注意、知觉、表象、记忆、创造性、问题解决、言语和思维等。狭义相当于当代的信息加工心理学。即采用信息加工观点研究认知过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨学科通识&quot;&gt;&lt;a href=&quot;#跨学科通识&quot; class=&quot;headerlink&quot; title=&quot;跨学科通识&quot;&gt;&lt;/a&gt;跨学科通识&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/cheese/play/ep69</summary>
      
    
    
    
    <category term="others" scheme="https://darren-dong.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>《最优化导论》笔记</title>
    <link href="https://darren-dong.com/2021/07/17/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>https://darren-dong.com/2021/07/17/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-17T09:28:04.000Z</published>
    <updated>2022-05-10T05:19:24.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无约束优化"><a href="#无约束优化" class="headerlink" title="无约束优化"></a>无约束优化</h1><h2 id="6、基础知识"><a href="#6、基础知识" class="headerlink" title="6、基础知识"></a>6、基础知识</h2><p>导数矩阵</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091058869.png" alt="image-20211203203532220" style="zoom:60%;" /><p>$Df(x)$是一行，$D\pmb{f}(x)$是好几行。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059786.png" alt="image-20211203203643378" style="zoom:60%;" /><ul><li><p>约束集可以表示为Ω = {x: h(x) = 0 , g(x) &lt;= 0} 其中h,g是函数向量</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210930185250441.png" alt="image-20210930185250441" style="zoom:50%;" /></li><li><p>局部最小一阶必要：对某点$x^*$ 所有可行方向$d$，上式均&gt;=0</p><p>推理：$\triangledown f(x^*) = 0$</p></li><li><p>局部最小二阶必要：f二阶可微，对x* 点处任意可行方向 d，有$d^T F(x^*)d$ &gt;=0</p><p>推论：当局部最小点x*是约束集内点时，所有方向都是可行方向。</p></li><li><p>局部最小二阶充分：f 二阶可微</p><ol><li>$\triangledown f(x^*) = 0$</li><li>$F(x^*)&gt; 0$</li></ol></li><li><p>接下来的章节中，将着重关注这类问题的迭代求解方法，这些方法具有很高的使用价值。可以避免巨大的工作量。</p></li></ul><p><code>还要这个用得很多的二次型求导</code>👇：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211002104901010.png" alt="image-20211002104901010" style="zoom:67%;" /><h2 id="7、一维搜索"><a href="#7、一维搜索" class="headerlink" title="7、一维搜索"></a>7、一维搜索</h2><ul><li>黄金分割法  （f）</li><li>斐波那契数列方法（f）</li><li>二分法（f导）连续可微</li><li>割线法（f导）</li><li>牛顿法（f导，f二阶导）连续二阶可微，还可用于求解方程。</li></ul><p>一维搜索法是多变量问题求解算法的一部分。</p><p>${1/2}^n$ 比斐波那契和黄金分割速度快，但是求导比较复杂。</p><p>黄金分割：$(\frac{3-\sqrt{5}}{2})^n$       斐波那契： $\frac{1+2\varepsilon}{F_{N+1}}$</p><p>牛顿法可以求解出方程的数值解！它能不断地迫使目标函数f的一阶导数趋向于0，<br>$$<br>x^{(k+1)} = x^{(k)}-\frac{g(x^{(k)})}{g^{‘}(x^{(k)})}\<br>其中 g(x) = f^{‘}(x)<br>$$<br>所以在某些点处若$f^{‘’}&lt;0$，可能收敛到极大点，而且初始点的比值 $g(x^{0})/g^{‘}(x^{0})$ 必须够大，否则牛顿切线法可能失效，因此初始点的选择非常重要。</p><p>以上方法各有优缺，实际中可以联合使用，还有许多改进、优化的算法，比如布伦特方法。</p><hr><p>前面的方法都需要目标极小值所在的区间，而找到区间的方法是【划界法】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107174028873.png" alt="image-20211107174028873" style="zoom: 80%;" /><p>多维优化问题的迭代求解算法通常每次迭代都要用到一维搜索过程。</p><p>但有时候计算极小点需要极大的计算量，甚至不存在。经验表明，实际应用中<u>应该将更多的计算资源配置到多维优化算法而不是追求高精度的一维搜索上。</u></p><p>因此需要设计<strong>合适的停止条件</strong>，使得一维搜索精度低时，目标函数f的值仍能得到足够下降。</p><p>比如Armijo划界法等方法，（感觉这个也tm是炼丹。。预设步长等条件。</p><h2 id="8、梯度下降"><a href="#8、梯度下降" class="headerlink" title="8、梯度下降"></a>8、梯度下降</h2><p>梯度下降方法包括很多不同的具体算法，最常用的方法为最速下降法</p><p>梯度方法便于实现，且在大部分情况下能够很好地运行。</p><p>最速下降法：</p><ul><li>相邻搜索方向正交</li><li>只要$\bigtriangledown f(x^{(k)}\neq 0 $ 那么</li></ul><p>$f(x^{(k+1)})&lt;f(x^{(k)})$ </p><p>👆 = 0说明达到局部最小点，可以作为停止规则，但是实际应用中采用数值计算很难恰好得到该结果，</p><ul><li>一种是用的规则是计算梯度的范数，若小于某个阈值则停止，</li><li>也可以计算相邻两点函数值差的绝对值，小于阈值则停止，</li><li>当然也可以用迭代点的差值，</li><li>还有相对值版本。相对值更优。相对值为了避免规则的分母过小，分母可以取 $max{1,||\pmb{x^{(k)}||} }$</li></ul><p><strong>P94的这几个👆停止规则，适用于本书第二部部分讨论的所有迭代求解方法！</strong></p><p>P97 最速下降法对二次型的公式。<br>$$<br>f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx} - \pmb{b}^T\pmb{x}\ 这个形式挺一般\<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)} - \frac{g^{(k)T}g^{(k)}}{g^{(k)T}Qg^{k}}g^{(k)}\<br>其中\  g^{(k)} = \bigtriangledown f(x^{(k)}) = Qx^{(k)} -b<br>$$</p><p>最速下降法需要归一化，不然搜索效率低。</p><hr><p>性质分析：</p><p>如果要求初始点足够靠近极小点，算法产生的迭代点序列才能够收敛到满足局部极小点一阶必要条件的点，那么算法就不是全局收敛而是局部收敛的。</p><p>算法的收敛性决定能否收敛，而评价算法多快收敛的指标是收敛率。</p><p><code>有一堆证明，暂时先不管了、、、</code>P98</p><p>反正最速下降一定收敛，定长下降有个条件。</p><p>收敛阶数的概念不难理解，【显然、任意收敛序列的收敛级数$\geq 1$】</p><p>可以证明，在最坏情况下，最速下降法的收敛阶数为1</p><h2 id="9、牛顿法"><a href="#9、牛顿法" class="headerlink" title="9、牛顿法"></a>9、牛顿法</h2><p>思路和泰勒一样，在每个迭代点处构造二次型函数，一阶导、二阶导与原函数相等。然后求出该近似函数的极小值点作为下一个迭代点。</p><p>若目标函数就是二次型函数，则与近似函数极小点一致，否则只能找出大体位置。</p><p>迭代公式：<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-\pmb{F}(\pmb{x}^{(k)})^{-1}\pmb{g}^{(k)}\<br>g^{(k)} = \triangledown f(x^{(k)})<br>$$<br>【不是确定了表达式就确定了矩阵性质，要带入值后才能确定。】</p><p>可以分两步</p><ul><li>求解$\pmb{F}(\pmb{x}^{(k)})\pmb{d}^{(k)} = -\pmb{g}^{(k)}$得到$\pmb{d}^{(k)}$这个d就是搜索方向</li><li>$\pmb{x}^{(k+1)} = \pmb{x}^{(k)}+\pmb{d}^{(k)}$</li></ul><p><strong>优势</strong>：当初始点和目标函数极小点足够接近时，收敛效果非常好</p><p><strong>缺点</strong>：F（x）不正定，或初始点离最小值太远，都可能无法收敛。还有n比较大时计算量太大</p><p>不过后续都有修正来解决。</p><hr><ul><li><p>当目标函数是二次型函数时，对任意初始点，一步就可收敛，收敛阶数为$\infty$</p></li><li><p>f 三阶连续可微，存在点$x^<em>\in R^n$且满足$\triangledown f(x^</em>) = 0$且$F(x^*)$可逆</p><p>则对所有与$x^*$足够接近的$x^{(0)}$，牛顿法至少以2的阶数收敛。【可能收敛到极大值点】</p></li></ul><p>一个修正是引入搜索方向并开展一维搜索，<code>定理给出在搜索方向上一定有一个区间是一直下降的</code></p><p>LM（Levenberg-Marquardt）修正还解决了黑塞矩阵不正定的问题。<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-(\pmb{F}(\pmb{x}^{(k)})+\mu_k\pmb{I})^{-1}\pmb{g}^{(k)}<br>$$<br>当$\mu_k$趋于无穷时，其实相当于是步长较小时梯度方法的特征。</p><p>实际应用时‘’$\mu_k$从小向大调，直到函数表现下降特征。</p><p>P116介绍了处理非线性最小二乘问题的<code>高斯牛顿法</code>，方便之处在于可忽略二阶导数项。</p><p>雅可比矩阵：就是函数的一阶导矩阵 $J(x)$<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-(\pmb{J}(\pmb{x})^T\pmb{J}(\pmb{x})+\mu_k\pmb{I})^{-1}\pmb{J}(\pmb{x})^T\pmb{f}(\pmb{x})<br>$$<br><code>注意一个思维，是把m个样本的处理（比如loss）看作m个函数，原来如此。</code>比如👆这个$f(x)$其实是一列，每行代表一个输入的$f(x_m)$</p><h2 id="10、共轭方向法"><a href="#10、共轭方向法" class="headerlink" title="10、共轭方向法"></a>10、共轭方向法</h2><p><a href="https://zhuanlan.zhihu.com/p/338838078">大佬的直观理解，和相比GD的提升</a></p><p>核心思想：相比于GD的全维度更新，共轭是解耦合，分成各个维度一次性更新一整个维度，共轭和正交差了个空间变换。</p><blockquote><p>GD每次更新一般都会改变迭代点的所有维度的值，因此，每次迭代一次后得到的迭代点就不一定是之前搜索方向上的最优点了。反观共轭方向法，共轭方向法每次只在影响一个维度的方向上搜索，就以上图为例，在更新完 <img src="https://www.zhihu.com/equation?tex=x_1" alt="[公式]"> 后，共轭方向法选择朝 <img src="https://www.zhihu.com/equation?tex=d_2" alt="[公式]"> 这个方向搜索，而 <img src="https://www.zhihu.com/equation?tex=d_2" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=d_1" alt="[公式]"> 是正交的，因此第二次搜索不会改变迭代点的第一个维度， 也就是不会对第一次搜索得到的成果造成影响。而GD算法的每一次搜索都会对上一次搜索的成果造成影响。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059148.png" alt="img" style="zoom: 50%;" /></blockquote><p>介于最速下降（低）和使用得当的牛顿法、拟牛顿法（高）中间。</p><p>从之前的例子可以看出，影响迭代搜索算法的<strong>关键因素为每次搜索的方向</strong>。</p><p><strong>优点</strong>：</p><ul><li>n维二次型问题，能在n步内得到结果</li><li>共轭梯度法不需要计算黑塞矩阵。</li><li>不需要存储 $n*n$ 的矩阵，也不需要对其求逆。</li></ul><p>共轭方向定义：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016142133692.png" style="zoom: 50%;" /><p>该方法的原理是证明对于n变量的二次型函数 $f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}\ ,x\in R^n，Q = Q^T&gt;0$来说，最好的搜索方向为Q的共轭方向。（$Q&gt;0$的意思是Q正定）。</p><hr><p>通过解方程来求解共轭向量效率太低，参考Gram-Schmidt过程可以设计一种<strong>系统化构造关于Q共轭向量</strong>的算法流程：<br>$$<br>\pmb{g}^{(k)} = \triangledown f(\pmb{x^{(k)}}=\pmb{Qx}^{(k)}-\pmb{b} \<br>\alpha_k = -\frac{\pmb{g}^{(k)T}\pmb{d}^{(k)}}{\pmb{d}^{(k)T}\pmb{Qd}^{(k)}}\<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}+\alpha_k\pmb{d}^{(k)}<br>$$<br>k 表示迭代次数。$g^{(k)}$代表在$x^{(k)}$处的梯度。</p><p>定理：目标函数为 $n$ 维二次型函数时，共轭方向法能够在 $n$步迭代后收敛到最小点，即 $x^{(n)} = x^*$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016162919706.png" alt="image-20211016162919706" style="zoom:50%;" /><p>$g^{(k+1)}正交于由d^{(0)}…d^{(k)}张成的子空间$</p><p>该引理可以证明共轭方向法一个很有意思的最优性性质。</p><p>$f(\pmb{x}^{(k+1)})$ 不仅满足👇<br>$$<br>f(\pmb{x}^{(k+1)}) = min_\alpha f(\pmb{x}^{(k)}+\alpha\pmb{d}^{(k)})\<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016163458980.png" alt="image-20211016163458980" style="zoom:50%;" /></p><p>一直保持最优。</p><p>如同逐维度扩张的子空间般，随着k增大，子空间不断扩展指导充满整个$R^n$，将 $x^*$也包含其中，因此又称扩张子空间定理。</p><hr><p>共轭方向法效率很高，但是必须给定一组 Q 共轭方向。</p><p>幸运的是存在一种方法能随迭代的进行，逐一产生Q共轭方向而无需提前指定——<code>共轭梯度法</code>，这种方法不需要预先给定共轭方向，而是随着迭代的进行不断产生共轭方向。</p><p>仍考虑 $f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}\ ,x\in R^n，Q = Q^T&gt;0$</p><p>在第$k+1$次迭代中，$d^{(k+1)}可以写为g^{(k+1)}和d^{(k)}$的线性组合，有了<a href="https://zhuanlan.zhihu.com/p/338838078">直观理解</a>就显然了。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020103111931.png" alt="image-20211020103111931" style="zoom:50%;" /><hr><h3 id="非二次型问题的共轭梯度"><a href="#非二次型问题的共轭梯度" class="headerlink" title="非二次型问题的共轭梯度"></a>非二次型问题的共轭梯度</h3><p>我们之前的算法和分析都是建立在研究的函数是二次型的假设下，这未免过于理想，要知道，深度学习中大部分loss关于前馈网络参数的函数甚至都不是凸函数，那么将我们得到的共轭梯度法进行泛化就显得很有必要了。</p><p>若将函数$f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}$<strong>视为某个目标函数泰勒展开式的二阶近似</strong>，就可以推广。</p><p>二次型中的矩阵Q，黑塞矩阵是常数矩阵，但是一般非二次型每次迭代都要重算Q，计算量太大，需要修改，消除该环节。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020110719239.png" alt="image-20211020110719239" style="zoom:50%;" /><ul><li><p>Hestenes-Stiefel</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020110952754.png" alt="image-20211020110952754" style="zoom:50%;" /></li><li><p>Polak-Ribiere</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020111024535.png" alt="image-20211020111024535" style="zoom:50%;" /></li><li><p>Fletcher-Reeves</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020111044047.png" alt="image-20211020111044047" style="zoom:50%;" /></li></ul><p>对二次型，这仨是等价的，但是对一般非线性函数，并不一致。。。。</p><p>ps：</p><p>还要选择合适的停止规则，而不是$\triangledown f(\pmb{x}^{(k+1)})=0$，还有合适的一维搜索方法，如果一维搜索方法不精确，建议用Hestenes公式来计算。。。</p><h2 id="11、拟牛顿法"><a href="#11、拟牛顿法" class="headerlink" title="11、拟牛顿法"></a>11、拟牛顿法</h2><p>牛顿法有较高实用性，且如果收敛，阶数至少为2.</p><p>但是起始点如果没选好，那么可能牛顿法根本下降不了。</p><p>牛顿法可通过每次进行一维搜索保证一定下降。但是还有计算黑塞矩阵和求解的困难。</p><p>拟牛顿法通过设计 $\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$的近似矩阵$\pmb{H}_k$来替代，以此来规避计算，只用目标函数值和梯度就能算。用来优化牛顿法的计算问题。</p><p>而只需要 $H$ 满足👇的后几行，就能与$\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$拥有类似的性质。当$\pmb{H}_k$正定时，必然下降。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211021104113854.png" alt="image-20211021104113854" style="zoom: 50%;" align = "left"/><p>而从$H^{(k)}$需要满足的方程看，该矩阵不能唯一确定。这就给了一定的发挥空间</p><p>作者给出了三种算法，这三种算法$H^{(k+1)}$均是在$H^{(k)}$的基础上增加修正项得出来的。</p><hr><ol><li>秩一修正公式</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107202703202.png" alt="image-20211107202703202" style="zoom: 50%;" /><p>研究，给定$H_k,\Delta\pmb{g}^{(k)},\Delta\pmb{x}^{(k)}$后，如何确定$\alpha$和$\pmb{z}^{(k)}$使得近似矩阵满足性质$\pmb{H}_{k+1}\Delta\pmb{g}^{(i)}=\Delta\pmb{x}^{(i)}$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107203753608.png" alt="image-20211107203753608" style="zoom: 50%;" /><p>秩一算法产生的$H_{k+1}$不一定正定，所以$d_{k+1}$不一定时下降方法。其次计算时如果分母接近0，有点难算</p><ol start="2"><li>DFP算法</li></ol><p>又称秩二算法、变尺度法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107204005135.png" alt="image-20211107204005135" style="zoom:50%;" /><p>DFP算法能保持H正定，但是处理规模较大的非二次型问题时，迭代无法开展，因为$\pmb{H}_k$接近成为奇异矩阵了。</p><ol start="3"><li>BFGS算法</li></ol><p>推导需要用到对偶、互补的概念。</p><p>除了构造$\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$的近似矩阵$\pmb{H}<em>k$，还构造$\pmb{F}(\pmb{x}^{(\pmb{k})}$的近似矩阵<br>$$<br>\pmb{B}</em>{k+1}\ 满足\<br>\Delta\pmb{g}^{(i)}=\pmb{B}_{k+1}\Delta\pmb{x}^{(i)}\ , 0\leq i\leq k<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107204938015.png" alt="image-20211107204938015" style="zoom:50%;" /></p><p>BFGS除了一定保持正定，<strong>即使一维搜索精度不高，依然比较稳健</strong>，有助于将计算资源解放出来、</p><p>效率上，很多情况下BFGS算法远超DFP算法</p><p>处理非二次型问题，拟牛顿法便不会在n步内收敛到极小点，与共轭梯度法类似，需要进行一些修正，</p><p>比如每经过几次迭代，搜索方向重置为梯度负方向。</p><h2 id="12、求解线性方程组"><a href="#12、求解线性方程组" class="headerlink" title="12、求解线性方程组"></a>12、求解线性方程组</h2><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p><strong>原最小二乘法</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107210727224.png" alt="image-20211107210727224" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107210824973.png" alt="image-20211107210824973" style="zoom:50%;" /><p>其实这就是strang讲的投影那里，感觉比这个讲的清楚。</p><hr><p><strong>递推最小二乘算法</strong></p><p>当在已有计算基础上给出新的数据时，不需要合并数据重新计算，可以对已有的计算结果进行更新，从而免去不必要的计算。<br>$$<br>\pmb{G}<em>0 = \pmb{A}<em>0^T\pmb{A}<em>0\<br>\pmb{G}</em>{k+1} = \pmb{G}</em>{k}+\pmb{A}</em>{k+1}^T\pmb{A}<em>{k+1}\<br>\pmb{x}^{(k+1)} =\pmb{x}^{(k)} +\pmb{G}</em>{k+1}^{-1}\pmb{A}<em>{k+1}^T(\pmb{b}^{(k+1)} -\pmb{A}</em>{k+1}\pmb{x}^{(x)})<br>$$<br>其中向量 $\pmb{b}^{(k+1)} -\pmb{A}_{k+1}\pmb{x}^{(x)}$ 通常成为新息，如果为0，那么其实没有进行更新。</p><p>为了简单计算$\pmb{G}_{k+1}^{-1}$，有下面这个引理。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107212218536.png" alt="image-20211107212218536" style="zoom:50%;" /><hr><h3 id="最小范数解"><a href="#最小范数解" class="headerlink" title="最小范数解"></a>最小范数解</h3><p><strong>线性方程组的最小范数解</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107212749533.png" alt="image-20211107212749533" style="zoom: 50%;" /><hr><p><strong>Kaczmarz算法</strong>【卡茨马兹】</p><p>针对上一节的最小范数解问题，虽然有解析解，但是很难算</p><p>该<strong>迭代</strong>算法能够在不直接计算$\pmb{AA}^T$逆矩阵的情况下收敛到解析解，非常实用，尤其是矩阵太大的情况。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213508375.png" alt="image-20211107213508375" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213438836.png" alt="image-20211107213438836" style="zoom:50%;" /><p>如果设定$\mu = 1$会有非常有趣的性质👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213851207.png" alt="image-20211107213851207" style="zoom:50%;" /><hr><p><strong>一般意义下线性方程组的求解</strong></p><p>本节研究在m*n矩阵A的秩为 r 时，没有逆，那就定义<strong>伪逆、广义逆</strong>，特别的，本节将讨论矩阵A的 Moore-Penrose逆。</p><p>何谓<strong>伪逆</strong>：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214616275.png" alt="image-20211107214616275" style="zoom:50%;" /><p><u>这其实也是一种通过奇异值分解计算伪逆的方式。</u></p><p>左伪逆和右伪逆，伪逆的唯一性。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214853701.png" alt="image-20211107214853701" style="zoom: 50%;" /><p>还是给出strang的图，直观理解就是把对应关系限制在行和列空间上，不考虑零空间</p><p>而幸运的是，可以证明，行空间和列空间（秩都为r ）里的向量是一一对应的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107222544879.png" alt="image-20211107222544879" style="zoom: 80%;" /><hr><p>然后补充一些线代的知识，<strong>满秩分解</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214239226.png" alt="image-20211107214239226" style="zoom:50%;" /><p>伪逆和满秩分解的关系。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107215833293.png" alt="image-20211107215833293" style="zoom:50%;" /><p>或者化简为<br>$$<br>\pmb{A}^\dagger = \pmb{C}^T(\pmb{B}^T\pmb{A}\pmb{C}^T)^{-1}\pmb{B}^T<br>$$</p><hr><p>那么$A^\dagger$在求解线性方程组时为什么重要呢？</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107221048200.png" alt="image-20211107221048200" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107221407945.png" alt="image-20211107221407945" style="zoom:50%;" /><p>别的定义方式不是重点。</p><h2 id="13、无约束优化问题和神经网络"><a href="#13、无约束优化问题和神经网络" class="headerlink" title="13、无约束优化问题和神经网络"></a>13、无约束优化问题和神经网络</h2><p>本章将前面讨论的方法应用于前馈神经网络的训练中。</p><p>神经网络的核心是神经元之间的连接权重，也称为学习参数，常用的训练方法为反向传播算法。</p><p>神经网络可视为<strong>函数逼近器</strong></p><p>神经网络的学习可以归纳为一个优化问题。利用前面的方法来设计训练过程。</p><p>多层反向传播其实确实也是归结为一个优化问题，只不过参数有点多，可以用前面的各种方法完成</p><p>吴恩达给出的是一种普通的梯度下降法。</p><h2 id="14、全局搜索算法"><a href="#14、全局搜索算法" class="headerlink" title="14、全局搜索算法"></a>14、全局搜索算法</h2><p>前面的迭代算法，往往只能收敛到局部极小点，而且还需要计算目标函数的一阶导数。</p><p>本章讨论一些全局意义上的搜索方法，这些方法也不需要对目标函数求导。因此适用面更广。</p><p>在某些情况下，这些方法产生的解，可以作为梯度、牛顿法<strong>“较好的”初始点。</strong></p><p>在本章讨论的方法中，某些方法还可用于求解组合优化问题。</p><h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><p>Nelder-Mead单纯形法</p><p>定义👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108145806398.png" alt="image-20211108145806398" style="zoom: 67%;" /><p>初始单纯性的构造方法：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108150312958.png" alt="image-20211108150312958" style="zoom:67%;" /><p>初始单纯形确定后，接下来就是一步步对其进行修改，朝着函数极小点收敛。</p><p>下面给出迭代过程中单纯形的更新规则，Amazing，先上一个二维单纯性搜索的图：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108151531733.png" alt="image-20211108151531733" style="zoom:50%;" /><hr><ul><li><p>首先选定初始的n+1个点，构成最初的单纯形。</p></li><li><p>计算n+1个点的目标函数值，按照从小到大进行排序，令 $\pmb{p}_s$位最小的点，$\pmb{p}<em>b$为最大的点。$\pmb{p}</em>{2b}$为第二大的点</p></li><li><p>计算重心$\pmb{p}_g$为除去$\pmb{p}_b$后，其他所有点的几何平均点。</p></li><li><p>开展反射操作，利用反射系数$\rho$对最差点$\pmb{p}_s$进行<strong>反射</strong> $\pmb{p}_r = \pmb{p}_g + \rho(\pmb{p}_g-\pmb{p}_r)$，就是相对重心反射。一般$\rho = 1$</p></li><li><p>判断反射是否成功</p><ul><li><p>如果$f_r &lt; f_s$说明反射方向正确，进行**延伸**$\pmb{p}_e = \pmb{p}_g + \chi(\pmb{p}_r-\pmb{p}_g)$，$\chi&gt;1$</p><ul><li>如果$f_e&lt;f_r$说明延伸成功，$\pmb{p}_e$取代$\pmb{p}_b$，取代最小点</li><li>否则$\pmb{p}_r$取代$\pmb{p}_b$</li></ul></li><li><p>如果$f_r\geq f_{2b}$说明反射个der，开展<strong>收缩</strong>操作。</p><p>如果$f_{2b}\leq f_r &lt; f_b$那么采用<u>外收缩</u> $\pmb{p}_c =\pmb{p}_g + \gamma(\pmb{p}_r - \pmb{p}_g)$，其实就是让它不要伸太长了，回来点</p><p>否则$f_r&gt;f_b$那就无药可救，采用<u>内收缩</u>，直接用$\pmb{p}_b$代替$\pmb{p}_r$，$\pmb{p}_c =\pmb{p}_g + \gamma(\pmb{p}_b - \pmb{p}_g)$。</p><ul><li>如果$f_c&lt;f_b$至少收缩成功了，用$\pmb{p}_c$替换$\pmb{p}_l$</li><li>否则开展<strong>压缩</strong>操作：除了$p_s$不变，其他各点距离$\pmb{p}_l$距离减半，$\pmb{p}_i = \pmb{p}_s + \sigma(\pmb{p}_i-\pmb{p}_s)$，$\sigma = 1/2$</li></ul></li></ul></li><li><p>然后计算新的顶点回到第二步</p></li></ul><p>（新点和旧点数值相等，新点排在右边。）</p><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>是一种随即搜索方法，也成为概率搜索方法，在优化问题的可行集$\Omega$中随机采样，逐步完成搜索。</p><p>基本假设为<u>可以从可行集$\Omega$中随机采样</u>。</p><p>随机采样：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108154621465.png" alt="image-20211108154621465" style="zoom:67%;" /><p>先来看一种简单的随机搜索算法，称为朴素随即搜索算法：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108154726543.png" alt="image-20211108154726543" style="zoom:67%;" /><p>牛啊，还有这样的下降算法。</p><p>朴素算法可能在局部极小点附近“卡住”，xs，为了解决这一问题，需要一种方法让它跳出来那片$N(x)$。</p><p>一种思路是<strong>保证邻域够大</strong>，但是邻域设置太大将导致搜索过程变慢。</p><p>另一种思路（模拟退火采用）是，设计让其能够爬出$N(x)$的算法，也就意味着<strong>算法产生的新点可能比当前点差</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108155706037.png" alt="image-20211108155706037" style="zoom:67%;" /><p>主要的进步在步骤3，有一定的概率【<strong>接受概率</strong>】选择备选点作为下一次迭代点，即使这个备选点比当前迭代点差，</p><p>接受概率要进行合理的设定，常用的为：<br>$$<br>p(k,f(\pmb{z}^{(k)}),f(\pmb{x}^{(k)})) = min{1,exp(-f(\pmb{z}^{(k)})-f(\pmb{x}^{(k)}))/T_k)}<br>$$<br>$T_K$构成一组正数序列，成为温度进度表 或 <strong>冷却进度表</strong>，该接受概率使模拟退火算法等价于Gibbs采样器</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108190854122.png" alt="image-20211108190854122" style="zoom: 80%;" /><p>需要指出的是，$f(\pmb{z}^{(k)})$和$f(\pmb{x}^{(k)}))$之间的差异越大，采用$\pmb{z}^{(k)}$作为下一个迭代点的可能’性就越小。类似地，$T_k$越小，采用$Z _{( k )}$作为下一个迭代点的可能性就越小。通常的做法是令温度$T_k$单调递减到O (表示冷却过程)。</p><p>也就是说，随着迭代次数k的增加，算法趋向于更差点的可能性越来越小。换句话说，最开始，算法在可行集内跳来跳去，以尽可能跳出局部极小点附近的区域，随着时间的推移，算法开始稳定在全局极小点附近的区域，将更多的时间投入到这一区域的搜索中。</p><blockquote><p>“退火”一词来自于冶金业，是一种能够改善金属品质的技术。</p><p>基本的操作方式为先将金属加热到一定程度，然后以可控的方式对其进行冷却。首先，当金属被加热时，其中的原子始变得活跃，脱离了原来的位置，内能增加。然后，随冷却的进行，原子逐渐变得有序，内能减少。如果冷却过程足够慢，那么可以保证最终的内能将低于开始阶段的内能，这样可以改善金属的晶体结构，并减少存在的缺陷。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108193912140.png" alt="image-20211108193912140" style="zoom:80%;" /><p>模拟退火法经常用于求解组合优化问题。</p><p>这类问题的可行集是有限的(但通常会非常大)。著名的旅行商问题就是一个组合优化问题。</p><h3 id="粒子群优化"><a href="#粒子群优化" class="headerlink" title="粒子群优化"></a>粒子群优化</h3><blockquote><p>由一位社会心理学家和工程师提出，在社交互动原理的启发下得到的。</p><p>粒子群优化算法与模拟退火算法存在一个主要区别:在一次迭代中，粒子群优化算法并不是只更新单个迭代点$\pmb{x}^k$，而是更新一群(组)迭代点，称为群。群中每个点称为一个粒子。可以将群视为一个无序的群体，其中的每个成员都在移动，意在形成聚集，但移动方向是随机的。</p><p>粒子群优化算法旨在模拟动物或昆虫的社会行为，如蜂群、鸟群和羚羊群等的形成过程。</p></blockquote><p><strong>算法的大致描述</strong>：</p><p>利用粒子群优化算法求取目标函数在$R^n$上极小点的过程。</p><p>首先，在$R^n$中随机产生一组数据点为每个点赋予一个速度构成一个速度构成一个速度向量。这些点视为粒子所在的位置，以指定的速度运动。接下来，针对每个数据点计算对应的目标函数值。基于计算结果，产生一组新的数据点，赋予新的运动速度，这可以通过对原有的数据点及其运动速度进行某些操作完成。</p><ul><li>pbest:某个粒子到目前为止经历过的最好的位置</li><li>gbest:到目前为止，每一轮的所有粒子中，出现的最小$f(x^{(k)})$</li></ul><p>根据粒子的个体最好位置和群的全局最好位置，调整各粒子的运动速度，以此实现粒子的”交互”。</p><p>在下面给出的gbest版本的粒子群优化算法中，每次迭代中，产生两个随机数，分别作为个体最好位置pbest和全局最好位置gbest的权重，以此构成pbest和gbest的一个组合值，可称为速度的随机项；再加上加权后的原有速度，可以实现对速度的更新。</p><p>因此，<u>粒子在个体最好位置和整个群的全局最好位置的共同作用下，朝着某个方向运动</u>。与前面相同，常用的停止规则为达到预先设定的迭代次数，或者目标函数达到了某个值。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173142921.png" alt="image-20211109173142921" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173155527.png" alt="image-20211109173155527" style="zoom:80%;" /><p>粒子群优化算法还有许多变种，👇是一种。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173353403.png" alt="image-20211109173353403" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173406495.png" alt="image-20211109173406495" style="zoom:80%;" /><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a><strong>遗传算法</strong></h3><p>是一种基于种群的随即搜索方法，在借鉴了遗传理论的基础上得到。</p><p>概括起来，遗传算法就是针对群迭代开展交叉和变异操作，产生新种群直到满足预定的停止条件。</p><p>PS：为了便于对遗传算法进行描述，将优化问题设定为最大化问题。</p><p><strong>基本概念</strong></p><p>首先有个约束集$\Omega$不能直接针对约束集$\Omega$中的点进行操作，而是需要将$\Omega$映射为一个字符串的集合【编码】，这些<u>字符串全部是等长</u>的，称为<u>染色体</u>。每个染色体中的元素都是从一个字符串集合中提取的，该集合称为<u>字符表</u>。{0,1}字符表得出的染色体都是二进制。</p><p>L表示染色体的长度即字符串中字符的数量。用 x 表示染色体，则f (x)表示适应度。可假设f是一个非负函数。</p><p><em>L，字符表，编码方式</em>(将$\Omega$映射为染色体) 统称为<em>表达模式</em>。选择合适的表达模式是利用遗传算法求解最优化问题的第一步。</p><p><strong>选择和进化步骤</strong></p><p>选定了表达模式，<em>初始化</em>染色体的第一代种群P(0)：通常是从染色体集合中随机抽取一定数量的染色体。</p><p><em>开展交叉和变异操作</em>：在第k次迭代中，计算种群P(k)中<u>每个个体$x^{(k)}$对应的适应度$f(x^{(k)})$</u>。</p><p><em>选择步骤</em>：</p><p>用选择操作构造一个新的种群$M(k)$，使其个体的数量与$P(k)$相等。种群中个体的数量称为种群容量，用$N$表示。$M(k)$称为<u>配对池</u>，是在$P(k)$的基础上进行随机处理后得到的</p><ul><li>轮盘赌模式：</li></ul><p>$M(k)$中每个个体$m ^{( k )}$以概率<br>$$<br>\frac{f(x^{(k)})}{F(k)}\ 其中F(k) = \sum f(\pmb{x}_i^{(k)}),对整个P(k)进行求和<br>$$<br>等于$P(k)$中的$\pmb{x}^{(k)}$，也就是说，<u>染色体选人配对池的概率与其适应度成正比</u>【精髓】</p><ul><li>锦标赛模式</li></ul><p>从P(k)中随机选定两个染色体，比较它们的适应度，将适应度大的放人配对池M(k)。持续开展类似操作，直到配对池M(k)中的染色体达到N个。</p><p><em>进化步骤</em>：</p><p>开展交叉和变异操作。从配对池中随机抽取一对染色体，称为父代，通过开展交叉操作，产生一对新染色体称为子代。</p><p>交叉操作指的是<u>两个父代字符串相互交换一段子字符串</u>。</p><p><code>父代染色体的选择</code></p><p>某个染色体被抽中用作交叉的概率为$p_c$。相互独立。</p><p>如果从配对池中随机抽取两个染色体作为父代，假定配对池中有N个染色体，可令$p_c=2/N$。类似地，如果从配对池中随机抽取2k个染色体，构成k组父代染色体(k &lt;N/2)，可令$p_c=2k/N$。在这两种情况下，<u>父代的数量是固定的</u>，概率$p_c$取决于父代的数量。</p><p>还有一种选择父代染色体的方式，即给定概率$p_c$，确定一个随机数作为父代的数量，以此选出需要进行交叉的父代，但需要保证<u>父代数量的均值应该为$p_cN/2$</u></p><p><code>开展交叉操作</code></p><p>有许多种不同类型的交叉操作。</p><p>最简单的交叉操作为单点交叉，在这种交叉方式下，按照<u>均匀分布</u>的原则，首先在1到L-1之间抽取一个<u>随机整数，称为</u><u>交叉点</u>，L表示染色体的长度。然后对父代的两个染色体交叉点右侧的字符串片段进行交换，即完成了交叉操作。</p><p>交叉操作还可以在多个交叉点上同时进行。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059844.png" alt="image-20211203140541937" style="zoom: 50%;" /><p>完成交叉操作之后，利用子代染色体替代配对池中对应的父代染色体。这样，就实现了对配对池的修改，并使其保持了原来的容量。</p><p><code>变异操作</code></p><p>从配对池中逐一抽取染色体，以变异概率Pm随机改变其中的字符。二进制编码时，字符的改变指的是求染色体对应位的补，即以概率$P_m$将0修改为1，或将1修改为0。如果符表中包括两个以上的字符，那么从字符表中<u>随机抽取一个其他字符</u>来替换该字符。</p><p>通常情况下，变异概率$P_m$比较小(如0.01，因此，只有<u>很少的染色体</u>会经历变异操作，在这些变异了的染色体中，也是只有<u>很少的字符</u>被改变。这意味着相对于交叉操作，变异操作在遗传算法中起到的作用比较小。</p><p><code>步骤概括</code></p><p>1.令k =0，产生一个初始种群P (0)。</p><p>2 .评估$P_(k)$即计算$P_(k)$中各个体的适应度。</p><p>3 .如果满足停止规则，就停止迭代。</p><p>4 .从$P(k)$中选择$M(k)$。</p><p>5 .进化$M(k)$，构成新种群$P(k+1)$。</p><p>6 .令k = k + 1，回到第2步。</p><p>持续追踪当前为止最好的染色体，即适应度最高的染色体。在一次迭代后，当前为止最好的染色体作为最优解的备选。实际上，甚至可以将其复制到新一代种群中。这是精英主义者的做法，这种<em>精英主义的策略</em>容易导致种群被”超级染色体”主导。但是，实际应用经验表，<u>精英主义的策略很多时候可以提高算法的性能。</u></p><p>遗传算法有很多种<em>不同的停止规则</em>。<br>一种比较简单的停止规则为指定最大的迭代次数;<br>另外一种停止规则为相邻两次迭代中，当前为止最好的染色体对应的造应度不再显著变化。</p><p>与前面几章中讨论的方法相比，遗传算法存在以下<em>四个方面的差异</em>。<br>第一，不需要计算目标函数的导数(本章中讨论的其他方法也有这个性质)。<br>第二，在每次迭代中，采用的是随机操作(与其他随机搜索方法是一致的)。<br>第三，每次迭代是利用一组点而不是一个点开展搜索(与粒子群优化算法相似)。<br>第四，对约束集进行编码，而不是直接在约束集本身上开展搜索。</p><hr><p><strong>性质分析</strong></p><p>模仿 “适者生存”，为了定量化深入描述遗传算法，需要先定义一些术语。</p><p>模式：就是指一组染色体，同一位置上的字符是相同的，扩展字符表（原字符表+*）上的字符串来表示模式。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059845.png" alt="image-20211203160654460" style="zoom:50%;" /><p>如果一个模式具有$r$个$*$，那么它包括$2^r$个染色体。此外长度为L的染色体对应着$2^L$个模式。</p><p>$H$表示某个给定的模式</p><p>$e(H,k)$表示$P(k)$中能够匹配$H$的染色体数量</p><p>$m(H,k)$表示$M(k)$中能够匹配$H$的染色体数量</p><p>$f(H,k)$表示$P(k)$中能够匹配$H$的染色体的平均适应度。$f(H,k) = \frac{f(x_1)+…+f(x_{e(H,k)})}{e(H,k)}$</p><p>$o(xxx)$ 阶次，等于L减去模式S中字符$*$的数量，就是确定的字符数，模式S的长度为$S(L)$</p><p>N表示种群中染色体的数量，<u>$F(k)$表示$P(k)$中所有染色体的适应度值和。</u>$\overline{F}(k) = \frac{F(k)}{N} = \frac{1}{N}\sum f(\pmb{x}_i^{(k)})$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059846.png" alt="image-20211203163022004" style="zoom:40%;" /><p>引理14.1从定量的角度说明，如果模式$H$中染色体的平均适应度要超过种群的平均适应度，那么配对池$μ(k)$中能够匹配 H 的<em>染色体数量</em> 的期望值大于种群$P(k)$中匹配 H 的染色体数量的期望值。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059847.png" alt="image-20211203170540710" style="zoom:43%;" /><p>同样，对于$M(k)$中满足模式H的染色体，没有被选中进行交叉操作，或被选中交叉后产生的子代中至少一个有染色体属于H的概率下届为1-上式</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059848.png" alt="image-20211203171959815" style="zoom:40%;" /><p>最终得到定理14.1</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059849.png" alt="image-20211203172205148" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059850.png" alt="image-20211203173927159" style="zoom: 40%;" /><p>遗传算法问题特别适合于求解组合优化问题（因为需要编码），也就是约束集$\Omega$不是$R^n$而是离散的。</p><hr><p><strong>实数编码</strong></p><p>但是二进制字符串编码有一些问题。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059851.png" alt="image-20211203195926941" style="zoom: 67%;" /><p>遗传算法最好能够直接针对原始的优化问题进行求解操作。希望能够设计一种遗传算法，能够直接在$R^n$上操作。这种算法的步骤应该与二进制编码方式下的算法<u>步骤相同</u>，只是种群中的元素是约束集$\Omega$中的点，而不是二进制字符串。为此，需要定义合适的交叉和变异操作。</p><p><em>交叉操作</em>存在多种不同的处理方式，比如①求平均值 ②或$z_1 = (x+y)/2+\omega_1$，$z_2 = (x+y)/2+\omega_2$，其中$\omega1$和$\omega2$是两个均值为0的随机变量，y最后$z_1$和$z_2$落在$\Omega$外，要通过投影等方式拉回来；③构造x 和 y的随机凸组合，产生一个随机数$\alpha \in (0,1)$，然后计算$z_1 = \alpha x+(1-\alpha)y$和$z_2 = \alpha y+(1-\alpha)x$作为子代染色体。④对第三种方式产生的子集稍加干扰，如同②对①一般。</p><p><em>变异操作</em>，简单的方式是在染色体上增加一个随机向量，$x^{‘} =x+\omega$，也叫实数蠕变，同样得保证变异后的染色体位于约束集。也可以产生$\alpha \in (0,1)$，$x^{‘} = \alpha x+(1-\alpha)\omega$，这种方式，当约束集为凸集时，变异后的染色体一定位于约束集。</p><h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><h2 id="15、线性规划概述"><a href="#15、线性规划概述" class="headerlink" title="15、线性规划概述"></a>15、线性规划概述</h2><p>一般基本可行解的数量相当庞大，穷举法自讨苦吃。</p><p>1947年<code>单纯形法</code>——高效简洁，但最差情况有指数复杂度。</p><p>1984Karmarkar提出多项式复杂度的方法。此后出现了一些非单纯形法，统称<code>内点法</code></p><hr><p><code>P218用凸多面体揭示了几何意义——找到正确的支撑超平面</code></p><p>标准模型为：<br>$$<br>minimize\ \pmb{c}^T\pmb{x}\<br>subject\ to\ \pmb{Ax}=\pmb{b}\<br>\pmb{x}\geq\pmb{0}<br>$$<br>其他变体（比如Ax&gt;=b，maximize cTx）都可以转换为标准形式。</p><p>而且线性规划问题的定理和求解方法大部分是针对标准型得到的。通过引入<strong>剩余变量\松弛变量$y$<strong>可以将任何形式的线性规划问题转变为标准型<code>P219</code><br>$$<br>\boldsymbol{Ax}\pm\boldsymbol{I_my} =[\boldsymbol{A},\boldsymbol{I}_m]\begin{bmatrix}x \y \\end{bmatrix} = \boldsymbol{b}\x\geq0\y\geq0<br>$$<br>代数意义上的等价是显然的，而几何意义可以</strong>用高维向低维的投影解释</strong>。</p><hr><p>此后的讨论都针对标准型：</p><ul><li>基本解：通过重组A解出的基本的一组基<code>P224</code> </li><li>可行解：满足限定条件的，【其实就是基本解加上零空间的基的组合那个。。】</li><li>最优解：能够最大、最小化目标且满足限定条件的。</li></ul><p>可行解和基本解不是包含关系，满足两者就叫基本可行解。基本解的某些基变量为零成为<strong>退化</strong></p><p>基本解的求法很有意思。。。直接把A重组，列空间放前面，左零空间不要了。</p><p>基本解的个数最多$\begin{pmatrix}n\m\end{pmatrix}$个，选择一组无关的向量，对应一个可行解。</p><p>:star: 线性规划基本定理：</p><ul><li>如果存在可行解，那么存在基本可行解</li><li>如果存在最优可行解，那么存在最优基本可行解</li></ul><p>这让几乎$\infin$的可行解转换为在有限数量的基本可行解上进行搜索。但是还是很大，因此需要一种更加有效的方法来求解线性规划问题——》几何含义——》单纯形法</p><p>满足👉$\pmb{Ax}=\pmb{b},\pmb{x}\geq\pmb{0}$的点集可证明一定为凸集。</p><p>极点不在集合中其他两点的连线上。可以证明：<code>满足👆的基本可行解就是极点！</code></p><p>因此，求解线性规划问题时，只需要检查约束集的极点即可。其实这一点早就在多胞形那里体现了，最终答案要么在点上，要么在支撑超平面上，而这都可以通过检查极点找到。</p><h2 id="16、单纯形法"><a href="#16、单纯形法" class="headerlink" title="16、单纯形法"></a>16、单纯形法</h2><p>从某个极点转移到另一个极点的操作方式的精细化描述和处理。</p><p><code>P238</code>枢轴变换提供了对$Ax = b$的新解释。考虑到mxn矩阵，秩为m的情况<br>$$<br>[\pmb{I}<em>m,\pmb{Y}</em>{m,n-m}]\pmb{x}= \pmb{y_0}<br>$$<br>这种形式成为【典式】</p><p>一般情况下，基变量不一定是前m个，这只是便于表示而已。</p><p>对应的基本解为$\pmb{x}=\begin{bmatrix}\pmb{y}_0\\pmb{0}\end{bmatrix}$</p><p><strong>增广矩阵标准型</strong>，如下<br>$$<br>[\pmb{I}<em>m,\pmb{Y}</em>{m,n-m},\pmb{y_0}]<br>$$<br><strong>此时该标准型的每一列元素都是关于基${a_1,a_2,…a_m}$的坐标。</strong></p><p>如果用非基变量$a_q(q&gt;m)$代替$a_P(1\leq p \leq m)$，首先得有$y_{pq}\neq 0$才能保持基继续线性无关。则结果👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211006161841012.png" alt="image-20211006161841012" style="zoom: 50%;" /><p>则可以推导出新的增广矩阵规范型，称为关于元素$(p,q)$的枢轴变换。</p><hr><p><u>单纯形法的思想就是从某基本可行解变换到另一个基本可行解，直到找到最优基本可行解为止。</u></p><p>按照上文的思路，用一个非基向量代替某个基向量，求解新基下的增广矩阵规范型。</p><p>增广矩阵规范型的最后一列是基本解中的基变量，$x_i = y_{i0},1\leq i\leq m$</p><p>但是基本解不一定是可行解，因为可能为负，在单纯形法中希望能变换到另一个基本可行解而不是基本解。本节将讨论这个问题。</p><p>三个问题：</p><ul><li>寻找被替换的$a_p$的方法，以及异常情况的解释</li><li>如何选定最初的基向量</li><li>如何判断基本可行解是否为最优解。</li></ul><p>判断基本可行解巧妙地通过化简比较函数值z表达式，引入$r_i=(0\ while\ [1,m],\ (c_i-z_i)\ while (m,n])$当且仅当$r_i$全都非负时为最优解。</p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p><code>P244</code>例题给出了单纯形法的求解！而且这些推论可拓展到包含退化基本可行解的情况。</p><p>注意的点：选择$r_j$中最小的值对应的列向量$a_j$作为进基向量。</p><p>选离基时，$p = arg\ min{y_{i0}/y_{ij}:y_{ij}&gt;0}$ <strong>要注意这里的 $i$ 是只看原来的基！！！</strong></p><p>$z_i = \pmb{c}^t\pmb{x_i}$ ，$r_i=c_i-z_i$ 这里的 $ i $ 针对的是<strong>非基</strong>。</p><p>:star: 步骤:</p><ol><li><p>根据初始基本可行解构造增广矩阵规范型。</p></li><li><p>计算非基变量的检验数，如果均$\geq 0$就找到最大基</p></li><li><p>否则选择最小的 $r_q$ 作为新入基 ，可用 $r^T_D = c^T_D-c_B^TB^{-1} D$直接算出所有的。</p></li><li><p>如果不存在$y_{iq}&gt;0$ 则停止运算，问题有无界解。否则令$p = arg\ min_i{y_{i0}/y_{iq}:y_{iq}&gt;0}$【只看原来的基，不看非基】，如果求解出多个满足条件的下标 $i$ 按约定选最小的。</p></li><li><p>以元素（p，q）进行枢轴转换，更新增广矩阵规范型<br>$$<br>y^{‘}<em>{ij} = y</em>{ij} - \frac{y_{pj}}{y_{pq}}y_{iq}\ ,i\neq p\<br>y^{‘}<em>{pj} = \frac{y</em>{pj}}{y_{pq}}<br>$$</p></li><li><p>转到步骤2</p></li></ol><p>单纯形表为单纯形法提供了一种便捷的实现方式，在更新单纯形表的过程中，可以同时得到基变量和检验数，甚至右下角还有（取负的）目标函数值。</p><p><code>P247</code> 给出了矩阵形式的求法，非常666，当最后一行除了最后一个元素都非负的时候就出结果了，而且最后一个元素就是结果取负，而 $x_i$ 的取值就在它上面。</p><hr><h3 id="二阶段单纯形法"><a href="#二阶段单纯形法" class="headerlink" title="二阶段单纯形法"></a>二阶段单纯形法</h3><p>初始基本可行解并不是显而易见的。</p><p>为了利用单纯形法求解一般形式的线性规划问题，需要设计一种<strong>系统化</strong>的方法来寻找初始基本可解。</p><p>简单的证明表示，若原问题存在基本可行解，等价于人工问题存在一个使目标函数值为0的最优解。</p><p>而且人工问题有个显然的初始基本可行解$\begin{bmatrix}\pmb{0}\\pmb{b}\end{bmatrix}$</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211006190811386.png" alt="image-20211006190811386"></p><p>因此多出了个求解初始基本可行解的新阶段。该阶段x作为参数而非变量。</p><p>从第一阶段到第二阶段只需要删除与人工变量有关的列向量，把价值系数还原就好了。</p><p>补充人工变量需要刚好凑足一组可行解$\begin{bmatrix}\pmb{0}\\pmb{b}\end{bmatrix}$ ，和原有的 $e_i$ 加起来能够凑足m个，才能满足条件。</p><hr><p>如果m远远小于n，很多列从来没成为过基向量，那么进行更新枢轴变换其实是无用的。</p><p>修正单纯形法能够避免这些无用的计算，降低了求解最优解的计算器。</p><p>原理是可以无视A = B,D中的D，从里面挑出需要的，操作得出下一个单纯形表后再扔掉。</p><p>:star2: 步骤：</p><ol><li><p>针对初始基本可行解构造修正的单纯形表$[B^{-1},y_0]$，一开始B-1应该是一个E</p></li><li><p>计算当前的检验数 $r^T_D = c^T_D-c_B^TB^{-1} D$ 这里建议<strong>先算</strong> $c^TB^{-1}$ 再与D计算，大大省了计算量。</p><p>这里的B-1其实就是每次你看到的 $y_0$前面那个矩阵。</p></li><li><p>如果所有 $r_j$都大于0，则找到最优解，否则挑选最小的$r_q&lt;0$，计算<br>$$<br>y_q = B^{-1}a_q<br>$$</p></li><li><p>如果不存在$y_{iq}&gt;0$ 则停止运算，问题有无界解。否则令$p = arg\ min{y_{i0}/y_{ij}:y_{ij}&gt;0}$【只看原来的基，不看非基】，如果求解出多个满足条件的下标 $i$ 按约定选最小的。</p><p>这里很好算，只要用倒数第二行【y_0】/新增的最后一行【y_q】就能比较出来。</p></li><li><p>构造增广修正单纯形表 $[B^{-1},y_0,y_q]$，以最后一列的第p个元素开展枢轴变换，得到m+1列作为新表。</p></li><li><p>返回步骤2</p></li></ol><h2 id="17、对-偶"><a href="#17、对-偶" class="headerlink" title="17、对 偶"></a>17、对 偶</h2><p>对偶问题的最优解可以由原问题的最优解得到，vice versu。</p><p>而在某些情况下，利用对偶理论求解线性规划问题更为简单，而且有助于深入了解待求解问题的本质。</p><p>在对偶理论的启发下，单纯形法——&gt;对偶单纯形法，改善了性能。</p><p>涌现出了一些非单纯形法。【第十八章】</p><p><strong>对称形式和非对称形式</strong>的对偶关系：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007113216063.png" alt="image-20211007113216063"  /></p><p>这两种形式：对偶的对偶是原问题<code>所以这个表是可以双向看的，但是注意列向量还是行向量，最大值还是最小值。。。</code>。先用前面章节的方法转换成<u>“原方法”的标准形式</u>，再利用对偶关系将其转换为对偶问题。记住b、c互换，x、λ互换。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007122511694.png" alt="image-20211007122511694">————&gt;<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007122520805.png" alt="image-20211007122520805"></p><p><code>P261底有个食谱和药店的对偶问题，有一点nb</code>，求解对偶问题的时候注意<strong>有转置</strong>。。烦死了</p><hr><p>对偶问题的性质：</p><p><strong>弱对偶引理</strong></p><p>假设 $x$ 和 $\lambda$ 分别是线性规划的原问题和对偶问题的<strong>可行解</strong>，则$c^Tx \geq \lambda^T b$,</p><p>（对 对称或非对称都成立。）<code>这都是在满足标准形式👆的基础上讨论的</code></p><p>这说明对偶问题的目标函数值不大于原问题的目标函数值。”极大值&lt;极小值”，当一个问题的目标函数值是无界的，里一个问题就没有可行解。比如极小化问题的极小值为$-\infin$，自然引出定理👇</p><p><code>定理1：如果原问题和对偶问题的可行解使得两个问题的目标函数值都相同，那么相应的可行解一定是各自问题的最优解</code></p><p><strong>对偶定理</strong></p><p>如果原问题（对称或非对称）有最优解，那么其对偶问题也有最优解，且目标函数最优值相同。或者说只要出现了👇这个形式，那么就找到了最优解。</p><p>并且有以下结论：<br>$$<br>\pmb{\lambda}^T\pmb{b} = \pmb{c}_B^T\pmb{B}^{-1}\pmb{b} = \pmb{c}_B^T\pmb{x}_B<br>$$<br>可以用$\pmb{\lambda}^T\pmb{b} = \pmb{c}_B^T$来计算，特别地，如果 rand D = m 有👇</p><p>当我们采用单纯形法求解原问题，得到最终单纯形表后，可依此计算对偶问题的最优解。<br>$$<br>\pmb{\lambda}^T\pmb{D} = \pmb{c}^T_D - \pmb{r}_D^T<br>$$<br>当rand D &lt; m时，<br>$$<br>\pmb{\lambda}^T\pmb{A} = \pmb{c}^T - \pmb{r}^T \<br>while\ \pmb{r}^T = [\pmb{0},\pmb{r}^T_D]<br>$$<br>:star: 三种情况：</p><ul><li>若其中一个问题有最优解，另一个问题也有最优解，且最有可行解值相同</li><li>若其中一个问题的目标函数无界，则另一个问题不存在可行解。</li><li>若其中一个问题没有可行解，另一个问题不存在最优解，但可能有可行解也可能没有。</li></ul><p><strong>互补松弛条件</strong><code>P269</code></p><p>$x$ 和 $\lambda$ 分别是原问题和对偶问题的可行解，则它们分别是各自问题的最优解的充分必要条件是：</p><ul><li>$(\pmb{c}^T - \pmb{\lambda}^T\pmb{A})\pmb{x} = 0$ </li><li>$\pmb{\lambda}(\pmb{Ax - b})=0$</li></ul><p>这俩式子是等价的，看你有的是c还是b</p><h1 id="约束、非线性"><a href="#约束、非线性" class="headerlink" title="约束、非线性"></a>约束、非线性</h1><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007150352909.png" alt="image-20211007150352909"></p><h2 id="20、仅含等式约束"><a href="#20、仅含等式约束" class="headerlink" title="20、仅含等式约束"></a>20、仅含等式约束</h2><p>线性规划是这类问题的一个特例。<br>$$<br>minimize\   f(\pmb{x}) \<br>subject\ to\ \pmb{Ax=b}\<br>\pmb{x}\geq0<br>$$<br>对于满足等式约束的$x^*$，若 $\triangledown h_1(x^*),\cdot\cdot\cdot,\triangledown h_m(x^*)$ 线性无关，则称 $x^*$为该约束的一个正则点。</p><p>显然，当 $rand\ D\pmb{h(x^*)} = m$ 时，$x^*$为正则点。$D\pmb{h(x^*)} $的每行，是梯度倒数的转置$\triangledown h_i(x)^T$</p><p>$S = {\pmb{x} \in R^n : \pmb{h(x) = 0}}$ S是$R^n$空间中的一个<strong>曲面</strong>，这就是高维曲面的一般方程吧。</p><p>若S上的<u>所有点都是正则点</u>，则S的维数是 $n-m$。</p><hr><p>曲面上曲线的定义：<code>理论来自P36多面体</code></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007155733411.png" alt="image-20211007155733411" style="zoom: 67%;" /><p>顺便定义一下可微和二次可微</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007155906762.png" alt="image-20211007155906762" style="zoom:67%;" /><p>​    $\pmb{h}\in C^m$ 意思是函数向量h，m阶可微</p><p>则曲线S中$x^*$处<strong>切线空间</strong>定义为：$T(\pmb{x^*}) = {\pmb{y:Dh(x^*)y = 0}}$，其实就是矩阵$\pmb{Dh(x^*)}$的零空间，</p><p>一般描述为二维切平面，便于直观理解。</p><p>$TP(x^*)=x^*+T(x^*)$因为子空间是在原点处的，平移就行。</p><p><code>当某个点为正则点时，该点处的切线空间就是该点所有切向量的集合。</code></p><p><strong>法线空间</strong>定义为$N(\pmb{x^*})={\pmb{x}\in R^n:\pmb{Dh(x^*)^Tz},z\in R^n}$，其实就是用z把$Dh(x^*)^T$的行线性组合了。</p><p>算是一种行空间的高级表示方法，实际上就是值域。</p><p>$NP(x^*)=x^*+N(x^*)$描述更为方便。</p><p>显然行空间和零空间互为正交补，即 $N(x)^{\bot} = T(x)$，可以用这俩对$R^n$进行直和分解。</p><hr><p><strong>拉格朗日条件（一阶必要条件）</strong></p><p>有约束极值问题的一阶必要条件，著名的拉格朗日定理。</p><p>法线空间和切线空间正交 等价于 $\triangledown h(\pmb{x})$与 $h(\pmb{x})$水平集 正交。</p><p>定理：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007195010904.png" alt="image-20211007195010904"><br>$$<br>Df(\pmb{x^*})+\pmb{\lambda^{<em>T}}D\pmb{h}\pmb{(x^</em>)}=\pmb{0}^T<br>$$<br>如果$x^*$是极值点，那么目标函数f在该点处的梯度可以表示为关于约束函数在该点处梯度的线性组合。</p><p>更紧凑的形式是$\triangledown f(x^*) \in N(x^*)$，$\pmb{\lambda^*}$为拉格朗日乘子向量。</p><p>:star:拉格朗日的精髓：</p><p><code>正则性</code>是拉格朗日的必需假设，为了便于描述引入拉格朗日函数 $l(\pmb{x,\lambda}  )\triangleq f(\pmb{x})+\pmb{\lambda}^T\pmb{h}(\pmb{x})$</p><p>通过求解👇可找出<u>可能的极值点</u>。这是<strong>必要而非充分条件</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008103355619.png" alt="image-20211008103355619" style="zoom:50%;" /><p>其中：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008103933015.png" alt="image-20211008103933015" style="zoom: 50%;" /><hr><p>但仅仅求出候选解不够，我们需要更强的条件。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059852.png" alt="image-20211203210800835" style="zoom:60%;" /><p><strong>二阶必要条件</strong><br>$$<br>\pmb{L}(\pmb{x,\lambda}) = \pmb{F}(\pmb{x})+[\pmb{\lambda H}(\pmb{x})]\<br>[\pmb{\lambda H}(\pmb{x})] = \lambda_1\pmb{H}_1(\pmb{x})+…+\lambda_m\pmb{H}_m(\pmb{x})<br>$$<br>对于满足一阶必要条件的正则点、局部极小点 $x^*$ ：</p><ol><li>存在$\lambda^<em>\in R^m$使得$Df(\pmb{x^</em>})+\pmb{\lambda^{<em>T}}D\pmb{h}\pmb{(x^</em>)}=\pmb{0}^T$</li><li>对于所有 $y \in T(\pmb{x^*})$ (切线空间)，有 $y^TL(x^*,\lambda^*)y \geq 0 $ 【区别于无约束，不是在整个 $R^n$上成立】</li></ol><p><strong>二阶充分条件</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008110258482.png" alt="image-20211008110258482" style="zoom: 33%;" /><p>这里是正定而不是半正定，若是负定，就是严格局部极大值点。</p><h2 id="21、含不等式约束的优化问题"><a href="#21、含不等式约束的优化问题" class="headerlink" title="21、含不等式约束的优化问题"></a>21、含不等式约束的优化问题</h2><p>$$<br>minimize\ f(\pmb{x})\<br>subject\ to\ h_i(\pmb{x}) = \pmb{0},\ i=1,…,m\<br>g_j(\pmb{x})\leq\pmb{0},\ j = 1,…,p\<br>$$</p><p>$f:R^n \rightarrow R\ ，\pmb{h}:R^n \rightarrow R^m\ ，m\leq n\ , \pmb{g}:R^n \rightarrow R^p$</p><p>对于不等式约束 $g_j(\pmb{x})\leq0$，在$x^*$处可分成起作用约束$g(x^*)=0$和不起作用约束$g(x^*)&lt;0$。等式约束视为总起作用。</p><p>修改了正则点的定义，如果正好处于起作用约束的 $\pmb{g}(x)$上，还得加上所有的$\triangledown h_i(x^*),$和起作用的$\triangledown g_j(x^*)$线性无关。其中切线空间和法线空间的修改完全类似。</p><p><strong>Karush-Kuhn-Tucker条件（KKT条件）（一阶必要条件）</strong>:</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010183126851.png" alt="image-20211010183126851" style="zoom:67%;" /><p>PS：有时候也称 库恩-塔克（KT）条件。</p><p><u>由第三个条件推得，不起作用约束对应的KKT乘子 $\mu_j^* = 0$，其他的乘子则是非负的</u></p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010200400492.png" alt="image-20211010200400492" style="zoom:67%;" /><p>还有很多其他的形式，抓住<strong>本质</strong>：</p><p>类似泰勒的拟合思想，通过一些约束得到拟合函数，然后它们有部分相同的性质，便于研究。$g(x)$这是用线性组合确定范围，$h(x)$则用函数那一点的梯度和$f(x)$一样来约束$f(x)$。</p><p>:star:👇</p><p>个人总结：g(x)小于或大于0，并不受f(x)影响，这是不同的函数，它规定了约束自己的哪一边，然后就能判断$\triangledown g(x)$的方向是指向围成的区域内还是外，然后再用$\triangledown g(x)$把$\triangledown f(x)$表达出来，就可以判断$\triangledown f(x)$ 是朝区域内还是朝区域外。</p><p>【<strong>比如条件为$g(x)\geq 0$，那么$f(x)$的方向如果表示为$\triangledown g(x)_i$的正的线性组合，那就是朝区域内，就是极小值。</strong>】</p><p>规律为：<u>【符号 * $\mu$ * $g_i(x)$】的符号为正，是极小；反之为极大。</u></p><p>注意这是必要条件，只能找出潜在的。</p><hr><p><strong>二阶必要</strong></p><p>二阶的定义如下，其实和等式约束一样，知识多了个$\mu G(x)$，其中$G_k(x)$是$g_k$在$x$处的黑塞矩阵。<br>$$<br>\pmb{L}(\pmb{x,\lambda}) = \pmb{F}(\pmb{x})+[\pmb{\lambda H}(\pmb{x})]+[\pmb{\mu G}(\pmb{x})]\<br>[\pmb{\lambda H}(\pmb{x})] = \lambda_1\pmb{H}_1(\pmb{x})+…+\lambda_m\pmb{H}_m(\pmb{x})\<br>[\pmb{\mu G}(\pmb{x})] =\mu_1 \pmb{G}_1(\pmb{x})+…+\mu_p \pmb{G}_p(\pmb{x})<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010202546145.png" alt="image-20211010202546145" style="zoom:67%;" /></p><p>可以说和仅含等式约束十分接近了。</p><p><strong>二阶充分</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010202659361.png" alt="image-20211010202659361" style="zoom:67%;" /><p>ps：👆那个子集关系是因为约束条件少了，可表示的范围就大啦！</p><p>上面那一坨其实是说，每出现一个 $\mu_i(&gt;0)$，就多出一个限制条件，而原先是满条件。</p><p>类似的有，如果$\mu ^* \leq 0$ 和 $L(x^*,\lambda^*)$在范围上负定，则是严格局部极大点。</p><h2 id="22、凸优化问题"><a href="#22、凸优化问题" class="headerlink" title="22、凸优化问题"></a>22、凸优化问题</h2><h3 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h3><p>总体而言，前面两章讨论的关于非线性优化问题的求解还是存在一定困难的，或是来自于目标函数，或是来自约束条件，甚至两者兼有，这会导致求解上的困难，但是凸函数这不会带来这些问题。</p><p>实值函数上图（epigraph）:</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010213323478.png" alt="image-20211010213323478" style="zoom:67%;" /><p><strong>定义</strong>：如果函数$f:\rightarrow R，\Omega \subset R^n $的上图是凸集，那么 $f $ 是集合 $\Omega$ 上的凸函数。</p><p><strong>定理</strong>：如果函数$f:\rightarrow R，\Omega \subset R^n $是集合 $\Omega$ 上的凸函数。那么 $\Omega$ 是凸集。</p> <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010215337043.png" alt="image-20211010215337043" style="zoom:67%;" /><p>（因为本书一开始说了，以极小值问题为主，极大值可以转换成极小值，所以是默认都用下凸函数）</p><p><strong>定理</strong>：假设函数 $f,f_1,f_2$都是凸函数，那么对 $\forall a \geq0$，函数 $af、f_1+f_2$也是凸函数。【线性组合】</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010220430622.png" alt="image-20211010220430622" style="zoom:67%;" /><p>当$-f$是（严格）凸函数时，$f$是（严格）凹函数</p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010225954694.png" alt="image-20211010225954694" style="zoom:67%;" /><p>内点：如果P存在某个邻域 $\sub$ D 则称点P为内点。</p><p>开集：若D中的每一个点都是D的内点则称D为开集，显然不包括边界。</p><p><strong>凸函数的判定：</strong></p><p><em>一阶可微</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010230008947.png" alt="image-20211010230008947" style="zoom: 67%;" /><p>几何理解是因为线性近似总是位于上图$epi(f)$的下方。</p><p>该定理关于 $\Omega$是开集的假设不是必须的，只要 $f$定义在某个<strong>包含 $\Omega$的</strong>开集上即可。</p><p><em>不可微函数的次梯度</em></p><p>函数 $f:\Omega\rightarrow R$定义在开凸集 $\Omega \sub R^n$上，如果对于<em><strong>所有</strong></em> $\pmb{y}\in\Omega$，都有<br>$$<br>f(\pmb{y}) \geq f(\pmb{x})+\pmb{g}^T(\pmb{y-x})<br>$$<br>则称向量 $\pmb{g} \in R^n$为函数 $f$定义在点 $\pmb{x} \in \Omega$处的次梯度。</p><p><em>二阶可微</em></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010231054775.png" alt="image-20211010231054775" style="zoom: 67%;" /><p>该定理可以拓展到<strong>定义域是非开集</strong>的情况，只需要把条件修改为对任意的 $\pmb{x,y}\in \Omega$，<br>有$(\pmb{y-x})^T\pmb{F}(\pmb{x})(\pmb{y-x}) \geq 0$。</p><hr><p><strong>凸优化问题</strong></p><p>凸优化问题有许多独特之处。比较特别的一点就是对某些问题，局部极小点就是全局极小点。</p><p>此外，<strong>极小点的一阶必要条件是凸优化问题的充分条件</strong>！</p><p>对于凸集，其范围内包含全局极小点的集合也是凸集。</p><p>若目标函数是连续可微的凸函数，那么某个点是极小点所应该满足的一阶必要条件同时也是充分条件。</p><p>:star:</p><p>第六章提到的 局部最小一阶必要：对某点$x^*$ 所有可行方向$d$，$d^T\triangledown f(x^*)$均&gt;=0</p><p>对于一阶连续的凸函数只要在凸集$\Omega$上存在梯度为0的点，就是全局极小点。</p><p>对于20章仅含等式的约束问题，只要满足拉格朗日条件，就是全局极小点。</p><p>对于21章一般情况下的问题，满足KKT条件就是全局极小点。</p><h3 id="半定规划"><a href="#半定规划" class="headerlink" title="半定规划"></a>半定规划</h3><p>作为<u>凸规划</u>问题的一个分支，求解的是<u>线性矩阵不等式约束</u>下的线性目标函数的极小值。线性矩阵不等式定义了一个<u>凸可行集</u></p><p>可视为线性规划的拓展，只要把向量不等式约束替换为矩阵不等式约束。</p><p>PS：仿射函数，即最高次数为1的多项式函数。常数项为零的仿射函数称为线性函数</p><p>$F_i\ ,i=0…n$ 是n+1个实对称矩阵，表达式$F(x)$可称为线性矩阵不等式（LMI），或仿射矩阵不等式</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211014105833873.png" alt="image-20211014105833873" style="zoom: 33%;" /><p>的点 x 的集合，也就是保证$F(x)$是半正定的【记为$F(x)\geq 0$】</p><p><strong>对于形如 $\pmb{F}(\pmb{x})\geq 0 $的线性矩阵不等式而言，容易证明 ${\pmb{x}:\pmb{F}(\pmb{x})\geq 0}$ 是凸集。</strong> </p><p>以此类推，对于形如$F(x)&gt;0$线性矩阵不等式而言，其要求为F(x)正定(不仅仅是半正定)</p><p>优化、控制系统设计以及信号处理中的许多问题都可以转化为<u>线性矩阵不等式的形式</u>。确定是否存在一个点x使得$F(x)&gt; 0$成立的问题称为<strong>可行性问题</strong>。如果不存在这样一个x，则称线形矩阵不等式问题是不可行的。</p><p>而对于这样的问题，MATLAB、Python库等已经实现了高效的求解方式。</p><h2 id="23、有约束优化问题的求解方法"><a href="#23、有约束优化问题的求解方法" class="headerlink" title="23、有约束优化问题的求解方法"></a>23、有约束优化问题的求解方法</h2><p>本章将针对特殊约束条件下的优化问题，讨论一些简单的求解算法。之前无约束优化问题的求解算法是这些算法的基础。</p><p>有投影法、拉格朗日法、罚函数法，旨在简单介绍有约束优化问题的部分求解算法及原理。</p><h3 id="投影法"><a href="#投影法" class="headerlink" title="投影法"></a>投影法</h3><p>第二部分讨论过的优化算法，大都具有通用的迭代公式。$x^{(k+1)} = x^{(k)} + \alpha_kd^{(k)}$</p><p>但是在有约束问题中，$x$的取值范围必须在预先设定的约束集内，所以不能直接套用以前的算法。</p><p>一种比较简单的改进方式就是<strong>引入投影</strong>。具体方法为：</p><ul><li>若$x^{(k)} + \alpha_kd^{(k)}$在$\Omega$内，则$x^{(k+1)} = x^{(k)} + \alpha_kd^{(k)}$；</li><li>否则，应该将$x^{(k)} + \alpha_kd^{(k)}$投影到$\Omega$中，然后将投影结果作为$x^{(k+1)}$。</li></ul><p>引入投影算子$\Pi$，$\Pi[x]$称为$x$到$\Omega$上的投影，则之前的算法可以改进为 $x^{(k+1)} = \Pi[x^{(k)} + \alpha_kd^{(k)}]$</p><p>对于一般的情况，可定义投影为： $\Pi[x] = \mathop{argmin}\limits_{z\in \Omega}||z-x||$</p><p>框式约束时，投影算子定义如下：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059853.png" alt="image-20211204094248769" style="zoom:67%;" /><p>许多情况下，投影$\Pi[x]$存在明确的计算公式。比如，<em>框式约束</em>👆，当$\Omega$为一个<em>线性簇</em>时，也有明确的公式。</p><p>但是很多时候，投影的计算也是个较为复杂的数值优化问题。</p><hr><p><strong>求解含线性约束优化问题的投影梯度法</strong></p><p>将投影算子引入梯度法，可得如下迭代公式$x^{(k+1)} = \Pi[x^{(k)} + \alpha \triangledown f(x^{(k)})]$，称为投影梯度法</p><p>形如<br>$$<br>minimize\ f(\pmb{x})\<br>subject\ to\ \pmb{Ax}=\pmb{b}\<br>$$<br>rank A = m， $b \in R^m $ 且假定$f \in C^1$，约束集的这种特定结构决定了可以使用正交投影算子作为$\Pi$，即<br>$$<br>P = I_n - A^T(AA^T)^{-1}A<br>$$<br>引理：P的零空间，是$A$的行空间；A的零空间，是P的列空间。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059854.png" alt="image-20211204100640630" style="zoom:67%;" /><p>这个拉格朗日条件的新形式就是关键，而投影算子可表示为<br>$$<br>\Pi[x^{(k)} + \alpha \triangledown f(x^{(k)})] =x^{(k)} - \alpha_kP \triangledown f(x^{(k)})<br>$$<br><strong>几何来看，其实是因为向量$\triangledown f(x)$不一定是可行方向，需要将其投影到可行集，也就是矩阵A的零空间（假定$x^{(k)}$已经属于可行集，只有让后面的$A\omega = 0$这样才能继续保证$A(x+\omega)=b$），而A的零空间就是P的列空间，投影过去等价于左乘P。</strong></p><p>看看性质：</p><ul><li>根据红字分析也能看出，只要$x^{(0)}$可行，任意$x^{(k)}$可行。</li><li>向量$-P \triangledown f(x)$是函数在 x 处的<u>最速下降可行方向</u></li><li>和无约束类似，如果$\alpha$选择一维正方形搜索最小的，称为投影最速下降法，该方法能保证每次迭代目标函数值都减小</li><li>当且仅当$P \triangledown f(x^*) = 0$时，满足拉格朗日条件，$x^*$为全局极小点</li></ul><h3 id="拉格朗日法"><a href="#拉格朗日法" class="headerlink" title="拉格朗日法"></a>拉格朗日法</h3><p>基本思路是利用梯度法，在更新决策变量的同时，也更新拉格朗日乘子向量。</p><p><strong>仅含等式约束的情况</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059855.png" alt="image-20211204103711220" style="zoom: 67%;" /><p>可以看出，$x^{(k)}$的更新方程是一种使得拉格朗日函数关于自变量$x$极小化的梯度算法，$λ^{( k )}$的更新方程也是一种梯度算法，使得拉格朗日函数关于自变量$ λ $极大化。由于仅仅用到了梯度，该方法也称为<u>一阶拉格朗日法</u>。</p><p>若收敛，那么<em>迭代点序列的极限</em>必须满足拉格朗日条件；特别的，<em>任意不动点</em>（更新后的新点与其相等）必满足拉格朗日条件。</p><p>局部收敛性：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059856.png" alt="image-20211204104417327" style="zoom:70%;" /><p><strong>含不等式优化的拉格朗日法</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059857.png" alt="image-20211204105344929" style="zoom:67%;" /><p>$x^{(k)}$的更新方程是一种使得拉格朗日函数关于自变量$x$极小化的梯度法，$\mu ^{( k )}$的更新方程是一种梯度投影法，使得拉格朗日函数关于自变量$ \mu $极大化。采用梯度投影法的原因在于，KKT乘子向量$\pmb{\mu}$必须是非负的。</p><p>同样，收敛极限和不动点必须满足KKT条件。</p><p>收敛性：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059858.png" alt="image-20211204110647649" style="zoom:67%;" /><p>第一阶段，不起作用的约束条件对应的乘子在有限时间内减小到0，此后一直为0</p><p>第二阶段，起作用的约束条件的乘子以线性速度收敛到各自的解。</p><p>对偶问题见《统计学习方法》P447</p><h3 id="罚函数法"><a href="#罚函数法" class="headerlink" title="罚函数法"></a>罚函数法</h3><p>考虑将有约束优化问题<strong>近似处理</strong>为如下的无约束优化问题<br>$$<br>minimize\ f(z)\<br>subject\ to\ x\in \Omega\ \downarrow\<br>minimize\ f(x) + \gamma P(x)<br>$$<br>其中<u>惩罚因子</u>$\gamma$是大于0的常数；<u>罚函数</u>$P：R^n \rightarrow R$是给定函数，求解该无约束优化问题，解作为原问题极小点。</p><p>为了使得无约束优化问题能够更好地<u>近似有约束问题</u>，必须选择合适的惩罚函数$P$。罚函数可以对<u>可行集外</u>的点进行 “惩罚”。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059859.png" alt="image-20211204124639606" style="zoom:67%;" /><p>绝对值罚函数👆在满足$g_i(x)=0$的点$x$上可能不是可微的，因此，在这些情况下，不能使用涉及求导的优化方法。</p><p>但是另一种版本$P(x) = \sum_{i=1}^{p}(g_i^+(x))^2$能保证罚函数可微。</p><p>无约束优化问题的解是否近似于真正的解，<u>取决于惩罚因子$\gamma$和罚函数$P$</u>，理论上当$\gamma \rightarrow \infin$时，得到真正的解，后续讨论。</p><hr><p>接下来，不假设罚函数的具体形式，仅假设其满足3个条件，分析<em>一般意义下的罚函数法</em>：</p><p>先引入一些符号和用法，</p><ul><li>$x^*$表示优化问题的一个解（全局最小点）。</li><li>$\gamma_k \in R，\ k = 1,2,…$是一个给定的正数。</li><li><strong>伴随函数</strong> $q(\gamma_k,\pmb{x}) = f(\pmb{x}) + \gamma_kP(\pmb{x})$，对于每个k，都可构造一个伴随的无约束优化问题：$minimize \ q(\gamma_k,\pmb{x})$<br>并用$x^{(k)}$表示该问题的极小点，随后给出以下引理。</li></ul><p>引理23.4给出了<u>有约束问题与伴随的无约束优化问题的关联关系</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059860.png" alt="image-20211204131635745" style="zoom:67%;" /><p>利用这一引理可以证明如下<strong>定理</strong>：</p><p>目标函数$f$连续，当$k \rightarrow \infin$时，$\gamma_k \rightarrow \infin$。那么序列${\pmb{x}^{(k)}}$的<em>任意收敛子序列</em> 的极限是约束优化问题的一个解。</p><p>​    如果进行无限多次极小化计算，随着惩罚因子$\gamma_k \rightarrow \infin$，那么定理能保证任何收敛子序列的极限都是有约束优化问题的极小点.<br>显然，这一定理在实际应用中是受限的。实际上，利用罚函数法求解无约束优化问题的最优解时，期望<strong>只通过一次极小化</strong>计算便可求得最优解，进而得到原问题的最优解。</p><p>​    换句话说，在$γ&gt;0$为一个<strong>给定常数</strong>的情况下，通过求解伴随的无约束优化问题$[minimize\ f(x) + \gamma P(x)]$获得原问题的精确解。可以证明，<u>这的确是可以做到的</u>，这种情况下的罚函数称为<strong>精确的罚函数</strong>。但是，精确的罚函数要求是<u>不可微的</u>【必要】，但是得满足存在可行方向 $d$ 使得$\pmb{d}^T\triangledown P(x)&gt;0$。如果存在某点$\triangledown f(x^*) = 0$，虽然P可微，仍然是精确罚函数。</p><p>​    接下来的求解工作就是无约束的内容啦！</p><p><em>本章仅仅讨论了罚函数的基础知识</em>，关于不可微函数的优化问题的深入讨论要自己查文献。。。</p><h2 id="24、多目标优化"><a href="#24、多目标优化" class="headerlink" title="24、多目标优化"></a>24、多目标优化</h2><p>The last one!</p><p>如果某个优化问题只包含一个目标函数，称为单目标优化问题；但是，绝大多数工程问题需要设计者同时处理多个目标，而这些目标之间往往存在冲突，即改进一个目标会导致另一个目标恶化。这种<u>存在冲突</u>的多目标问题，也成为<u>多准则、向量优化问题</u>。</p><p>这种问题需要找到一个决策变量，个元素就是目标函数。多目标优化问题可以表示为</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059861.png" alt="image-20211204162618132" style="zoom:67%;" /><p>3种多目标优化问题【后两类可以等价转换为第一类问题，即极小化问题】</p><ul><li>极小化所有目标函数</li><li>极大化所有目标函数</li><li>极小化某些目标函数，极大化其余目标函数</li></ul><p><strong>帕累托解 Pareto</strong></p><p>多目标函数给各个决策变量分配一个位于多目标空间中的<u>多目标函数向量函数值</u>。</p><p>单目标优化问题的目标是找到一个解，主要关注<strong>决策向量空间</strong>；</p><p>而在多目标问题问题中，通常对<strong>目标函数空间</strong>更感兴趣。</p><p>正如某位M开头大师所说，多目标问题某种意义上无法进行明确的定义，因为目标函数空间中不存在自然排序，不像一维空间中可以清晰、直观地比较大小关系，但是最终仍然给出了正式定义。</p><p>目前，最优解的正式定义，习惯于将多目标优化问题的最优解称为帕累托极小点（帕累托解）定义如下：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059862.png" alt="image-20211204163914597" style="zoom:67%;" /><p>成立，则$x^*$是一个帕累托极小点。也成为非支配解，它意味着<u>不存在一个可行的决策变量$x$能够使得某些目标函数减少的同时不会导致另一个其他目标函数增加。</u>【知乎大佬：<strong>从此以后，非损人不能利己</strong>。】也可以用于博弈论啊</p><p>帕累托极小点（最优解）的集合称为帕累托前沿，绝大多数多目标优化算法用到了“支配”概念，但帕雷托解是非支配的。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059863.png" alt="image-20211204165010255" style="zoom: 67%;" /><p><strong>帕累托前沿的求解</strong></p><p>在求解帕累托前沿时，需要对两个解进行比较，从候选的帕累托解集合中移除支配解。因此，帕累托前沿只包含非支配解。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059864.png" alt="image-20211205140953483" style="zoom:67%;" /><p>对于新的候选解$\pmb{x}^{j}$，可能有三种情况：</p><ul><li>$\pmb{x}^{j}$至少支配一个当前的帕累托解——用$\pmb{x}^{j}$替代被支配的解</li><li>$\pmb{x}^{j}$不支配任何当前的帕累托解——直接将$\pmb{x}^{j}$加入帕累托候选集合</li><li>$\pmb{x}^{j}$收到一个当前的帕累托解支配——不操作。</li></ul><p><strong>帕累托前沿的生成算法</strong></p><p>$J$ 表示为得到最优解而必须进行分析的候选解的数目，$R$ 是当前候选的帕累托解数量。$\varrho$ (类似的那个符号)是目标函数向量的维数，$n$是决策空间的维数，即$x$的元素个数。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059865.png" alt="image-20211205143500435" style="zoom:60%;" /><p><strong>多目标优化到单目标优化的转换</strong></p><p>在某些情况下，可以将多目标优化问题转换为单目标优化问题，这样，就可以利用前面讨论过的一些常用方法进行求解了。</p><p><strong>Method1</strong>：将目标函数向量中的各元素进行线性组合（组合系数必须为正数），也就是各元素的凸组合。<br>$$<br>f(\pmb{x}) = c^Tf(x)<br>$$<br>向量c的<u>元素全部为正</u>，称为加权求和法，系数成为权值，反映的是目标向量中的<u>各元素相对重要度</u>。不得不提出的是，<em>权值的确定可能相当困难</em>。</p><p><strong>Method2</strong>：以目标向量中的最大元素作为单目标函数：</p><p>实际上，这就是将多目标极小化问题转换为使目标函数的最大元素极小化的问题，可称之为<u>极小极大法</u>。</p><p>使用条件：各元素具有可比性或彼此相容的情况。【彼此相容：它们具有相同的单位】</p><p>局限性：产生的单目标函数是不可微的，因此无法使用那些要求目标函数可微的优化求解方法（比如梯度）</p><p>而目标函数向量中中各元素为线性函数、约束为线性方程的极小极大问题可简化为线性规划问题。</p><p><strong>Method3</strong>：若目标向量的元素全部非负，那么以目标函数向量的$p$范数作为单目标函数，也可转换为单目标优化。</p><p>极小极大方法可视为特例，也就是$p = \infin$；当$p$有限时，可以用 p范数的p次方代替范数本身！【突然好算多了】</p><p><strong>Method4</strong>：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059866.png" alt="image-20211205191554118" style="zoom:67%;" /><hr><h3 id="存在不确定性的线性规划"><a href="#存在不确定性的线性规划" class="headerlink" title="存在不确定性的线性规划"></a>存在不确定性的线性规划</h3><p>所谓不确定，指的是约束条件的上下界不能确定，约束条件表现为$(\pmb{Ax})_i \leq b_i + \theta t_i$</p><p>其中，$\theta \in [0,1],t_i &gt;0, i = 1,2,…,m$</p><p>未完待续。。。等真正理解再来吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无约束优化&quot;&gt;&lt;a href=&quot;#无约束优化&quot; class=&quot;headerlink&quot; title=&quot;无约束优化&quot;&gt;&lt;/a&gt;无约束优化&lt;/h1&gt;&lt;h2 id=&quot;6、基础知识&quot;&gt;&lt;a href=&quot;#6、基础知识&quot; class=&quot;headerlink&quot; title=&quot;6</summary>
      
    
    
    
    <category term="Math" scheme="https://darren-dong.com/categories/Math/"/>
    
    
    <category term="理论" scheme="https://darren-dong.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软工概念</title>
    <link href="https://darren-dong.com/2021/07/03/%E8%BD%AF%E5%B7%A5/"/>
    <id>https://darren-dong.com/2021/07/03/%E8%BD%AF%E5%B7%A5/</id>
    <published>2021-07-03T03:08:21.000Z</published>
    <updated>2022-05-10T02:38:30.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件工程（2）"><a href="#软件工程（2）" class="headerlink" title="软件工程（2）"></a>软件工程（2）</h2><p><strong>软件的概念</strong></p><p><u>软件= 程序+ 数据+ 文档</u><br>(1) 程序：按事先设计的功能和性能需求执行的指令序列<br>(2) 数据：是程序能正常操纵信息的数据结构<br>(3) 文档：与程序开发、维护和使用有关的图文材料</p><p><u>双重作用：软件一方面是一种产品，另一方面是开发其他软件产品的工具。</u></p><p> <strong>软件分类</strong><br>（1）功能分类：系统软件、支撑软件、应用软件<br>（2）服务对象：项目软件、产品软件</p><p><em>软件的特征</em><br>1、软件是开发的或者是工程化的，并不是制造的<br>2、软件开发环境对产品影响较大<br>3、软件开发时间和工作量难以估计<br>4、软件会多次修改<br>5、软件的开发进度几乎没有客观衡量标准<br>6、软件测试非常困难<br>7、软件不会磨损和老化<br>8、软件维护易产生新的问题<br>9、软件生产是简单的拷贝    </p><p><strong>软件危机</strong></p><p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p><p>项目超出预算、项目超过计划完成时间、软件运行效率很低、软件质量差、软件通常不符合要求、项目难以管理并且代码难以维护、软件不能交付。</p><p><strong>原因</strong></p><p>客观：软件本身特点——（逻辑部件，规模庞大）<br>主观：不正确的开发方法——（忽视需求分析，错误认为：软件开发=程序编写，轻视软件维护）</p><p><strong>软件工程定义</strong></p><p>（1）应用<u>系统化的、学科化的、定量</u>的方法，来开发、运行和维护软件，即将工程化方法应用到软件。<br>（2）对（1）中各种方法的研究。</p><p><strong>软工三要素</strong>【后面章节以此为纲吗】</p><p><u>工具</u>：为软件工程的过程和方法提供自动化或半自动化的工具支持 。</p><p><u>方法</u>：软件工程方法是完成软件工程项目的技术手段。分两类: 结构化方法和面向对象方法</p><p><u>过程</u>：过程贯穿软件开发的各个环节，在各环节之间建立里程碑;管理者在软件工程过程中对软件开发的质量、进度、成本进行评估、管理和控制； 技术人员采用相应的方法和工具生成软件工程产品（模型、文档、数据、报告、表格等）</p><p>根基：质量焦点</p><p><em>发展过程</em></p><p>传统软件工程、对象工程、过程工程、构件工程。</p><h2 id="软件过程（2）"><a href="#软件过程（2）" class="headerlink" title="软件过程（2）"></a>软件过程（2）</h2><p><u>软件工程是一种层次化技术</u></p><p><em>软件生命周期</em>（龙说关注各个阶段产出，不过这图确实是有用。）</p><p>指软件产品或软件系统从定义、设计、投入使用到被淘汰的全过程。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215101731360.png" alt="image-20211215101731360" style="zoom:67%;" /><p><strong>软件过程概念</strong></p><p>软件过程是在工作产品构建过程中，所需完成的工作<u>活动、动作和任务的集合</u>。</p><p>活动主要实现宽泛的目标</p><p>动作包含了主要工作产品生产过程中的一系列任务</p><p>任务关注小而明确的目标，能够产生实际产品</p><p><strong>软件过程模型</strong> </p><p>是软件开发全部过程、活动和任务的<u>结构框架</u>。<br>直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。</p><p><strong>软件过程评估</strong></p><blockquote><p>能力成熟度模型<strong>CMM</strong>（Capability Maturity Model）是迄今为止学术界和工业界公认的有关软件工程和管理实践的最好的软件过程评估模型。</p></blockquote><p>分级：【感觉非常有道理！有借鉴意义】</p><p>（1）初始级           有能力的人和个人英雄主义</p><p>（2）可重复级        基本项目管理</p><p>（3）已定义级        过程标准化</p><p>（4）量化管理级     量化管理</p><p>（5）优化级           持续的过程改进</p><hr><p><strong>瀑布模型</strong></p><p><u>软件开发过程与软件生命周期是一致</u>的，也称经典的生命周期模型。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215103712171.png" alt="image-20211215103712171" style="zoom:80%;" /><p>特点：<br>阶段间具有<u>顺序性和依赖性。</u><br><u>推迟实现</u>的观点。<br>每个阶段必须完成规定的文档; 每个阶段结束前完成文档审查,及早改正错误。<u>以文档为驱动。</u></p><p>缺点<br>增加工作量<br>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；</p><p>开发风险大<br>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；</p><p>早期错误发现晚<br>早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。</p><p>不适用于需求变化的场合<br>适用于：<u>系统需求明确、技术成熟、工程管理较严格</u>的场合，如军工、航天、医疗。</p><p><strong>V模型（瀑布变种）</strong></p><p>龙老师说记住对应关系。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215103954519.png" alt="image-20211215103954519" style="zoom:80%;" /><p><strong>原型模型</strong>——思想是首先实现软件的最核心的、最重要的功能</p><p>原型（prototype）：<br>一个部分开发的产品，使客户和开发人员能够对计划开发的系统的相关方面进行检查。</p><p>结果：<u>抛弃原型、把原型发展</u>成最终产品。</p><p>优点：减少需求不明带来的风险。</p><p>缺点：</p><ul><li>构造原型采用的工具和技术不一定主流；</li><li>设计者在质量和原型中进行折中；</li><li>客户意识不到一些质量问题。</li></ul><p>适用场合：客户定义一个总体目标集，但是他们<u>并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式</u>。</p><p><strong>增量模型</strong></p><p>增量：满足用户需求的一个子集，能够完成一定功能、小而可用的软件。</p><p>增量方式分为：增量方式（增加新功能）和迭代方式（改进）</p><p>特点：<br>• 增量模型从部分需求出发，先建立一个不完整的系统，通过测试运行这个系统，取得经验和反馈，进一步使系统扩充和完善<br>• 增量模型结合了原型模型的基本要素和迭代的特征，采用了基于时间的线性序列，每个线性序列都会输出该软件的一个“增量”<br>• <u>每个增量的开发可用瀑布或快速原型模型</u>。</p><p>优点：</p><ul><li>不需要提供完整的需求， 只要有一个增量包出现，开发就可以进行。</li><li>在项目的 初始阶段不需要投入太多的人力资源。增量可以 有效地管理技术风险。 </li><li>产品逐步交付，能较好的适应需求变化。 </li><li>开放式体系结构 ，便于维护。 </li><li>软件能够更早的投入市场。</li></ul><p>缺点：每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小适合的增量。软件必须具备开放式体系结构（困难）。易退化成边做边改的方式，使软件过程控制失去整体性</p><p>适用场合：开发中<u>需求可能变化、具有较大风险、或希望尽早进入市场</u>的项目。</p><p><strong>螺旋模型</strong></p><p>把开发活动和风险管理结合起来控制风险，强调风险管理，因此该模型适用于<u>大型系统</u>的开发。<br>模型结合了<u>瀑布模型和原型模型</u>的特点。</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215105238453.png" alt="image-20211215105238453" style="zoom:67%;" /><p>优点：</p><ul><li>特别强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力。支持<u>用户需求的动态变化</u>。</li><li>易于为用户和开发人员共同理解，还可作为<u>继续开发的基础</u>，并为用户参与所有关键决策提供了方便。</li><li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可<u>降低开发风险。</u></li></ul><p>缺点：</p><ul><li>如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟提交时间；</li><li>使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高。</li></ul><p>适用场合：</p><p>适用于需求不明确或者<strong>需求可能发生变化的大型复杂</strong>的软件系统。</p><p><em>喷泉模型</em></p><p>是一种以用户需求为动力，以对象为驱动的模型，主要用于<u>描述面向对象</u>的软件开发过程</p><p>优点：各个阶段没有明显的界限，开发人员可以同步进行开发。其提高软件项目开发效率，节省开发时间。<br>缺点：由于喷泉模型在各个开发阶段是重叠的，在 开发过程中需要大量的开发人员，不利于项目的管理。此外这种模型 要求严格管理文档 ，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。</p><p><strong>敏捷开发</strong></p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215110616835.png" alt="image-20211215110616835" style="zoom:80%;" /><p>敏捷软件过程是<u>基本原理和开发准则</u>的结合</p><p>优点： 对变化和不确定性有更快更敏捷的反应。在 快速的同时<u>保持可持</u><u>续的开发速度</u>。能较好地适应商业竞争环境下对<u>小项目</u>提出的 有限资源和有限开发时间的约束<br>缺点：极限编程中的测试驱动开发可能会导致 系统<u>通过了测试但不是用</u><u>户期望的</u>。 重构而不降低体系结构的质量是困难的。用于 大型项目有很多问题</p><p><strong>选择模型</strong>【在不同的条件下选择相应的思路，对我有启发】</p><p>1.前期<u>需求明确</u>的情况下，尽量采用瀑布模型<br>2.<u>用户无系统使用经验，需求分析人员技能不足的情况下</u>，尽量借助原型模型<br>3.<u>不确定因素很多</u>，很多东西无法提前计划的情况下，尽量采用增量模型或螺旋模型<br>4.需求不稳定或资金和成本无法一次到位的，尽量采用增量模型</p><p>6.对于完成多个独立功能开发的情况，可在需求分析阶段就进行<u>功能并行</u>，每个功能内部都尽量遵循瀑布模型<br>7.全新系统的开发必须在总体设计完成后再开始增量或并行<br>8.编码人员<u>经验较少的情况下，尽量不要采用敏捷或迭代模型</u><br>9.增量、迭代和原型可以综合使用，但每一次增量或迭代都必须有<u>明确的交付和出口原则</u></p><p>瀑布模型、增量模型、原型模型和螺旋模型的<strong>联系和区别</strong></p><table><thead><tr><th>比较项</th><th>瀑布模型</th><th>原型模型</th><th>增量模型</th><th>螺旋模型</th></tr></thead><tbody><tr><td>是否事先定义大部分需求</td><td>是</td><td>无</td><td>无</td><td>是</td></tr><tr><td>每次迭代输出是否为产品</td><td>是</td><td>无</td><td>无</td><td>是</td></tr><tr><td>驱动方式</td><td>文档</td><td>用户</td><td>用户</td><td>风险</td></tr><tr><td>迭代周期内的过程模型</td><td>瀑布模型</td><td>瀑布模型</td><td>原型模型</td><td>可选</td></tr></tbody></table><p>举例说明：若一个软件包含A、B、C、D四个功能，那么</p><p>瀑布模型输出结果为ABCD</p><p>原型模型输出结果为A’B’C’D’-&gt;ABCD</p><p>增量模型输出结果为A-&gt;AB-&gt;ABC-&gt;ABCD</p><p>螺旋模型输出结果为A1B1C1D1-&gt;A2B2C2D2-&gt;……-&gt;ABCD</p><h2 id="需求分析（1）"><a href="#需求分析（1）" class="headerlink" title="需求分析（1）"></a>需求分析（1）</h2><p><strong>需求分析的定义</strong>：</p><p>确定系统必须具有的<u>功能和性能，系统要求的运行环境</u>，并且<u>预测</u>系统发展的前景。<br>换句话说需求就是以一种 <u>清晰 、简洁 、一致且无二义性</u>的方式，对一个待开发系统中<u>各个有意义方面的陈述</u>的一个集合。</p><blockquote><p>需求获取</p><p>用户目标、领域知识、投资者、运行环境、组织环境</p><p>采访、设定情景、原型、会议、观察商业工程和工作流。</p><p>十原则：倾听、有准备的沟通、有地位足够的人推动、最好当面沟通、记录决定、保持通力合作</p></blockquote><p>需求分析的过程：<u>需求确认与需求变更</u></p><p><strong>需求确认</strong>：<u>需求获取-&gt;需求提炼-&gt;需求描述-&gt;需求验证</u>：</p><ul><li>需求获取：软件需求的 来源以及软件工程师收集这些软件需求的方法。</li><li>需求提炼（需求分析）：将用户需求 精确化、完全化，最终形成下一步的 需求规格说明书。<u>核心在于建立分析模型</u>。</li><li>需求描述：软件需求规格说明书（SRS）——软件系统的需求规格说明，是对待开发系统的行为的 <u>完整描述</u>。为了使用户和软件开发者双方对该软件的初始规定有一个<u>共同的理解</u>，使之成为整个开发工作的基础。</li><li>需求验证：重要性：如果在后续的开发或当系统投入使用时才发现需求文档中的错误，就会导致更大代价的返工。<br>需对文档进行：<ul><li>有效性检查：检查不同用户使用不同功能的有效性</li><li>一致性检查：在文档中，<u>需求之间不应该冲突。</u></li><li>完备性检查：需求文档应该包括<u>所有</u>用户想要的功能和约束。</li><li>可行性检查：检查保证<u>能利用现有技术</u>实现需求。</li></ul></li></ul><p><strong>需求类型/需求分析的分类</strong></p><p>(1) 功能性需求：描述<u>系统应该做什么</u>，即<u>为用户和其它系统完成的功能、提供的服务</u>。<br>(2) 非功能性需求：必须遵循的标准，外部界面的细节，实现的<u>约束条件</u>，质量属性等等<br>(3) 非功能需求限定了选择解决问题方案的范围，如运行平台、实现技术、编程语言和工具等</p><hr><p><strong>分析模型描述工具</strong></p><p>一个典型的软件系统使用数据结构（数据模型），执行操作（行为模型），并且完成数据值的变化（功能模型）</p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215115345970.png" alt="image-20211215115345970"></p><p><em>面向过程分析模型</em>：基本思想 是用系统工程的思想和工程化的方法，根据用户至上的原则，自始自终按照 <u>结构化、模块化，自顶向下</u> 地对系统进行分析与设计。</p><p>结构化分析（Structured Analysis，简称SA），是<u>面向数据流</u>进行需求分析的方法。 结构化分析的主要思想是采取<u>自顶向下逐层分解</u>的分析策略，即面对一个复杂的问题，分析人员不可能一开始就考虑到问题的所有方面以及全部细节，采取的策略往往是分解，把一个复杂的问题划分成若干小问题，然后再分别解决，将问题的复杂性降低到人可以掌握的程度。</p><p><em>面向对象分析模型</em>：由5个层次（主题层、对象类层、结构层、属性层和服务层）和5个活动（标识对象类、标识结构、定义主题、定义属性和定义服务）组成。</p><p>面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。 面向对象方法的解决问题的思路是<u>从现实世界中的客观对象（如人和事物）入手，尽量运用人类的自然思维方式来构造软件系统</u>，这与传统的结构化方法从功能入手和信息工程化方法从信息入手是不一样的。</p><hr><p><strong>面向过程</strong>—结构化分析方法</p><p><strong>数据流图DFD</strong></p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120035900.png" alt="image-20211215120035900" style="zoom: 50%;" /><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120514343.png" alt="image-20211215120514343" style="zoom:50%;" /></p><p>数据流图层次结构</p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120610055.png" alt="image-20211215120610055" style="zoom: 60%;" align = 'left' /><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215141325037.png" alt="image-20211215141325037" style="zoom:67%;" align = 'left'/>与、或、异或。</p><p><em>加工</em> 的命名注意事项</p><p> 1）顶层的加工名就是整个系统项目的名字</p><p> 2）尽量最好使用<u>动宾词组</u>，也可用<u>主谓词组</u></p><p> 3）不要使用空洞的动词</p><p><em>外部实体</em>（数据源点/ /终点）<br>起到更好的理解作用，但不是系统中的事物</p><p><em>数据流</em></p><p> 数据流可从加工流向加工，也可在加工与数据存储或外部项之间流动；两个加工之间可有多股数据流</p><p>1） 不要把控制流作为数据流。 2) 不要标出激发条件</p><p><u>每个加工至少有一个输入数据流和一个输出数据流。</u></p><p><u>数据流必须有一端是加工，而不能两端都是 外部项/数据存储。</u></p><hr><p><strong>面向对象</strong></p><p><strong>功能模型-用例图</strong></p><p>用例建模用于描述系统需求，把系统当作黑盒，<u>从用户的角度，描述系统的场景</u>。</p><p>主要图形元素有以下几个：</p><p><em>参与者</em>：是指外部用户或外部实体在系统中扮演的角色。可以是 <u>人、其他系统、设备</u> 或者时间等角色。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034754.png" alt="image-20220102214007908" style="zoom:50%;" /><blockquote><p>确定参与者：</p><p>开发人员可以通过回答以下的问题来寻找系统的参与者。<br>（1）谁将使用该系统的主要功能？<br>（2）谁将需要该系统的支持以完成其工作？<br>（3）谁将需要维护、管理该系统，以及保持该系统处于工作状态？<br>（4）系统需要处理哪些硬件设备？<br>（5）与该系统交互的是什么系统？<br>（6）谁或什么系统对本系统产生的结果感兴趣？</p></blockquote><p><em>用例</em>：对<u>一组动作序列</u>的描述，系统通过执行这一组动作序列为参与者<u>产生一个可观察的结果</u>。用例名往往用<u>动宾结构</u>命名</p><p>​            用椭圆形表述</p><blockquote><p>• 说明了系统具有的一种<u>行为模式</u><br>• 说明了一个参与者与系统执行的一个相关的事件序列<br>• 提供了一种获取系统需求的方法<br>• 提供了一种与最终的用户和领域专家进行沟通的方法<br>• 提供了一种测试系统的方法</p></blockquote><p><em>执行关联</em>： 参与者（Actor ）执行用例（Use Case）之间的关系</p><ol><li>关联： <u>参与者与用例之间的关系（其他都是用例之间的关系）</u>。表示 参与者与用例之间的通信，任何一方都可发送或接受消息。<br> 【箭头指向】：指向消息接收方，<u>也可以不加箭头</u></li><li>泛化： 就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关<br>系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。<br>【箭头指向】：指向父用例</li><li>包含：包含（include）关系指的是两个用例之间的关系，其中一个用例（称为基本用例）的行为包含另一个用例（称为包含用例，inclusion use case）的行为。<br> 【箭头方向】由基本用例指向分解出的用例。 <u>执行基本用例的时候，每次都应该调用被包含用例</u>， 被包含用例也<u>可单独执行</u>。</li><li>扩展：扩展关系是指用例功能的延伸，相当于为基础用例提供一个 附加功能。 <u>扩展用例依赖于被扩展用例，不是完整的独立用例， 无法单独执行</u>。在扩展关系中，一个基本用例执行时，<u>可以执行、也可以不执行</u><br> 【箭头方向】由扩展用例指向基本用例。</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034755.png" alt="image-20211215145904906" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034756.png" alt="image-20220102214202201" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034757.png" alt="image-20220104222122993" style="zoom:67%;" /><hr><p><strong>行为模型-活动图（泳道图）</strong></p><p><u>是对用例的图形化！</u></p><p>• 每一步都是做某事的一个<u>状态</u><br>• 执行步骤称为<u>动作</u><br>• 描述哪些步骤被顺序执行、哪些可被并发地执行<br>• 控制流 – 控制从一个动作到下一个动作的流</p><p>在用例流中发现动作。</p><p>活动图别忘了开始和结束的标记，注意分叉的类型</p><p>开始：实心圆  结束：牛眼</p><p>转换可以分支及合并（钻石框） – （可选）计算线程【如果需要判断，也得在菱形外面加说明，如果有条件，要附上说明】</p><p>转换可以分叉及汇合（短横线）– 并发（并行）计算线程</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034758.png" alt="image-20211215150956912" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034759.png" alt="image-20211215151013131" style="zoom:57%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034760.png" alt="image-20220102215033431" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034761.png" alt="image-20220102215052674" style="zoom:50%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034762.png" alt="img" style="zoom:67%;" /><p>这俩图还是建议好好看完PPT。</p><h2 id="软件设计（1）"><a href="#软件设计（1）" class="headerlink" title="软件设计（1）"></a>软件设计（1）</h2><p><strong>软件设计</strong>：软件系统或组件的架构、构件、接口和其他特性的<u>定义过程及该过程的结果。</u><br>软件工程生命周期中的一个活动。进行软件编码的基础。<br>软件需求分析被转化为软件的内部结构。是连接用户需求和软件技术的桥梁。设计是<u>软件工程技术的核心</u>。</p><blockquote><p><strong>指导原则</strong>：<br>1 设计应该是一种<strong>架构</strong><br>2 设计应该是<strong>模块化</strong>的<br>3 设计应该包含 <u>数据、体系结构、接口和组件</u>各个方面</p><p>应该设计出系统所用的数据结构<br>应该设计出展现独立功能特性的各组件<br>应该设计出各组件与外部环境连接的各接口</p><p>4 设计由软件需求分析过程中获得信息驱动，采用可重复使用的方法导出<br>5 设计应该采用正确清楚的表示法</p></blockquote><p>概要设计：实现目标产品的总体框架，包括<strong>体系结构设计、数据设计、接口和组件</strong>设计。<br>                    其中体系结构是设计师概要设计的主要内容。<br>详细设计：对概要设计划分出来的模块分别去描述设计，以便能够编码实现</p><p>系统设计从<strong>数据、体系结构、接口和组件</strong>四方面进行设计。【自底向上】</p><p><strong>八大概念</strong>【知道即可，不会让详细解释】</p><p>抽象、体系结构、设计模式、模块化、信息隐藏、功能独立、细化、重构。<br>其中，着重考察 <u>体系结构、模块化、信息隐藏、功能独立</u>。</p><ol><li><p>抽象</p><p>忽略具体的信息将不同事物看成相同事物的过程， <u>参数化、规范化</u>。</p></li><li><p><strong>体系结构</strong></p><p>含义：软件的整体结构 和 这种结构为系统提供 概念上完整性 的方式<br>表达方式：结构模型、框架模型、动态模型、过程模型、功能模型</p></li><li><p>设计模式</p><p> 在给定上下文环境中一类共同问题的共同解决方案，如抽象工厂</p></li><li><p><strong>模块化</strong></p><p>软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求</p><p>软件的模块性：程序可被智能管理的单一属性</p><p>理论依据：基于人类解决问题的观测数据</p><p>模块化基本问题 如何分解软件系统以达最佳的模块划分</p><blockquote><p>设计标准：</p><ol><li>分解性：可分解为子问题</li><li>组合性：组装可重用的组件</li><li>可理解性：可作为独立单元理解</li><li>连续性：需求小变化只影响单个模块</li><li>保护： 模块内异常只影响自身</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034763.png" alt="image-20211215153317948"  align = 'left'/></blockquote></li><li><p><strong>信息隐藏</strong></p><p> 模块应该具有彼此相互隐藏的特性，模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问</p></li><li><p><strong>功能独立</strong></p><p>每个模块只负责<u>需求中特定的子功能</u>，并且从程序结构的其他部分看，该模块具有简单的接口</p><p>• 易于开发：功能被划分，接口被简化。<br>• 易于维护（和测试）：次生影响有限，错误传递减少，模块重用。</p><p>定性衡量标准：</p><p>• 内聚性：模块的功能相对强度<br>• 耦合性：模块之间的相互依赖程度<br>• 模块独立性强 = 高内聚低耦合</p></li><li><p>精化</p><p> 逐步求精的过程</p><p> 与抽象的关系：</p><p> • 抽象使设计师确定过程和数据，但不局限于底层细节<br> • 精化有助于设计者在设计过程中揭示底层细节</p></li><li><p>重构</p><p> 不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术</p><p> 检查现有<u>设计的冗余情况、未使用的设计元素、无效或不必要的算法、较差的构建方式或不恰当的数据结构</u>，或任何其他可被更改从而优化设计的问题</p></li></ol><blockquote><p><strong>面向过程设计技术概要</strong></p><p>系统设计从体系结构、数据、接口和组件四方面进行设计。</p><p><u>数据设计</u><br>（有时也被称为数据架构）构建高层抽象（客户/用户的数据视图）的数据模型、信息模型</p><ol><li>数据建模： 数据字典、E-R 图 、类图。</li><li>数据结构：计算机存储组织数据的方式。</li><li>数据库：按照数据结构来组织、存储和管理数据的仓库</li></ol><p><u>体系结构设计</u> </p><p>风格和模式简要分类：<strong>数据中心结构、数据流体系结构、调用和返回结构、层次结构、面向对象结构</strong>【图要认得出】</p><p>组织和细化两个基本问题：</p><ul><li>控制结构：在架构内部如何实现管理控制？是否有不同的控制架构存在</li><li>数据传递：组件之间如何进行数据传递？数据流是否连续，或者传递给系统的数据对象是否零散</li></ul><p><u>接口设计</u>（含界面设计）</p><p>• 允许用户操作控制（用户为中心）<br>• 减少用户记忆负担<br>• 保持界面一致</p><p><u>组件设计</u>：面向过程（函数、模块）、面向对象（类与操作）<br>在过程设计、详细设计，位于数据设计、体系结构设计和接口设计完成之后</p><p><em>面向过程的总体设计</em></p><p>1 首先研究、分析和审查数据流图。 从软件的需求规格说明中弄清数据流加工的过程，对于发现的问题及时解决。<br>2 然后根据数据流图决定问题的类型。数据处理问题典型的类型有两种：<u>变换型和事务型</u>。针对两种不同的类型分别进行分析处理。<br>3 由数据流图推导出系统的初始结构图。<br>4 利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。（系统结构图）<br>5 修改和补充数据词典。</p></blockquote><p>软件体系结构是系统的一个或多个结构，它包括<u>软件构件、构件的外部可见属性、以及它们之间的相互关系</u>。</p><p>风格和模式简要分类：<strong>数据中心结构、数据流体系结构、调用和返回结构、面向对象结构、层次结构</strong>【图要认得出】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034764.png" alt="image-20220102221017990" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034765.png" alt="image-20220102221030497" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034766.png" alt="image-20220102221041211" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034767.png" alt="image-20220102221058679" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034769.png" alt="image-20220102221111954" style="zoom:67%;" /></p><p><strong>流程图</strong>(flow chart)</p><p>利用各种方块图形、线条及箭头等符号来表达解决问题的步骤及进行的顺序；是算法的一种表示方式。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034770.png" alt="image-20211215162409417" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034771.png" alt="image-20211215162425931" style="zoom:67%;" /></p><p><em>基本结构</em></p><p>顺序结构、选择结构（二元、多重）、循环结构（while-do\do-while）【可以看看陈安龙出的题】</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034772.png" alt="image-20220102220751495" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034773.png" alt="image-20211223210208725" style="zoom:50%;" /></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034774.png" alt="image-20220105211743862" style="zoom: 33%;" /><p>其他面向过程组件设计方法：盒图（N-S图）、PDL(程序设计语言)、判定表、判定图</p><hr><p><strong>面向对象的设计</strong></p><p>分为系统架构设计、用例设计、类设计、数据库设计、用户界面设计。</p><p><strong>架构设计</strong><br>架构设计的目的是要勾画出系统的总体结构，这项工作由经验丰富的架构设计师主持完成。</p><p>输入：用例模型、分析模型。     输出：物理结构、子系统及其接口、概要的设计类。</p><p><strong>用例设计</strong></p><p>进一步细化用例</p><p>根据分析阶段产生的高层类图和交互图，由用例设计师<u>研究已有的类，将它们分配到相应的用例中</u>。</p><p>检查每个用例功能，依靠当前的类能否实现，同时检查每个用例的特殊需求是否有合适的类来实现。</p><p>细化每个用例的类图，<u>描述实现用例的类及其类之间的相互关系</u>，其中的通用类和关键类可用粗线框区分，这些类将作为项目经理检查项目时的重点。</p><p><strong>类设计</strong></p><p>类是包含信息和影响信息行为的逻辑元素。类的符号是由三个格子的长方形组成，有时下面两个格子可以省略。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034775.png" alt="image-20211215163820307" style="zoom:80%;" /><p> <em>类间关系</em></p><p>(1) 关联关系:关联是一种结构化的关系，指一种对象和另一种对象有联系。<br>(2) 聚合关系:指的是整体与部分的关系。<br>(3) 泛化关系：泛化也就是继承关系<br>(4) 组合关系：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。<br>(5) 依赖关系：是一种使用关系，特定事物的改变有可能会影响到使用该事物的事物</p><p><u>组合是一种较为紧密的关系，从生命周期上看，部分和整体是共存亡的关系。 聚合则是一种较为松散的关系，部分和整体的生命周期未必一致。</u></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034776.png" alt="image-20211215151848878" style="zoom: 50%;" /><p><em>不同的类</em></p><p>实体类用于对必须存储的<u>信息</u>和<u>相关行为</u>进行建模。源于业务模型中的业务实体</p><p>边界类用于参与者与用例之间、有交互的用例间、用例与系统边界之外交互时，</p><p>控制类来源于对用例场景中动词的分析和定义，主要起到协调对象的作用，例如从<u>边界类通过控制类访问实体类</u>，或者<u>实体类通过控制类访问另一个实体类</u>。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034777.png" alt="image-20211215164219626" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034778.png" alt="image-20220101201405506"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034779.png" alt="image-20220101201422808"></p><p><em>类设计三步</em></p><ol><li><p>定义类的属性，类的属性反映类的特性，通常属性是被封装在类的内部，不允许外部对象访问。</p><p>原则：尽量使用已有的类型，一个类不要太复杂，坚持简单的原则。</p></li><li><p>定义类的操作</p><p>一个类可能被应用在多个用例中，由于它在不同用例中担当的角色不同，所以设计时要求详细周到。<br>检查<u>类在每个用例中实现是否合适</u>，补充必要操作；考虑特殊情况。</p></li><li><p>定义类之间的关系</p></li></ol><p><strong>UML顺序图</strong></p><p>用例常常被细化为一个或多个顺序图。它还能用来记录一个存在于系统的对象现在如何交互。<br>当强调按时间展开信息的传送时，一般使用顺序图建模技术。</p><ol><li>顺序图是强调消息<u>时间顺序</u>的交互图。</li><li>顺序图描述了对象之间传送消息的时间顺序，用来表示用例中的<u>行为顺序</u>。</li><li>顺序图将交互关系表示为一个二维图。即在图形上，顺序图是一张表，其中显示的对象沿横轴排列，从左到右分布在图的顶部；而消息则<u>沿纵轴按时间顺序排序</u>。创建顺序图时，以能够使图尽量简洁为依据布局。</li></ol><p><em>四个元素</em></p><p><u>对象（符号和对象图中对象所用的符号一样）、生命线、消息、激活。</u></p><p>对象置于顺序图的顶部意味着在交互开始的时候对象就已经存在了，否则表示对象是在交互的过程中被创建的。<br>一般最多两个参与者，他们分列两端。启动这个用例的参与者往往排在最左边；接收消息的参与者则排在最右端；<br>对象从左到右按照<u>重要性排列或按照消息先后顺序</u>排列</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034780.png" alt="image-20220102224513467" style="zoom:67%;" /><p>每个对象都有自己的生命线（垂直的虚线），用来表示在该用例中一个对象在一段时间内的存在，生命期结束，则用<u>注销符号</u>表示。</p><p>激活表示该对象被占用以完成某个任务，去激活指的则是对象处于空闲状态、在等待消息。</p><p>面向对象方法中，消息是对象间交互信息的主要方式。<br>结构化程序设计中，模块间传递信息的方式主要是过程（或函数）调用。</p><p><em>消息分类：</em></p><p>同步消息：消息名称通常就是被调用的操作名称。【普通箭头】</p><p>异步消息表示发送消息的对象不用等待回应的返回消息，即可开始另一个活动。【半箭头】</p><p>一个对象也可以将一个消息发送给它自己，这就是反身消息。【指向自己】</p><p>返回消息是顺序图的一个可选择部分，它表示控制流从过程调用的返回。【返回的虚线箭头】<br>一般可以缺省，隐含表示每一个调用都有一个配对的调用返回。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034781.png" alt="image-20211215170104945" style="zoom: 80%;" /><p>要注意创建和销毁<em>临时对象</em>的画法</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034782.png" alt="image-20220102224940022" style="zoom:50%;" /><p>步骤：Ø确定交互的范围、Ø识别参与交互的对象和活动者、Ø设置对象生命线的开始和结束、Ø设置消息、Ø细化消息</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034783.png" alt="image-20211215170552213" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034784.png" alt="image-20220105194213354"></p><blockquote><p>面向对象设计原则【有用】：</p><p>强调定义软件对象，并且使这些软件对象相互协作来满足用户需求。</p><p>注意：</p><p>• 对接口进行设计<br>• 发现变化并且封装它<br>• 先考虑聚合然后考虑继承</p><p>强内聚：一个类的属性和操作全部都是完成某个任务所必须的，其中不包括无用的属性和操作。</p><p>弱耦合：耦合主要指不同对象之间相互关联的程度。如果一个对象过多地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。<br>当两个对象必须相互联系时，应该通过<u>类的公共接口实现耦合</u>，不应该依赖于类的具体实现细节。</p><p>可重用性：</p><p>• 尽量使用已有的类，包括开发环境提供的类库和已有的相似的类；<br>• 如果确实需要创建新类，则在设计这些新类时考虑将来的可重用性</p><p>框架：</p><p>框架是一组可用于不同应用的类的集合。框架中的类通常是一些抽象类并且相互有联系，可以通过继承的方式使用这些类。</p></blockquote><h2 id="质量保证（1）"><a href="#质量保证（1）" class="headerlink" title="质量保证（1）"></a>质量保证（1）</h2><p><strong>质量保证（QA）概念</strong></p><p>定义：系统地监测和评估一个工程的各个方面，以最大限度地提高由生产过程实现的质量的最低标准。</p><p>原则：适合用途：该产品应<u>符合预期的目的</u>          一次成功：<u>错误应该被淘汰</u></p><p><strong>软件质量</strong>：明确表示是否符合功能和性能要求，明确地记载开发标准和期望的隐性特点</p><ul><li>符合明确规定的功能和性能要求（前期约定）</li><li>符合明确的开发标准（明确标准）</li><li>符合所有软件开发专业的共性、隐性标准，如易用性、可维护性等（共性期望）</li></ul><p><strong>软件质量保证（SQA）</strong></p><p>遵照一定的软件生产标准、过程和步骤对软件质量进行评估的活动</p><p><strong>评估指标</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034785.png" alt="image-20211216104448415" style="zoom:67%;" align = 'left'/><p><strong>可靠性是</strong>一个持续性的状态，更多地强调系统自身；<br>可用性是一个短暂的状态，更多地强调外部的触发。<br>一个人如果随叫随到，但是时不时偷懒，就是高可用、低可靠；而如果他经常找不到人，但干活很负责，就是低可用、高可靠。</p><p><strong>V模型！</strong></p><p><u>要注意水平对应关系！</u>(这个和之前瀑布的图差了很多)</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034786.png" alt="image-20211216104609617" style="zoom:67%;" align = 'left'/><ol><li><strong>单元测试</strong>的主要目的是验证<u>软件模块</u> 是否按详细设计的规格说明<u>正确运行</u>。</li></ol><p>单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p><p><em>测试内容</em>：<u>模块接口 + 局部数据结构 + 边界条件 + 独立路径 + 出错处理</u></p><p>主要内容：模块接口测试（数据流、内外存交换）、局部数据结构测试、路径测试、错误处理测试、边界测试（流边界、关键路径）</p><p><em>测试环境</em>：模块并非独立程序，进行测试时，要考虑它和外界的联系，需用一些辅助模块去做相应模拟。</p><ul><li>驱动模块：用来模拟被测试模块的上一级模块，相当于被测模块的主程序。</li><li>桩模块：模拟被测试的模块所调用的模块，而不是软件产品的组成的部分。</li></ul><ol start="2"><li><strong>集成测试</strong>主要目的是检查<u>多个模块间</u> 是否按概要设计说明的方式<u>协同工作</u>。</li></ol><p>将软件集成起来后进行测试。检查诸如两个模块单独运行正常，但集成起来运行可能出现问题的情况。</p><p><em>自顶向下</em>：将模块按系统程序结构，沿控制层次自顶向下进行集成。<br>可首先实现和验证一个完整的软件功能。桩模块的开发量较大。<br>适用于：控制结构清晰稳定；高层接口变化较小；希望<u>尽早能看到产品的系统功能行为</u>，底层接口未定义或经常可能被修改。</p><p><em>自底向上</em>：从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成以进行测试。<br>不需要桩模块；必须编写驱动模块；缺陷的隔离和定位不如自顶向下。<br>适用于：底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。</p><p>实际工作中，常综合使用：自底向上、自顶向下</p><p><em>SMOKE方法</em>：<br>将已经转换为代码的软件构件集成为构造（build）。一个构造包括所有的数据文件、库、可复用的模块以及实现一个或多个产品功能所需的工程化构件。<br>每天将该构造与其他构造，及整个软件产品集成，进行冒烟测试。</p><ol start="3"><li><strong>系统测试</strong>的主要目的是验证<u>整个系统</u> 是否满足需求规格说明。</li></ol><p>从用户使用的角度进行测试，将完成了集成测试的系统放在真实的运行环境下进行。</p><p>目的：功能确认和验证       测试方法：黑盒测试</p><p>系统测试是软件开发过程必不可少的一环，<u>软件质量保证的最重要环节</u></p><p><em>测试内容</em>：面向：外部输入层测试，如不做，则<u>外部输入层向接口层转换</u>的代码就没有得到测试。</p><p>•    功能性测试：在规定的一段时间内运行软件系统的<u>所有功能</u>，以验证有无严重错误<br>•    性能测试：检查系统是否<u>满足需求规格说明书中的性能</u>，常与压力测试结合<br>•    压力测试：检查在系统<u>运行环境不正常乃至发生故障</u>的情况下，系统可以运行到何种程度的测试。敏感性测试<br>•    恢复测试：克服硬件故障后，系统能否继续正常工作。并不对系统造成任何损害。<br>•    安全测试：检测系统的安全性、保密性措施是否发挥作用，有无漏洞</p><ol start="4"><li><strong>验收测试</strong><u>从最终用户的角度检查系统是否满足合同中定义的需求</u>，以及以确认产品是否能符合<u>业务上的需要</u>。</li></ol><p>时间：系统的有效性测试及软件配置审查通过之后。人员：以用户为主。软件开发人员和 QA（质量保证）人员也应参加<br>测试数据：实际生产数据。</p><p><em>主要形式</em>：<br>根据合同的验收测试——系统测试子集再测试<br>用户验收测试：分为客户和最终用户<br>现场测试：α测试、β测试</p><p><em>α测试</em>：是由公司内部的用户在 开发环境下进行的测试，模拟实际操作环境下进行的测试。<br>评价FLURPS特性（功能、本地化、可使用性、可靠性、性能和支持）。尤其界面和特色<br>开始时间：模块（子系统）测试完成后<u>系统测试过程中产品达到一定的稳定和可靠程度后</u>。</p><p><em>β测试</em>：多个用户在实际使用环境下进行测试。这些用户返回有关错误信息给开发者。<br>用户记录所有问题（真实的、主观的），定期向开发者报告。<br>评价 产品的FLURPS。着重产品的支持性（文档、客户培训和支持产品生产能力）<br>开始时间：α测试达到一定的可靠程度时开始，<u>测试的最后阶段，所有手册文本此阶段完全定稿</u></p><p><strong>回归测试</strong></p><p>指有选择地重新测试系统或其组件，以验证<u>对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。</u></p><p>Why：<br>测试中，如有<u>缺陷修正、功能增加，变化的部分</u>必须再测试。<u>软件的修改可能会导致新的缺陷及其他问题</u>。为防止，需再测试。</p><p>回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中。范围：</p><ul><li>缺陷再测试：重新运行所有发现故障的测试，而新的软件版本已经修正了这些故障。</li><li>功能改变的测试：测试所有修改或修正过的程序部分。</li><li>新功能测试：测试所有新集成的程序。</li><li>完全回归测试：测试整个系统。</li></ul><hr><p><strong>软件缺陷</strong></p><p>至少满足下列一个条件，称发生了一个软件缺陷</p><p>(1) 软件<u>未实现</u>产品说明书要求的功能。<br>(2) 软件出现了产品说明书指明不能出现的<u>错误</u>。<br>(3) 软件<u>实现了产品说明书未提到的功能。</u><br>(4) 软件未实现产品说明书<u>虽未明确提及但应该实现的目标。</u>（xswl）<br>(5) 软件难以理解、不易使用、运行缓慢或者——从测试员的角度看——最终用户会认为不好。</p><p><strong>验证</strong>（Verification）保证软件特定开发阶段的输出已经正确完整地实现了规格说明<br>（我们正确地构造了产品吗？）</p><p><strong>确认</strong>（Validation）对于每个测试级别，都要检查开发活动的输出是否满足具体的需求或与这些特定级别相关的需求<br>（我们构造了正确的产品吗？）</p><p><strong>测试</strong>（补救）<br><u>找出软件缺陷</u>，并确保缺陷得以修复</p><p><strong>质量保证</strong>（预防）<br>创建和执行改进、软件开发过程并<u>防止软件缺陷发生</u>的标准和方法。</p><p><strong>质量与可靠性</strong><br>功能性、可靠性、可维护性、可用性、效率、可移植性。</p><p><strong>软件测试</strong>：目标是发现软件缺陷的存在</p><p><strong>软件调试</strong>：目标是定位与修复缺陷</p><p><strong>测试用例</strong>（test case）：是<u>测试输入、执行条件、以及预期结果</u>的集合<br>是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合。<br>设计格式：【输入的(oldpwd, newpwd, newpwdag)，输出的(提示1,提示2)】</p><hr><p><strong>白盒测试</strong></p><p>考虑系统或组件的内部机制的测试形式（如分支测试、路径测试、语句测试等），也称结构性测试或逻辑驱动测试。</p><p><em>逻辑覆盖</em> 是以程序内部的逻辑结构为基础的设计测试用例的技术。</p><p><strong>每条边设置个英文字母，每条路径设置个$L_i$</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034787.png" alt="image-20220103094104162" style="zoom: 67%;" /><ol><li><p>语句覆盖：就是设计若干个测试用例，运行被测程序，使得<u>每一可执行语句</u>至少执行一次。</p></li><li><p>分支覆盖/判定覆盖：使得程序中<u>每个判断的取真分支和取假分支</u>至少经历一次。</p></li><li><p>条件覆盖：使得程序中每个判断的<u>每个条件的可能取值</u>至少执行一次。只要每个可能都出现过就好，理论上最少2次就行。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034788.png" alt="image-20220105150214533" style="zoom:50%;" /></li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034789.png" alt="image-20220103094444920" style="zoom:67%;" /><ol start="4"><li>条件组合覆盖：使得每个判断的所有可能的条件取值组合至少执行一次<br>一个判断里，可能有多个条件$T_1,T_2…T_n$,每个条件两种可能，组合起来就是$2^n$种。(还要做标记)</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034790.png" alt="image-20220103094510612" style="zoom:67%;" /><p><em>控制流图覆盖</em> 是将代码转变为控制流图（CFG），基于其进行测试的技术</p><p>结点：符号○ ，表示一个或多个无分支的PDL语句或源程序语句。<br>边：箭头，表示控制流的方向。<br>汇聚节点：在选择或多分支结构中，<strong>分支的汇聚处应有一个汇聚结点。这个不能漏，不然算复杂度会错</strong><br>区域：<u>边和结点圈定的区域</u>。对区域计数时，图形外的区域也应记为一个区域。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034791.png" alt="image-20211216144744301" style="zoom:67%;" align = 'left'/><ol><li><p>节点覆盖</p><p>对图中的每个节点，至少要有一条测试路径访问该节点显然，节点覆盖=语句覆盖<br>节点覆盖和<u>语句覆盖是等价的</u>。</p></li><li><p>边覆盖</p><p>对图中每一个可到达的长度小于(无边图)等于1 的路径，中至少存在一条测试路径覆盖。显然，边覆盖包含节点覆盖，且边覆盖也可以<u>实现分支覆盖</u>。</p></li><li><p>路径覆盖</p><p>覆盖程序中所有可能的路径，</p></li><li><p>基本路径覆盖</p><p>独立路径：至少包含有一条在其它独立路径中从未有过的边的路径</p><p>找独立路径条数：V(G)（环路复杂度） = e（边数）−n（结点数）+2</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034792.png" alt="image-20220103095027872" style="zoom:67%;" /><p>开始的点被舍掉，连续的点，比如2，3和4，5被<u>合并到一个节点</u></p><p>找基本路径：每次<u>回溯</u>上一个节点，即从最后一个节点倒推，如果能走新的路就走新的路。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034793.png" alt="image-20220103095206100"></p></li></ol><hr><p><strong>黑盒技术</strong></p><p>黑盒测试：忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式</p><p><em>等价类划分</em>：</p><p>把所有可能的输入数据，即 程序的输入域划分成若干部分，然后从每一部分中 选取少数有代表性的数据做为测试用例。</p><p>等价类：某个输入域的子集合。在该子集合中，各个输入数据对于<u>揭露程序中的错误都是等效</u>的。</p><p>有效等价类：对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。</p><p>无效等价类：对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。</p><p>原则：</p><p>(1) 如果输入条件规定了取值<u>范围</u>，或值的个数（范围），则可以确立一个有效等价类和两个无效等价类。<br>(2) 如果输入条件规定了输入值的<u>集合</u>，或者是规定了“必须如何”的条件，这时可确立一个有效等价类和一个无效等价类。<br>(3) 如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。<br>(4) 如果规定了输入数据的一组值，而且程序要<u>对每个输入值分别进行处理</u>（不同于 2 ）。这时可为 每一个输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。<br>(5) 如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从<u>不同角度违反规则</u>）。（比如，输入条件：学生的学院字段数据类型，那有效等价类：字符串型；无效等价类：整数、浮点、布尔型）</p><p>【2和5相比，5只是规定了一项规则，2直接规定了整个集合】</p><p>步骤：</p><p>列出表【输入条件、有效等价类、无效等价类】为每个等价类规定一个唯一编号<br>测试用例尽可能多地覆盖尚未被覆盖的有效等价类，仅覆盖一个尚未被覆盖的无效等价类</p><blockquote><p>例：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034794.png" alt="image-20211216151109884" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034795.png" alt="image-20211216151123275" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034796.png" alt="image-20211216151144014" style="zoom:67%;" /></blockquote><p><em>边界值分析</em></p><p>对等价类划分方法的补充，大量的错误是发生在输入或输出范围边界上</p><p>闭区间：选择边界点、边界点加一个步长的点和边界点减一个步长设计测试用例</p><p>开区间：选择边界点、边界点范围内方向移动一个步长的点计测试用例。</p><p><u>上点</u>，即边界上的点，不管是开区间还是闭区间。<br><u>内点</u>，上点范围内的任意一点。<br><u>离点</u>，离上点最近的点称为离点。<u>开区间为上点范围内</u>加一个步长，闭区间为<u>上点范围外</u>加一个步长。</p><p>比如[85,100]，离点就是 84，101      (0,60)，离点就是1，59，  [60,75) 离点 59,74</p><p>所以一元函数有5个测试用例。</p><p>二元函数：</p><p>先列出每一个变量的上点、内点和离点（5*2）。</p><p>用第一个变量的上点、离点与第二个变量的内点配对设计4个测试用例<br>用第一个变量的内点与第二个变量的上点、离点配对设计4个测试用例<br>最后两个变量的内点配对形成最后一个测试用例，共设计9个测试用例。</p><p>多元函数类似，都是某个变量的上点、离点配上别的元的内点，再加上一个都是内点，共$4n+1$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034797.png" alt="image-20220103102412117" style="zoom: 50%;" /><p>黑盒还有一种<em>状态测试</em>。</p><p>在黑盒测试阶段，通过对状态的测试间接地加以验证功能</p><p>建立状态转换图-&gt;根据状态转换图设计测试用例。</p><p>灰盒测试：<br>介于白盒测试与黑盒测试之间的一种测试，多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况</p><p><strong>静态分析</strong></p><p><u>不运行程序</u>，通过检查和阅读等手段来发现错误并评估代码质量的测试技术</p><p>主要内容：检查<u>需求、设计、代码</u>（缺陷产生的可能由大到小）</p><p>类型：同事审查（初次）、走查（开发组内部进行）、审查（会议形式，开发组、测试组和相关人员联合进行）</p><h2 id="项目管理（2）"><a href="#项目管理（2）" class="headerlink" title="项目管理（2）"></a>项目管理（2）</h2><p><em>项目管理</em>：计划、协调、度量、监控、控制及报告等管理方法<u>在软件开发和维护中的具体应用</u><br>以保证整个过程是系统的、有原则的、可量化的</p><p><strong>四要素</strong>：人员(People)、产品(Product)、过程(Process)、项目(Project)。</p><p>关键业务领域：招聘、选拔、绩效管理、培训、薪酬、职业发展、组织和工作设计、团队/文化的发展。</p><p>在策划一个项目以前，应当建立产品的<u>目标和范围</u>，应考虑其他解决办法，以及技术和管理应当被约束。</p><p>软件开发的一个全面计划</p><p>理解成功项目管理的关键因素，掌握项目计划、监控和控制的一般方法</p><p><strong>软件度量</strong>：</p><p>一种量化衡量方法,使得人们可以理解和把握软件项目的(生产)效率(或者所需要的劳动量)</p><p>目的：软件项目管理的成熟化也需要<u>度量与数字化</u>，目的是<u>持续改进软件过程，并用于项目估算、质量控制、生产率评估</u>等</p><p><em>面向规模</em>【直接测量】：</p><p>通过<u>对质量和（或）生产率的测量进行规范化</u>而得到的，这些测量是根据开发过的软件的规模得到的。</p><ul><li> 千行代码（ KLOC ）： 这些代码指的是源代码，通过源代码的行数来直观度量一个软件程序有多大规模</li><li>生产率（PM）：PM = L / E, L表示<u>代码总量</u>(单位：KLOC)，E表示<u>软件工作量</u>(单位：人月)</li><li> 每千行代码的平均成本（ CKL ）：CKL = S / L，S为软件项目总开销 </li><li>代码出错率（EQRl）：EQRl = Ne / L，Ne表示代码出错的行数</li><li>文档与代码比（Dl）：Dl = Pd / L，Pd表示文档页数</li></ul><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034798.png" alt="image-20211217100450012" style="zoom:67%;" /><p>简单易行，自然直观；但 软件开发初期很难估算出最终软件的代码行数，对短小精悍的程序不利</p><p><em>面向功能</em>【间接测量】</p><p>功能点（Function Point, FP）法，项目开发<u>初期就可估算出</u></p><p>方法：先算未调整功能点总计数 UFC，再算功能点 FP</p><p>$FP = UFC×TCF = UFC × (0.65 + 0.01×\sum F_i)$</p><p>UFC相关的五类组件：内部逻辑文件ILF、外部接口文件EIF、外部输入EI、外部输出EO、外部查询EQ。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034799.png" alt="image-20211217101343777" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034801.png" alt="image-20211217101407856" style="zoom:50%;" /></p><p>至于14个复杂性调节因素 $F_i$从0【没有影响】到5【严重影响】</p><p>优点：与程序设计语言无关, 在开发前就可以估算出软件项目的规模</p><p>不足：没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统，功能点计算主要靠经验公式，主观因素比较多</p><p>FP起到了代码行的作用，但是也可以换算，估计不考👇</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034802.png" alt="image-20220102162809429" style="zoom:50%;" /><p><strong>项目估算</strong></p><p>分两种</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034803.png" alt="image-20220102162431806" style="zoom:50%;" /><p><em>基于问题分解的估算</em></p><p>就是把问题分解成各个子系统，分别估算，最后合并。</p><p>三点期望法：估计期望值=(最大值＋4×最可能值＋最小值) / 6</p><p>基于LOC的估算：估算出各个子系统的代码行（直接主观猜）</p><p>用LOC或FP算出LOC总代码行或FP功能点数，然后结合历史数据</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034804.png" alt="image-20220102163248576" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034805.png" alt="image-20220102163345120" style="zoom:50%;" /><p><em>基于回归分析的经验估算模型</em></p><p>$E=A+B×(e_v )^ C$ 其中E是工作量（人月），$e_v$是估算变量（LOC或功能点）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034806.png" alt="image-20211217135256729" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034807.png" alt="image-20211217135311450" style="zoom:67%;" /></p><p><strong>COCOMO经验估算模型</strong>（COnstructive COst MOdel，构造性成本模型）</p><p>是一个综合经验模型，模型中的参数取值来自于<u>经验值，并且综合了诸多的因素、比较全面的估算模型</u></p><p><u>用来根据KLOC算工作量和开发时间</u></p><p>模型层级</p><ul><li>基本COCOMO模型：估算整个系统的工作量(包括维护)和软件开发和维护所需的时间</li><li>中间COCOMO模型：估算各个子系统的工作量和开发时间</li><li>详细COCOMO模型：估算独立的软构件，如各个子系统的各个模块的工作量和开发时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034808.png" alt="image-20211217135834159" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034809.png" alt="image-20220102163524699" style="zoom:50%;" /></p><p>EAF的取值(考虑15个因素) 建议取值范围[0.70-1.66] EAF的计算＝$\prod F_i  ( i=1..15)$</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034810.png" alt="image-20220102163925277" style="zoom:50%;" /><p><strong>项目计划</strong></p><p>对项目进行任务划分，定义任务之间的<u>依赖关系</u>，并进行<u>时间估算和资源分配</u>，确保以最佳的时间与成本输出满足质量要求的产品。</p><p>编制项目计划本质是一个<u>优化问题</u>。</p><p>项目计划可视化用甘特图</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034811.png" alt="image-20211217140902607" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034812.png" alt="image-20211217140924890" style="zoom:67%;" /><p>关键路径——在任务网络图中，从项目开始到项目完成有许多条路径，路径上<u>所有弧权重之和最大的路径</u>（路径最长）叫关键路径。</p><h2 id="软件维护（2）"><a href="#软件维护（2）" class="headerlink" title="软件维护（2）"></a>软件维护（2）</h2><p>定义：由于软件产品出现问题或需要改进，而对代码及相关文档进行修改，</p><p>目的：对现有软件产品进行修改的同时保持其完整性</p><p>软件维护阶段一般要消耗软件生命周期中经费开支的大部分</p><p><strong>四种基本类型</strong>：</p><p>完善性维护【一半以上】扩充软件功能、增强软件性能、 改进加工效率、 提高软件的可维护性<br>纠错性维护<br>适应性维护（环境变化）<br>预防性维护【最少】采用先进的软件工程方法对需要维护的软件或软件中的 某一部分（重新）进行设计、编制和测试</p><p>决定软件<u>可维护性</u>的主要因素：可理解性、可测试性、可修改性、可移植性、可重用性</p><p>影响软件可维护性的<u>环境因素</u>——软件维护的文档、软件的运行环境、软件的维护组织、软件维护质量。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034813.png" alt="image-20211217141553964" style="zoom:67%;" /><p><strong>软件维护技术</strong></p><p>程序的理解：建立从问题/应用域到程序设计/实现域的映射集</p><p>程序理解的具体任务：</p><p>通过检查单个的程序设计结构，程序被表示成抽象语法树、符号表或普通源文本<br>尽量做到程序隐含信息的显性表示及程序内部关系的可视化<br>检查程序构造过程中的结构关系，明确表示程序组成部分之间的依赖关系。</p><p><em>软件再工程</em>：<br>对现有软件进行仔细审查和改造，对其<u>进行重新构造</u>，使之成为一个新的形式，同时包括随之产生的对新形式的实现。</p><p><em>软件逆向工程</em>：<br><u>分析目标系统，识别系统的构件及其交互关系</u>，并且通过高层抽象或其他形式来展现目标系统的过程。</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034814.png" alt="image-20211217141846309" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034815.png" alt="image-20220103111000545" style="zoom:50%;" /></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件工程（2）&quot;&gt;&lt;a href=&quot;#软件工程（2）&quot; class=&quot;headerlink&quot; title=&quot;软件工程（2）&quot;&gt;&lt;/a&gt;软件工程（2）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;软件的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;软件= 程序+ 数据+ 文档&lt;/u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《十年一梦》</title>
    <link href="https://darren-dong.com/2021/06/15/%E5%8D%81%E5%B9%B4%E4%B8%80%E6%A2%A6/"/>
    <id>https://darren-dong.com/2021/06/15/%E5%8D%81%E5%B9%B4%E4%B8%80%E6%A2%A6/</id>
    <published>2021-06-15T03:22:57.000Z</published>
    <updated>2022-05-09T03:06:17.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十年一梦"><a href="#十年一梦" class="headerlink" title="十年一梦"></a>十年一梦</h1><p>第一篇<strong>读书笔记</strong>，我也不知道该咋写。。</p><h2 id="序1-唯有事实"><a href="#序1-唯有事实" class="headerlink" title="序1 唯有事实"></a>序1 唯有事实</h2><p>我们的认知需要建立在确切的<strong>事实</strong>上，不然就是无根之萍。事实应该包括两个方面，一个是我们自己，另一个是我们所面对的对象，在面对市场的时候，通常假定谁也改变不了市场，只能适应市场，因此我们更有理由重视“自己”</p><p>我们通常忽略自己，但是这是致命的错误，<strong>我们应该主动适应市场</strong>，成为行动的主体但是要认清自己实在是太难了，我们一言一行对周围的影响远超我们的外观。然而我们对这方面<strong>缺乏足够的参照物</strong>，在社会上，这些后果需要相当长的周期才能看得到，以至于我们可能忘记了前因后果，更何况大部分人总是缺乏反思和改正的想法。</p><p>对于学习市场操作，其实很不错，因为反馈是即刻的，这对于认知自己非常有效，但是我们要注意改进和纠正</p><p>另一方面，认清我们面对的对象也并非易事，每个人都有特定而局限的角度和立场，而这些不一定是最佳的，更不可能是全面的，甚至还随时间而改变。关于对象，我们获得的信息也总是滞后、有限的，观察方法和工具也受到时代的限制和自身能力的限制。</p><p>因此，获取事实是艰难的，但是这也是人生的主课，需要我们持续学习、领悟、突破。</p><p>这对初入社会的大学生是一个巨大的考验，光凭自己的人生经验和脑子，很难不吃苦头。</p><p>不要成为环境的奴隶，被各种情绪和刺激占据了所有的心思，做出过度的反应，而是要保持平静，认清这些事实，<strong>不应该预设某种态度</strong>，<strong>应保持思想的开放而不带着偏见</strong>（我感觉我最近偏见有点多了），但是这是十分占据时间精力的，我们要精挑细选有价值、有意义的刺激，而记住，<strong>刺激的重要程度并不和刺激的强度成正比</strong>。</p><p>做人做事从观察事实开始，进而采取行动；在行动过程中，还得持续观察行动的实际效果，反过来调整和修正行动。得到的事实越少，则虚妄的成本越多。</p><p>建议多读《大学》《中庸》《论语》《老子》，还有《周易》！具有极高的实践性，特别是针对个人行为的管理和塑造。尤其适合投资交易者，关键在自己能不能应用。还有就是研究实际案例。</p><p>第二本书《期货交易的策略与技巧》</p><h2 id="前言-艰难的路"><a href="#前言-艰难的路" class="headerlink" title="前言 艰难的路"></a>前言 艰难的路</h2><p><strong>期货交易是一条艰难的路</strong></p><p>不要小看期货交易的艰难性，两三年，甚至十年都是远远不够称得上是精通交易、战胜市场的，更别说孔子先生所说的“从心所欲不逾矩了”。</p><p>青泽先生认为的难点：</p><ol><li><p>理解、把握市场价格波动的特征难</p><p>最刻骨民心的莫过于市场价格的反复无常、神秘莫测，不确定性、随机性。</p><p>很多市场参与者都有一种认知误区：<strong>追求交易的确定性，把科学的思维简单应用到投机交易中，以为预测是市场交易的全部，希望找到一种科学的预测理论，但是这所谓的科学方法主张的严密和正确，其实很多时候不但无用武之地，还可能成为成功的障碍。</strong></p><p>当然，很多预测工具（比如波浪理论）确实很常用，有价值，但是不要把期货投机当作一门科学，事实上，什么理论都无法保证我们的交易和市场走势。</p><p><strong>投机领域充满了辩证法，模糊和缺陷是美，追求完美恰恰背道而驰</strong>。</p><p><u>市场价格运动表面看起来往往是一个偶然性接着另一个偶然性，但是在看似完全偶然的背后，市场也不是完全混乱无序，隐隐约约透露出一定的必然性或者说是趋势性。投机成功的核心就是要去追求，把握这种必然性。</u>，交易高手就是能够从表面上看来不确定、随机的市场波动中找到相对确定、比较有把握的机会，知道什么时候<strong>成功的概率高，比较有利，什么时候静观其变</strong></p><p>从抽象的层面、事后的角度我们可以看清规律，但是对于未来，需要投机者有客观、定量、科学的理性分析能力，也要有灵活、变通、前瞻的艺术、直觉</p></li><li><p>良好的风险管理难</p><p>市场不确定性、随机性的一面决定了投机永远有<strong>博弈的成分</strong>，不可能有科学系统的预测理论。</p><p>良好的风险管理是投资者的立身之本。</p><p><u>期货交易既是一门赢的艺术，更是一门控制风险的输的艺术</u></p><p>成功的投资者在交易中能做到严格控制损失，<strong>即使砍掉亏损部位</strong>，对盈利头寸则做到了尽可能地扩大战果</p><p>短期的走势偶然性、人为性，投机者的贪婪、恐惧等心理因素，是的投机者找到适合自己的风险管理策略并非易事，但是无论是怎样的交易方式，短或长，感性、程序化，都要坚持<strong>几个原则</strong>：</p><ul><li>任何一笔交易都不要出现大的损失</li><li>一如既往的采取试探——加码的交易策略</li><li>在行情走势和自己的判断不一致时迅速止损，一致时逐步加仓，扩大利润</li></ul><p>青泽把期货交易的盈利模式分为两类：仓位取胜（博弈型）、幅度取胜（趋势性），但核心一样。</p></li><li><p>了解自己、战胜自己难</p><p>在某种意义上说这是一个心理游戏，投机者应该做出正确的决策而不是舒服的决策，心理上舒服的决策结果往往很不好，遵守交易技术和资金管理策略，不要被情绪左右。</p><p>从交易之道到市场行为，隔了 知（了解），情（心理认同），意（执行的意志力），这三者的合力才能决定行为是否理性。</p><p>技术和基础知识其实一两年就够了，但是稳定、良好的心态和境界，这可能是一辈子的事</p></li></ol><p><u>关于期货最好的忠告：在开始之前就停止行动</u></p><p>有奇迹的故事，更有数不胜数的尸骨和黯然的退场</p><p>市场交易是残酷、险恶，梦醒之后，也不要忘记当年的热情和豪言壮志（我的热情还没开始呢！</p><p>青泽先生的前言是一篇难得的好文章。</p><h2 id="一、命运之门"><a href="#一、命运之门" class="headerlink" title="一、命运之门"></a>一、命运之门</h2><p>人的命运可以自己选择吗？可以，你可以走你愿意走的路。</p><p>但是，一旦你上了路，回头恐怕就没有那么容易了，人生的许多事情都无法重来一次。</p><p>人生就像一个怪圈。有些年轻时候认为无足轻重的问题，年龄大后可能觉得很重要，比如一个人的修养、个性、习惯等；有些年轻时认为很有意义的事，以后看来往往没有想象中那么有价值，比如年轻的时候某种特别的兴趣和爱好等。</p><p>索罗斯：“你不可能随心所欲，又在市场中有良好的表现”</p><p>一念之差，一面是个哲学领域的教授、学者。一面是专业投资家，睿智的赌徒。</p><p><strong>期货是浓缩的人生</strong>，交易世界和现实生活有着如梦如幻的巨大反差</p><p>当时头脑精明点就能赚到钱，大部分人都是先扎进去，然后才开始了解基本知识，现在的股市就凶险了许多，人们的整体素质高了不少，难度暴增。</p><p>大多数涉足股市的新手，只要在股票上赚过一次钱，就会被吸引住，从此欲罢不能，沉迷上瘾。心乱了</p><p>一次偶然的急于，让他成为公司的操盘手，即使当时毫无投资理念和策略，但这就是时代和命运。</p><p>这给了他坐着一个巨大的发展机会，也让他的人生充满跌宕起伏，承受了许多常人无法体会的坎坷磨难。曲折的经历，平淡的人生，都在羡慕着彼此。</p><h2 id="二、一个与众不同的赌徒"><a href="#二、一个与众不同的赌徒" class="headerlink" title="二、一个与众不同的赌徒"></a>二、一个与众不同的赌徒</h2><p>股票市场要赚大钱，不仅要靠知识，也要靠信念；不但要靠智慧，也要靠胆量。</p><p><strong>新手的运气往往很好</strong></p><p>有观点：新手想要在投机市场中赚钱，最佳策略时找机会大赌一次，而经验丰富，有胜算和有势的人反而应该注意控制资金，减少偶然性运气的影响。<strong>投机是一个大多数人必输的游戏。</strong></p><hr><p>理解股市：</p><p>西方发达国家证券市场诞生的意义来自经济发展的内在需要。有人需要筹集成本，有人希望投资，这是一个公平、高效的互惠互利、各取所需市场。</p><p>中国早期股市却打上了深深的中国特色烙印，为国有企业融资解困。因此判断国内市场我们既要看内在的市场规律，更要高度关注政治、决策的态度，这样才能提高投资的胜算。</p><ol><li><p>用政治眼光来审视股票市场，抓住市场可能出现的重大变化。</p><p>青泽认为在未来相当长的一段时间内仍是政策市，因此股票市场一点出现过于离谱的暴涨暴跌，就随时可能出现外在的力量左右市场走势，回到社会政治所能容忍的范围内。<strong>政治敏感度极其重要。</strong></p></li><li><p>抓住<strong>大行情</strong>可能来临的机会，长线交易，重仓交易，不贪小利，迷恋股市，整天炒来炒去。</p></li><li><p>绝不染指垃圾股，这些股票甚至在大牛市都没有出头之日。</p><p>分散投资是减少垃圾股上海的一个简单策略。</p></li></ol><p><u>重价不重势——典型的外行炒股手法。</u></p><p>作者有了一些新的认识：</p><p>如果股市波动时循环的，而长远看指数一直在稳步上涨，那么，投机者的操作只要稍稍聪明一点，不太干愚蠢的事，在一定意义上，股票交易其实一点风险都没有。作者希望投机者深入透彻地思考👇：</p><ol><li><p>操作手法问题。大利润一定来自于大的市场波动</p><p>要有足够的耐心等待永恒的牛熊循环，不要整天频繁的短线交易，在市场地无需波动中迷失自我</p></li><li><p>投机者的市场信念问题</p><p>巴菲特：“利润有时候往往来自对市场的愚忠”，对市场没有坚定信念的人，往往拿不住很有可能带来巨大回报的仓位，不能获得市场重大波动的利润。但是还是得远离垃圾股。</p></li><li><p>参与股票交易的投资者，对市场指数高低要有一些基本常识，不能犯太离谱的错误。</p><p>但是指数的高低总是相对的，判断起来不是简单的问题。</p></li></ol><hr><p>股票终究不是真正的赌场，背后有企业、业绩、国家政治的影响。</p><p>股市大跌后再买入，耐心等待下个牛市，这是一种常识，但遵循这个简单的真理却十分困难。</p><p>对市场短期走势过于在意，就不宜涉足股票市场。</p><p>通过抓住重大趋势波动来赢利的交易模式，只是一种策略，需要眼光、胆识、魄力和长线持仓的勇气。</p><p><u>对于操盘手来说，一两次交易中出现亏损是非常普通的事情，但是面对重大的历史机遇，在锐利的行情中只赚了小钱，这种错误是无法原谅的。</u></p><h2 id="三、误入“期”途"><a href="#三、误入“期”途" class="headerlink" title="三、误入“期”途"></a>三、误入“期”途</h2><p>【我刚玩投机就误入了hh】</p><p>我被自我一次次打倒，却不知道敌人在哪里。</p><p>在股票、期货这个弱肉强食的市场，大多数散户投机者的命运，就像天空中一只断了线的风筝，一会上升，一会儿下降。散户的资金、心理承受能力、市场经验决定他们注定是被动的牺牲品。在一个不规范的市场中，主力们只要略使小计，就能杀绝大部分跟风者</p><p><strong>如果股票是抽烟，那么期货就是毒品</strong></p><p>期货投机的魔力在于，对于单独某一次交易，即使是赌博，也有50%赢的可能。</p><p>尽管从账面上看，很多人的本金在一天天减少，但是偶尔的几次交易赢利，会使大多数投机者产生一种幻觉，迟早能重新赚回来，还有暴富的机会。但能赚回损失的人是少数。</p><p>短期交易没有什么道理可言，也无从分析，只是凭着感觉对市场波动做出反应。这样的人往往成了市场短期波动的俘虏，思维、情绪被支配，变得不由自主，控制不了自己的交易冲动，不愿失去一切交易机会，过度敏感。</p><p>赚的时候，幻想一直保持，亏的时候十分沮丧，但是一旦进入下一次交易，不佳的心情就被忘记。</p><h2 id="四、绝处逢生"><a href="#四、绝处逢生" class="headerlink" title="四、绝处逢生"></a>四、绝处逢生</h2><p>327之战。</p><p>这是作者的运气，但是也是作者的经验告诉他选择哪一边。</p><p>也许是年龄增长，市场中经历过的偶然性太多了，很多事情的评价标准有时反而变得模糊了。青泽先生现在也不能完全确定当初自己的举动（全仓多头）是疯狂、鲁莽还是大胆、勇敢。这取决于角度。</p><p>毫无疑问，这种重仓交易、以命相搏的交易手法是自取灭亡之道。</p><p>尽管有时候保守和谨慎可能是一种束缚人的枷锁，短期会拖投机者的后腿，但是长远来看，保守、谨慎、稳健无疑是期货交易者的立身之本。</p><p><strong>一旦一个人获得了如此辉煌的战绩，无论旁观者还是他自己，都会有意无意地把这种成功归功于投机者的主观因素，而对事情发生偶然性的一面选择性忽略。</strong></p><p><strong>对于一个职业投机客来说，交易是一条漫长地路，局部的输赢犹过眼云烟，实在是一件无足轻重地小时。过于拘泥某一笔交易地得失，对此痛心疾首或津津乐道，并非是一种聪明、理智的态度。只能说认识浅。</strong></p><h2 id="五、苦闷的求索"><a href="#五、苦闷的求索" class="headerlink" title="五、苦闷的求索"></a>五、苦闷的求索</h2><p>哲学家必须从感觉世界的”洞穴“上升到理智世界</p><p>但是一个人总不可能平白无故地进行行动，他需要某种行为方式和标准，至于这种权威是否可靠并不重要，不然这会让他面对波动不知所措。</p><p><strong>从预测制胜到重视资金、仓位的风险管理到心理、人生修养是一条漫长而痛苦的路。</strong></p><p>短期交易，迷惑人的心智，其实是赌博罢了。</p><hr><p><u>不可能有预测制胜，没有人能精确地预测市场的未来变化。</u></p><p><strong>市场交易是一个动态、系统的控制过程。理解价格变化、判断未来走势只是成功交易的一个不是最重要的环节</strong></p><p>在实际操作中：</p><ul><li>每一次交易投入的资金多少</li><li>情况不利时如何处理，有利时如何加码</li><li>价码后出现有利、不利情况如何应对</li><li>影里的交易怎样既不由赢转亏，又不丧失一旦市场大波动带来的暴利等</li></ul><p><em><strong>这些问题的应对技巧、策略、方法，远比希望准确预测走势重要得多，需要投机者有一套完整、系统的交易思路。</strong></em></p><hr><p>确实，在大行情下的急剧波动，不论多空其实都无安宁。</p><p>据好事者统计，当年在股票、国债期货市场上赚过大钱的人，90%的结局都不太妙，这反映了一些东西。</p><p><u>投机市场中，一个人偶尔可以赚大钱也许并不难，难的是一直稳稳当当地赚钱，而且守得住钱。</u></p><p><a href="https://baike.baidu.com/item/%E7%AE%A1%E9%87%91%E7%94%9F/10343491">管金生</a></p><p>他们藐视法律，操纵行情，玩弄市场。</p><p>中经开的营业部令人向往——神奇的部门</p><p>早期国内股票市场、期货市场，市场操纵横行，政府法规朝令夕改，普通投机者生存环境十分恶劣，在这样的情况下，已经不能完全的归结于投机者自身的内在原因，外界因素几乎对投资者的命运起到决定性的作用</p><h2 id="六、纸上富贵一场梦"><a href="#六、纸上富贵一场梦" class="headerlink" title="六、纸上富贵一场梦"></a>六、纸上富贵一场梦</h2><p>1995，国债期货叫停，游资转战上海、深圳股票市场。</p><p>一次典型的纸上富贵——两鸟在林不如一鸟在手，但是谁有真正看得清这一点呢。</p><p>鞍山信托的一枝独秀——庄家也可能犯错。</p><p>市场里，没有庄家，往往走势清淡乏味。投机者没有机会</p><p>但是庄家来了以后兴风作浪。谁都不可能独善其身，包括庄家自己。</p><h2 id="七、单纯与复杂"><a href="#七、单纯与复杂" class="headerlink" title="七、单纯与复杂"></a>七、单纯与复杂</h2><p>——交易有那么难么</p><p>在成千上万的交易后，总的结果取决于投机者综合实力和心理优势，而不是一两次的市场预测能力。</p><p>在实际交易中，投机者会面临巨大的心理、精神压力，这是一个股评家不能完全了解和体会的。</p><p>一旦建立头寸，趋势就不像原先一般客观、超然、自信，你的恐惧、焦虑、患得患失等主观因素很有可能扭曲你的思维，使你陷入混乱。你当初的判断完全准确，但是你没有从中赚到钱。</p><p>不要依靠盘面变化和市场感觉、本能杀进杀出，这是缺乏理性的，也缺乏外在的客观约束。</p><p>要从长远分析市场状态和下一步变化的可能。看大势，理性审视。</p><p>在期货交易中，如果投机者入市后三天都没有出现利润，立刻平仓出场。</p><p>作者的第一个月大获成功，他在日后也感慨那段时间的美妙和带给他的信心，他总结：</p><ol><li><p>精神、心理条件非常好。</p><p>保持谨慎的态度，反复思考，再三权衡。</p><p>不要奢望一夜之间赚大钱，不要被急躁、贪婪的欲望支配。</p><p>没有交易的损失，没有历史包袱，不会畏手畏脚，在需要大胆行动时犹豫不决</p></li><li><p>中线顺势操作</p><p>中线顺势交易是期货赚钱的最佳策略</p></li><li><p>严格的风险控制</p></li><li><p>加码策略</p><p>试探-加码策略。在第一次投资后，如果市场走势证明判断错误，立马离场。否则便一次次加码，即使资金量不大，这样总能赚大钱，亏小钱。</p></li><li><p>时代和运气</p></li></ol><h2 id="八、兵败苏州红小豆"><a href="#八、兵败苏州红小豆" class="headerlink" title="八、兵败苏州红小豆"></a>八、兵败苏州红小豆</h2><p>当你将身体交给一个陌生人任意处置，你一定会感到愤慨。那么，当你将自己的精神交给一个偶遇者任意处置时，你难道不感到羞愧吗？</p><p><u>许多投机大师都反对利用内幕消息交易，认为这是投机者自我毁灭的捷径</u></p><p>因为急于翻本，作者被负面情绪支配，越做越赔，越赔越做。</p><h2 id="九、与天为敌"><a href="#九、与天为敌" class="headerlink" title="九、与天为敌"></a>九、与天为敌</h2><p>重仓交易的危害</p><p><strong>以安全性为代价追求收益率最终往往是得不偿失的</strong>。——本杰明</p><p>在期货交易中，一个人的心理、精神状态远比他拥有的市场知识和预测技术重要得多</p><p>作者准确的把握了几次做大钱的趋势，但却被短线思维所害，无法贯彻中长线交易的策略和原则。这是一种从“中长线”开始衍生出的一系列思维模式吧</p><p>害怕自己到手的利润得而复失，不愿继续等待利润自然而然地增长，不断换市场。仿佛非常忙碌，但一无所获</p><p><strong>经验不是你经历过什么，而是你从经历中学到了什么，<em>包括别人的经历</em></strong></p><p>期货的成功建立在一个非常危险的观念之上，就像脆弱地基上的大楼，来的快，去的也快。</p><p>P114生动的讲述了作者在面对期货起落的精神状态</p><p>来自十年后的反思：</p><ol><li><p>对于大多数人来说，即使拿出五分之一的资产来从事期货投机，也是危险的</p><p>保守、胆小的行为其实是高瞻远瞩，胆大妄为的重仓交易，早晚会在市场中牺牲。</p></li><li><p>坏习惯“钱烧口袋漏，一有就不留”</p><p>交易的姬会不是每天都有，不能凭想象行事，否则就是不尊重市场，将会受到市场的惩罚</p></li><li><p>在期货市场可以赚大钱，但需要时间，量的积累带来质的飞跃</p><p>重仓交易者企图战胜时间的束缚，一夜暴富，辉煌的成功靠的是以命相搏，一次意外就可能彻底失败。</p><p>真正成功的人，要么是拥有极其强大的意志，在赌赢后果断离场，要么靠的是长期、稳定的赢利。</p></li></ol><p>索罗斯：</p><ul><li>相对于近期赢利，我更关心<strong>基金资本的安全</strong></li><li>我主要还是着眼于<strong>限制亏损</strong>，而不是牟取暴利</li></ul><h2 id="十、激战海南咖啡"><a href="#十、激战海南咖啡" class="headerlink" title="十、激战海南咖啡"></a>十、激战海南咖啡</h2><p>面对诱惑，人的记忆力总显得太弱</p><p>期货市场本应是用来规避风险的地方，然而，曾几何时，在国内的一些交易所，期货却成了制造风险，激化矛盾的东西。</p><p>海南咖啡交易的几大特点：</p><ol><li><p>咖啡纯粹只是个符号被炒作</p><p>它托利里基本面因素和供求关系的制约，谁也不知道内在价值是多少。</p><p>没有人想阵得买进咖啡，投机者的唯一目的是赚取市场差价，最终结果是金钱的重新分配而已。</p><p>这不就是数字货币的雏形吗</p></li><li><p>波动巨大，虽然比不过炒币</p></li><li><p>波动方式诡异，凶狠，残酷</p><p>常规的风险控制措施不管用，绝对不能出现方向性的措施，连续性的跌涨停板，没有逃命的姬会。</p></li><li><p>市场主力争斗你死我活、白热化</p><p>大量非市场因素参与其中</p></li></ol><p><strong>方向判断准确只是交易成功的第一步，并且可能不是最关键的一步。</strong></p><p><strong>赚大钱最主要的是投机者需要有大的耐心和忍耐力，面对短期波动的不确定性、反复无常，要坚定自己的市场信念。</strong></p><p><em><strong>能否抵御市场短期波动的威胁、欺骗，是顺势交易最令人头疼而不得不面对的现实问题。</strong></em></p><p>K线完全是形而上的思维方式，用静止，片面而孤立的观点看待市场，一叶障目，应该从整体，全局，的角度看待。</p><h2 id="十一、逆势操作的反思"><a href="#十一、逆势操作的反思" class="headerlink" title="十一、逆势操作的反思"></a>十一、逆势操作的反思</h2><p><strong>你不可能靠风向标致富</strong>——巴菲特</p><p>比起重仓的谨慎，逆势者像温水里的青蛙，慢慢丧命。</p><p>大多数情况下，市场的趋势运动是温和、缓慢演变的，趋势都不是很明显，具有偶然性和随机性</p><p>所以逆势操作有可能也能赚到钱，因此其巨大危险性不易察觉，直到大势到来，恶果就暴露无遗。</p><p>一般来说，操纵者并不怕市场对手，他们更怕法律和市场监管。期货市场不完善和监管缺失，使他们有机可乘，那么数字货币呢？</p><p>这些折戟的精英们，每一件失败的事都有大量的偶然因素，但是偶然背后也有必然的一面，他们有一些共同的特点：</p><ol><li><p>自负和贪婪</p><p>大多数人似乎总是高估自己的判断力，过于自负</p><p>如果一个投资者顺势交易，他往往觉得自己没有格调，不能证明自己，一旦被套住他会觉得自己愚蠢，一旦成功他会给予自己极高的评价。</p><p>当自负和贪婪集中在一个人身上，尤其是掌握巨额资金的大人物身上，悲剧就开始上演了。</p></li><li><p>侥幸</p><p>心理学预期认为：失败的时候我们是风险的爱好者，有盈利时我们是风险的厌恶者。</p><p><strong>大多数人都是这样，赚小钱、亏大钱，刚好与正确的交易原则相反。</strong></p><p>其实，任何巨大损失的造成，除了突发性消息引起的个别意外情况，一般有从到质变的过程。</p><p>没有人能避免错误，我们能做的只有——止损原则。</p></li><li><p>虚荣</p><p><u>处于自我保护和虚荣的本能下，不愿让别人知道自己犯的错误。</u></p><p>一大群投机者在牛市做空的原因：</p><ol><li>市场行情看似是高估的</li><li>市场行情的矫正时间到了</li><li>他们听到一个看跌的消息，认为价格将会下跌</li><li>消息</li></ol></li></ol><p>人们不愿反思、正视自己的弱点，不愿承认因为缺乏自我约束而犯下的愚蠢错误，故意遗忘掉那些令人不快的痛苦经历。</p><p>理由是：</p><ol><li><p>短线交易方式隐含的天然缺陷</p><p>过于注重细节的人，往往对大事情一无所知</p></li><li><p>总比市场慢一拍的思维</p><p><strong>总以为历史会简单的重复</strong></p></li><li><p>作者迷失在短期波动的大海里</p><p>投机者很容易沉溺短线思维而失去超然的思维，让投机者不知不觉中，稀里糊涂地变成了一个逆势交易者</p></li><li><p>市场趋势会反弹吗？——思维陷阱</p><p>任何一个市场趋势一旦明朗，市场价格往往已经涨跌了相当幅度。</p><p>在这种情况下，市场趋势随时反转的可能性并非不存在。一般人很难不折不扣地遵循顺势投资地原则，就是怕趋势反转。</p><p><strong>在市场交易中，投机者应该做出正确地决策，而不是做出让自己感觉舒服的决策。</strong>所以说投机是反人性</p></li></ol><p>教训：</p><ol><li>价格变化本身透露出的消息远比指标的意义重要。</li><li>对投机者来说，从众是大忌，风向标不会让人赚钱</li><li>再次强调止损</li></ol><p>现代决策心理学的研究表明：当一个人的内心充满矛盾时，最典型的行为特征是不采取任何行动。</p><h2 id="十二、冥河摆渡者"><a href="#十二、冥河摆渡者" class="headerlink" title="十二、冥河摆渡者"></a>十二、冥河摆渡者</h2><p>让新手盲目进入市场是非常不负责任的</p><p>市场交易离不开预测，但是预测只是一个合理的交易计划的一小部分。</p><p>投机者一定要时时刻刻保持冷静、理智，客观、谦逊的评价自己，不论低谷或高峰。</p><p>投机需要技巧、时机、经验和运气，蛮干、强求是无法成功的。</p><h2 id="十三、与恶魔进餐"><a href="#十三、与恶魔进餐" class="headerlink" title="十三、与恶魔进餐"></a>十三、与恶魔进餐</h2><p>市场主力的目的：让大多数投机者犯错，自己从中获利。</p><p>作者入瓮后试图破局：</p><ol><li>在市场真正突破有意义的技术点位后入市 失败</li><li>设置好小亏损，止盈设置高一点，在众多指标中，找到了一种恰好比较符合的遵守</li></ol><p>作者构建了一套理解市场的核心框架工具，严格遵守。</p><p>大势交易准则。</p><h2 id="十四、Jesse-Livermore"><a href="#十四、Jesse-Livermore" class="headerlink" title="十四、Jesse Livermore"></a>十四、Jesse Livermore</h2><p>进入市场前，要爬上巨人的肩膀。</p><p>作者发现安了里费默的这本书。</p><p>本杰明、投资：《价值投资》</p><p>里费默、投机：《股票作手回忆录》</p><p>ps:大致来讲，我们可以把股市回报分为两大类：<strong>基本面和投机面</strong>。基本面是指股票自身给予投资者的回报，主要包括公司分红和盈利增长。而投机面则主要反映了大众对于市场的悲观或者乐观情绪。从比较长的时间维度来看，基本面给予投资者的回报是可以预测并且比较稳定的，而投机面则变化无常，经常在天堂和地狱之间游走。</p><p>全书内容大致分三类：<u>市场认识、交易策略、心理精神</u></p><p><strong>市场认识</strong>：对股票、期货市场的重大原则问题的基本观点。包括市场趋势出现的原因，市场价格变化的必然性、偶然性，操作行为的影响等</p><p><strong>交易策略</strong>：应对市场价格变化的基本方法、技巧。包括入市时机，点位选择，投入资金，利好利空策略，何谓最佳离场时机。</p><p><strong>心理精神</strong>：如何看待盈亏，对待金钱的态度，长线交易中对待波动的准备，还有种种投机者盲目的心里根源。</p><p>不能无原则的止损！趋于大势。</p><p>主力的力量也必须服从供求关系，经济学理论并非毫无用处，市场价格大方向上必然符合经济大规律。</p><p>赚大钱不能靠看盘，而在于股价整个股市行情和走势。</p><p><strong>试探-加码策略</strong>，<strong>好有道理</strong></p><p>有学者认为投机者应该着重追市，在发生突破后再进入市场。</p><h2 id="十六、离市场远一点"><a href="#十六、离市场远一点" class="headerlink" title="十六、离市场远一点"></a>十六、离市场远一点</h2><p>在缓慢上涨的行情中，如果市场涨姿突然加速，这可能是市场要见顶。。</p><p>大行情要有一个发展过程，投机者必须给市场足够的时间，投机者是不是不该天天注意市场细节，而是离他远一点呢？</p><p>一个看图经验，在大幅下跌后的市场行情中，如果市场价格连续两周上涨，周K线都是中等长度阳线，后市往往极度看好。</p><p>既然自己把持不住短期波动的扰乱，那就躲远一点吧！</p><h2 id="十七、投机者"><a href="#十七、投机者" class="headerlink" title="十七、投机者"></a>十七、投机者</h2><p>面对相同的行情，投机者们有着完全不同的各种应对方式。</p><p>市场交易无非一买一卖，但背后却隐含着投机者不同的观念、意识、目的、动机，反映出投机者的价值观、交易理念、对待风险、金钱的态度等。</p><p>投机者在金融领域的最终命运，深层次的原因取决于一个投机者的综合素质——人生修养和境界。</p><p>这建立在两个方面上：</p><ul><li><u>对市场的理解</u>，对市场交易中一些重大的原则性问题的基本态度</li><li><u>对自我的认识</u>，既包括对人类本性的洞察，也包括对自身独特弱点、性格缺陷的反省</li></ul><p>心理游戏，与人斗，与自己斗。</p><p>很多人们都能随口说出的朴素、简单的经验，投机者都为之可能付出过惨痛的代价才能铭刻于心</p><p>投资的特性让人们容易忘记错误，沉迷于数字上涨的愉悦，忘记反省，便多出了无数的错误成本。</p><p>投机里的止损、冲动性交易等问题，其实都不是孤立的，投机者整体的交易理念、境界达不到一定的高度，就难以彻底</p><p><strong>冲动性交易是一种超级短线交易</strong></p><p>缺乏自我控制能力，沉迷于短时间赚大钱的欲望。</p><p>平静、淡然的欣赏市场的变化，也审视着自己的内心世界，这种境界。。</p><p><strong>止损需要莫大的勇气</strong></p><p>再交易不利时果断止损，推翻原来的市场判断是沉重的。这还涉及投机者的市场认识，投机策略，交易思路是否正确，更要求极高的精神境界。</p><p>每一次交易中，具体止损点位的设立，也是个复杂问题。不然就可能来回割肉，被市场愚弄</p><p>不能孤立、静止、机械地看待市场交易中的止损问题。如果一个人的盈利不能弥补止损的损失，那也毫无用处，止损对长线更有意义，因为利润远远大于损失。</p><ul><li>天下唯一确定的事情就是不确定性</li><li>任何决策都是均衡几率的结果</li><li>一旦做出决定就要立刻付出行动</li><li>决策者的品质远远比决策结果重要</li></ul><p>这是一个长期的培养、追求、领悟过程。</p><p>面对市场的不确定性，哲学的世界观、方法论、价值观和抽象思维模式也许能帮助投机者把握市场脉络。</p><p>高手之间的较量是投资哲学的较量，心态和境界的较量。</p><h2 id="十八、你能摆脱地星引力吗"><a href="#十八、你能摆脱地星引力吗" class="headerlink" title="十八、你能摆脱地星引力吗"></a>十八、你能摆脱地星引力吗</h2><p>理智的最后一步就是意识到有无数事物是它力所不及的。</p><p>不知命无以为君子。市场中人的因素重要，偶然性，同样重要。</p><p>环境、机遇和运气对一个的影响也是很大的，过于强调自我的意志、智慧和天赋，难免陷入幼稚和狂妄，付出惨痛的代价。</p><ol><li>社会政治、经济环境</li><li>政策因素，尤其在中国，一定要看得懂国家的态度，做出准确判断</li><li>市场本身，挑选市场，不同市场的规律不同，蕴含的机会也不同，波动大的市场蕴含更多的机会。</li><li>不公平竞争，几十年前市场的公平、公正原则荡然无存，内部勾结严重，尤其是交易所</li></ol><p>不要赌性太重，不要去做那些毫无把握的交易，珍惜已有的东西，善待自己，善待人生。</p><p>要根据环境的变化，审时度势，难免会被市场淘汰。</p><h2 id="十九、里费默之死"><a href="#十九、里费默之死" class="headerlink" title="十九、里费默之死"></a>十九、里费默之死</h2><p>生命本质的非理性之谜</p><p>人难胜天</p><p>一个富有想象力的人，在他的生活中，总是看到自己的生活具有传奇色彩，这就决定了他的生活方式——与其说他想创造美好的生活，不如说他想使他的生活成为一个美妙的故事。</p><p>没有人是绝对理性的，哪怕是传奇。</p><p>人性的困境如此悲哀。金融工程是不是就是为了解决这个问题？</p><p>忍不住好奇心，厌倦呆板的交易策略，迷失在探索市场奥妙的旅程，沉溺交易的快感，最后一无所有。</p><p>难道有什么比让自己心里愉悦更重要的吗？高明的交易原则在内心面前，也显得苍白无力</p><p>投机遵守的规矩是反人性的，领悟市场交易的局限性、危险性、悲剧性——性格决定命运</p><p>投机算的上是工作吗？——天空不留下鸟的痕迹，但我已飞过。</p><p>期货交易要赚钱，不但要有心，更要有运，多少年轻人都死在里面了。</p><p>市场交易中没有持续、安全、稳定的成功之路。</p><p>在西方国家，大众参与期货交易的方式往往是间接的，一般是通过基金让专业人士来操作，而我国期货市场80%都是散户，期货市场的残酷和凶险最后必然会淘汰大部分人，并使他们收到严重的伤害。</p><p>人啊，也许根本就无法战胜非理智地一面。</p><p>张爱玲《非走不可的弯路》</p><p>一个交易经验丰富、市场理解深刻的投机者，经历了长时间的摸索和尝试以后，往往能够建立起自己的交易模式、套路，具有明确的交易思路和交易风格。其思维和行为方式具有逻辑性和前后一致性。</p><p>成功操盘手的几个特征：</p><ol><li><p>拥有一套相对稳定的，有优势、有胜算的交易模式</p><p>这样才能明确自己在市场中关注什么，什么时候采取行动。</p></li><li><p>交易策略和风险控制的始终一贯性</p><p>坚持每一笔交易都不要出现重大损失；每一次都采取试探—加码策略。</p><p>限制亏损，发展利润</p></li><li><p>市场判断和操作的前后一致性</p><p>紧握头寸，把持住长期的确定性</p></li><li><p>哲学境界</p><p>武士道、茶道等东方哲学，在这个孤独的心里搏斗游戏中，如何贯彻一套哲学</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十年一梦&quot;&gt;&lt;a href=&quot;#十年一梦&quot; class=&quot;headerlink&quot; title=&quot;十年一梦&quot;&gt;&lt;/a&gt;十年一梦&lt;/h1&gt;&lt;p&gt;第一篇&lt;strong&gt;读书笔记&lt;/strong&gt;，我也不知道该咋写。。&lt;/p&gt;
&lt;h2 id=&quot;序1-唯有事实&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="finance" scheme="https://darren-dong.com/categories/finance/"/>
    
    
    <category term="股市心理" scheme="https://darren-dong.com/tags/%E8%82%A1%E5%B8%82%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据科学导论</title>
    <link href="https://darren-dong.com/2021/06/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    <id>https://darren-dong.com/2021/06/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/</id>
    <published>2021-06-12T12:33:45.000Z</published>
    <updated>2022-05-07T14:03:22.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据科学导论"><a href="#数据科学导论" class="headerlink" title="数据科学导论"></a>数据科学导论</h1><h2 id="1-基础理论"><a href="#1-基础理论" class="headerlink" title="1 基础理论"></a>1 基础理论</h2><p>数据富足时代——大数据时代</p><ul><li>现代处理器功能增强，密集度up</li><li>存储、管理成本降低，新的存储技术使得数据运行更快，规模up</li><li>跨计算机集群分布计算处理能力，提高了分析复杂数据的能力</li><li>有更多业务数据集可供分析，而且大部分提供了API</li><li>机器学习算法的开源社区日渐庞大</li><li>可视化更容易使用</li></ul><p>很多过去的研究方法和理论思维有明显的“面向数据贫乏时代”特点，不再适用</p><h3 id="1-1-术语定义"><a href="#1-1-术语定义" class="headerlink" title="1.1 术语定义"></a>1.1 术语定义</h3><p>数据、信息、知识、智慧</p><p>结构化数据、半结构化数据、非结构化数据 （可否用传统关系数据库存储）</p><p><strong>结构化：先有结构，再捕获数据</strong></p><p>4V： Volume  Variety  Value  Velocity</p><p>涌现：质变</p><p>理解数据科学：现实映射到数据，研究问题，对现实进行预测、洞见、解释、决策</p><h3 id="1-2-研究目的"><a href="#1-2-研究目的" class="headerlink" title="1.2 研究目的"></a>1.2 研究目的</h3><p>最终目标：实现数据、物质、能量间的转换，降低后两者损耗、提高后两者效果和效率</p><p>具体：</p><ul><li>揭示大数据内容，元数据特征、规律，帮助人们理解大数据的本质特征</li><li>从数据到智慧的转换 P11</li><li>数据洞见：将数据转化为实际行动</li><li>数据业务化</li><li>数据驱动型决策支持，将数据当作驱动方式</li><li>数据产品研发：<strong>0-3次数据 原生 干净 增值 洞见数据</strong></li><li>数据生态系统建设<ul><li>数据生产</li><li>数据采集</li><li>数据处理</li><li>业务流程</li></ul></li></ul><h3 id="1-3-研究视角"><a href="#1-3-研究视角" class="headerlink" title="1.3 研究视角"></a>1.3 研究视角</h3><p>原本：我能为数据做什么</p><p>​            传统的数据工程、数据结构、数据库、数据仓库、数据挖掘都是这个</p><p>​            强调通过人的努力改变数据，使数据更有价值，便于后续利用</p><p>现在：数据能为我做什么</p><p>​            大数据辅助决策、决策支持，带来商业机会，降低不确定性，发现可用的新模式</p><p>​            新术语：数据驱动、数据业务化、让数据说话、以数据为中心、数据柔术 都强调该视角</p><h3 id="1-4-理论体系"><a href="#1-4-理论体系" class="headerlink" title="1.4 理论体系"></a>1.4 理论体系</h3><p>领域知识：决定数据科学的主要关注点、应用领域和未来发展，重要</p><p>理论基础：统计学、机器学习、数据可视化与故事化</p><p>核心内容：</p><ul><li>基础理论：理念、方法、技术、工具、原则、目标等等</li><li>数据加工：融入3C精神，更强调<strong>增值活动</strong></li><li>数据计算：过渡至云计算，则关注的问题发生根本变化</li><li>数据管理：出现新兴的NoSQL、NewSQL和关系云等</li><li>数据分析</li><li>数据产品开发</li></ul><h3 id="1-5-基本原则"><a href="#1-5-基本原则" class="headerlink" title="1.5 基本原则"></a>1.5 基本原则</h3><ol><li><p>三世界原则</p><p>数据世界，使用“痕迹数据”，更加客观，而不是”采访数据“</p><p>第四范式：数据密集型科学发现范式——更注重相关性而不是因果</p></li><li><p>三要素</p><p>理论、实践、精神（3C）</p><p>提升实践能力：参加竞赛+参加开源项目</p><p>Creative Working</p><p>Critical Thinking</p><p>Curious Asking</p></li><li><p>数据密集型原则</p><p>挑战来自数据本身复杂性而不是计算</p></li><li><p>数据中心原则</p><p>从数据出发，改变业务</p></li><li><p>数据范式</p><p><strong>用数据直接解决问题</strong></p></li><li><p>数据复杂性原则</p><p>复杂性被认为是大数据不可分割的属性，数据在先，模式在后或无模式</p></li><li><p>数据资产原则</p></li><li><p>数据驱动原则</p></li><li><p>协同原则</p></li><li><p>从简原则</p><p>数据科学追求简单高效，面向具体应用需求，不考虑通用而复杂的算法</p></li></ol><h3 id="1-6-能力要求"><a href="#1-6-能力要求" class="headerlink" title="1.6 能力要求"></a>1.6 能力要求</h3><ul><li>创新精神、独特视角、不断进取</li><li>团队合作、协同工作</li><li>提出“nice”研究假设和问题，能够完成对应试验设计</li><li>参与项目的经验</li><li>灵活运用领域实务知识经验</li><li>研发数据产品</li></ul><h3 id="1-7-学习"><a href="#1-7-学习" class="headerlink" title="1.7 学习"></a>1.7 学习</h3><p>加法：操作系极强，培养动手操作能力，利用python和R</p><p>减法：不同学科领域对数据科学的研究视角和侧重点不同，应优先学习领域共性的数据科学，再日后专精</p><p>乘法：经典理论X最佳实践，优先学习最代表数据科学的理论和实践，数据科学里<strong>实践领先于理论</strong></p><p>除法：注意学习知识的完整性和逻辑性，用最简单的逻辑和最清楚的语言来学习</p><p>八个步骤：</p><ol><li><p>数学、统计学、机器学习</p></li><li><p>学会写代码</p></li><li><p>理解数据库</p></li><li><p>探索数据科学流程</p><p>采集、探索、加工、建模、验证、报告</p></li><li><p>重视并学习大数据</p></li><li><p>竞赛，建立自己的项目，培养精神</p></li><li><p>实习、集训、进入职场</p></li><li><p>参与社区</p></li></ol><h2 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2 理论基础"></a>2 理论基础</h2><h3 id="2-1-学科地位"><a href="#2-1-学科地位" class="headerlink" title="2.1 学科地位"></a>2.1 学科地位</h3><p>跨学科视角</p><p>关注理论研究和<strong>领域务实知识（需要相关专家参与）</strong>的结合</p><p>主要精神是hacker精神</p><h3 id="2-2-统计"><a href="#2-2-统计" class="headerlink" title="2.2 统计"></a>2.2 统计</h3><p>从行为目的和思维方式看</p><p>描述统计+推断统计</p><p>从方法论角度看</p><p>基本分析法：对低层数据（0次1次）分析</p><p>回归、分类、时间序列、线性分析、方差分析、聚类分析、其他</p><p>元分析法：对高层数据（尤其是基本分析法得出的）进一步分析</p><p>方向：</p><ul><li>不再是随机样本，而是全体数据</li><li>不是精确性，而是复杂性，目的不再是追求精确性，而是提升效率</li><li>不是因果关系，而是相关关系</li></ul><h3 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h3><p>基础理论来自多个学科：</p><p>人工智能、贝叶斯方法、计算复杂性理论、控制论、信息论、哲学、心理学与神经生物学、统计学</p><p>分类P62</p><p>按照输出结果：</p><ul><li>概念学习：用结果推出未知的布尔函数，找到最好你和训练样本的假设</li><li>决策树学习：逼近离散值目标函数过程</li><li>分析学习：用先验知识分析每个样本，推算各特征与目标函数的相关性</li><li>归纳学习</li></ul><p>按照学习方式：</p><ul><li>人工神经网络</li><li>贝叶斯学习</li><li>遗传算法</li><li>基于实例学习</li><li>增强学习</li></ul><p>按照学习任务不同：</p><ul><li>监督学习<ul><li>最近邻</li><li>朴素贝叶斯</li><li>决策树</li><li>随机森林</li><li>线性回归</li><li>支持向量机</li><li>神经网络分析</li><li>。。。。</li></ul></li><li>无监督学习<ul><li>K-Means聚类</li><li>主成分分析</li><li>关联规则分析</li></ul></li><li>半监督学习<ul><li>半监督分类：生成式、判别式</li><li>半监督回归：基于差异、基于流形学习</li><li>半监督聚类：基于距离、大间隔方法</li><li>半监督降维：基于类标签、基于成对约束</li></ul></li></ul><p><strong>挑战</strong>：</p><ul><li><p>过拟合（Overfitting）</p><p>训练集准确率高，测试集准确率低</p></li><li><p>维度灾难（Curse of Dimensionality）</p><p>低维算法难以移植到高维</p></li><li><p>特征工程（Feature Engineering）</p><p>还得考虑相关领域知识</p></li><li><p>算法可拓展性（Scalability）</p></li></ul><p>P74常用统计模型和机器学习算法</p><h2 id="3-流程与方法"><a href="#3-流程与方法" class="headerlink" title="3. 流程与方法"></a>3. 流程与方法</h2><p><em><strong>数据科学没有统一的流程，不同专家、应用场景中所提出的流程可能不同，学习数据科学流程的母的在于掌握活动类型，而不是活动之间的严格先后顺序。</strong></em></p><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>图P83</p><p>数据化、数据加工、数据规整化、探索性分析、数据分析与洞见、结果展现和数据产品的提供</p><ol><li><p>数据化</p></li><li><p>数据加工和规整化</p><p>本质是将低层数据化为高层数据0-&gt;1-&gt;2-&gt;3</p><p><strong>干净数据</strong>（相对脏）：质量没问题，没有缺失值，错误值和噪声信息</p><p><strong>规整数据</strong>（相对乱）：形态符合计算与算法要求，从数据形态分类</p><p>注意应该是<strong>增值过程</strong>，不等于传统的“数据预处理”和“数据工程”</p></li><li><p>探索性分析</p><p>在尽量少的先验假定下探索，通过作图、制表、方程拟合、计算特征量等<strong>探索数据的结构和规律</strong></p><p>先探索后验证</p><ul><li><p>耐抗性：</p><p>对局部不良行为的非敏感性，因为大数据难免有部分差错</p><p>耐抗性分析统计量：集中趋势、离散程度、分布状态、频度等</p></li><li><p>残差</p></li><li><p>重新表达</p><p>找到合适的尺度或数据表达方式进行准换，有利于化简分析，主语对称性，恒定性，线性和可加性，和线性代数概念类似，也叫变换</p></li><li><p>启示</p></li></ul></li><li><p>数据分析与洞见</p><p>在理解数据的基础上，设计、选择、应用具体的机器学习算法和统计模型进行分析</p><ul><li>描述性分析：转换为信息</li><li>预测性分析：转换为知识</li><li>规范性分析：转换为智慧</li></ul></li><li><p>结果展现，提供数据产品</p></li></ol><h3 id="3-2-数据加工"><a href="#3-2-数据加工" class="headerlink" title="3.2 数据加工"></a>3.2 数据加工</h3><p>需求：数据质量要求 和 数据计算要求</p><p>往往需要综合运用多种数据加工方法</p><p>图见P92</p><ol><li><p>数据清洗（多轮审计和清洗）</p><ul><li><p>缺失数据</p><p>识别、分析（特征，影响，原因）、处理（忽略，删除，插值）</p></li><li><p>冗余（重复、无关）数据</p><p>重复数据用重复过滤</p><p>无关数据用条件过滤</p></li><li><p>噪声（错误、虚假、异常）</p><p>分箱、聚类、回归</p></li></ul><hr></li><li><p>数据变换</p><p>使形式符合算法要求，常见策略：</p><ol><li>平滑处理——去噪声</li><li>特征构造——构造新属性，描述客观现实（体积+质量-&gt;密度）</li><li>聚集——汇总聚合数据，进行粗粒度计算（日销量-&gt;月销量）</li><li>标准化</li><li>离散化——用区间标签和概念标签表示属性值</li></ol></li><li><p>数据集成</p><p>内容集成：结构相同、描述不同对象，或可通过映射变为相同（同时进行冲突检测、处理等清洗操作）</p><p>结构集成：来源不同、描述同一对象，分结构和内容两层次，可进行<strong>属性选择</strong></p><p>难点：</p><ul><li>模式集成：如何匹配来自多个数据源的同一实体</li><li>数据冗余：冗余属性可以从其他属性推演出来，命名不一致，用相关分析P99</li><li>冲突检测和消除：比例尺度或编码不同（kg 和 g）</li></ul></li><li><p>数据脱敏（Data Masking）</p><ol><li>单向性：无法从脱敏数据 推导 出原始数据</li><li>无残留：用户无法用其他途径还原敏感信息，小心用户画像技术</li><li>易于实现：涉及数据量大，所以不能太复杂</li></ol></li><li><p>数据归约（Data Reduction）</p><p>在不影响数据完整性和分析结果正确性前提下，减少数据规模和数据量</p><ol><li><p>维归约</p><p>避免维度灾难，减少考虑的随机变量或属性，通常采用线代方法</p><p>主成分分析、奇异值分解、离散小波转换</p></li><li><p>值规约</p><p>用参数模型或非参数模型近似表示数据，只存储生成方法和参数？？</p></li><li><p>数据压缩</p><p>重构数据来压缩</p></li></ol></li><li><p>数据标注：</p><p>对目标数据补充必要的标签类元数据来提高检索、洞察、分析、挖掘效率</p><p>自动化程度：有手工、半自动、自动化标注</p><p>实现层次：语法标注和语义标注  不懂</p></li></ol><h3 id="3-3-数据审计"><a href="#3-3-数据审计" class="headerlink" title="3.3 数据审计"></a>3.3 数据审计</h3><p>按照数据质量的一般规律与评价方法审计，发现问题</p><p>比如缺失值、噪声值、不一致值（相互矛盾）、不完整值（被篡改或无法溯源）</p><p>P102</p><ol><li>预定义审计、自描述性规则</li><li>自定义审计</li><li>可视化审计</li></ol><p>常用技巧：第一数字定律、小概率原理、语言学规律、数据连续性理论、数据鉴别技术</p><h3 id="3-4-数据分析"><a href="#3-4-数据分析" class="headerlink" title="3.4 数据分析"></a>3.4 数据分析</h3><p>描述性-&gt;诊断性-&gt;预测性-&gt;规范性</p><p>​            ↑商务智能              ↑数据科学</p><ol><li><p>描述性</p><p>已经发生了什么</p><p>描述性统计分析方法</p></li><li><p>诊断性</p><p>为什么发生</p><p>关联分析法（数据科学家）和因果分析法（领域专家）</p></li><li><p>预测性</p><p>将要发生什么</p><p>分类分析方法、趋势分析方法</p></li><li><p>规范性</p><p>关注模拟与优化问题，如何从将要发生的事情受惠、如何优化将发生的事</p><p>运筹学、模拟与仿真技术</p></li></ol><h3 id="3-5-数据可视化"><a href="#3-5-数据可视化" class="headerlink" title="3.5 数据可视化"></a>3.5 数据可视化</h3><ol><li>科学可视化</li><li>信息可视化</li><li>可视分析学</li></ol><p>可视分析学以<strong>可视交互</strong>为基础，综合运用图形学、数据挖掘、人机交互，实现人机协同完成可视化任务</p><p>P112有一个模型，有以下特点:</p><ol><li><p>强调从数据到知识的转换过程</p><p>不是单纯的展示，而是转换成<strong>知识</strong>，两种途径 👇</p></li><li><p>强调可视化分析与自动化建模之间的<strong>相互作用</strong></p></li><li><p>强调数据映射和数据挖掘的重要性</p><p>（用来实现👆，作为重要支撑技术），配合使用</p></li><li><p>强调数据加工工作的必要性</p><p>不然会影响可视化效果</p></li><li><p>强调人机交互的重要性</p><p>人机互补和人机协同，重视互补优势</p></li></ol><p><strong>方法体系</strong></p><ol><li><p>方法论基础</p><p>主要指 <strong>视觉编码</strong> 作为数据可视化方法体系的根基</p><p>通常采用视觉图形元素和视觉通道两个维度进行视觉编码</p></li><li><p>基础方法</p><p>建立在👆之上，应用不局限于特定领域，提供高层不同应用领域的共性方法，比如统计图表、图论方法、视觉隐喻、图形符号学</p></li><li><p>领域方法</p><p>往往仅限于特定领域或任务范围，不具备跨领域/任务性</p><p>但在该领域的信度和效度高于基础方法的直接应用</p><p>比如地理信息可视化、时间数据可视化、不确定性、文本、媒体、实时数据之类的</p><p>很多领域已出现了自己独特的数据可视化方法，比如地铁路线图全球统一</p></li><li><p>视觉感知与视觉认知</p><p>视觉编码的关键在于找到符合目标用户群体的视觉感知习惯的表达方法</p><ul><li><p>视觉感知（Visual Perception）</p><p>指客观事物通过视觉感觉器官在人脑中产生直接反映的过程</p><p>应充分利用人类视觉感知特征</p></li><li><p>视觉认知（Visual Coginiton）</p><p>指个体对视觉感知信息的<strong>进一步加工</strong>处理过程</p><p>包括抽取、转换、存储、简化、合并、理解、决策等，很好的例子是<strong>完图法则</strong></p></li></ul></li><li><p>可视化视角下的数据类型</p><ul><li><p>定类数据</p><p>主要用于记录事物的所属类型或标签信息，只能进行相等判断</p></li><li><p>定序判断</p><p>主要记录事物的排信息，支持相等判断和大小比较运算</p></li><li><p>定距排序</p><p>用于记录事物的量化信息，“0”的位置具有任意性，不代表事物是否存在，如温度为0°</p></li><li><p>定比数据</p><p>用于记录事物的量化信息，“0”为基准，表示不存在，例如我的身高是他的1.5倍</p></li></ul></li><li><p>视觉通道的选择方法<strong>P118</strong></p><p>从人类的视觉感知和认知习惯看，数据类型与视觉通道时存在一定的关系的</p><p>一般有：位置、尺寸、数值、纹理、颜色、方向、形状，分别能够对应不同的数据类型</p><p>要综合考虑目标用户需求、可视化任务本身、原始数据的数据类型，成为数据可视化工作的重要挑战</p><p>不同视觉通道的<strong>数据表现力</strong>不同，评判标准：</p><ol><li><p>精确性</p><p>编码结果与原始数据间的吻合程度</p></li><li><p>可辨认性</p><p>字面意思，不要让视觉通道和背景混淆之类的</p></li><li><p>可分离性</p><p>不同视觉通道的表现力之间应具有一定的独立性，比如面积颜色表现力会受到面积大小影响</p></li><li><p>视觉突出性</p><p>编码结果能否在非常短的时间内迅速、精确传达出主要意图</p></li></ol><p>但是应注意：各种视觉通道的表现力往往是<strong>相对</strong>的，与原始数据、通道类型选择、用户感知习惯都有关</p></li><li><p>数据假象</p><p>不可忽视的特殊问题</p><p>目标用户产生的错误或不正确的视觉感知：</p><ol><li>可视化试图所处的上下文可能导致视觉假象</li><li>人眼对亮度和颜色的相对判断容易造成视觉假象</li><li>目标用户的经历和经验可能造成视觉假象</li></ol></li></ol><h3 id="3-6-数据故事化"><a href="#3-6-数据故事化" class="headerlink" title="3.6 数据故事化"></a>3.6 数据故事化</h3><p>“数据的故事化描述”是为了提升数据的可理解性、可记忆性、可体验性</p><p>将“数据”还原成成关联至特定的“情景”的过程，因此故事化也是数据转换的表现形式之一</p><p>三类“情景”：</p><ul><li><p>还原情景</p><p>还原数据所计算和计算信息的“原始情景”</p></li><li><p>移植情景</p><p>将数据移植到另一个真实发生（比如客户熟悉的情景）的情景中</p></li><li><p>虚构情景</p></li></ul><ol><li><p>重要地位</p><p>这被认为是“最后一公里”问题，直接影响整个数据科学项目的成败</p><ul><li><p>易于记忆</p></li><li><p>易于认知</p><p>可视化易于感知、故事化易于认知</p></li><li><p>易于体验</p><p>一是故事讲述者和倾听者之间共享相同、相似的情景</p><p>二是故事的具体表现形式和情节设计</p></li></ul></li><li><p>故事化描述与故事的展现方式</p><p>👆是两个不同的概念，电影、图书、海报等都是故事化处理后、选择特定的形式具体展现</p><ul><li>故事化描述是故事展现的前提条件，不同展现方式表现效果不同</li><li>故事的展现对故事化描述起反馈作用</li></ul></li><li><p>故事化描述的基本原则</p><ol><li><p>忠于数据原则</p><p>尤其不得以“提高故事生动性”为借口扭曲原始数据</p></li><li><p>设计共同情景原则</p><p>要真正了解目标倾听者，结合他们的经验和知识</p></li><li><p>体验式讲述原则</p><p>比如尽量用第一、第二人称，多一些交互式体验</p></li><li><p>个性化定制原则</p></li><li><p>有效性利用原则</p><p>有时候故事化不一定合适，要论证是否合适，是否应采取其他方法</p></li><li><p>3C精神原则</p><p>实现增值，避免套路化</p></li></ol></li></ol><p>近年来，自动化故事化描述成为新的关注点！</p><h3 id="3-7-数据科学项目管理"><a href="#3-7-数据科学项目管理" class="headerlink" title="3.7 数据科学项目管理"></a>3.7 数据科学项目管理</h3><p>遵循一般项目管理的原则和方法</p><p>涉及 <u>整体、范围、时间、成本、质量、人力资源、沟通、风险、采购</u> 九个方面的管理 P129</p><p>So Complex!</p><ol><li><p>主要角色 P130</p><p>项目发起人、项目经理、客户、数据科学家、数据工程师、操作人员</p></li><li><p>基本流程</p><p>都是双向的链条，主要活动包括六项</p><ul><li><p>项目目标的定义</p><p>我们通此项目解决什么问题</p></li><li><p>数据的获得与管理</p><p>我们需要哪些数据？如何获得？如何管理</p></li><li><p>模式/模型的洞见</p><p>我们从数据洞见了什么模式/模型？</p></li><li><p>模式/模型的验证与优化</p><p>已洞见的模式/模型是否可靠、适用以及如何优化</p></li><li><p>结果的可视化与文档化</p><p>我们用什么方式记录和展现数据预期结果</p></li><li><p>模式/模型的应用与维护</p><p>如何运用已确定的模式/模型解决实际问题，并根据数据和问题的动态变化优化模式/模型。</p></li></ul></li></ol><h3 id="3-8-数据科学常见错误"><a href="#3-8-数据科学常见错误" class="headerlink" title="3.8 数据科学常见错误"></a>3.8 数据科学常见错误</h3><p>主要原因在于人们尚未完全理解数据科学理念、理论、方法、工具</p><p>用自己一贯采用的习惯性思维和传统理论去“解决”大数据问题</p><ol><li><p>不检查数据</p><p>80%时间获取、清理数据，检查是否可用，谨慎使用模拟数据</p></li><li><p>不理解数据</p><p>应该在训练数据模型前仔细研究数据，更快的利用直觉</p></li><li><p>不评估数据</p><p>对数据内容及其模态和目标任务之间的匹配度进行评估，寻找新的途径而不老是局限于过去</p><p>从小目标开始、不要一开始就挑战技术难题</p></li><li><p>不测试模型</p></li><li><p>只有目标、没有假设</p><p>合情的假设可以从一开始缩小范围，减少在这个问题上浪费的时间</p></li><li><p>采用过时失效的模型</p><p>当你的竞争对手从你的市场表现中学习时就已经过时了</p></li><li><p>不评估最终结果</p></li><li><p>忽略业务专家的作用</p><p>比如在确定需要的特征时节省大量的时间</p><p>开始项目前，数据团队和业务专家之间进行对话，确保每个人都清楚项目要实现什么效果，然后做探索性的数据分析，看看能否实现它，如果不能，可能需要用一种新的方法重新表述该问题，或者采用不同的数据源，但这个具体领域的专家<strong>应该帮助确定目标是什么以及项目是否符合目标</strong></p></li><li><p>选择过于复杂的模型/算法</p><p>简单优先，先考虑简单的，注意到过拟合更可能发生在复杂的算法中</p></li><li><p>模型与算法选择上的偏见</p><p>最好从开源模型中构筑自己的版本</p></li><li><p>曲解基本概念和基础原理</p></li><li><p>低估目标用户的理解能力</p></li></ol><p>奥卡姆剃刀定律：</p><ol><li>剃掉不必要的假设</li><li>分割两个类似的结论来区分两个假设</li></ol><p>不应盲目追求数据量，以最必要的数据集为基础数据，不要追求”高大上“。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据科学导论&quot;&gt;&lt;a href=&quot;#数据科学导论&quot; class=&quot;headerlink&quot; title=&quot;数据科学导论&quot;&gt;&lt;/a&gt;数据科学导论&lt;/h1&gt;&lt;h2 id=&quot;1-基础理论&quot;&gt;&lt;a href=&quot;#1-基础理论&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="data science" scheme="https://darren-dong.com/categories/data-science/"/>
    
    
  </entry>
  
  <entry>
    <title>基本数据结构实现</title>
    <link href="https://darren-dong.com/2021/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://darren-dong.com/2021/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-05-25T05:15:54.000Z</published>
    <updated>2022-05-09T06:59:26.708Z</updated>
    
    <content type="html"><![CDATA[<p>考前抱佛脚┭┮﹏┭┮</p><p>记住这里大量用了c++的引用。。好方便，但是答题的时候记得换成 *和全局变量</p><p>一个算法应该具有以下特性：</p><ol><li>有穷性</li><li>确定性  不存在二义性</li><li>可行性</li><li>有输入</li><li>有输出</li></ol><p>1&lt;n&lt;log2n&lt;n&lt;nlog2n&lt;n2&lt;n3 (多项式)|| &lt;2n&lt;n!(指数)</p><h1 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>SqList 是线性表</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*基本运算：InitList(&amp;L);DestoryList(&amp;L);ListEmpty(L);ListLength(L);DispList(L);GetElem(L,i,&amp;e);LocateElem(L,e);ListInsert(&amp;L,i,e);ListDelete(&amp;L,i,&amp;e);*/</span><span class="token comment">/*线性表的顺序存储i--; //转化为物理序号if(i&lt;1 || i>L->length+1) //插入的时候是允许插入第 n+1 位置的，所以还要额外+1最后不要忘了改一下k的符号*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> SqList<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span class="token comment">//需要改变的就传入引用，不需要改变的就直接传入指针就好了。</span><span class="token keyword">void</span> <span class="token function">CreateList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//用来统计数量，i用来当索引，但是为什么不直接用i呢？</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">free</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListEmpty</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> L<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DispList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bool <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//记住逻辑序号和物理序号差了一个1嗷</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//插入的时候是允许插入最后一个位置的，所以还要额外+1</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//转化为物理序号</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    L<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//转换成物理非常重要！</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//****************************************************************************************************</span><span class="token comment">//删除L中所有值等于 x 的元素，双指针扫描</span><span class="token keyword">void</span> <span class="token function">delnode1</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            L<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//用k记录个数</span><span class="token keyword">void</span> <span class="token function">delnode2</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>length <span class="token operator">-=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这一片巧妙利用“缺位，补位”的技巧，节省了许多空间和时间，直接对换会消耗一个额外内存，不如缺位补位</span><span class="token comment">//感觉不够通用,不过现在懒得改了，很多二分的其实都是pattition，跟python提供的key函数参数一样</span><span class="token keyword">void</span> <span class="token function">partition1</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    ElemType pivot <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//中文翻译：枢</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//顺序表归并算法,要求不改变原有的LA和LB</span><span class="token keyword">void</span> <span class="token function">UnionList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>LA<span class="token punctuation">,</span> SqList <span class="token operator">*</span>LB<span class="token punctuation">,</span> SqList <span class="token operator">*</span><span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//i,j为两组下标</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>LA<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>LB<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>LA<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>LB<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    LC<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>p是遍历用的节点，有一个工具节点用来接受创建或者进行删除，insert用s，delete用q</p><p>尾插法的工具节点r</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*单链表记得要设置最后一个是NULLLinkNode *pre = L,*p = L->next   //这个初始化挺好的！！！分析多或少1的时候，从开头0各和少数几个的极端情况分析。头节点L是没有存放数据的，也不算进长度，这就解释了为什么p有时是L有时是L->next，插入和删除都是先j&lt;i-1找到第i-1然后操作,所以初始化为p = L，因为是对后面那个操作*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> LinkNode<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span class="token comment">//头插法</span><span class="token comment">/*这里如果只传指针的话，只是传了一个指针的副本，相当于告诉你我的地址在这里，你可以修改我地址里的东西，但是这没有什么意义，因为我需要操作的是这个指针，不然操作全都传不回去，相当于你把一个副本连在一个结构里了，虽然这个副本和原来的指针有着相同的地址，但是此时我并不需要这个地址，我此时需要的是指针本身。加引用才是把原本的指针传过来了。*/</span><span class="token keyword">void</span> <span class="token function">CreateListF</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>s<span class="token punctuation">;</span> <span class="token comment">//工具节点上线</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//经典创建</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token comment">//头插四件套</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//尾插法</span><span class="token keyword">void</span> <span class="token function">CreateListR</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        r <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//这个初始化挺好的！！！</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后一步别忘了！！</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListEmpty</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        n<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DispList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//别漏了</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        e <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//</span><span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//逻辑修正</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>        s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//多检验一次，因为检验不到这里</span><span class="token comment">/*不如直接if(!(p &amp;&amp; p->next)) return false;*/</span>        e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//****************************************************************************************************</span><span class="token comment">//删除一个单链表L中元素最大的节点（假设唯一）插入一个标记就好了</span><span class="token keyword">void</span> <span class="token function">delmaxnode</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>maxp <span class="token operator">=</span> p<span class="token punctuation">,</span> <span class="token operator">*</span>maxpre <span class="token operator">=</span> pre<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxp<span class="token operator">-></span>data <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            maxp <span class="token operator">=</span> p<span class="token punctuation">;</span>            maxpre <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    maxpre<span class="token operator">-></span>next <span class="token operator">=</span> maxp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>maxp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使元素递增有序排列，没有想象中巧妙</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    L<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//p接下了第二个节点，原来的头和首被当作了新的有序链表</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//保存原来剩下的链</span>        pre <span class="token operator">=</span> L<span class="token punctuation">;</span>     <span class="token comment">//每次pre都从头扫描一遍。。。</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>next<span class="token operator">-></span>data <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span>            pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//找到合适的位置</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        pre<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//p接在这</span>        p <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment">//去q保存的地方继续操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">UnionList1</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>LA<span class="token punctuation">,</span>LinkNode <span class="token operator">*</span>LB<span class="token punctuation">,</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkNode <span class="token operator">*</span>pa <span class="token operator">=</span> LA<span class="token operator">-></span>next<span class="token punctuation">,</span><span class="token operator">*</span>pb <span class="token operator">=</span> LB<span class="token operator">-></span>next<span class="token punctuation">,</span><span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token operator">*</span>s<span class="token punctuation">;</span><span class="token comment">//尾插法和创建</span>    LC <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pa<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pb<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>data <span class="token operator">&lt;</span> pb<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            s <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token operator">-></span>data <span class="token operator">=</span> pa<span class="token operator">-></span>data<span class="token punctuation">;</span>            r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>            r <span class="token operator">=</span> s<span class="token punctuation">;</span>            pa <span class="token operator">=</span> pa<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pb<span class="token operator">-></span>data <span class="token operator">></span> pa<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            s <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token operator">-></span>data <span class="token operator">=</span> pb<span class="token operator">-></span>data<span class="token punctuation">;</span>            r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>            r <span class="token operator">=</span> s<span class="token punctuation">;</span>            pb <span class="token operator">=</span> pb<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pa<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> pa<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        r <span class="token operator">=</span> s<span class="token punctuation">;</span>        pa <span class="token operator">=</span> pa<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pb<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> pb<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        r <span class="token operator">=</span> s<span class="token punctuation">;</span>        pb <span class="token operator">=</span> pb<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*双链表return true;//不要漏了*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>prior<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> DLinkNode<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span class="token comment">//建立头插法</span><span class="token keyword">void</span> <span class="token function">CreateListF</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DLinkNode <span class="token operator">*</span>s<span class="token punctuation">;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    L<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">//一共要链4条，但是这一条可能不需要链接👇</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            L<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">CreateListR</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DLinkNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        s<span class="token operator">-></span>prior <span class="token operator">=</span> r<span class="token punctuation">;</span>        r <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//其余操作很多类似单链表，插入和删除有点区别罢了,工具节点叫s</span>bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>        s<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>        s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token comment">//不要漏了</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//****************************************************************************************************</span><span class="token comment">//工具节点叫q</span>bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            q<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//逆置,头插法就能进行逆置,头节点还能保留</span><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            L<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        p <span class="token operator">=</span> q<span class="token punctuation">;</span> <span class="token comment">//继续指向后继节点</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//双链表的删除是不需要工具节点的，这里用一个循环双链表的例子展示一下,删除第一个data为x的节点</span>bool <span class="token function">delelem</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//不需要工具点，p可以直接指向操作节点，而不是前一个</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> L <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> x<span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> L<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token operator">-></span>prior<span class="token punctuation">;</span>        p<span class="token operator">-></span>prior<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//循环双链表判断对称</span>bool <span class="token function">Symm</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    bool same <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//这类题的典型flag</span>    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    DLinkNode <span class="token operator">*</span>q <span class="token operator">=</span> L<span class="token operator">-></span>prior<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>same<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span>            same <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q <span class="token operator">||</span> p <span class="token operator">==</span> q<span class="token operator">-></span>prior<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//当相等（奇数）或相邻（偶数），为结束条件</span>            q <span class="token operator">=</span> q<span class="token operator">-></span>prior<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> same<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h1><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> SqStack<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqStack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    s<span class="token operator">-></span>top<span class="token operator">++</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//判断字符串是否为对称串</span>bool <span class="token function">Symmetry</span><span class="token punctuation">(</span>ElemType str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ElemType e<span class="token punctuation">;</span>    SqStack <span class="token operator">*</span>st<span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*共享栈，适用于一方可能用到满，另一方还有很多空间栈空：top1 == -1   top2 == MAXSIZE栈满：top1 ==top2-1进栈出栈的时候top2的操作和top1是反的循环队列A[0..n-1]存放其元素值，F表示队头元素所在的前一个位置，R表示队尾元素的位置。则当前队列中的元素数是当R>F时，元素个数为  R-F个当R&lt;F时，元素个数为 n - （F-R）= R-F+n个*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//选用带头结点的，更加便捷</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">linknode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    linknode <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> LinkStNode<span class="token punctuation">;</span> <span class="token comment">//这名字真长</span><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStNode <span class="token operator">*</span>pre <span class="token operator">=</span> s<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    e <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>    s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//迷宫问题和逆波兰表达式在P87</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在队头进行删除，在队尾进行插入</span><span class="token comment">//记住，front指的是空的地方</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Elemtype<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> SqQueue<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestoryQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">enQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    q<span class="token operator">-></span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">deQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    q<span class="token operator">-></span>front<span class="token operator">++</span><span class="token punctuation">;</span>    e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/****************************************************************************************/</span><span class="token comment">//环形队列</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//不是-1了</span><span class="token punctuation">&#125;</span>bool <span class="token function">enQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE <span class="token operator">==</span> q<span class="token operator">-></span>front<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>    q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">dequeue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    q<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这两个if判断条件挺有趣的</span><span class="token comment">//队列非常有层次感，有很多妙用，既可以用于递归层次，又可以用于重复</span><span class="token comment">//比如书上这个很强的1212报到1出列的问题</span><span class="token keyword">void</span> <span class="token function">number</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ElemType e<span class="token punctuation">;</span>    SqQueue <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">enQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"报数出列顺序：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">enQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//偶数惨遭重新排队哈哈</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DestoryQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//还可以定制双端队列什么的，其实原理都差不多</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">qnode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">qnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> DataNode<span class="token punctuation">;</span><span class="token comment">//需要一个链队节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    DataNode <span class="token operator">*</span>front<span class="token punctuation">;</span>    DataNode <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> LinkQuNode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkQuNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyQueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DataNode <span class="token operator">*</span>pre <span class="token operator">=</span> q<span class="token operator">-></span>front<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这个怎么总是忘掉啊！</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span> <span class="token comment">//因为无限长度，所以类型是bool</span><span class="token punctuation">&#123;</span>    DataNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span>DataNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//还要判断是不是空列表！！！</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        q<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        q<span class="token operator">-></span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bool <span class="token function">dequeue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DataNode <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    t <span class="token operator">=</span> q<span class="token operator">-></span>front<span class="token punctuation">;</span><span class="token comment">//两种情况都可以先将t指过来</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token comment">//只有一个节点</span>        q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        q<span class="token operator">-></span>front <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-串"><a href="#3-串" class="headerlink" title="3.串"></a>3.串</h1><h2 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">若串S<span class="token operator">=</span>′software′<span class="token punctuation">,</span>其子串的数目是<span class="token punctuation">(</span><span class="token punctuation">)</span>字符串的子串，就是字符串中的某一个连续片段。截取一个字符串长度需要一个起始位置和结束位置。字符串“software”有<span class="token number">8</span>个字符，可是设置间隔的位置有<span class="token number">9</span>个，使用<span class="token function">C</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">36</span>即可求得字符串“software”的所有子串。因为题目标明空串也是子串，故还需要加上<span class="token number">1</span>，总共<span class="token number">37</span>个子串。所以答案选<span class="token number">37</span>空格串是指由空格字符所组成的字符串，其长度等于空格个数。 。组成串的数据元素只能是字符。<span class="token comment">/*StrAssign(&amp;s,cstr)将cstr字符串内容赋给sDestoryStr(&amp;s)销毁串StrCopy(&amp;s,t)串复制，将串t赋给串sStrEqual(s,t)StrLength(s)Concat(s,t)返回一个新串，不改变原来的串SubStr(s,i,j)求子串InsStr(s1,i,s2)字串插入DelStr(s,i,j)字串删除RepStr(s,i,j,t)字串替换DispStr(s)串输出*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> SqString<span class="token punctuation">;</span><span class="token comment">//把字符串转换成串的数据结构</span><span class="token keyword">void</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span>length <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestoryStr</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//因为这个不是malloc分配的，会自动回收</span><span class="token keyword">void</span> <span class="token function">StrCopy</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>length <span class="token operator">=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//判断相等</span>bool <span class="token function">StrEqual</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    bool same <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">!=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//能用长度排除就直接去世吧</span>        same <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                same <span class="token operator">=</span> false<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> same<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">StrLength</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//链接</span>SqString <span class="token function">Concat</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SqString str<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">+</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>s<span class="token punctuation">.</span>length <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//从这时起，下标注意进行简单的计算</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求子串，返回从第i个字符开始的，连续j个字符组成的字串</span>SqString <span class="token function">SubStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    SqString str<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span>         <span class="token comment">//i+j-1注意一下下，理解不了就最简单的i=1,j=2,s</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//i-1开始，因为逻辑和物理差1</span>    <span class="token punctuation">&#123;</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这个里面的加减1有点骚，理解好了这类题就不怕了。</span>SqString <span class="token function">IntStr</span><span class="token punctuation">(</span>SqString s1<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> SqString s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    SqString str<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s1<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//插入的时候是可以多插一位的</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>                  <span class="token comment">//返回空串</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>s2<span class="token punctuation">.</span>length <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s1<span class="token punctuation">.</span>length <span class="token operator">+</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>SqString <span class="token function">DelStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    SqString str<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//便于返回空串</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">-</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将i开始到j的字串用t替换</span><span class="token comment">//我好像有点明白了，他在for循环里用的索引对标某个长度，很简单，其他的操作通过改变数组索引的表达式来实现。</span>SqString <span class="token function">RepStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    SqString str<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>length <span class="token operator">-</span> j <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> j <span class="token operator">+</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DispStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//比较大小</span><span class="token keyword">int</span> <span class="token function">Strcmp</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> comlen<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        comlen <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">else</span>        comlen <span class="token operator">=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//这里也包括了相等的情况</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> comlen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">==</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">></span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求s中出现的第一个最长连续相同字符构成的平台，用index开始索引，maxlen保存长度</span><span class="token keyword">void</span> <span class="token function">LongestString</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>index<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>maxlen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    index <span class="token operator">=</span> maxlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">;</span> <span class="token comment">//用来保存局部的  这种全局和局部都有对应的变量！</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//留个物理索引</span>        length <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            length<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxlen <span class="token operator">&lt;</span> length<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            maxlen <span class="token operator">=</span> length<span class="token punctuation">;</span>            index <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//Brute-Force</span><span class="token keyword">int</span> <span class="token function">BF</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//i回退到最初的后一位，j清空</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>i<span class="token operator">-</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链串（堆串）"><a href="#链串（堆串）" class="headerlink" title="链串（堆串）"></a>链串（堆串）</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token comment">//链串的创建都是用尾插法，因此都有一个工具节点r</span><span class="token comment">//带头节点的单链表作为链串，结点大小是每个结点存储的字符个数,未占用的用特殊符号（#）填补</span><span class="token comment">//链串中，节点大小越大，存储密度越大，基本操作有所不便，适合很少修改的情况，这里规定大小为1</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">snode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span> <span class="token comment">//存放字符</span>    <span class="token keyword">struct</span> <span class="token class-name">snode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> LinkStrNode<span class="token punctuation">;</span><span class="token comment">//要用尾插法保证顺序</span><span class="token keyword">void</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>data <span class="token operator">=</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        r <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStrNode <span class="token operator">*</span>pre <span class="token operator">=</span> s<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">StrCopy</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">StrEqual</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//直接比较本身</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">==</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q<span class="token operator">-></span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">StrLength</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//链接两个数组其实就是分别遍历一遍</span>LinkStrNode <span class="token operator">*</span><span class="token function">Concat</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    p <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//这样直接转过来，少一个工具节点，是我蠢了</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//当参数不正确的时候返回一个空串，这里需要调用之前已经封装好的函数</span>LinkStrNode <span class="token operator">*</span><span class="token function">Substr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span> <span class="token comment">//经典四件套哈哈</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先把空串准备好在这里</span>    r <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这里的k取得是1，因为要取到逻辑顺序第i位的前一位，而不是物理顺序</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//怎么感觉这里所有的其实都差不多，都是链表啊啥的，没啥意思</span>LinkStrNode <span class="token operator">*</span><span class="token function">InsStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p1<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p1 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这个基本上都是完全一样的，直接copy一部分，瞬间刷完，我吐了，这些那么相似的还搞</span>LinkStrNode <span class="token operator">*</span><span class="token function">DelStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这里的k应该是0，因为这个就不是逻辑序号，而是物理上的序号了</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkStrNode <span class="token operator">*</span><span class="token function">RepStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这样的其实也是逻辑，所以i-1，使用哪种看自己喜欢吧</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//好垃圾啊，，真的全都一样的，我感觉我都能背下来了</span><span class="token keyword">void</span> <span class="token function">DispStr</span><span class="token punctuation">(</span>LinkStrNode s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h1><p>只要确保了子结构和大结构 <strong>结构一致</strong>，就不用考虑过多细节，在设计算法的时候留意递归调用的意义，比如求树的深度，在某个地方需要子树的深度了，<strong>就直接调用就好</strong>，只用关心你这最宏观的一层，不用考虑内在的东西，这就是递归的魔力。因此【递归模型】非常重要</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在算法设计中，任何间接递归都可以转换为直接递归，这是自顶向下，同时考虑最底部的</span><span class="token comment">//如果递归过程或者递归函数的递归调用语句是最后一条执行语句，则称为尾递归</span><span class="token comment">/* 三个条件：1.问题可以转化为1个或多个2.递归调用的次数必须是有限的3.必须有用来结束递归的条件*/</span>用到递归的三种情况：<span class="token number">1.</span> 数学公式，数列本身的定义就是递归的，比如n！和斐波那契数列<span class="token number">2.</span> 数据结构是递归的，比如指向本身的链表，对于这样的结构，递归方法既方便又有效但是要注意大结构和小结构保持一致性，比如对单链表设计递归算法时，通常采用不带头结点的单链表。<span class="token keyword">int</span> <span class="token function">Sum</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> <span class="token function">Sum</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token number">3.</span> 问题的求解是递归的，比如汉诺塔P149<span class="token keyword">void</span> <span class="token function">Hanoil</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">char</span> X<span class="token punctuation">,</span><span class="token keyword">char</span> Y<span class="token punctuation">,</span><span class="token keyword">char</span> Z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将第%d个盘片从%c移动到%c"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">Hanoil</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">,</span>Y<span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将第%d个盘片从%c移动到%c"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归模型：递归出口和递归体，可以看P150</strong></p><p>可以说递归的思想来自数学归纳法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">char</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    bool flag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> StackType<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Push</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    s<span class="token operator">-></span>top<span class="token operator">++</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Pop</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">GetTop</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*共享栈，适用于一方可能用到满，另一方还有很多空间栈空：top1 == -1   top2 == MAXSIZE栈满：top1 ==top2-1进栈出栈的时候top2的操作和top1是反的*/</span><span class="token comment">//********************************************************************</span><span class="token comment">//一般，尾递归算法可以通过循环或者迭代转换为等价的非递归算法</span><span class="token keyword">int</span> <span class="token function">Fib2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            s <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*对于不是尾递归的复杂递归，可以在 理解递归调用实现过程 的基础上用栈来模拟递归执行过程(这是关键啊)，从而将其转换为等价的非递归算法*/</span><span class="token comment">//汉诺塔问题的非递归实现：注意栈的结构决定了e1,e3的push顺序和实际执行顺序相反！</span><span class="token keyword">void</span> <span class="token function">Hanoi2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">,</span> <span class="token keyword">char</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    StackType <span class="token operator">*</span>st<span class="token punctuation">;</span>    ElemType e<span class="token punctuation">,</span> e1<span class="token punctuation">,</span> e2<span class="token punctuation">,</span> e3<span class="token punctuation">;</span> <span class="token comment">//一共要用到这么多变量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    e<span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    e<span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    e<span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>flag <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            e1<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            e1<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>            e1<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>            e1<span class="token punctuation">.</span>z <span class="token operator">=</span> e<span class="token punctuation">.</span>z<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e1<span class="token punctuation">.</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                e1<span class="token punctuation">.</span>flag <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token keyword">else</span>                e1<span class="token punctuation">.</span>flag <span class="token operator">=</span> false<span class="token punctuation">;</span>            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>            e2<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n<span class="token punctuation">;</span>            e2<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>            e2<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>            e3<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            e3<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>            e3<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>z<span class="token punctuation">;</span>            e3<span class="token punctuation">.</span>z <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e3<span class="token punctuation">.</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                e3<span class="token punctuation">.</span>flag <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token keyword">else</span>                e3<span class="token punctuation">.</span>flag <span class="token operator">=</span> false<span class="token punctuation">;</span>            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将%d个盘片从%c移动到%c\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>n<span class="token punctuation">,</span> e<span class="token punctuation">.</span>x<span class="token punctuation">,</span> e<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//递归算法执行中，最长的递归调用的链长称为该算法的递归调用深度</span><span class="token comment">/*设计队规算法的基本步骤是先确定问题的递归模型，再转化成C/C++语言的函数确定递归模型的步骤是：1. 对原问题f(n)进行分析，假设出合理的小问题f(n-1)2. 给出f(n)与f(n-1)甚至更多项之间的关系，也就是确定递归体，也就是数学归纳法中的假设i = n-1成立，求证 i =n3. 找到特定情况如f(1)作为递归出口 4. 注意栈的次序和你的逻辑次序可能需要一定的调整*/</span><span class="token comment">//有0~i个元素，求最小值，思路是找到前面的最小值</span><span class="token keyword">double</span> <span class="token function">Min</span><span class="token punctuation">(</span><span class="token keyword">double</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> min<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        min <span class="token operator">=</span> <span class="token function">Min</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><p>通常只有读和写两种操作。</p><p>每个元素占k个存储单元，则LOC(ai) = LOC(a1)+(i-1) x k</p><p>二维数组大家都是按行存放的，为啥要搞出按列来。</p><h2 id="特殊矩阵压缩"><a href="#特殊矩阵压缩" class="headerlink" title="特殊矩阵压缩"></a>特殊矩阵压缩</h2><p>对于ai,j  = bk</p><ol><li><p>对称矩阵 P169</p><p>k = i(i+1)/2 + j   i&gt;=j                     k= j(j+1)/2  +i  j&gt;=i</p></li><li><p>下三角和对称矩阵十分相似，但是上三角还是有点差距的，最后一位有一个常数c P70</p><p>上三角：k = i(2n-i+1)/2 +j-i   i&lt;=j           n(n+1)/2   i&gt;j</p><p>下三角：k = i(i+1)/2 + j   i&gt;=j                  n(n+1)/2   i&lt;j</p></li><li><p>三对角矩阵且存储到一维数组时，k = 2i+j   b = 1</p></li></ol><p>这样的压缩存储只需在算法中按公式作映射就可以实现随机存取</p><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p>非零元素具有随机性，用三元组表，十字链表比较复杂来存取</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span>       </span><span class="token comment">//行数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">200</span>       </span><span class="token comment">//列数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>      <span class="token comment">//行号</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>      <span class="token comment">//列号</span>    ElemType d<span class="token punctuation">;</span> <span class="token comment">//元素值</span><span class="token punctuation">&#125;</span> TupNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> rows<span class="token punctuation">;</span>    <span class="token keyword">int</span> cols<span class="token punctuation">;</span>    <span class="token keyword">int</span> nums<span class="token punctuation">;</span>    TupNode data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> TSMatrix<span class="token punctuation">;</span><span class="token comment">//从二维稀疏矩阵创建三元组表示,有点新奇哈哈</span><span class="token keyword">void</span> <span class="token function">CreateMat</span><span class="token punctuation">(</span>TSMatrix <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> ElemType A<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    t<span class="token punctuation">.</span>rows <span class="token operator">=</span> M<span class="token punctuation">;</span>    t<span class="token punctuation">.</span>cols <span class="token operator">=</span> N<span class="token punctuation">;</span>    t<span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> j<span class="token punctuation">;</span>                t<span class="token punctuation">.</span>nums<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//三元组元素的赋值，不存在（0）时插入一个非零元素，存在时修改要理解好他这个数据结构是怎样的</span>bool <span class="token function">Value</span><span class="token punctuation">(</span>TSMatrix <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> ElemType x<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> t<span class="token punctuation">.</span>rows <span class="token operator">||</span> j <span class="token operator">>=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        k<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//这个查找方式。。。秀啊</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> j<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//存在这样的非0元素</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>k1 <span class="token operator">=</span> t<span class="token punctuation">.</span>nums <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k1 <span class="token operator">>=</span> k<span class="token punctuation">;</span> k1<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//这里注意带 =，不然第k项原本有意义的就被覆盖了</span>        <span class="token punctuation">&#123;</span>            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">;</span>            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> j<span class="token punctuation">;</span>        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> x<span class="token punctuation">;</span>        t<span class="token punctuation">.</span>nums<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//最终四步处理</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Assign</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> t<span class="token punctuation">.</span>rows <span class="token operator">||</span> j <span class="token operator">>=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        x <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//返回0</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DispMat</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>nums <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t%d\t%d\t%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>rows<span class="token punctuation">,</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t------------------------\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t%d\t%d\t%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//转置，把列号放在前面，那就要依次查找列号，高效的是快速转置</span><span class="token keyword">void</span> <span class="token function">TranTat</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>tb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span> k1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token comment">//k1记录tb中的元素个数</span>    tb<span class="token punctuation">.</span>rows <span class="token operator">=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">;</span>    tb<span class="token punctuation">.</span>cols <span class="token operator">=</span> t<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>    tb<span class="token punctuation">.</span>nums <span class="token operator">=</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>nums <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//每一列都完整的遍历一遍，效率巨低。</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> v<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">;</span>                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>                    k1<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//接下来是十字链表的数据结构P178</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Max</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">?</span> M <span class="token operator">:</span> N<span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mtxn</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> row<span class="token punctuation">;</span>    <span class="token keyword">int</span> col<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mtxn</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>down<span class="token punctuation">;</span>  <span class="token comment">//向右循环的行指针和向下循环的列指针</span>    <span class="token keyword">union</span>    <span class="token punctuation">&#123;</span>        ElemType value<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">mtxn</span> <span class="token operator">*</span>link<span class="token punctuation">;</span> <span class="token comment">//指向下个头节点</span>    <span class="token punctuation">&#125;</span> tag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> MatNode<span class="token punctuation">;</span><span class="token comment">//代价是运算算法比较复杂</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表的特征：</p><ol><li>广义表中的数据元素是有相对次序的</li><li>长度定义为最外层包含元素的个数</li><li>深度定义为包含括弧的重数，原子的深度为0，空表的深度为1</li><li>广义表可以共享，这种叫再入表</li><li>广义表可以是一个递归表，一个广义表可以是自己的子表，这种叫递归表，深度∞，长度有限</li></ol><p>不讨论再入表和递归表，小写字母表示原子，大写字母表示广义表的表名</p><p>没有给出表明的叫做<em>匿名表</em> ，用 <strong>·</strong> 表示</p><p>表头：head（GL）叫做表头，取第一个元素，tail（GL）为其余所有部分（<strong>包括原来的括号</strong>），显然一个广义表的表尾始终为一个广义表，空表无表头表尾：</p><p>A（）无表头表尾</p><p>B（e） 表头e   表尾（） <strong>空的也会被算上！！</strong></p><p>C（a，· （b,c,d）） 表头 a   表尾（（b,c,c））<strong>注意有两层括号</strong>，看来表尾会保持原有的深度</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">lnode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span> <span class="token comment">//标识符 0为原子节点，1为表节点</span>    <span class="token keyword">union</span>    <span class="token punctuation">&#123;</span>        ElemType data<span class="token punctuation">;</span>         <span class="token comment">//存放数据值</span>        <span class="token keyword">struct</span> <span class="token class-name">lnode</span> <span class="token operator">*</span>sublist<span class="token punctuation">;</span> <span class="token comment">//指向子表的指针</span>    <span class="token punctuation">&#125;</span> val<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">lnode</span> <span class="token operator">*</span>link<span class="token punctuation">;</span> <span class="token comment">//同一层的下一个元素</span><span class="token punctuation">&#125;</span> GLNode<span class="token punctuation">;</span><span class="token comment">//tag = 1的节点可以看成是一个单链表的头节点，指向子表的首节点,通过递归性，有两种解法</span><span class="token comment">//解法1，把整个看成一个带头节点的单链表，种类分原子和子表，子表类似整个表，而原子则仅仅是原子处理罢了。</span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">fun1</span><span class="token punctuation">(</span>gl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//z</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原子处理语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//处理后继元素</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//解法2，对于元素节点，其兄弟域的节点和整个广义表是相似的，对于表节点，其元素域和兄弟域的处理均与整个广义表相似</span><span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment">//为子表</span>            <span class="token function">fun2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先递归处理表节点的元素域</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原子处理语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">fun2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理两种节点的兄弟（不用分类，因为无论什么节点，兄弟都相似于整个表）</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//实际问题中根据求解问题的特点自行选择其中来设计递归求解，比如计数：</span><span class="token keyword">int</span> <span class="token function">Count1</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            n <span class="token operator">+=</span> <span class="token function">Count1</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Count2</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            n <span class="token operator">+=</span> <span class="token function">Count2</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        n <span class="token operator">+=</span> <span class="token function">Count2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">GLLength</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        n<span class="token operator">++</span><span class="token punctuation">;</span>        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//只用算最表层的哈哈</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">GLDepth</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GLNode <span class="token operator">*</span>gl<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dep<span class="token punctuation">;</span> <span class="token comment">//maxd是同一层子表中深度的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>gl <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//这下面这个操作还是挺妙的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dep <span class="token operator">=</span> <span class="token function">GLDepth</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//dep代表该节点的深度！自顶向下</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dep <span class="token operator">></span> maxd<span class="token punctuation">)</span>                maxd <span class="token operator">=</span> dep<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>maxd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回这一层的最大值到上一层的节点</span><span class="token punctuation">&#125;</span><span class="token comment">//要输出成括号的形式还是有点麻烦的，元素直接输出值，子表则输出 ‘（’，空表输出‘#’，非空子表递归，再输出‘）’</span><span class="token comment">//这里其实用到的就是递归思想，仅考虑一层。非常简单</span><span class="token keyword">void</span> <span class="token function">DispGL</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">DispGL</span><span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这个括号不要漏了</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>link <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">DispGL</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//兄弟应该在子表后面输出</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//与输出对应的，建立广义表的链式存储结构,记得空表是 “#”，遇到则将g->val.sublist置空</span><span class="token comment">//扫描到 （ 则用g递归开启一个子表节点，遇到 ）说明已经处理完，g置空</span><span class="token comment">//时空复杂的均为O（n）</span><span class="token comment">//切记把链式结构和符号表示分开想，不要混在一起！</span><span class="token comment">//巧妙地递归逻辑，配合引用参数（注意这里默认一个元素是‘单个’字符）</span><span class="token comment">//这里我一开始理解难受是因为它既有嵌套递归，又有把子任务视为平级的递归，害。</span>GLNode <span class="token operator">*</span><span class="token function">CreateGL</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GLNode <span class="token operator">*</span>g<span class="token punctuation">;</span>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//取一个字符,直接操作指针的话，便于后续调用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        g <span class="token operator">=</span> <span class="token punctuation">(</span>GLNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            g<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist <span class="token operator">=</span> <span class="token function">CreateGL</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span>            g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">)</span>            g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            g<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            g<span class="token operator">-></span>val<span class="token punctuation">.</span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//若s扫描完，把g置空</span>    ch <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">','</span><span class="token punctuation">)</span>            g<span class="token operator">-></span>link <span class="token operator">=</span> <span class="token function">CreateGL</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            g<span class="token operator">-></span>link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> g<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//采用解法1,递归销毁，注意要灵活一点，顺序什么的不影响那么怎样方便怎样来</span><span class="token keyword">void</span> <span class="token function">DestroyGL</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span><span class="token operator">&amp;</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GLNode <span class="token operator">*</span>g1<span class="token punctuation">,</span> <span class="token operator">*</span>g2<span class="token punctuation">;</span>    g1 <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>g1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g1<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            g2 <span class="token operator">=</span> g1<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//保存兄弟节点</span>            <span class="token function">free</span><span class="token punctuation">(</span>g1<span class="token punctuation">)</span><span class="token punctuation">;</span>            g1 <span class="token operator">=</span> g2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            g2 <span class="token operator">=</span> g1<span class="token operator">-></span>link<span class="token punctuation">;</span>            <span class="token function">DestroyGL</span><span class="token punctuation">(</span>g1<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>            g1 <span class="token operator">=</span> g2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-树"><a href="#6-树" class="headerlink" title="6.树"></a>6.树</h1><h2 id="基本和存储"><a href="#基本和存储" class="headerlink" title="基本和存储"></a>基本和存储</h2><p>有树形表示法，文氏图表示法，凹入表示法和括号表示法等等。</p><p>树的定义是递归的，树的性质在P192</p><ol><li>结点数 = 所有节点的出度（其实就是边数） + 1</li><li>度为m的树（就是节点中最大出度为m）中第i层上最多有m^(i-1)个节点，若每一层都是满的，称为满m次树</li><li>高度为h的m次树最多有(m^h - 1)/(m-1) 个节点</li><li>具有n个结点的m次树的最小高度为logm(n(m-1)+1)向大取整</li></ol><p>其实性质2，3，4说的都是一种情况。。。</p><p>对于m次树，含有n个节点，那么最大高度maxh = n - (m-1) 显然，除了最后一个节点，其他度都为1就好了</p><p>基本运算有寻找特定节点，插入/删除特定节点，<strong>遍历</strong></p><p>遍历的先中后原来是根节点的输出次序，一般都习惯先左后右。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//存储结构</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token comment">//1.双亲存储，顺序存储，根节点的父节点设置为-1，其余设置为父节点在顺序中的位置</span><span class="token comment">//求双亲容易，但是求某个节点的子节点难，要遍历整个存储结构</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSons</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设树的度为100</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> PTree<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//2.子链存储，每个节点有指向所有孩子结点的指针，因为难以确定数目，统一用最大的【树的度】来分配</span><span class="token comment">//找双亲费时，找孩子很方便，树的度与平均度偏差较大时，浪费</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSons</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设树的度为100</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>sons<span class="token punctuation">[</span>MaxSons<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> TSonNode<span class="token punctuation">;</span><span class="token comment">//以此为基础求树的高度</span><span class="token keyword">int</span> <span class="token function">TreeHeight1</span><span class="token punctuation">(</span>TSonNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    TSonNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> h<span class="token punctuation">,</span> maxh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxSons<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> t<span class="token operator">-></span>sons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                h <span class="token operator">=</span> <span class="token function">TreeHeight1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求子树的深度</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxh <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>                    maxh <span class="token operator">=</span> h<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>maxh <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//3.孩子兄弟链，每个节点三个域，一个元素，一个指向长子，一个指向兄弟</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tnode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">tnode</span> <span class="token operator">*</span>hp<span class="token punctuation">;</span> <span class="token comment">//指向兄弟 horizontal point</span>    <span class="token keyword">struct</span> <span class="token class-name">tnode</span> <span class="token operator">*</span>vp<span class="token punctuation">;</span> <span class="token comment">//指向孩子 vertical point</span><span class="token punctuation">&#125;</span> TSBNode<span class="token punctuation">;</span><span class="token comment">//其实这种结构是把树转换为二叉树的存储结构</span><span class="token comment">//最大的优点就是方便的实现树和二叉树的相互转换,缺点时查找父节点麻烦</span><span class="token keyword">int</span> <span class="token function">TreeHeight2</span><span class="token punctuation">(</span>TSBNode <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    TSBNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> h<span class="token punctuation">,</span> maxh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> t<span class="token operator">-></span>vp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//遍历同一层的p</span>    <span class="token punctuation">&#123;</span>        h <span class="token operator">=</span> <span class="token function">TreeHeight2</span><span class="token punctuation">(</span>p<span class="token operator">-></span>vp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求出这一层的最大值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxh <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>            maxh <span class="token operator">=</span> h<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>hp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> maxh <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>呜呜呜，好长这里，冲冲冲！</p><p>二叉树是区分左右的，任何m次数都可以转化为二叉树结构</p><p><strong>满二叉树</strong>：叶子节点都集中在二叉树的最下一层，所有分支节点都有左右孩子的树，只有度为0或2的节点。</p><p>可以进行层序编号，第一个是0，若节点为x，则左孩子为2x，右孩子为2x + 1</p><p><strong>完全二叉树</strong>：只有最下两层节点度数可以小于2，且叶子节点全都靠左排列。</p><p>最多只有1个出度为1的节点，且节点有左孩子，结点总数n为奇数时没有出度为1的结点</p><p><strong>满二叉树是完全二叉树的特例</strong></p><p>二叉树性质：</p><ol><li><p>非空二叉树上的<strong>叶子节点数</strong>等于<strong>双分支结点数+1</strong></p><p>用到了：m(度的和) = n-1   度的和 = n1 + 2n2    n = n0(叶子结点数) + n1 + n2</p></li><li><p>非空二叉树的第i层最多只有2^(i-1)个结点</p></li><li><p>高度为h的二叉树最多有 2^h - 1 个结点</p></li><li><p>若节点为x，则左孩子为2x，右孩子为2x + 1，父节点为x/2 向下取整</p></li><li><p>具有n个节点的完全二叉树高度为 log2(n+1)向上取整 或者log2n向下取整 +1</p></li></ol><p>树转二叉树：相邻兄弟加线，保留长子线，其余删除    森林则把根节点链接</p><p>二叉树转树：若某节点为双亲的左孩子，则把该节点的右孩子，右孩子的右孩子都与该节点的双亲连起来，</p><p>删除原二叉树中所有双亲结点与右孩子结点之间的连线。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token comment">/*先看看顺序存储结构对于完全二叉树和满二叉树，可以实现随机存储，完全二叉树最后几个空的用 # 表示对于一般的二叉树，可以增添一些不存在的空结点，使之成为一棵完全二叉树的形式。图可以看看P204  */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> ElemType SqBinTree<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//但是如果空的太多，会造成空间的大量浪费，但是查找子节点和父节点都很方便。</span><span class="token comment">//当然还有一般顺序存储结构的缺点，就是插入，删除很不方便</span><span class="token comment">//链式存储，称为二叉链，用根节点指针b唯一标识整个存储结构，称为二叉树b</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    <span class="token comment">//struct node *parent;</span><span class="token punctuation">&#125;</span> BTNode<span class="token punctuation">;</span><span class="token comment">//这样节省空间，但不方便访问父节点，可以增加一个指向父节点的指针域parent来解决。</span><span class="token comment">//后续一般假设一棵二叉树中所有结点值均不同，为单个字符</span><span class="token comment">//创建，销毁，按值查找（父），找孩子，求高度，输出   创建和输出都用括号表示法</span><span class="token comment">//首先得理解二叉树的括号表示，模拟一个栈来实现,因为栈的实现很简单，并没有封装</span><span class="token comment">//这个用栈保存双亲结点的思想太妙了！栈顶存放的是当前处理节点的父节点</span><span class="token keyword">void</span> <span class="token function">CreateBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>St<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//St为顺序栈</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//j为str索引,k用来判断孩子类型</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    ch <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">'('</span><span class="token operator">:</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            St<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">')'</span><span class="token operator">:</span>            top<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">','</span><span class="token operator">:</span>            k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            p <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>            p<span class="token operator">-></span>lchild <span class="token operator">=</span> p<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//这是只存在一次的还未建立根节点的情况</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token comment">//只有1和2的情况来回切换！</span>                <span class="token punctuation">&#123;</span>                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                    St<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>lchild <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                    St<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        ch <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//查找x的结点</span>BTNode <span class="token operator">*</span><span class="token function">FindeNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>        <span class="token keyword">return</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> <span class="token function">FindeNode</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token function">FindeNode</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//p</span>        <span class="token comment">//这也把没找到的情况包含在内了，要学会简化代码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>BTNode <span class="token operator">*</span><span class="token function">LchildNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BTNode <span class="token operator">*</span><span class="token function">RchildNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求高度</span><span class="token keyword">int</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> lchild<span class="token punctuation">,</span> rchild<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        lchild <span class="token operator">=</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        rchild <span class="token operator">=</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>lchild <span class="token operator">></span> rchild <span class="token operator">?</span> lchild <span class="token operator">:</span> rchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//终究还是比广义表简单不少啊,当是NULL的时候不操作，非常流弊</span><span class="token keyword">void</span> <span class="token function">DispBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> b<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">DispBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">DispBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//突然想玩一下下</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A(B(D(,G))C(E,F))"</span><span class="token punctuation">;</span>    BTNode <span class="token operator">*</span>BT<span class="token punctuation">;</span>    <span class="token function">CreateBTree</span><span class="token punctuation">(</span>BT<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DispBTree</span><span class="token punctuation">(</span>BT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nI prefer Python, C is to complex and confused"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*遍历，四种顺序，层次遍历是非递归的一颗二叉树可以分为根节点和子树两类，根节点直接处理，子树递归处理如果必须先处理子树，那就用后序，如果必须先处理根节点，那就用先序，否则随便如果要区分左，右树，那就要考虑中序，但是比较少*/</span><span class="token keyword">void</span> <span class="token function">Preorder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Preorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Preorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Inorder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Inorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Inorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//求给定二叉树的所有结点个数</span><span class="token keyword">int</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//这个是先左后右后根，是后续遍历</span><span class="token punctuation">&#125;</span><span class="token comment">//输出所有的叶子节点</span><span class="token comment">/*递归模型很重要！f(b) === 不做任何事情    b=NULLf(b) === 输出b的data域   b为叶子结点f(b) === f(b->lchild);f(b->rchild) 其他情况*/</span><span class="token keyword">void</span> <span class="token function">DispLeaf</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DispLeaf</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DispLeaf</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//求深度，h置处置1，这个和之前那个稍微有点不同，具体分析</span><span class="token keyword">int</span> <span class="token function">Level</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">,</span> <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> l<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>        <span class="token keyword">return</span> h<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        l <span class="token operator">=</span> <span class="token function">Level</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">Level</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//又见到了这种操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//求b树第k层的结点数,h是用来传递参数，初始为1</span><span class="token comment">//这是另一种递归思路，并没有回带的过程，利用了void和引用</span><span class="token comment">//如果在c语言中，可以用全局变量来代替所谓的引用。</span><span class="token keyword">void</span> <span class="token function">Lnodenum</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> h<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> k<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">Lnodenum</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">Lnodenum</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出x的结点的所有祖先,多判断一级的思维</span>bool <span class="token function">ancestor</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>lchild<span class="token operator">-></span>data <span class="token operator">==</span> x <span class="token operator">||</span> b<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>rchild<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">putchar</span><span class="token punctuation">(</span>b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ancestor</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">ancestor</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">putchar</span><span class="token punctuation">(</span>b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//非递归算法区域P218</span><span class="token comment">//层次遍历算法</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> SqQueue<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    SqQueue <span class="token operator">*</span>qu<span class="token punctuation">;</span>    <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">deQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">putchar</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h2><p>由先序序列+中序序列，或者中序序列+后序序列唯一地确定一颗二叉树</p><p>实际上，先序序列的作用是确定一棵二叉树的根节点，中序序列的作用是确定左、右子树的中序序列，从而进一步确定先序序列，递归构造左右子树。</p><p>原理在P229</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//二叉树的构造</span><span class="token comment">//pre存放先序序列，in存放中序序列，n为二叉树的节点个数</span><span class="token comment">//其实函数的参数选择同时得考虑递归时不同层级间需要的参数</span>BTNode <span class="token operator">*</span><span class="token function">CreateBT1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span> <span class="token comment">//根节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> in<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> in <span class="token operator">+</span> n<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> <span class="token operator">*</span>pre<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    k <span class="token operator">=</span> p <span class="token operator">-</span> in<span class="token punctuation">;</span> <span class="token comment">//确定根节点在in中的位置</span>    b<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> in<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里不能光考虑第一次的，要用通用的写法</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//和上面基本一致</span>BTNode <span class="token operator">*</span><span class="token function">CreateBT2</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>post<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BTNode <span class="token operator">*</span>b    <span class="token keyword">char</span> r<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//因为根节点在后头，所以得用一个变量单独保存</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>post <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>data <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> post<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> post <span class="token operator">+</span> n<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> r<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    k <span class="token operator">=</span> p <span class="token operator">-</span> post<span class="token punctuation">;</span>    b<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token function">CreateBT2</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> in<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token function">CreateBT2</span><span class="token punctuation">(</span>post <span class="token operator">+</span> k<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈夫曼"><a href="#哈夫曼" class="headerlink" title="哈夫曼"></a>哈夫曼</h2><p>WPL  Weighted Path Length 带权路径长度</p><p>定理：假如哈夫曼树有n个叶子结点，那么一共有2n+1个</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//哈夫曼树采用数组存放，总的结点数可以算出来 P239</span><span class="token comment">//前n个存放原结点（叶子结点），剩下的存放分支节点。</span><span class="token comment">//思路是先将全部节点的parent、lchild、rchild赋值为-1,然后不断找最小的放在后面，同时补全信息</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> lchild<span class="token punctuation">;</span>    <span class="token keyword">int</span> rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HTNode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n0<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">;</span>    <span class="token keyword">double</span> min1<span class="token punctuation">,</span> min2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> n0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> n0 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        min1 <span class="token operator">=</span> min2 <span class="token operator">=</span> <span class="token number">32767</span><span class="token punctuation">;</span>        lnode <span class="token operator">=</span> rnode <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token comment">//通过确定两个最小值的相对次序来巧妙地处理该问题</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">//在尚未构造二叉树的结点中查找</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> min1<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    min2 <span class="token operator">=</span> min1<span class="token punctuation">;</span>                    rnode <span class="token operator">=</span> lnode<span class="token punctuation">;</span>                    min1 <span class="token operator">=</span> ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                    lnode <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> min2<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    min2 <span class="token operator">=</span> ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>                    rnode <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> ht<span class="token punctuation">[</span>lnode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">+</span> ht<span class="token punctuation">[</span>rnode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> lnode<span class="token punctuation">;</span>        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> rnode<span class="token punctuation">;</span>        ht<span class="token punctuation">[</span>lnode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> i<span class="token punctuation">;</span>        ht<span class="token punctuation">[</span>rnode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//哈夫曼编码,规定左分支为0，右分支为1</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> cd<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放当前节点的哈夫曼编码</span>    <span class="token keyword">int</span> start<span class="token punctuation">;</span>  <span class="token comment">//表明cd[start..n0]部分是哈夫曼编码</span><span class="token punctuation">&#125;</span> HCode<span class="token punctuation">;</span><span class="token comment">//这是个从下向上的过程，但是最终是顺序的</span><span class="token keyword">void</span> <span class="token function">CreateHCode</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> HCode hcd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n0<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    HCode hc<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n0<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        hc<span class="token punctuation">.</span>start <span class="token operator">=</span> n0<span class="token punctuation">;</span>        c <span class="token operator">=</span> i<span class="token punctuation">;</span>        f <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span> <span class="token comment">//初始化</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">//循环到根节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">==</span> c<span class="token punctuation">)</span>                hc<span class="token punctuation">.</span>cd<span class="token punctuation">[</span>hc<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                hc<span class="token punctuation">.</span>cd<span class="token punctuation">[</span>hc<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> f<span class="token punctuation">;</span>            f <span class="token operator">=</span> ht<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        hc<span class="token punctuation">.</span>start<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//因为多减了一次，加回来</span>        hcd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> hc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-图"><a href="#7-图" class="headerlink" title="7.图"></a>7.图</h1><p>找强连通分量：先找一个有向环，如果外面的某个顶点到该环任意结点均有双向路径，则加入</p><p>带权图也称作网</p><h2 id="矩阵、表存储"><a href="#矩阵、表存储" class="headerlink" title="矩阵、表存储"></a>矩阵、表存储</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXV</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//最大结点数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INF</span> <span class="token expression"><span class="token number">32767</span> </span><span class="token comment">//所谓的正无穷，也就是没有路</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> InfoType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> no<span class="token punctuation">;</span>        <span class="token comment">//顶点编号</span>    InfoType info<span class="token punctuation">;</span> <span class="token comment">//其他信息</span><span class="token punctuation">&#125;</span> VertexType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> edges<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵数组</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span>              <span class="token comment">//顶点数、边数</span>    VertexType vexs<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放结点信息</span><span class="token punctuation">&#125;</span> MatGraph<span class="token punctuation">;</span><span class="token comment">/*适合储存边比较多的稠密图邻接矩阵表示是唯一的，注意无向图、有向图每一行/列的意义非常适合提取两个顶点之间的边，适用于该目的的算法*/</span><span class="token comment">//邻接表结构是后续众多算法的基础，一定要弄清楚P259</span><span class="token comment">//每个顶点一个链表，链接关联的边。其中的每个边结点表示一条！边！的信息，not 点</span><span class="token comment">//头节点存储的则是顶点的信息，并指向首节点。</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ANode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>            <span class="token comment">//该边的临界点编号,指的是出边临界点</span>    <span class="token keyword">struct</span> <span class="token class-name">ANode</span> <span class="token operator">*</span>nextarc<span class="token punctuation">;</span> <span class="token comment">//指向下个边的指针</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>            <span class="token comment">//该边的相关信息</span><span class="token punctuation">&#125;</span> ArcNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Vnode</span><span class="token punctuation">&#123;</span>    InfoType info<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>firstarc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> VNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    VNode adjlist<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//头节点数组</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> AdjGraph<span class="token punctuation">;</span><span class="token comment">//还有所谓的逆邻接表</span><span class="token comment">/*邻接表的表示不唯一，取决于算法和输入次序，适合边数目稀疏的图对于无向图，第i个单链表的边数目是顶点i的度，有向图则为出度，入度得统计所有的adjvex域为i的数目适合提取某个顶点的所有临界点*/</span><span class="token comment">//依次扫描，头插法插入。</span><span class="token keyword">void</span> <span class="token function">CreateAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INF<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                p <span class="token operator">=</span> <span class="token punctuation">(</span>ArcNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArcNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token operator">-></span>adjvex <span class="token operator">=</span> j<span class="token punctuation">;</span>                p<span class="token operator">-></span>weight <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                p<span class="token operator">-></span>nextarc <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>                G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    G<span class="token operator">-></span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    G<span class="token operator">-></span>e <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出规则为先输出头结点的定点信息，再依次输出所有结点的顶点编号</span><span class="token keyword">void</span> <span class="token function">DispAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d[%d]"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">,</span> p<span class="token operator">-></span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DestroyAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pre <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> pre<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                pre <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> pre<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//别忘了把头节点数组也释放掉</span><span class="token punctuation">&#125;</span><span class="token comment">//将邻接表转换为邻接矩阵</span><span class="token keyword">void</span> <span class="token function">ListToMat</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">,</span> MatGraph <span class="token operator">&amp;</span>g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>weight<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    g<span class="token punctuation">.</span>n <span class="token operator">=</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span>    g<span class="token punctuation">.</span>e <span class="token operator">=</span> G<span class="token operator">-></span>e<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*十字链表是给有向图用的，是邻接表和逆邻接表的结合，现在看其实非常简单。。不知道当时为啥讲那么久。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图遍历及应用"><a href="#图遍历及应用" class="headerlink" title="图遍历及应用"></a>图遍历及应用</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//图的遍历，要求每个顶点仅被访问一次。</span><span class="token comment">//因为图不像树，存在回路，得设置一个访问标记数组visited,当访问过时置1，否则为0</span><span class="token comment">//深度优先Depyh First Search DFS</span><span class="token keyword">int</span> visited<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//全局置0,从v开始遍历</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//广度优先算法Breadth First Search BFS,显然这种结构要用到队列</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"linked_queue.cpp"</span></span><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    LinkQuNode <span class="token operator">*</span>qu<span class="token punctuation">;</span>    <span class="token function">InitQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> visited<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dequeue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历非连通图</span><span class="token keyword">void</span> <span class="token function">DFS1</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BFS1</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">Connect</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    bool flag <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            flag <span class="token operator">=</span> false<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> flag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//图遍历算法的应用</span><span class="token comment">//深度搜索判断是否存在路径。</span><span class="token keyword">void</span> <span class="token function">ExitPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> bool <span class="token operator">&amp;</span>has<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        has <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">ExitPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> has<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出从u到v的一条路径，假设已知u到v间有路径。</span><span class="token comment">//只要正常遍历就好，绝对会输出一条路径，不过非常随机就是了。</span><span class="token keyword">void</span> <span class="token function">FindaPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//d表示path中的路径长度，初始为-1</span>    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    d<span class="token operator">++</span><span class="token punctuation">;</span>    path<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">FindaPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//这个递归还是让人想了一会</span><span class="token keyword">void</span> <span class="token function">FindALLPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//d表示path中的路径长度，初始为-1</span>    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    d<span class="token operator">++</span><span class="token punctuation">;</span>    path<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">FindALLPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span> <span class="token comment">//递归体的核心就在这里</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//恢复环境，可以重复利用。</span><span class="token punctuation">&#125;</span><span class="token comment">//后面的广度优先算法的应用暂时没有更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>图的最小生成树是树的所有生成树中边上权值最小的。（实际上是选节点）</p><ul><li>n个顶点的话就有n - 1条边。</li><li>必须只使用该图中的边来构造</li><li>不能使用会产生回路的边。</li></ul><p>这个应用有很多，求最小生成树的算法：Prim 、克鲁斯卡尔</p><p>只要遍历一次，就能得到生成树，分为深度优先生成树和广度优先生成树。</p><p><strong>普利姆算法</strong></p><p>P281 依次选择最小边，因为需要频繁取边，所以图采用邻接矩阵更合适</p><p>这体现出了从算法逻辑设计到代码实现的过程也并非易事的，需要一些巧妙的构思</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Prim算法</span><span class="token comment">//建议先阅读一下P284,搞清楚lowcost(到U中的最小边)和closet（最小边对应的顶点）,这种实时更新最值的思想很有用，简化了算法</span><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> closet<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        closet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token comment">//初始化</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//找出n - 1个顶点</span>    <span class="token punctuation">&#123;</span>        MIN <span class="token operator">=</span> INF<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> MIN<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                MIN <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最小边的顶点编号</span>            <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"边(%d,%d)权为%d\n"</span><span class="token punctuation">,</span> closet<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> MIN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出最小生成树的一条边</span>        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                 <span class="token comment">//标记k已经加入U中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                closet<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>克鲁斯卡尔算法</strong></p><p>这才是正儿八经的选边。P285</p><p>当一个图有多个最小生成树时，这两个算法的求解结果不一定是相同的。</p><p>因为同样要频繁取边，也采用邻接矩阵来处理。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//关键在于如何判断选取一条边(i,j)加入到T中是否出现回路，可以通过判断顶点i,j是否同属于一个连通分量来解决</span><span class="token comment">//利用vset[0..n-1]数组来完成，太厉害了，i和j处理时，改成i或j的vset值都可以</span><span class="token comment">// Prim算法</span><span class="token comment">//建议先阅读一下P284,搞清楚lowcost(到U中的最小边)和closet（最小边对应的顶点）,这种实时更新最值的思想很有用，简化了算法</span><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> closet<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        closet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token comment">//初始化</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//找出n - 1个顶点</span>    <span class="token punctuation">&#123;</span>        MIN <span class="token operator">=</span> INF<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> MIN<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                MIN <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最小边的顶点编号</span>            <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"边(%d,%d)权为%d\n"</span><span class="token punctuation">,</span> closet<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> MIN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出最小生成树的一条边</span>        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                 <span class="token comment">//标记k已经加入U中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                closet<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//克鲁斯卡尔</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">;</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span>    <span class="token comment">//起始顶点，终止顶点和权值</span><span class="token punctuation">&#125;</span> Edge<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">20000</span> </span><span class="token comment">//最大边数</span></span><span class="token keyword">void</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> u1<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> sn1<span class="token punctuation">,</span> sn2<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> vset<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>    Edge E<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放所有的边</span>    k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//e数组的下标</span>    <span class="token comment">//第一步，由g产生E</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INF<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>u <span class="token operator">=</span> i<span class="token punctuation">;</span>                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> k<span class="token punctuation">;</span>                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">//InsertSort(E,g.e)//对所有的边按照权值排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//初始化辅助数组</span>    k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">//表示当前构造生成树的第几条边，初始为1</span>    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//E中边的下标，初始为0</span>    <span class="token comment">//主体</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token comment">//生成树有n-1条边</span>    <span class="token punctuation">&#123;</span>        u1 <span class="token operator">=</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">;</span>        v1 <span class="token operator">=</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        sn1 <span class="token operator">=</span> vset<span class="token punctuation">[</span>u1<span class="token punctuation">]</span><span class="token punctuation">;</span>        sn2 <span class="token operator">=</span> vset<span class="token punctuation">[</span>v1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sn1 <span class="token operator">!=</span> sn2<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d,%d):%d\n"</span><span class="token punctuation">,</span> u1<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出一条边</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> sn2<span class="token punctuation">)</span>                    vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sn1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>突然想研究一下能不能上传文件</p><p><a href="/papers/2021%E5%B9%BF%E4%B8%9C%E6%8B%9B%E7%94%9F%E8%AE%A1%E5%88%92.pdf">广东省2021招生计划</a></p><p>haha，那我到时候直接把源代码传上来好了，免得这个复制太难弄了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//不想做了。。狄克斯特拉算法和弗洛伊德算法，反正只考概念罢了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV"><a href="#AOV" class="headerlink" title="AOV"></a>AOV</h3><p>AOV网，用顶点表示活动，用有向边表示活动之间优先关系的有向图称为AOV网（顶点表示活动的网）</p><p>选择没有前驱的顶点输出，删去该顶点以及该顶点发出的所有边，重复以上二步</p><p>若全部顶点被输出，则不存在回路，否则存在回路</p><h3 id="AOE"><a href="#AOE" class="headerlink" title="AOE"></a>AOE</h3><p>顶点表示事件，有向<strong>边表示活动</strong>，开始事件（源点），结束事件（汇点）</p><p>从源点到汇点所有路径中具有最大路径长度的路径称为<strong>关键路径</strong>。</p><p>建议看看P304</p><p>先进行一次拓扑排序，然后递归从头找最大，递归从尾找最小。</p><h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找"></a>8.查找</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//线性表分顺序和链式，只介绍顺序表，属于静态查找。</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> years<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span>   <span class="token comment">//关键字</span>    InfoType data<span class="token punctuation">;</span> <span class="token comment">//其他数据</span><span class="token punctuation">&#125;</span> RecType<span class="token punctuation">;</span><span class="token comment">//顺序查找，ASL成功 = (n+1)/2 ASL失败 = n</span><span class="token keyword">int</span> <span class="token function">SeqSearch</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> n<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//逻辑值要加一</span><span class="token punctuation">&#125;</span><span class="token comment">//从精简算法，提高查找速度的角度说，可以在R末尾增加一个关键字为k的记录为哨兵，就不用判断i是否超界</span><span class="token keyword">int</span> <span class="token function">SeqSearch1</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    R<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//折半查找</span><span class="token comment">//要求有序表,mid = (low+high)/2向下取整，成功返回逻辑序号，失败返回0</span><span class="token keyword">int</span> <span class="token function">BinSearch</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            <span class="token keyword">return</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//好精简的算法！</span><span class="token comment">//可以用判定树刻画，n种成功情况，成功时比较次数恰为层数和n+！种失败情况。失败时比较次数为层数-1</span><span class="token comment">//ASLbn = log2(n+1)-1  最坏性能和平均性能相当接近,归纳起来复杂度为O（log2n）</span><span class="token comment">//索引结构和分块查找</span><span class="token comment">/*索引项一般为（关键字，地址），可以现在有序索引表中快速查找，然后通过地址找到提高了查找效率，但是需要建立索引表会增加时空开销*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXI</span> <span class="token expression"><span class="token number">10000</span> </span><span class="token comment">//索引表最大容量。</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span>    <span class="token keyword">int</span> link<span class="token punctuation">;</span> <span class="token comment">//对应在存储表里的下标</span><span class="token punctuation">&#125;</span> IdxType<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">IdxSearch</span><span class="token punctuation">(</span>IdxType I<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> b<span class="token punctuation">;</span> <span class="token comment">//s为每块的元素个数，I的长度为b</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>I<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> k<span class="token punctuation">)</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//接下来在该块中顺序查找</span>    i <span class="token operator">=</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link<span class="token punctuation">;</span> <span class="token comment">//记住是high+1，总会取到偏小的一个</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link <span class="token operator">+</span> s <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link <span class="token operator">+</span> s <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*折半查找配合时，成功查找的平均长度为ASLblk = ASLbn + ASLsq= log2(b+1) -1 + (s+1)/2 = log2(n/s+1) + s/2 可见s即每块的长度越小越好*/</span><span class="token comment">/*顺序查找时，ASLblk = ((b+1)+(s+1))/2 =1/2(n/s +s) +1 因为b = n/s向上取值，当s=根号n时最佳*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树表"><a href="#树表" class="headerlink" title="树表"></a>树表</h2><p>如果要进行表的删除、插入操作，会带来很多额外开销，若要对动态查找表进行查找，可以用几种树来。</p><p>二叉排序树的中序序列就是排好序的表</p><p>查找的ASL成功和ASL失败在P328</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//假设各结点的关键字是唯一的</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> years<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span>    InfoType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> BSTNode<span class="token punctuation">;</span><span class="token comment">//用根节点bt来唯一标识一棵二叉排序树</span><span class="token comment">//插入关键字k，若已有则返回假</span>bool <span class="token function">InsertBST</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span><span class="token operator">&amp;</span>bt<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        bt <span class="token operator">=</span> <span class="token punctuation">(</span>BSTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>        bt<span class="token operator">-></span>lchild <span class="token operator">=</span> bt<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建一棵二叉排序树是从一个空树开始，一直调用插入就好了。</span>BSTNode <span class="token operator">*</span><span class="token function">CreateBST</span><span class="token punctuation">(</span>KeyType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BSTNode <span class="token operator">*</span>bt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//销毁算法和普通的二叉树算法一样</span><span class="token comment">//查找就要方便很多</span>BSTNode <span class="token operator">*</span><span class="token function">SearchBST</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>bt<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt<span class="token operator">-></span>key <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> bt<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">)</span>        <span class="token keyword">return</span> bt<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求最大\最小结点可以利用性质</span>KeyType <span class="token function">maxnode</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>KeyType <span class="token function">minnode</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//一定是叶子节点</span><span class="token comment">//删除要分几种情况讨论，是最麻烦的。</span><span class="token comment">//是叶子就直接删除，只有左、右子树就接上去</span><span class="token comment">//同时有左右子树的话可以从左中选最大的结点r代替p，然后把r删除，也可以选右中最小的，一般前者</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡因子：左子树高度 - 右子树高度</p><p>平衡条件：平衡因子的绝对值小于1</p><p>前提是二叉排序树，</p><p>四种类型 调整前后中序序列相同是前提条件。这个建议看学校发的教材P283</p><p>删除的时候，如果不平衡了，可以通过左右孩子的平衡因子来判断做哪一种调整，P337</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>又称散列表，设要存储的元素个数为n，设置一个长度为m&gt;=n的连续内存单元，每个元素的关键字ki(i&lt;=n-1)</p><p>为自变量，通过哈希函数映射到内存单元的地址h(ki)，并存储在这个内存单元中。</p><p>哈希冲突，不同的自变量映射到同一个地址</p><p>通常情况是关键字的取值区间远大于哈希地址的变化区间</p><p>查找性能取决于：</p><ul><li>装填因子 α = n/m 应控制最终的α在0.6~0.9范围内</li><li>哈希函数应该使哈希地址尽可能均匀地分布在哈希地址空间上</li><li>合适的解决哈希冲突的策略。</li></ul><h3 id="构造哈希函数"><a href="#构造哈希函数" class="headerlink" title="构造哈希函数"></a>构造哈希函数</h3><p>构造哈希函数</p><p>根据关键字的结构和分布的不同可构造出许多不同的哈希函数，这里主要讨论几种常用的整数类型关键字的</p><ol><li><p>直接定址法 h(k) = k + c</p><p>当关键字分布基本连续时比较好</p></li><li><p>除留余数法 h(k) = k mod p (p &lt;= m) </p><p>这种该方法的关键是选好p，使得概率分布较平均，p奇数好，不大于m的素数效果最好</p></li><li><p>数字分析法</p><p>提取关键字较均匀的数字位，适合所有关键字值都已知的情况</p></li></ol><p>还有平方取中法，折叠法等。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>开放地址法(也叫再散列法)：</p><ol><li><p>线性探测法</p><p>容易产生堆积问题，d0 = h(k)  di = ( (d(i-1) + 1) mod m)</p></li><li><p>平方探测法</p><p>d0 = h(k)    di = ( (d0 +- i2) mod m)</p><p>不一定能探测到哈希表上的所有单元，但最少能探测到一半的单元</p></li><li><p>还有伪随机序列法，双哈希函数法等</p></li></ol><p>再哈希法：</p><p>同时构造多个哈希函数，一个冲突就换另一个</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//用开放地址法构造的哈希表的运算算法</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULLKEY</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span> </span><span class="token comment">//空关键字值</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DELKEY</span> <span class="token expression"><span class="token operator">-</span><span class="token number">2</span>  </span><span class="token comment">//被删除关键字值</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KetType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KetType key<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">//探测次数域</span><span class="token punctuation">&#125;</span> HashTable<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InsertHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>                                         <span class="token comment">//adr是关键字k对应的哈希值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> NULLKEY <span class="token operator">||</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> DELKEY<span class="token punctuation">)</span> <span class="token comment">//可以直接放入</span>    <span class="token punctuation">&#123;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//i 记录k发生的次数</span>        <span class="token keyword">do</span>        <span class="token punctuation">&#123;</span>            adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> DELKEY<span class="token punctuation">)</span><span class="token punctuation">;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//设置探测次数</span>    <span class="token punctuation">&#125;</span>    n<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//哈希表中总元素个数增1</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//由关键字序列keys[0..nl-1]创建哈希表</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nl<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">InsertHT</span><span class="token punctuation">(</span>ha<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> p<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//插入nl个</span><span class="token punctuation">&#125;</span><span class="token comment">//删除算法</span><span class="token comment">//在开放地址法处理的哈希表上不能简单的删除，因为在查找算法中空是查找失败，应该置特殊值</span>bool <span class="token function">DeleteHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">&amp;</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> DELKEY<span class="token punctuation">)</span>        adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> DELKEY<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">SearchHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span> <span class="token comment">//线性探测</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success:%d compare %d times"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ASL成功为关键字列表中每个关键字的比较次数的平均数</p><p>ASL失败为直到空时的探测次数，P357 记得要算上自己的这次</p><p>拉链法：</p><p>此时的装填因子可以设定为大于1</p><p>优点：无堆积现象，平均查找长度较短，适合无法定长的情况，元素较大时指针开销可忽略不计，删除操作容易实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//拉链法</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> NodeType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    NodeType <span class="token operator">*</span>firstp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HashTable<span class="token punctuation">;</span><span class="token comment">//理解这个HashTable ha数组，下标即为“地址”</span><span class="token keyword">void</span> <span class="token function">InsertHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>    NodeType <span class="token operator">*</span>q<span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>NodeType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NodeType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>    q<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    n<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nl<span class="token punctuation">)</span><span class="token comment">//由关键字序列keys[0..nl-1]创建哈希表</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nl<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">InsertHT</span><span class="token punctuation">(</span>ha<span class="token punctuation">,</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//删除算法 在逻辑上更为简单，可以直接删除</span>bool <span class="token function">DeleteHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span> <span class="token comment">//删除哈希表中的关键字k</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>    NodeType <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>preq<span class="token punctuation">;</span>    q <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//首节点不为k时</span>    preq <span class="token operator">=</span> q<span class="token punctuation">;</span>    q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        preq<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">SearchHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> adr<span class="token punctuation">;</span>    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>    NodeType <span class="token operator">*</span>q <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ASL成功就是比较次数求平均嘛</p><p>ASL不成功 就是每条链的结点数求平均哈哈，有几个结点就白比较了几次</p><h1 id="9-内排序"><a href="#9-内排序" class="headerlink" title="9.内排序"></a>9.内排序</h1><p>此处的关键字是可以重复的</p><p>根据相同关键字排序后相对次序是否改变可分为稳定和不稳定，这相对于<strong>所有可能的输入实例</strong></p><p>在排序中不需要进行数据的内、外存交换，称之为内排序。</p><p>需要关键字<strong>比较</strong>的方法有插入排序、选择排序、交换排序、归并排序</p><p>不需要的方法有基数排序</p><p>基于比较的排序主要进行两种操作：比较+移动</p><p>正序：关键字顺序正好和排序顺序相同，反序则相反。</p><p>比较排序的<strong>最好的平均理论时间</strong>复杂度为O(nlog2n) 比如堆排序、二路归并、快速排序 P367</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">//基本数据类型</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> one<span class="token punctuation">;</span>    <span class="token keyword">char</span> two<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span>    InfoType data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> RecType<span class="token punctuation">;</span><span class="token comment">//插入排序</span><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token comment">//如果直接就大于有序区最大的，</span>        <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">do</span>            <span class="token punctuation">&#123;</span>                R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">></span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//折半插入排序</span><span class="token comment">//在有序区查找位置时用折半查找就好了</span><span class="token keyword">void</span> <span class="token function">BinInsertSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>                R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            R<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//希尔排序</span><span class="token comment">//这和上一章查找好像啊，分组插入,原理我感觉是避免高次运算的爆炸增长</span><span class="token comment">//这里取di+1 = di/2向下取整,d1 = n/2</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> d <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>d <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这个上下界真是绝了，一步到位全部都排好，我还想了一会</span>        <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> i <span class="token operator">-</span> d<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                R<span class="token punctuation">[</span>j <span class="token operator">+</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j <span class="token operator">=</span> j <span class="token operator">-</span> d<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            R<span class="token punctuation">[</span>j <span class="token operator">+</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        d <span class="token operator">=</span> d <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//交换排序</span><span class="token comment">//冒泡排序,从后开始，把有序的冒到最前面</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//实际上，一旦某一趟不出现任何元素交换，就说明排好序了，可以用一个flag来达到这点</span><span class="token comment">//快速排序 当年初学感觉非常巧妙的算法哈哈</span><span class="token comment">//选一个枢纽（一般第一个），然后将所有的放在其前后，递归进行处理</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//从头尾向中扫描</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">,</span> j <span class="token operator">=</span> t<span class="token punctuation">;</span>    RecType tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> j <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;=</span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token comment">//对R[s...t]元素进行快速排序</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;</span> t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//选择排序</span><span class="token comment">//基本思路是每一趟都挑出最大、最小的，适合从大量元素中选择一部分排序元素</span><span class="token comment">//简单选择选择</span><span class="token comment">//分成有序区和无序区，从无序区选出最的后与无序区第一个元素交换，之所以叫简单排序是因为找最小值的方法是简单的两两比较</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        k <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最值的位置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            R<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//堆排序</span><span class="token comment">/*看成是一颗完全二叉树的顺序存储结构，大根堆，小根堆，挑选最大元素是采用筛选方法实现的筛选：假定某节点左右子树是大根堆，选择子节点和本身最大的上来，由于可能会破坏子树，因此递归判断*/</span><span class="token keyword">void</span> <span class="token function">sift</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token comment">//low是根节点,j指向当前结点的孩子</span>    RecType tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//看看两个孩子谁大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j<span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token comment">//这个索引的变换有点巧妙</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//筛选结束</span>    <span class="token punctuation">&#125;</span>    R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//构建初始堆，从最后一个分支点n/2向下取整开始，反复筛选</span><span class="token comment">//for(i = n/2;i>=1;i--) sift(R,i,n)</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    RecType tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">sift</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//建立初始堆</span>    <span class="token comment">//每次抽掉“根”，就是堆上最大那个</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp <span class="token operator">=</span> R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token function">sift</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>多次将两个或以上的有序表合成一个新的有序表。我们研究二路归并</p><p>先分成n个长度为1的，两两归并成n/2个向上取整的有序序列，依次类推直到得到长度为n的有序序列</p><p>我不想写啦！！！！P389自己看图吧</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>借助多关键字排序的思想堆单关键字进行排序。通过“分配”、“收集”</p><p>单关键字R[i].key 由d位数字组成，每一位的值都在(0 , r)之间，二进制r为2</p><p>最低位LSD和最高位优先MSD。选择方式由数据序列特点决定，越重要的位越放在后面.</p><p>想看原理在P390</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//基数排序</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXD</span> <span class="token expression"><span class="token number">10000</span> </span><span class="token comment">//最大关键字位数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXR</span> <span class="token expression"><span class="token number">10</span>    </span><span class="token comment">//每一位的取值上限（开区间）</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span>MAXD<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//存放关键字的各位</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向下一个结点</span><span class="token punctuation">&#125;</span> NodeType<span class="token punctuation">;</span><span class="token comment">//输入数据为p为首节点的单链表</span><span class="token keyword">void</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span>NodeType <span class="token operator">*</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    NodeType <span class="token operator">*</span>head<span class="token punctuation">[</span>MAXR<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">[</span>MAXR<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>             <span class="token comment">//将原链表所有节点分配到链队</span>        <span class="token punctuation">&#123;</span>            k <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span> <span class="token comment">//找到第k个链队</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                head<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>                tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//重新用p来收集所有节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//找到第一个非空链队,通过首位指针处理，中间已经连好了</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    p <span class="token operator">=</span> head<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    t <span class="token operator">=</span> tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                <span class="token punctuation">&#123;</span>                    t<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    t <span class="token operator">=</span> tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//如果不是第一个,就连上来</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        t<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//别忘了！！！！！卧槽结束了！</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然课后习题一道没写</p><p>虽然后面跳过了一些明显不考的算法，但是终于在考试前5天写完了还是好开心</p><p>但是还有大雾和微积分:cry:</p><p>学弟学妹们，虽然这门数据结构在未来会被淘汰，但是它的绩点很重啊QWQ,不要向我一样临时抱佛脚QWQ</p><p>试验一下新功能，把我的代码看能不能直接放在这方便你们下载</p><p><a href="/papers/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.zip">数据结构</a></p><p>👆</p><h1 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h1><p>串：KMP</p><p>稀疏矩阵快速转置</p><p>二叉树遍历的非递归</p><p>最短路径的两种算法</p><p>AOV和AOE</p><p>平衡二叉树的算法实现</p><p>归并排序</p><p>明年学算法设计前应该会写完这些</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;考前抱佛脚┭┮﹏┭┮&lt;/p&gt;
&lt;p&gt;记住这里大量用了c++的引用。。好方便，但是答题的时候记得换成 *和全局变量&lt;/p&gt;
&lt;p&gt;一个算法应该具有以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有穷性&lt;/li&gt;
&lt;li&gt;确定性  不存在二义性&lt;/li&gt;
&lt;li&gt;可行性&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="algorithm" scheme="https://darren-dong.com/categories/algorithm/"/>
    
    
    <category term="data-structure" scheme="https://darren-dong.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>python二刷</title>
    <link href="https://darren-dong.com/2021/05/21/python%E4%BA%8C%E5%88%B7/"/>
    <id>https://darren-dong.com/2021/05/21/python%E4%BA%8C%E5%88%B7/</id>
    <published>2021-05-21T06:28:04.000Z</published>
    <updated>2022-05-09T06:59:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python课件总结"><a href="#python课件总结" class="headerlink" title="python课件总结"></a>python课件总结</h1><p>[toc]</p><p>ps：</p><p>这份笔记并不完整，是笔者学了一遍粗糙的python后二刷看课件觉得有用的东西，课件想要的私聊，不贵不贵，一杯奶茶:laughing:</p><p>还有那份课件的题目值得一做！</p><h2 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.语言基础"></a>1.语言基础</h2><p>面向对象 、 解释型 、 动态数据类型</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101010.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101018.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101003.png"  style="zoom:50%;" /><h3 id="变量与地址"><a href="#变量与地址" class="headerlink" title="变量与地址"></a>变量与地址</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101121.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101133.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101142.png"  style="zoom:50%;" /><p> Python  解释器会为每个出现的对象分配内存单元，即使它们的值相等，也会这样 </p><p>为了 提高内存利用效率，对于一些简单的对象，如一些数值 较小（-256~256 ）的 整型（int ）对象，Python  采取重用对象内存的办法</p><p>单独的下画线（_ ）是一个特殊变量，用于表示上一次运算的结果</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521110533.png"  style="zoom:50%;" /><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>整数二进制0b\0B开头,八进制0o\0O开头，十六进制0x\0X开头</p><p>对于浮点数，Python 3.x  默认提供17  位有效数字的精度，相当<br>于C  语言中的双精度浮点数</p><p>可以通过x.real  和x.imag  来分别获取复数x  的实部和虚部，结果都是浮点型，是j不是i</p><p>数学常量：e  pi</p><p>函数：</p><p>fabs  sqrt  pow(x,y)   exp log(x[,base])（base默认是e）  log10()</p><p>ceil floor  </p><p>fmod(x,y) # x/y的余数 （浮点）</p><p>degrees  &lt;=&gt;  radians</p><p>sin cos tan asin acos atan（默认用弧度）</p><p>Cmath模块函数基本一致，但是对复数运算</p><p>cmath.sqrt(-1)  ij 用的是j不是i</p><p> cmath 模块包括复数 运算特有的 函数。</p><p>复数x=a+bi ，phase(x) 函数返回复数x 的幅 角，即atan(b/a) 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521111433.png"  style="zoom:50%;" /><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>seed设置种子，默认将<strong>系统时间</strong>设为种子值</p><p>choice(seq) ：从 序列的元素中随机挑选一个 元素 。</p><p>sample(seq,k) ：从 序列中随机挑选k 个元素。</p><p>shuffle(seq) ：将 序列的所有元素随机排序 ,这个只能用于可更改的，字符串不可用</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521111617.png"  style="zoom:50%;" /><h3 id="时间和日历"><a href="#时间和日历" class="headerlink" title="时间和日历"></a>时间和日历</h3><p>datetime基于time进行了优化，更方便全面</p><h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span>date<span class="token punctuation">,</span>timedt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>dt<span class="token punctuation">.</span>year<span class="token punctuation">,</span>month<span class="token punctuation">,</span>day<span class="token punctuation">,</span>hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>seconddt<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token punctuation">)</span>输出前三个dt<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>输出后三个dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%x%x%x'</span><span class="token punctuation">)</span>datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">'202151'</span><span class="token punctuation">,</span><span class="token string">"%Y%m%d"</span><span class="token punctuation">)</span><span class="token comment">#转换为datetime对象！！这个是datetime下的datetime子类！！！</span>datetime相减会产生datetime<span class="token punctuation">.</span>delta对象delta <span class="token operator">=</span> datetime2 <span class="token operator">-</span> datetime1delta <span class="token operator">==</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">7179</span><span class="token punctuation">)</span> <span class="token comment">#间隔99天,7179秒</span>timedelta和datetime可以做加减得到新的datetime<span class="token operator">%</span>y     两位数的年份表示（<span class="token number">00</span><span class="token operator">-</span><span class="token number">99</span>）<span class="token operator">*</span><span class="token operator">%</span>Y     四位数的年份表示（<span class="token number">000</span><span class="token operator">-</span><span class="token number">9999</span>）<span class="token operator">*</span><span class="token operator">%</span>m     月份（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）<span class="token operator">*</span><span class="token operator">%</span>d     月内中的一天（<span class="token number">0</span><span class="token operator">-</span><span class="token number">31</span>）<span class="token operator">*</span><span class="token operator">%</span>H     <span class="token number">24</span>小时制小时数（<span class="token number">0</span><span class="token operator">-</span><span class="token number">23</span>）<span class="token operator">*</span><span class="token operator">%</span>I     <span class="token number">12</span>小时制小时数（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）<span class="token operator">*</span><span class="token operator">%</span>M     分钟数（<span class="token number">00</span><span class="token operator">=</span><span class="token number">59</span>）<span class="token operator">*</span><span class="token operator">%</span>S     秒（<span class="token number">00</span><span class="token operator">-</span><span class="token number">59</span>）<span class="token operator">*</span><span class="token operator">%</span>a     本地简化星期名称<span class="token operator">*</span><span class="token operator">%</span>A     本地完整星期名称<span class="token operator">%</span>b     本地简化的月份名称<span class="token operator">%</span>B     本地完整的月份名称<span class="token operator">%</span>c     本地相应的日期表示和时间表示<span class="token operator">%</span>j     年内的一天（<span class="token number">001</span><span class="token operator">-</span><span class="token number">366</span>）<span class="token operator">%</span>p     本地A<span class="token punctuation">.</span>M<span class="token punctuation">.</span>或P<span class="token punctuation">.</span>M<span class="token punctuation">.</span>的等价符<span class="token operator">%</span>U     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期天为星期的开始<span class="token operator">%</span>w     星期（<span class="token number">0</span><span class="token operator">-</span><span class="token number">6</span>），星期天为星期的开始<span class="token operator">%</span>W     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期一为星期的开始<span class="token operator">%</span>x     本地相应的日期表示<span class="token operator">%</span>X     本地相应的时间表示<span class="token operator">%</span>Z     当前时区的名称<span class="token operator">%</span><span class="token operator">%</span>     <span class="token operator">%</span>号本身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zhuanlan.zhihu.com/p/101939095">详述</a></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112059.png"  style="zoom:50%;" /><h3 id="python内置"><a href="#python内置" class="headerlink" title="python内置"></a>python内置</h3><p>range  iter</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112219.png"  style="zoom:50%;" /><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112244.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112255.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112308.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112324.png"  style="zoom:50%;" /><p> Python 中能表示浮点数的有效数字是有限的，而在实际应用中数据的有效位数并无限制，这种矛盾，势必带来计算时的微小误差。</p><h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a>2.顺序结构</h2><p>在Python 中，语句行从解释器提示符后的第一列开始， 前面不能有任何空格 ，否则会产生语法错误</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112701.png"  style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112733.png"  style="zoom:67%;" /><p>Python 中的赋值并不是直接将一个值赋给一个变量的，而是通过引用传递的，在赋值时，不管这个对象是新创建的还是一个已经存在的，都是将该对象的 引用（ 并不是值 ）</p><p>同步赋值指的是多变量一条式子赋值时，实际上先创建了一个元组，先后顺序不影响</p><p>eval（）去掉字符串最外侧的引号</p><p>print(xxx[,sep =][,end = ])</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113027.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113057.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113106.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113124.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113149.png"  style="zoom:50%;" /><h3 id="字符串format方法"><a href="#字符串format方法" class="headerlink" title="字符串format方法"></a>字符串format方法</h3><p>这才是王道</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113226.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113241.png"  style="zoom:50%;" /><p>用序号调整次序，重复什么的很方便</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113335.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113426.png"  style="zoom:50%;" /><p>注意这个居中填充，还有居中不对称时左边少一个</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'what &#123;1:&lt;10&#125;&#123;0&#125;the &#123;c:&amp;&lt;10.1f&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token number">21.311</span><span class="token punctuation">)</span><span class="token punctuation">)</span>what b         athe <span class="token number">21.3</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'what &#123;1:&lt;10&#125;&#123;0&#125;the &#123;c:&amp;=+10.1f&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token number">21.311</span><span class="token punctuation">)</span><span class="token punctuation">)</span>what b         athe <span class="token operator">+</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token number">21.3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113449.png"  style="zoom:50%;" /><h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706145044.png"  style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706145338.png"  style="zoom:50%;" /><p>for 语句是通过遍历任意序列的元素进行来建立循环的，针对序列的每一个元素执行一次循环体</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113716.png"  style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113742.png"  style="zoom: 67%;" /><p>首先Python 对关键字in 后的对象调用iter() 函数获得迭代 器，然后 调用next() 函数获得迭代器的 元素，直到 抛出stopIteration</p><p> while 语句多用于循环次数不确定的情况，而对于循环次数确定的情况，使用for</p><p>pass空语句</p><p>注意 ：布尔常量True 和False 首字母必须大写 ！</p><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h2><p><strong>建议看看原文</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>万国码Unicode是python选择的标准符号表，它每种语言中的每个字符设定了<strong>统一并且唯一的二进制编码</strong>，以满足跨语言、跨平台进行文本转换、处理的要求（翻译二进制码的方式）</p><p>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</p><p>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</p><p>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p><p>字节只是一个单位（8位）罢了，不同的编码中采用不同的规则存储字符，而这些规则实现的时候消耗字节大小不同</p><p>UTF-8</p><p>​    是 一种为Unicode 字符设计的变长编码系统</p><p>对于ASCII 字符，UTF-8 仅使用1 个字节来编码</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123412.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123508.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123527.png"  style="zoom:50%;" /><p>Unicode规定了，所有字符<strong>统一由两个字符</strong>来表示，也就是<strong>16位</strong></p><p>utf-8就是缩小一点，从4到8到12到16分段</p><p><a href="https://zhuanlan.zhihu.com/p/137875615">详述</a>有一点错误就是最后那个中文例子，看我的👇</p><p><strong>而python字符串默认是unicode编码</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> <span class="token string">'卧槽'</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'卧'</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">b'\xe5\x8d\xa7\xe6\xa7\xbd'</span> <span class="token comment">#一个汉字拆成三个字节</span>    In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c <span class="token operator">=</span> <span class="token string">'dnoad'</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">b'dnoad'</span><span class="token comment"># 英文在utf-8中不会发生转换，直接用一个字节表示</span>In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'我'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">25105</span> <span class="token comment">#unicode</span>    In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">25104</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'成'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分片的操作很灵活，开始和结束 的索引值 可以超<br>过字符串的长度 </p><p>字符串用 +  和 *</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130045.png"  style="zoom:50%;" /><p>但是在解释器里面，都是输出普通的’abc’</p><p>Python 的字符串是不可变类型，只能通过新建一<br>个字符串去改变一个字符串的元素</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130119.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130139.png"  style="zoom:50%;" /><p>字符比较是按其计算机内部字符编码值的大小进<br>行比较，西文字符按ASCII 码值大小进行比较</p><p>  比较的基本规则是，空格字符最小，数字比字母<br>小，大写字母比小写字母小（ 对应字母相 差32</p><h3 id="函数。。"><a href="#函数。。" class="headerlink" title="函数。。"></a>函数。。</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130239.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130256.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130327.png"  style="zoom:50%;" /><p>prefix和suffix是字符串，start 可以选择开头位置，end我不知道干嘛的</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130413.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130614.png"  style="zoom:50%;" /><p>split如果两个分隔符中没东西，也会拆出空字符串,从左右拆顺序不变，可能只影响matsplit参数</p><p>那个splitlines试了一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> <span class="token string">'dada\nwdad'</span>cOut<span class="token punctuation">[</span><span class="token number">51</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'dada\nwdad'</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>dadawdadc<span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'dada'</span><span class="token punctuation">,</span> <span class="token string">'wdad'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130715.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130738.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130818.png"  style="zoom:50%;" /><h3 id="字节类型"><a href="#字节类型" class="headerlink" title="字节类型"></a>字节类型</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130927.png"  style="zoom:50%;" /><p>和字符串一样，可以使用内置的len() 函数求bytes对象的长度，也可以 使用“+ ” 运算符连接两个bytes 对象，其操作结果是一个新的bytes 对象</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131019.png"  style="zoom:50%;" /><p>如果需要改变某个字节，可以组合使用字符串的分片和连接操作（效果跟字符串是一样的）， 也可以 将bytes 对象转换为bytearray 对象，bytearray对象是可以被修改的</p><p>可以 使用编号给bytearray 对象的某个字节赋值 ， <strong>并且这个值必须是0~255 之间的一个整数</strong></p><p>  也 不允许针对bytes 对象的出现次数进行计数，因为字符串里面 根本没有字节字符</p><p>encode和decode可以在两者间转换</p><h2 id="5-正则"><a href="#5-正则" class="headerlink" title="5.正则"></a>5.正则</h2><p><a href="https://darren-dong.com/2021/03/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">看我的博客了解基础知识</a></p><p>  在Python 中，正则表达式的功能通过正则表达式<br>模块re</p><p> re 模块提供各种正则表达式 的匹配 操作，在文本解析、复杂字符串分析和信息提取时是一个非常有用的工具。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131633.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131657.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131718.png"  style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131726.png"  style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131733.png"  style="zoom:33%;" /><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131810.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131819.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131839.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131907.png"  style="zoom:50%;" /><p>正则表达式中，group（）用来提出分组截获的字符串<strong>，（）用来分组</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span>  rea  <span class="token operator">=</span>  <span class="token string">"123abc456"</span><span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">#123abc456,返回整体</span><span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment">#123</span><span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span>    <span class="token comment">#abc</span><span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span>    <span class="token comment">#456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>正则表达式中的三组<strong>括号</strong>把匹配结果分成三组</li></ol><ul><li> group() 同group（0）就是匹配正则表达式整体结果</li><li> group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。</li></ul><ol start="2"><li>没有匹配成功的，re.search（）返回None</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131927.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132000.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132021.png"  style="zoom:50%;" /><p><strong>注意到匹配模式串使用了原始字符串r’  ‘</strong></p><p> match() 方法并不是完全匹配。当正则表达式结束时，若string 还有剩余字符 ，仍然视为 成功</p><p>  想 要完全匹配，可以在表达式末尾加上边界匹配符’$</p><hr><p>match() 函数只是在字符串 的左端位置 尝试匹配正则表达式，也就是只报告从位置0 开始的 匹配情况。</p><p>  如果想要搜索整个字符串来寻找匹配，应当用search() 函数 ,使用方法完全一样</p><p> findall() 函数搜索字符串，以列表形式返回全部能匹配正则表达式的子串 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132802.png"  style="zoom:50%;" /><p>finditer()  与findall() 函数类似，在字符串中找到正则表达式所匹配的所有子串，并组成一个迭代器返回。</p><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132849.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132909.png"  style="zoom:50%;" /><p> subn() 函数的功能和sub() 函数 相同，但 返回新的字符串以及替换的次数组成的元组 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132944.png"  style="zoom:50%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133009.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133156.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133228.png"  style="zoom:50%;" /><p><strong>两个斜杠噢，第一次先让编译器把两个斜杠转成一个斜杠，第二步到正则字符串则把剩下的单斜杠看成是转义</strong></p><h2 id="6-列表-amp-元组"><a href="#6-列表-amp-元组" class="headerlink" title="6.列表&amp;元组"></a>6.列表&amp;元组</h2><p>len()  min()  max()</p><p>sum()返回序列s中所有元素和，元素必须为数值</p><p>reduce 位于functools模块中</p><p> reduce(f,s[,n]) ：reduce() 函数把序列s 的前两个元素作为 参数，传 给函数f ，返回 计算的结果和 序列的下一个元素重新作为f 的参数，直到序列的最后一个元素 </p><p>enumerate 和 zip不必多言</p><p>利用* 号操作符，可以将对象解压 还原</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> m<span class="token operator">=</span><span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有sorted reversed  all any</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141444.png"  style="zoom:50%;" /><p>加星号的变量只允许一个，否则会出现语法错误syntaxError 。</p><p>列表可以进行元素赋值（索引不能超）</p><p>元素删除  del   分片赋值  在使用<strong>分片赋值</strong>时，<strong>可使用与原序列不等长的序列将分片替换</strong> </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141731.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706154841.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141802.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141833.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141849.png"  style="zoom:50%;" /><p>for前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果，必须加上else，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><ol><li><strong>序列都可以用</strong></li></ol><p>并不改变序列本身，可用于列表，元组，字符串</p><p>s.count(x) ：返回x 在序列s 中出现的次数</p><p>s.index(x) ：返回x 在s 中第一次出现的下标</p><p>不过x是完整的</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521142351.png"  style="zoom:50%;" /><ol start="2"><li>仅使用列表</li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143101.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143117.png"  style="zoom: 50%;" /><p>s.reverse() ：将列表s 中的元素逆序排</p><p> s.pop([i]) ：删除并返回列表s 中指定位置i 的元素，默认是最后一个元素。若i 超出列表长度 ，则 抛出IndexError 异常 </p><p> s.insert(i,x) ：在列表s 的i 位置处插入x 。<strong>如果i 大于列表的长度，则插入到列表最后 。</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143709.png"  style="zoom:50%;" /><p>可以看看题目</p><h2 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144114.png"  style="zoom:50%;" /><p>更新和创建都用索引，删除则用del，检查关键字用in / not in</p><p> len() 函数可以获取字典所包含“关键字: 值”对的数目，即字典长度 。虽然 也支持max() 、min() 、sum() 和sorted() 函数，但只针对字典的关键字进行计算，很多情况下没有实际意义。</p><p>  字典不支持连接(+) 和重复操作符(*) ，关系运算中只有“==”  和“!=”  有意义 </p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>dict三用法:</p><ol><li><p>使用dict() 函数创建一个空字典并给变量赋值</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160413.png"  style="zoom:50%;" /><p><strong>第二种方法应该是大规模处理中用的多的</strong></p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160432.png"  style="zoom:50%;" /></li></ol><p>Python 字典和集合实际上也是对象，Python 提供了很多有用的方法。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144729.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144739.png"  style="zoom:50%;" /><p>原先的键会被清除，字符串也可以做序列，   <strong>重复的键会被删除</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d2 <span class="token operator">=</span> d<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'dwad'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>d2Out<span class="token punctuation">[</span><span class="token number">92</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144757.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144814.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144833.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144857.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144930.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144948.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144955.png"  style="zoom:50%;" /><h2 id="8-集合"><a href="#8-集合" class="headerlink" title="8.集合"></a>8.集合</h2><p>  在Python 中， 集合（ set  ）是 一个无序排列的、不重复的数据集合体，类似于数学中的集合概念 ，可 对其 进行并、 交、 差等 运算</p><p>集合和字典都属于无序集合体，有许多操作是一致的 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145206.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145235.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145238.png"  style="zoom:50%;" /><p>  在Python 中，用大括号将集合元素括起来，这与字典的创建类似，但{} 表示空字典，空集合用set()表示。</p><p>集合 的 自动删除重复元素 这个特性非常有用，例如，要删除列表中大量的重复元素，可以先用set()函数将列表转换成集合，再用list() 函数将集合转换成列表，操作效率非常高。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150012.png"  style="zoom:50%;" /><p> Python 提供frozenset() 函数来创建不可变集合，不可变集合是不能修改的，因此能作为其他集合的元素，也能作为字典的关键字。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150057.png"  style="zoom:50%;" /><h3 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150124.png"  style="zoom:50%;" /><p>比较用 == 和 ！=  还有包含真包含 &lt; &lt;=</p><p>当然还有赋值运算符 s1 |= s2</p><p>集合与for 循环语句配合使用，可实现对集合各个元素的遍历</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706161507.png"></p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li><strong>适用于可变和不可变集合</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150431.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150451.png"  style="zoom:50%;" /><p> s.copy() ：复制集合s 。</p><ol start="2"><li><strong>适合可变集合的方法</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150621.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150630.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150705.png"  style="zoom:50%;" /><h2 id="9-函数与模块"><a href="#9-函数与模块" class="headerlink" title="9.函数与模块"></a>9.函数与模块</h2><p>在Python 中，实参向形参传送数据的方式是“值传递”，即“拷贝”或“复制”</p><p>  实参 的值传给形参 ，是对象间整体赋值，是 一种单向传递方式，不能由形参传回给实参。</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521151042.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521151105.png"  style="zoom:50%;" /><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">1</span><span class="token punctuation">.</span> 必选参数就是位置参数，必须填，<span class="token number">2</span><span class="token punctuation">.</span> 默认参数可填可不填。默认参数有个坑，就是每次调用函数，默认参数的指向不便且会保存，所以可修改，每次都不一样，因此定义默认参数要牢记一点：默认参数必须指向不变对象!<span class="token number">3</span><span class="token punctuation">.</span> 然后就到可变参数，指的是可以接受所有值的元组，<span class="token operator">*</span>args  放在第三位接受所有的<span class="token number">4</span><span class="token punctuation">.</span> 第四是命名关键字，或者说可变字典<span class="token operator">**</span>kw  接受所有的 a <span class="token operator">=</span> <span class="token string">'xxx'</span> 这样的参数，并赋给字典，但是key不用加引号<span class="token number">5</span><span class="token punctuation">.</span> 最后是关键字参数，不能省略的键值对！<span class="token comment">#其实就是无限接受的放在后面。</span>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：<span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span>    和关键字参数<span class="token operator">**</span>kw不同，命名关键字参数需要一个特殊分隔符<span class="token operator">*</span>，<span class="token operator">*</span>后面的参数被视为命名关键字参数。调用方式如下：<span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Beijing'</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Engineer'</span><span class="token punctuation">)</span>Jack <span class="token number">24</span> Beijing Engineer如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<span class="token operator">*</span>了：<span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span>    命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：<span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'Engineer'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>TypeError<span class="token punctuation">:</span> person<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">2</span> positional arguments but <span class="token number">4</span> were given<span class="token comment">#命名关键字参数可以有缺省值，从而简化调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数参数规则：</p><ol><li><em><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></em></li><li>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</li><li><strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li></ol><p>注意 **dict解包作为参数时，是复制一份，也就是传值</p><hr><p>  当在 函数内部修改列表、字典的 元素时，形参的改变会影响实参，即双向传递，类似于“传地址”、“共享内存”、“借”，</p><p>匿名函数lambda</p><p> lambda [ 参数1[, 参数2,……, 参数n]]: 表达式</p><p>  关键字lambda 表示匿名函数，冒号前面是函数参数，可以有多个函数参数，但只有一个返回值 ，所以只能有一个表达式，返回值就是该表达式的结果。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211105121650828.png" alt="image-20211105121650828" style="zoom:50%;" /><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>这个讲的比一般的清楚一点所以放在这。</p><p>  装饰器 （decorator ，[ˈdekəreɪtə(r)] ）可简单地理解为一个函数，这是一个用来包装函数的函数，经常用于为已经存在的函数添加额外的功能</p><p>  当多个函数有重复代码时，可以将此部分代码单独拿出来整理成一个 装饰 器，然后对每个函数调用该装饰器，这样可以实现代码的复用，而且可以让原来的函数更轻便 。</p><p>  当 需要为多个己经写好的函数添加一个共同功能，例如检查参数的合法性时，就可以单独写一个检查合法性的装饰器，然后在每个需要检查参数合法性的函数处调用即可，而不用去每个函数内部修改 </p><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153116.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153130.png"  style="zoom:50%;" /><p>  <strong>把@deco 语句放在函数square_sum() 定义之前，实际上是将square_sum 传递给装饰器deco  ，并将deco 返回的新函数对象赋给原来的函数名</strong> square_sum=deco(square_sum)</p><p>从本质上，装饰器起到的就是这样一个重新指向函数名的作用，让同一个对象名指向一个新返回的函数，从而达到修改可调用函数的目的 </p><p>最外层定义deco的本体，把函数传进去，里面定义新函数，新函数肯定要调用到原来的函数。如果需要传参数，就在本体外面再加一层传递参数的壳。</p><h4 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153708.png"  style="zoom:50%;" /><p><strong>要注意多重装饰器的执行顺序，应该是先执行后面的装饰器，再执行前面的装饰器。</strong></p><p>global</p><p>在程序中定义全局变量的主要目的是，为函数间的数据联系提供一个直接传递的通道 。</p><p>  因此不要滥用全局变量</p><h3 id="模板有条件执行"><a href="#模板有条件执行" class="headerlink" title="模板有条件执行"></a>模板有条件执行</h3><p>模块 中可以是一段 可以 直接执行的 程序（也称为<br>脚本 ） ， 也可以定义一些变量、类或函数，让别的模块导入和调用， 类似于库。</p><p>  模块中的定义部分，例如全局变量定义、类定义、函数定义等，因为没有程序执行入口，所以 不能直接运行，但对主程序代码部分有时希望只让它在模块直接执行的时候才执行，被其他模块加载时就不执行。</p><p>  在Python 中，可以通过系统变量“__name__”（注意前后都是两个下画线）的值来区分这两种情况。  如果模块是被其他模块导入的，__name__ 的值是模块的名称，主动执行时它的值就是字符串“__main__” 。</p><p>  通过__name__ 变量的这个特性，可以将一个模块文件既作为普通的模块库供其他模块使用，又可以作为一个可执行文件进行 执行。</p><h2 id="10-面向对象"><a href="#10-面向对象" class="headerlink" title="10.面向对象"></a>10.面向对象</h2><p>  <strong>面向对象程序设计（Object-Oriented programming ，OOP ）则以对象作为程序的主体，将程序和数据封装于其中，以提高软件的重用性、灵活性和扩展性</strong></p><p>面向对象程序设计是按照人们认识客观世界的系统思维方式，采用基于对象的概念建立问题模型，模拟客观世界，分析、设计和实现软件的办法</p><p>面向对象语言的三大核心内容是封装（类和对象）、 继承（派生）和 多态 </p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154319.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154329.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154351.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154441.png"  style="zoom:50%;" /><p>class  A：</p><p>   x = 5</p><p>我定义了一个类A，这个时候自动出现了个类对象A，我可以使用A.x调用类属性</p><p>  <strong>“ .” 运算符：成员运算符</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154708.png"  style="zoom:50%;" /><p>  类中的实例方法至少应有 一 个变量 参数，一般命名为“ self ”( 习惯，非语法要求) ) ，而且该参数必须 作为形参表的第一 个参数，即必须放 于形式参数 表的最左边 </p><p>实例的方法和对象只能实例调用，不能类调用，这不是废话嘛</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>  类 属性（class attribute ）是类的 属性，它被 所有类对象和实例对象共有 ，在内存中只存在一个副本</p><p>公有 的类属性，在类外可以通过类对象和实例对象访问 ，但是不提倡用实例对象访问，容易绕晕</p><p>  类属性还可以在类定义结束之后通过类 名（类对象）增加  比如 A.new  = 212</p><p>实例对象也 可以在类定义结束之后通过实例对象名增加实例属性</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155315.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155327.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155408.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521160210.png"  style="zoom:50%;" /><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155453.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155458.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155511.png"  style="zoom:50%;" /><p> 只要创建实例对象，就一定要调用构造方法</p><p> 只要调用了构造方法，就一定创建了实例对象</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155619.png"  style="zoom:50%;" /><p>构造方法重载：</p><ol><li>使用默认参数</li><li>构造方法根据条件调用其他的自定方法</li><li>构造方法根据条件执行不同的操作，可以用*arg来接受数量未知的参数</li></ol><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155658.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155717.png"  style="zoom:50%;" /><p><strong>实例方法必须有一个参数放在最左端，self</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155752.png"  style="zoom:50%;" /><p><a href="http://c.biancheng.net/view/4552.html">一点详解</a></p><p>@staticmethod 静态方法只是名义上归属类管理，但是不能使用类变量和实例变量，是类的工具包<br>放在函数前（该函数不传入self或者cls），所以不能访问类属性和实例属性</p><p>静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>  从已有类产生新类的过程就称为类的派生（derivation）（派生是继承的另一种说法）</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161333.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161544.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161554.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161602.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161627.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161723.png"  style="zoom:50%;" /><p>多重 继承（multiple inheritance ）是指一个子类有两个或多个直接父类，子类从两个或多个直接父类中继承所需的 属性和方法。</p><p>class  子类名( 父类名1, 父 类名2,…):</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161843.png"  style="zoom:50%;" /><p> Python 本身是一种 解释型语言 ，不进行编译，因此它就只在运行时 确定 其状态，故也可以说Python 是一种多态语言 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163054.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163113.png"  style="zoom:50%;" /><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><p>__slot__，限制示例对象能自主添加的属性。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211105155310776.png" alt="image-20211105155310776" style="zoom: 50%;" /><p><code>@property</code>广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查（在setter里），这样，程序运行时就减少了出错的可能性。</p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208">https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@property</span> <span class="token comment">#相当于getter</span>    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__width    <span class="token decorator annotation punctuation">@width<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__width <span class="token operator">=</span> value    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__height    <span class="token decorator annotation punctuation">@height<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__height <span class="token operator">=</span> value    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">resolution</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">786432</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir 返回所有的方法和属性，包括私有的和隐藏的，私有的会变成 <code>_类名__属性</code></p><p>hasattr  getattr  setattr</p><p>还可以将object提供的类的诸多参数比如<code>__len__ \ __call__</code>override来自定义类</p><h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><p>这个把我的心态搞炸了一会 </p><p>首先python里的默认编码都是Unicode，所有的文件其实本质都是二进制码，二进制文件只能用bytes类型操作，读出来怎么解读自己来，一般都用Unicode规则来decode（  二进制文件 是把数据按其在内存中的存储形式原样输出到磁盘上存放。）</p><p>小心那个文件指针位置，你写入了以后会放在最后，再读取啥都读不出来类似的</p><p>Python你在读写文件的时候<strong>不要打开</strong>。。不然会出现更改不了。。</p><p>理解python的<a href="https://blog.csdn.net/qq_23953717/article/details/78434292">open</a>txt默认是ANSI编码，不是UTF-8，坑死了，解决方案👈</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163612.png"  style="zoom:50%;" /><p>经常需要用到“终端形式”阅读的，用文本，经常修改的，最好用二进制</p><p>  读/ 写操作是相对于磁盘文件而言的，而输入/ 输出操作是相对于内存储器而言的</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163715.png"></p><p> r+是从最开始开始读的</p><p>文件对象=open( 文件说明符[, 打开方式][, 缓冲区])</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706170109.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706170146.png"  style="zoom:50%;" /><hr><p>文件对象有一些属性</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163754.png"  style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163811.png"></p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>文本文件是指以ASCII 码方式存储的文件：英文、数字等字符存储的是ASCII 码 ，而 汉字存储的是机内码。</p><p>  文本文件中除了存储文件有效字符信息（包括能用ASCII 码字符表示的回车、换行等信息）外，不能存储其他任何信息</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164102.png"  style="zoom:50%;" /><p>文本文件的 优点：方便 阅读和理解，使用常用的文本编辑器或文字处理器就可以对其创建和修改的，文件 对象提供了read() 、readline() 和readlines() 方法 用于读取文本文件的内容</p><p>  每次write() 方法 执行完后并不 换行，如果 需要换行则在字符串最后加 换行符“\n</p><p>读取中文问题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">InIn <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'try.txt'</span><span class="token punctuation">,</span><span class="token string">'r+'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>UnicodeDecodeError                        Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">648df9718e18</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>UnicodeDecodeError<span class="token punctuation">:</span> <span class="token string">'gbk'</span> codec can't decode byte <span class="token number">0xad</span> <span class="token keyword">in</span> position <span class="token number">8</span><span class="token punctuation">:</span> illegal multibyte sequence    默认gbkIn <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'try.txt'</span><span class="token punctuation">,</span><span class="token string">'r+'</span><span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> aOut<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'我是中文'</span>    In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'现在能输中文吗'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">7</span> <span class="token comment">#成功了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164604.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164625.png"  style="zoom:50%;" /><p>seek()偏移为正数表示朝文件尾方向移动，偏移为负数表示朝文件头方向移动；</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521165042.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521165103.png"  style="zoom:50%;" /><p>  文本文件 存放的是与编码对应的字符，而二进制文件直接存储字节编码。</p><h3 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185801.png"  style="zoom: 50%;" /><p>读文件的时候，可以一次读出4 个字节，然后用unpack() 方法转换成Python 的整数 。</p><p>注意：<strong>unpack() 方法执行后得到的结果是一个元组。</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185829.png"  style="zoom:50%;" /><p>  如果写入的数据是由多个数据构成的，则需要在pack() 方法中使用格式串</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185901.png"  style="zoom:50%;" /><p>  此时的bytes 就是二进制形式的数据了，可以直接写入二进制文件 。当需要时可以读出来，再通过struct.unpack() 方法解码成Python 变量</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185938.png"  style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185948.png"></p><h3 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521190026.png"  style="zoom:50%;" /><p>在pickle 模块中有2 个常用的方法：dump() 和load()</p><p>pickle.dump( 数据，文件对象）</p><p>  其功能是直接把数据对象转换为字节 字符串，并保存到文件中 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521191834.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521191845.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521192855.png"  style="zoom:50%;" /><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p> Python 的os 模块提供了类似于操作系统级的文件管理功能，如文件重命名、文件删除、目录管理等 </p><p>os.rename(“ 当前文件名”,” 新文件名”)</p><p>os.remove(“ 文件名”)</p><p>os.mkdir(“ 新目录名”)</p><p>os.chdir(“要成为当前目录的目录名”)</p><p>getcwd() 方法显示当前的工作目录。</p><p>os.rmdir(“ 待删除目录名”) <strong>在用rmdir() 方法删除一个目录前，先要删除目录中的所有内容。</strong></p><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.异常"></a>12.异常</h2><p>程序中的错误通常分为 语法错误 、 运行错误 和 逻辑错误 。</p><p>语法 错误是由于程序中使用了不符合 语法规则 的信息而导致的 ，这类错误比较 容易 修改，因为编译器或解释器会指出错误的位置和性质</p><p>运行错误则不容易修改，因为其中的错误是 不可预料的，或者可以预料但无法避免 的，  例如：内存 空间不够、数组下标越界、文件打开失败等</p><p>逻辑错误 主要表现在程序运行后，得到的结果与设想的结果不一致，通常出现逻辑错误的程序都能正常运行系统 不会给出提示信息，所有很难发现。</p><p>良好的程序应该对用户的不当操作做出提示，能识别多种情况下的程序运行状况，并选择适当 的应对 策略 </p><p>在程序中，对各种可预见的异常情况进行处理称为异常处理（exception handling）</p><p>处理程序异常的方法有很多，最简单和最直接的办法是在发现异常时，由Python 系统进行 默认的异常处理 </p><p>如果 异常对象未被处理或者捕捉，程序就会用所谓的 回溯（Traceback ） 终止</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194005.png"  style="zoom:50%;" /><p>标准错误信息包括两个部分：错误类型（如NameError ）和错误说明（如name ‘A’ is not defined ），两者用冒号分隔</p><p> Python 系统还追溯错误发生的位置，并显示有关<br>信息</p><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194142.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194153.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194218.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521195131.png"  style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521195150.png"  style="zoom:67%;" /><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    xxx<span class="token keyword">except</span> 异常类型<span class="token number">1</span><span class="token punctuation">[</span><span class="token keyword">as</span> 错误描述<span class="token punctuation">]</span><span class="token punctuation">:</span>    xxx<span class="token keyword">except</span> 异常类型<span class="token number">2</span><span class="token punctuation">[</span><span class="token keyword">as</span> 错误描述<span class="token punctuation">]</span><span class="token punctuation">:</span>    xx<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">except</span><span class="token punctuation">:</span>    默认异常处理语句块<span class="token keyword">else</span><span class="token punctuation">:</span>    语句块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200428.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200444.png"  style="zoom:50%;" /><p>当发生异常时，直接跳转到except，try中没执行完的语句会被跳过嗷！</p><p>可以嵌套。</p><p><strong>finally 子句是指无论是否发生异常都将执行相应的</strong><br><strong>语句块 。</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200807.png"  style="zoom:50%;" /><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在编写程序时，在程序调试阶段往往需要判断程序执行过程中变量的值，根据变量的值来分析程序的执行情况 </p><p>可以 使用print() 函数打印输出结果，也可以通过断点跟踪调试查看变量，但使用断言更加灵活高效 。</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201018.png"  style="zoom:50%;" /><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">assert</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'除数不可为0'</span>c <span class="token operator">=</span> a<span class="token operator">/</span>b<span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>Lenovo@LAPTOP<span class="token operator">-</span>08D3H5DC MINGW64 <span class="token operator">~</span><span class="token operator">/</span>Desktop<span class="token operator">/</span>env$ D<span class="token punctuation">:</span><span class="token operator">/</span>Anaconda3<span class="token operator">/</span>envs<span class="token operator">/</span>TF2<span class="token operator">/</span>python<span class="token punctuation">.</span>exe c<span class="token punctuation">:</span><span class="token operator">/</span>Users<span class="token operator">/</span>Lenovo<span class="token operator">/</span>Desktop<span class="token operator">/</span>env<span class="token operator">/</span>one<span class="token punctuation">.</span>py<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"c:/Users/Lenovo/Desktop/env/one.py"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token keyword">assert</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'除数不可为0'</span>AssertionError<span class="token punctuation">:</span> 除数不可为<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> AssertionError 异常可以被捕获，并像使用在try-except 语句中的任何其他异常处理，但如果不处理，它们将终止程序并产生回溯</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201713.png"  style="zoom:50%;" /><h3 id="主动引发异常与自定义类"><a href="#主动引发异常与自定义类" class="headerlink" title="主动引发异常与自定义类"></a>主动引发异常与自定义类</h3><p>前面的异常类都是由Python 库中提供的，产生的异常也都是由Python 解释器引发的</p><p>  在程序设计 过程中，有时需要在编写的程序中主动引发异常，还可能需要定义表示特定程序错误的异常类。</p><p>  在Python 中，要想自行引发异常，最简单的形式就是输入关键字raise ，后跟要引发的异常的名称 </p><p>异常 名称标识出具体的类，Python 异常处理是这些类的对象 。 raise 语句还可指定对异常对象进行初始化的参数  ，<strong>执行raise 语句时，Python 会创建指定的异常类的一个对象</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201958.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521202026.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521202332.png"  style="zoom:50%;" /><p>处理学生成绩时，成绩不能为负数。利用前面创建的NumberError 异常类，处理出现负数成绩的异常 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python课件总结&quot;&gt;&lt;a href=&quot;#python课件总结&quot; class=&quot;headerlink&quot; title=&quot;python课件总结&quot;&gt;&lt;/a&gt;python课件总结&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;ps：&lt;/p&gt;
&lt;p&gt;这份笔记并不完整，是笔者学了</summary>
      
    
    
    
    <category term="python" scheme="https://darren-dong.com/categories/python/"/>
    
    
    <category term="python" scheme="https://darren-dong.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数据科学手册（前半完结）</title>
    <link href="https://darren-dong.com/2021/05/17/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/"/>
    <id>https://darren-dong.com/2021/05/17/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/</id>
    <published>2021-05-17T09:28:04.000Z</published>
    <updated>2022-05-09T04:30:02.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言和环境"><a href="#前言和环境" class="headerlink" title="前言和环境"></a>前言和环境</h1><p>跨学科是数据科学的关键</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210510110540.png" alt="公认的学科交叉图" style="zoom: 33%;" /><h2 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h2><p>？和？？    ？几乎适用任何对象包括魔法指令</p><p>有时候？？不能显示源代码，因为该对象不是用python实现的，此时等价于一个？</p><p>Tab补全，配合通配符 * 使用</p><p>一般带下划线的私有方法和特殊方法不会被默认显示，可以通过显式输入 _ 再tab来获取他们</p><p>甚至可以 import &lt;TAB&gt; 查看你能导入的包</p><p><a href="https://www.cnblogs.com/Pythonzrq/p/11346578.html#:~:text=2%E3%80%81pycharm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%201%20%E3%80%81%E7%BC%96%E8%BE%91%EF%BC%88Editing%EF%BC%89%202%20%E3%80%81%E6%9F%A5%E6%89%BE%2F%E6%9B%BF%E6%8D%A2%20%28Search%2FReplace%29%203%20%E3%80%81%E8%BF%90%E8%A1%8C,History%209%20%E3%80%81%E6%A8%A1%E7%89%88%20%28Live%20Templates%29%2010%20%E3%80%81%E5%9F%BA%E6%9C%AC%20%28General%29"><strong>快捷键</strong></a></p><p>C + a/e </p><p>C + u/k 剪掉前面，后面</p><p>C + t 交换前两个字符，怪毙了</p><p>C + r对历史反向搜索，继续ctrl+r往前匹配下一个，找到后回车</p><p>C + l/c/d 清屏，中断当前python命令，退出ipython会话</p><p><strong>魔法指令</strong></p><p>ipython在普通python语法上的增强功能</p><p>行魔法 %</p><p>单元魔法 %%，用于处理多行输入比如%%timeit</p><pre class="line-numbers language-pytho" data-language="pytho"><code class="language-pytho">%quickref  快速参考卡%magic 探索所有魔术命令%debug从最后发生报错的底部进入交互式调试器  %pdb出现任意报错自动进入调试器%hist%paste   %cpaste 解决包含符号的多行输入&#x2F;复制问题%reset 清空所有变量&#x2F;名称  %xdel variable 删除变量和相关引用%page OBJECT  通过分页器更美观的打印一个对象%run   %prun statement  使用CProfile执行语句，报告输出%time 报告单个语句执行时间   %timeit 多次运行单语句，计算平均执行时间，用于估算代码最短执行时间%who  %who_ls  %whos  依次更加详细的展示变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://developer.51cto.com/art/202007/620863.htm">这个厉害</a></p><p>集成matplotlib:</p><ul><li>在ipython命令行中 %matplotlib</li><li>在jupyter中 %matplotlib inline</li></ul><p>In是一个列表，记录了历史命令</p><p><strong>Out是一个字典</strong>，将输入的索引对应起输出，很多命令没有输出（None），则不会被记录！</p><p><strong>Out[x] 的简写是_x</strong></p><p>print(_) 一二三条下划线对应倒数第几个历史输出，这个厉害，或者直接 _3</p><p><strong>但是如果输入的最后加上；就不会被添加到历史，也不会把输出显示出来</strong>，这样当其他引用被删除时，该空间可以被释放。</p><p><strong>shell</strong></p><p>很多教材说是用 ! 加shell指令，但是pycharm全是%呀</p><p>可以用赋值将任何shell命令的输出保存到一个python列表，这是一个长得像列表的特殊返回类型</p><p>在shell里面用{varname}来调用变量</p><p>很多shell的指令可以直接使用，比如%cd 可以直接cd</p><p><strong>调试</strong></p><p>%xmode Plain/Context/Verbose 异常模式，改变异常时的打印信息</p><p>plain只会输出函数和行号，context是默认，会显示出错行上下几行代码，verbose还会显示每一级的参数和出错位置的变量值，好方便</p><p>标准调试工具pdb 的Ipython增强版ipdb，ipython专用</p><p>还有个很方便的%debug魔法指令，在最近的异常点打开一个交互式调试指令符（是用了ipdb）</p><p>%pdb on 会在抛出异常时自动启动，pdb有 up down 等命令配合print来检查</p><p>有一些常用调试命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span> 显示路径h<span class="token punctuation">(</span><span class="token builtin">help</span><span class="token punctuation">)</span> 显示命令列表q<span class="token punctuation">(</span>uit<span class="token punctuation">)</span> 退出调试器和程序c<span class="token punctuation">(</span>ontinue<span class="token punctuation">)</span> 推出调试器，继续程序n<span class="token punctuation">(</span>ext<span class="token punctuation">)</span> 跳到程序下一步<span class="token operator">&lt;</span>enter<span class="token operator">></span> 重复前一个命令p<span class="token punctuation">(</span>rint<span class="token punctuation">)</span> 打印变量s<span class="token punctuation">(</span>tep<span class="token punctuation">)</span> 步入子进程r<span class="token punctuation">(</span>eturn<span class="token punctuation">)</span> 从子进程跳出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码的分析与计时</strong></p><p>“大约百分之97的时间，我们应该忘记微小的效率差别；过早优化是不被推荐的”</p><p>但是当代码跑起来后，提高运行效率是有用的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">%</span>time 对单个语句的执行时间进行计时<span class="token punctuation">(</span>适合不可重复的，或者时间较长的<span class="token punctuation">)</span><span class="token operator">%</span>timeit 对单个语句的重复执行进行计时，以获得更高的精确度<span class="token punctuation">(</span>但需要保证可重复性，别对排序这样干<span class="token punctuation">)</span>在进行相同操作时，timeit总是比time更快，因为timeit在底层采取了一些措施组织系统调用对计时过程的干扰，例如阻止清理未利用的python对象。👇需要安装line_profiler 和 memory_profiler 拓展python包含一个内置的代码分析器，可以通过魔法指令👇简单的调用<span class="token operator">%</span>prun 使用分析器运行代码，输出一个时间报告 <span class="token operator">+</span> 函数<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token operator">%</span>lprun 使用逐行分析器运行代码，逐行分析<span class="token operator">%</span>memit 测量单个语句的内存使用<span class="token operator">%</span>mprun 使用逐行的内存分析器运行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>%%file 来写一个简单的模块文件</p><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>将异构的各种数据都看成数组，第一步将这些数据转化成数值数组形式的可分析数据。</p><p>数据科学的绝对基础：有效存储数据，操作数值数组</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>标准的python实现是用C编写的，这意味着每一个python对象都是一个聪明的伪C结构体</p><p>比如python的整形变量其实是一个指针，它的结构体里包含了大量额外信息，所以可以自由，动态编码，但也会成为负担。</p><p>python<strong>列表</strong>实质：指向一个指针域，域里的每一个指针指向一个确切的对象</p><p>numpy牺牲了这一点，指向一块类似C的域，但是能更有效地存储和操作数据。</p><p>所以numpy要求数组必须包含同一类型的数据，不匹配则向上转换</p><h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>手打l<span class="token punctuation">)</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token operator">/</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token operator">/</span>full<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3.14</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>full<span class="token punctuation">(</span>size<span class="token punctuation">,</span>fulfiller<span class="token punctuation">)</span> <span class="token comment">#用fulfiller填充</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#左闭右开 默认int</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#左闭右闭 默认float,找5个等间距点</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 0~1均匀分布</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 均值 方差 shape</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#左闭右开 区间[0,10)</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token comment">#n单位矩阵</span>np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token comment">#未初始化的数组，数组值是内存空间中的任意值</span>np<span class="token punctuation">.</span>mgrid<span class="token punctuation">(</span>坐标轴<span class="token number">1</span>（左开右闭）<span class="token punctuation">,</span>坐标轴<span class="token number">2</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span>拉直  <span class="token punctuation">.</span>c_<span class="token punctuation">(</span><span class="token punctuation">)</span>组合 看另一个教程吧用来生成网格还有各种_alike<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dtype可以用字符串参数或者相关的Numpy对象来指定。</p><p>标准类型大概有bool_ int类 float类 complex类  可以查一查，还有更高级的数据类型指定P35</p><p>后面带一个下划线的代表默认的类型</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>ndim 维度  shape 形状（每个维度大小）   size 元素个数（数组大小）</p><p>dtype 数据类型   itemsize 每个元素的字节大小   nbytes  总字节大小</p><h3 id="索引切片"><a href="#索引切片" class="headerlink" title="索引切片"></a>索引切片</h3><p>与python类似，更改元素时自动发生类型变换</p><p>获取第一列x2[: , 0]</p><p>获取第一行x2[0 , :] #获取行时其实可以省略，直接x2[0]</p><p>抽取左上角的2x2数组，x2[:2，:2]</p><p><strong>切片返回的是视图</strong>，.copy() 才是复制，这意味着可以处理大型数据集的片段而不用花费额外的内存</p><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>.reshape() 大小必须一致</p><p>或者在索引中使用newaxis 关键字，插入一个新维度，不过记得要加上前缀，即np.newaxis,比如原来有个是3（一行），后插变成（3，1）（一列）</p><p>x = x[np.newaxis,:] 在前面加了一个维度，反之则是在后面插入</p><h3 id="拼接和分裂"><a href="#拼接和分裂" class="headerlink" title="拼接和分裂"></a>拼接和分裂</h3><p><strong>np.concatenate</strong>(默认沿着第一个轴) #二维就是列，用axis  = 1 可以改成行</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">grid <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span> concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>grid<span class="token punctuation">,</span>grid<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前三维可以用<strong>np.vstack(垂直) np.hstack(水平) np.dstack(第三维)</strong> 来拼接</p><p>vertical horizontal deep</p><p>np.split(x, [3,5])#后面那个数组记录的是下一段首的索引位置，如果是3，那就在索引2（第3个元素）和3间断开，返回一个子元组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> gridOut<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span>x3 <span class="token operator">=</span> np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>grid<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x1Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x2Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#np.hsplit 和 np.vsplit 和 np.dsplit 差不多，记得后面那里要用索引列表</span>upper<span class="token punctuation">,</span>lower <span class="token operator">=</span> np<span class="token punctuation">.</span>vsplit<span class="token punctuation">(</span>grid<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#上下四行均分成两行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>Numpy高效的关键是采用 <strong>向量化</strong> 操作，通常用通用函数（ufunc）实现——提高了数组元素重复计算的效率</p><p>Python灵活的数据类型导致序列操作不能被编译成有效的机器码，所以循环操作超级慢</p><p>很多方案试图解决，比如Cpython，Cython，LLVM字节码，但是Cpython是最流行的</p><p>Cpython的主要瓶颈在于每次循环时必须做<strong>数据类型检查和函数的调度</strong>。</p><p><strong>Numpy为许多类型的操作提供了方便，静态，可编译程序的接口，被称为向量操作。这将被循环推送至Numpy下的编译层。</strong></p><p>只要看到python脚本有循环，就可以考虑能否用向量替代。</p><p>通用函数有两种形式，一元和二元。</p><p>python原生的算术运算符被重构了，相当于调用一些通用函数，比如 * 相当于 np.mulitiply</p><p><code> + - * /  //  **  %</code>都被重构了，还有布尔/位运算符</p><p>Numpy可以理解python内置的某些函数比如绝对值函数 abs(x)，对应的是np.absolute 或者别名np.abs，但这个numpy的处理复数时返回幅值。</p><p>三角函数：sin cos tan arcsin arccos acrtan  还有很多别的</p><p>指对数：exp exp2(2^)  power(底数，操作的数组x)       ||log  log2  log10</p><p>还有<strong>专门用来处理小量</strong>的：np.expm1(x)  == exp(x) - 1               np.log1p(x)  == log(1+x)   #在x很小时精度较高</p><p>还有很多双曲三角啊，比特位运算，比较运算，弧度角度转化等等等。可以查<a href="https://numpy.org/">文档</a></p><p>还有一个更专用的子模块scipy.special 里面有一堆牛逼函数比如伽马（广义阶乘）， 高斯积分啥的，可以搜索xxx function python</p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p><strong>指定输出</strong></p><p>有一个out参数指定输出结果的存放位置，此时不创建临时数组而直接写入目标位置，对于较大的数据能有效节约内存，但是注意要提前创建好用来存放的nparray</p><p><strong>聚合</strong></p><p><strong>二元通用函数</strong>指的是对两个输入操作，它们有些非常有趣的聚合功能，可以直接在对象上计算，会对给定的元素和操作重复执行，直到得到单个结果，这是任何通用函数都有的方法</p><p>比如reduce(压缩)，任何通用函数都有，可以重复计算直到获得单个结果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>add<span class="token punctuation">.</span><span class="token builtin">reduce</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>x <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要存储每次计算的中间结果，可以使用accumulate，项数不会变，但是除了第一项其他依次被处理</p><p>np.add.accumulate(x)     –array([1,3,6,10,15])</p><p><strong>外积</strong></p><p>任何输入函数都可以使用<strong>outer</strong>方法获得 两个不同输入数组 <strong>所有元素对</strong> 的函数运算结果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">.</span>outer<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的通用函数信息可以在Numpy和SciPy的文档网站查到</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>在处理大量数据的时候第一步通常是计算相关概率的概括统计值，比如最常用的均值和方差。</p><p>Numpy又快速的内置聚合函数可用于数组，如下：</p><p>np.sum 和内置的sum都可以起作用，但是numpy的sum在编译码中运行，所以<strong>操作更快</strong>（1000倍），而且注意不要混淆，他们的参数有不同的意义，np.sum函数是知道数组的维度的</p><p>np.min  max啥的，还有一种更简洁的语法是数组对象直接调用这些方法: x.min()  x.sum()</p><p><strong>多维度聚合</strong></p><p>可以用axis指定处理的维度，但是要注意，这个指定的是数组将会被聚合（折叠）的维度，而不是要返回的维度，比如说axis = 0 意味着第一个轴（二维数组的列）将要被折叠。</p><p>numpy有很多内置的聚合函数，大多数聚合都有对NaN的安全处理策略，即计算的时候<strong>忽略所有缺失值</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span><span class="token builtin">sum</span>  np<span class="token punctuation">.</span>nansumnp<span class="token punctuation">.</span>prod np<span class="token punctuation">.</span>nanprod 积（product）np<span class="token punctuation">.</span>mean  平均值std  标准差 Standard deviationvar  方差  variance<span class="token builtin">min</span> <span class="token builtin">max</span>  最小最大argmin argmax 最小最大的索引median  中位数percentile  基于元素排序的统计值<span class="token punctuation">,</span>例子如下In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> xOut<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">4.0</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">5.0</span><span class="token builtin">any</span>  <span class="token builtin">all</span>  存在  任意为真 <span class="token comment">#无安全版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>可以理解为将低维数组拓展，拓展到匹配的维度，但是其实并没有发生这样的内存分配，只是便于理解。</p><p>规则如下：</p><ol><li>如果两个数组的维度不同，小维度数组<strong>的形状在最左边补1</strong></li><li>如果数组在任何一个维度上大小不相等，而且数组<strong>该维度为1</strong>，则会沿着该维度拓展到匹配另一个数组</li><li>如果数组在任何一个维度上大小不相等，而且并没有某个数组维度为1，那么引发异常。</li><li>小心numpy的一维数组，也就是shape是（n,）<strong>这不等于列向量！</strong></li></ol><p>最值得注意的就是他补充一个维度是在左边补1而不是右边，如果希望右边补全，可以使用变形数组。</p><p>这些广播规则适用于<em><strong>任意二进制通用函数</strong></em></p><p><strong>实际应用</strong></p><p>数组的归一化</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Xmean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#沿着第一个维度聚合</span>In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X_centered <span class="token operator">=</span> X <span class="token operator">-</span> XmeanIn <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X_centered<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8.88178420e-17</span><span class="token punctuation">,</span>  <span class="token number">0.00000000e+00</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.11022302e-17</span><span class="token punctuation">]</span><span class="token punctuation">)</span>妙啊<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>画一个二维函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">看不懂他的骚操作，可以翻一下书的P60页<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="比较，掩码，布尔"><a href="#比较，掩码，布尔" class="headerlink" title="比较，掩码，布尔"></a>比较，掩码，布尔</h2><p>当想<strong>基于某些准则</strong>来抽取，修改，技术或对一个数组中的值进行其他操作时，掩码就可以派上用场了，在Numpy中，布尔掩码是完成这类任务的最高效完成方式。</p><p>比较有六种运算符<code>== != &lt; &lt;= &gt; &gt;=</code> 两边可以是表达式，<strong>每次返回的结果是布尔数组</strong></p><p>利用复合表达式实现逐元素比较也是可行的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>x <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">,</span>  <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些比较运算符也是<strong>借助通用函数</strong>来实现的，例如x &lt; 3 其实调用np.less(x,3) </p><h3 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h3><p>记录布尔数组中非零（其实就是True）的个数 np.count_nonzero(）</p><p>统计小于6的则np.count_nonzero(x&lt;6) </p><p>或者也可以 np.sum(x&lt;6) 都是返回为True的个数，sum的好处是可以沿着行或者列进行</p><p>np.any 和 np.all 快速检测全部 </p><p>需要提醒的是python有内置的sum，any，all函数，这些函数在numpy中有对应的版本，但是语法不同，如果在多维数组上混用这两个版本，会导致神奇的错误，请确保使用numpy版本</p><p><strong>布尔运算符</strong></p><p>逻辑运算符也被重载，可以实现对数组的逐位逻辑运算。有<code>&amp; | ^ ~</code></p><p>np.sum((inches &gt; 0.5) &amp; (inches &lt; 1))  注意用括号调整运算次序。表示inches在0.5到1间的数目</p><p>将布尔数组作为掩码</p><p>就是传说中的布尔矩阵作为索引呗，会得到一个一维数组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">and</span> <span class="token keyword">or</span>  和  <span class="token operator">&amp;</span> <span class="token operator">|</span>  的区别<span class="token keyword">and</span> <span class="token operator">/</span> <span class="token keyword">or</span> 判断整个对象是真是假，而后两者是指每个对象中的比特位，依次化成二进制码进行操作而布尔矩阵可以被当成比特字符组成的，所以采用后者，而使用前者比较整个对象的时候会出错。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记得布尔索引会被拉直成一个一维数组，所以还是当作索引用，不要单独用。</p><h2 id="花哨的索引"><a href="#花哨的索引" class="headerlink" title="花哨的索引"></a>花哨的索引</h2><p>花哨（fancy）的索引对多个维度也适用。</p><p><strong>花哨索引和前面的简单索引类似，但是传递的是索引数组，可以让我们快速获得并修改复杂的数组值的子数据集</strong></p><p>结果的形状与<strong>索引数组的形状</strong>一致，如果有广播，就是<strong>跟广播后的索引数组的形状</strong>一致,而不是被索引的数组</p><p>如果是普通的一维一维的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>row <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>col <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b<span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span>那就像坐标一样Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>但如果b<span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span><span class="token punctuation">,</span>col<span class="token punctuation">]</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>那就是广播，淦，当年为何困惑了我这么久，广播以后 索引数组的每一个位置其实都是一个坐标。。就这么简单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配合切片，简单索引，布尔效果更好。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>从一个矩阵中选择行的子集！</p><p>可以用花哨索引来修改值，但是重复的索引会有一些诡异的事情发生</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> i <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>In <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> xOut<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#应该看成x[i] = x[i] + 1就会发现神奇索引导致的诡异地方，解决方法是at👇</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>at函数可以对给定的操作，给定的索引，给定的值进行就地操作。</p><p>比如np.add.at(x,i,1) x为被操作的矩阵，i为索引，1为操作数（+1）</p><h2 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h2><p>python有内置的sort和sorted但是太慢了</p><p>np.sort 是快速排序【N log N】,另外可以选择归并排序和堆排序。</p><p>np.sort(X) 不会修改原始数组，x.sort()这种python内置的方法会<strong>替代原始数组</strong></p><p>np.argsort(X)返回的是<strong>如果排序</strong> 好的索引值。</p><p>利用axis可以选择行列排序噢,<strong>这是将行和列当成独立数组，任何关系都将丢失！</strong></p><p><strong>部分排序：分隔</strong></p><p>np.partition(x,3) 将最小的3个和其他的分隔开，两组数是任意排序的</p><p>当用<strong>axis时也会破坏行和列的关系</strong>，np.argpartition返回索引</p><h2 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h2><p>P82 <strong>数据类型</strong></p><p>Numpy的结构化数组和记录数组。</p><p>他们为复合的，异构的数据提供了非常有效的存储。</p><p>其实就是把dtype当作一个结构嘛</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span>age <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">]</span>weight <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">21.21</span><span class="token punctuation">,</span><span class="token number">4.43</span><span class="token punctuation">,</span><span class="token number">4334.65</span><span class="token punctuation">,</span><span class="token number">45.9</span><span class="token punctuation">]</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'names'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'weight'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          <span class="token string">'format'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">'U10'</span><span class="token punctuation">,</span><span class="token string">'i4'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">#U10表示长度不超过10的字符串，</span>data<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token operator">=</span>namedata<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">=</span>agedata<span class="token punctuation">[</span><span class="token string">'weight'</span><span class="token punctuation">]</span><span class="token operator">=</span>weight这样可以用连续的内存存储异构的数据，反映了他们间的关系可以用date<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>查看是<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21.21</span><span class="token punctuation">)</span>然后就有很多骚操作比如data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token comment">#获得年龄小于30的人的年龄</span>数值类型可以用python类型或者Numpy的dtype来指定<span class="token number">2</span><span class="token operator">&lt;</span> 和 <span class="token operator">></span> 分别表示低字节序 和 高字节序b 字节型i u 有、无符号整形f 浮点型c 复数浮点型S a 字符串U Unicode编码字符串V 原生数据<span class="token comment">#还有一种格式是元组列表</span>np<span class="token punctuation">.</span>dtype<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'U10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>这样就直接生成一个结构化数组结构化数组的dtype属性里，第n个反映了每个单元中第n个数据的索引和属性，比如data<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">55.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">85.8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Cathy'</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">68.0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>data<span class="token punctuation">.</span>dtype<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'&lt;U10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span><span class="token string">'&lt;f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>np.dtype([(&#39;id&#39;,&#39;i8&#39;),(&#39;mat&#39;,&#39;f8&#39;,(3,3))])这样就定义了一个id和3x3矩阵的结构</code>由于numpy中的dtype直接映射到C结构定义，包含数组内容的缓存可以直接在C程序里使用，如果想写一个python接口与一个遗留的C\Fortran接口交互，非常有用</p><p>如果需要使用结构化数组，更好是掌握pandas包。</p><h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>Pandas是在Numpy基础上建立的新程序库，提供了一种高效的DataFrame结构。</p><p>DataFrame本质上是一种<u>带行标签和列标签、支持相同类型数据和缺失值的</u>多维数组。</p><p>Pandas不仅为各种带标签的数据提供了便利的存储界面，还实现了许多强大的操作，这些操作对数据库框架和电子表格程序的用户来说非常熟悉</p><p>当我们需要处理更灵活的数据任务（为数据添加标签，处理缺失值），或者需要分组数据计算，Numpy就会显露出限制，而Pandas为“数据清理”（data munging）任务提供了捷径</p><h2 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h2><p>如果从底层视角观察pandas对象，可以看成是增强版的Numpy结构化数组，行列不再是简单的整数索引，还可以带上标签！要理解基本数据结构内部的细节！</p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>带索引数据的一维数组</p><p>可以用<strong>数组</strong>创建Series对象 data = pd.Series([0.25,0.5,0.75,1.0])</p><p>values属性返回Numpy数组的对象</p><p>index返回一个类型为pd.Index的类数组对象，后续介绍</p><p>name属性会作为dataframe的列标签</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span>Darren     <span class="token number">21</span>Jack       <span class="token number">37</span>Jessica    <span class="token number">56</span>Name<span class="token punctuation">:</span> one<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32In <span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>nameOut<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'one'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Series比它模仿的一维Numpy数组更加通用，灵活！！</strong></p><p>本质差别在索引</p><p>Numpy数组用的是隐式定义的索引，Series是显式定义，索引完全可以是任意类型，不按顺序</p><p>pd.Series([2,2,22,],index = [‘a’,’c’,’d’])</p><p>字典将任意键映射到一组任意值，Series将类型键映射到一组类型值，</p><p>Pandas Series的类型信息使得她在某些操作上<u>比Python的字典更高效</u></p><p>可以用<strong>字典</strong>创建一个Series对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'dadaa'</span><span class="token punctuation">:</span> <span class="token number">1223</span><span class="token punctuation">,</span> <span class="token string">'tda'</span><span class="token punctuation">:</span> <span class="token number">12124</span><span class="token punctuation">,</span> <span class="token string">'dada'</span><span class="token punctuation">:</span> <span class="token number">341</span><span class="token punctuation">&#125;</span>dict2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">)</span>dict2Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dadaa     <span class="token number">1223</span>tda      <span class="token number">12124</span>dada       <span class="token number">341</span>dtype<span class="token punctuation">:</span> int64<span class="token comment">#用字典创建对象时，索引按照排序好的默认顺序排列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Series支持索引切片！</p><p>dict2[‘dadaa’:’dada’] </p><p>在pd.Series(data,index = index)中，data若是标量，则会填充到每一项上</p><p>索引默认0-n整数序列，RangeIndex（start = 0, stop = n, step = 1）</p><p>data可以是列表，字典（index是默认的排序字典键,也就是先会按照默认方式排序一遍）</p><p>每种类型都可以通过<strong>显式指定索引筛选</strong>需要的结果：<strong>但是字典这样做只会保留显式定义的部分键值对！</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> b <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>a<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>ValueError                                Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">5bed21d603af</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>a<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>D<span class="token punctuation">:</span>\Anaconda3\lib\site<span class="token operator">-</span>packages\pandas\core\series<span class="token punctuation">.</span>py <span class="token keyword">in</span> __init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> index<span class="token punctuation">,</span> dtype<span class="token punctuation">,</span> name<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> fastpath<span class="token punctuation">)</span>    <span class="token number">348</span>                 <span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token number">349</span>                     <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">350</span>                         <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>    <span class="token number">351</span>                             <span class="token string-interpolation"><span class="token string">f"Length of passed values is </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">, "</span></span>    <span class="token number">352</span>                             <span class="token string-interpolation"><span class="token string">f"index implies </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">len</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">."</span></span>ValueError<span class="token punctuation">:</span> Length of passed values <span class="token keyword">is</span> <span class="token number">5</span><span class="token punctuation">,</span> index implies <span class="token number">3</span><span class="token punctuation">.</span>    <span class="token comment">#当列表的时候index和data长度需一致</span>In <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>b<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span>a    <span class="token number">4</span>c    <span class="token number">7</span>dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>和Series一样，它也既可以作为一个通用型Numpy数组，也可以看作特殊的Python字典</p><p>可以看成一种既有灵活行索引，又有灵活列名的<strong>二维数组</strong></p><p>可以看成有序排列的若干Series对象。这里的“排列”指的是它们拥有共同的索引</p><p>假设a，b是两个Series对象，而且拥有相同的索引，那么可以</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'column1'</span><span class="token punctuation">:</span>a<span class="token punctuation">,</span><span class="token string">'column2'</span><span class="token punctuation">:</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">#其中a和b为长度一样的Series对象</span>ccolumn1   column2index1      <span class="token number">32423</span>     <span class="token number">32423</span>index2      <span class="token number">2189</span>      <span class="token number">2198128</span>index       <span class="token number">312312</span>    <span class="token number">21312</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DataFrame的index属性和Series一样，返回Index对象（如果是默认生成的，则是RangeIndex）</p><p>还有个columns属性，也返回Index对象，不过是每列的标签</p><p>DataFrame可看成特殊的字典，每列映射一个Series数据，通过列索引c[‘column1’]可以得到该Series对象</p><hr><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a><strong>创建</strong></h4><p>ps：创建字典</p><ol><li><p>使用dict() 函数创建一个空字典并给变量赋值</p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160413.png"  style="zoom:50%;" /><p><strong>第二种方法应该是大规模处理中用的多的</strong></p></li><li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160432.png"  style="zoom:50%;" /></li></ol><p>创建<strong>DataFrame</strong></p><p>（1）可以用单个Series对象</p><p>pd.DataFrame(populations,columns = [‘population’])</p><p>（2）可以用<strong>元素是字典的列表</strong>来创建,若是字典有一些键(作为列索引)不在，会用NaN补全</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span>i<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>dataOut<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>    pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    a  b<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">2</span><span class="token number">2</span>  <span class="token number">2</span>  <span class="token number">4</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span>      a  b    c<span class="token number">0</span>  <span class="token number">1.0</span>  <span class="token number">2</span>  NaN<span class="token number">1</span>  NaN  <span class="token number">3</span>  <span class="token number">4.0</span><span class="token comment">#这里的例子都是用默认Index</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）通过<strong>Series对象、列表字典</strong>创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'column1'</span><span class="token punctuation">:</span>a<span class="token punctuation">,</span><span class="token string">'column2'</span><span class="token punctuation">:</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>ccolumn1   column2index1      <span class="token number">32423</span>     <span class="token number">32423</span>index2      <span class="token number">2189</span>      <span class="token number">2198128</span>index       <span class="token number">312312</span>    <span class="token number">21312</span>如果值是列表，索引是默认的<span class="token number">0</span>，<span class="token number">1</span>，<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4)通过Numpy二维数组创建。假如有二维数组，就可以创建一个可以指定行列索引值的DataFrame，如果不指定，那么行列都是默认索引  IndexRange</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span><span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span>         foo       bara  <span class="token number">0.855538</span>  <span class="token number">0.595667</span>b  <span class="token number">0.575162</span>  <span class="token number">0.149108</span>d  <span class="token number">0.034177</span>  <span class="token number">0.156297</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(5)通过Numpy结构化数组创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'i8'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> AOut<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'&lt;i8'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'&lt;f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>A<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   A    B<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0.0</span><span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">0.0</span><span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">0.0</span>可以发现子结构的名字被作为了列标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>可以看成一个<strong>不可变数组</strong>或<strong>有序集合</strong>，可以包含重复值。这两种观点体现了其一些功能</p><ol><li><p>不可变数组</p><p>Index很多操作都像数组，比如切片，还有许多与Numpy数组相似的属性，比如</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ind <span class="token operator">=</span> pd<span class="token punctuation">.</span>Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> indOut<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Int64Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int64'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ind<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Int64Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int64'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ind<span class="token punctuation">.</span>size<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>ndim<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token number">5</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token number">1</span> int64<span class="token comment">#这几个属性竟然还保留了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最大的不同在于<strong>Index对象的索引是不可变的</strong>，ind[1]=0会报错，这使得索引共享更安全</p></li><li><p>有序集合</p><p>Index遵循python标准库的集合（set）数据结构的许多惯用法 &amp; | ^ ~</p><p>indA &amp; indB 也有indA.intersection(indB)</p></li></ol><h2 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h2><p>类推Numpy的各种花式操作</p><h3 id="Series-1"><a href="#Series-1" class="headerlink" title="Series"></a>Series</h3><p>两个类比：<strong>一维Numpy数组和Python标准字典</strong>，很多操作是一样的。</p><p><strong>看作字典</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.75</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0.</span>5In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'a'</span> <span class="token keyword">in</span> dataOut<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> TrueIn <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#这个失败了</span>In <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>valuesOut<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">0.5</span> <span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>keysOut<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>bound method Series<span class="token punctuation">.</span>keys of a    <span class="token number">0.</span><span class="token number">25b</span>    <span class="token number">0.</span><span class="token number">50c</span>    <span class="token number">0.</span><span class="token number">75d</span>    <span class="token number">1.</span>00dtype<span class="token punctuation">:</span> float64<span class="token operator">></span>In <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token builtin">zip</span> at <span class="token number">0x201ee3bbcc0</span><span class="token operator">></span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.25</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dataOut<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span>a    <span class="token number">0.</span><span class="token number">25b</span>    <span class="token number">0.</span><span class="token number">50c</span>    <span class="token number">0.</span><span class="token number">75d</span>    <span class="token number">1.</span><span class="token number">00e</span>    <span class="token number">1.</span>25dtype<span class="token punctuation">:</span> float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Series对象的可变性</strong>是一个非常方便的特性，pandas在底层已经为可能发生的<strong>内存布局和数据复制</strong>自动决策，用户不用担心。</p><p><strong>看作一维数组</strong></p><p>包括索引，掩码，花哨索引都有</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token comment">#显示索引包含最后一位Out[13]:a    0.25b    0.50c    0.75dtype: float64In [14]: data[0:2] #隐式索引不包含最后一位Out[14]:a    0.25b    0.50dtype: float64In [15]: data[(data>0.3) &amp; (data&lt;0.8)] #布尔索引yydsOut[15]:b    0.50c    0.75dtype: float64In [16]: data[['a','e']]#fancy indexOut[16]:a    0.25e    1.25dtype: float64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a><strong>索引器</strong></h4><p>切片和取值的习惯用法经常混乱，如果Series选了<strong>显式整数索引</strong>，那么data[1]这样取值会使用显式索引，而data[1:3]这样的切片操作却会使用隐式索引！</p><p>所以Pandas准备了一些索引器（indexer）来作为取值的方法</p><p>它们不是Series对象的方法，而是暴露切片接口的<strong>属性</strong></p><p><strong>loc属性</strong></p><p>表示使用显式切片和取值，<strong>左闭右闭！！</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'a'</span>In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">1</span>    a<span class="token number">3</span>    bdtype<span class="token punctuation">:</span> <span class="token builtin">object</span>    <span class="token comment">#不然的话默认是隐式的</span>In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">3</span>    b<span class="token number">5</span>    cdtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，iloc 表示都是python形式的隐式索引，左闭右开</p><p>ix是前两者的混合，在Series对象中ix等价隐式，主要用于DataFrame。<strong>已经被弃用了</strong></p><p>Python的设计原则之一是“<strong>显式优于隐式</strong>”，loc和iloc让代码更容易维护。</p><h3 id="DataFrame-1"><a href="#DataFrame-1" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame有些方面像<strong>二维或结构化数组</strong>，有些方面又像一个<strong>共享索引的若干Series对象构成的字典</strong></p><p><strong>看作字典</strong></p><p>看作由若干Series对象组成的字典</p><p>比如 area 和 pop是索引一样的两个Series</p><p>data = pd.DataFrame({‘area’: area,’pop’: pop})来构建列索引为area和pop的数组</p><p>可以通过对列名进行字典形式取值，也可以用属性形式选择<strong>纯字符串列名</strong>的数据</p><p><code>data[&#39;area&#39;] is data.area True </code>都是选取同一个Series对象</p><p>但是如果<strong>列名不是纯字符串</strong>，或者<strong>列名与DataFrame的方法同名</strong>，那么就不能使用，比如pop方法</p><p>由此还要避免用data.pop = z 这种形式赋值，而要用 data[‘pop’] = z来赋值</p><p>和前面介绍的Series对象一样，还可以用字典形式的语法调整/增加对象，如果要增加一列可以这样：</p><p>data[‘c’] = data[‘a’]/data[‘b’] 顺便展示了两个Series对象算术运算的简便语法，(｡･∀･)ﾉﾞ嗨</p><hr><p><strong>看作二维数组</strong></p><p>可以看成是一个增强版的二维数组，用values属性按行查看数组数据(还记得Series是没有values属性的)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> xOut<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>          one      twoDarren    <span class="token number">123</span>   <span class="token number">123313</span>Jack    <span class="token number">21212</span>  <span class="token number">2131132</span>In <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>TOut<span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     Darren     Jackone     <span class="token number">123</span>    <span class="token number">21212</span>two  <span class="token number">123313</span>  <span class="token number">2131132</span>In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>valuesOut<span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>    <span class="token number">123</span><span class="token punctuation">,</span>  <span class="token number">123313</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span>  <span class="token number">21212</span><span class="token punctuation">,</span> <span class="token number">2131132</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>itemsOut<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>bound method DataFrame<span class="token punctuation">.</span>items of           one      twoDarren    <span class="token number">123</span>   <span class="token number">123313</span>Jack    <span class="token number">21212</span>  <span class="token number">2131132</span><span class="token operator">></span>In <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>columns <span class="token comment">#注意复数</span>Out<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>indexOut<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>keysOut<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>bound method NDFrame<span class="token punctuation">.</span>keys of           one      twoDarren    <span class="token number">123</span>   <span class="token number">123313</span>Jack    <span class="token number">21212</span>  <span class="token number">2131132</span><span class="token operator">></span><span class="token comment">#因为索引被用在了列上，我们取行的能力收到了限制，x['one']可以取出一列</span>x<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Darren      <span class="token number">123</span>Jack      <span class="token number">21212</span>Name<span class="token punctuation">:</span> one<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32<span class="token comment">#但是取行得用values属性</span>x<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1213313</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>data.values，理解了”二维数组“这一点，就能引出很多骚操作：比如data.T转置</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#可以用索引器来帮助进行索引</span><span class="token comment">#loc 和 iloc 处理起来就像处理二维数组一样，而且行列标签会自动保存在结果中</span><span class="token comment">#ix的规则是，既可以使用隐式也可以使用显式，但是在遇到整数索引时，规则和之前的Series一样混乱</span><span class="token comment">#其他用于索引的功能全都可以用于这些索引器</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">87</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token string">'Jessica'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>dataOut<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span>          one  two  three  fourDarren    <span class="token number">21</span>   <span class="token number">34</span>     <span class="token number">12</span>    <span class="token number">45</span>Jack      <span class="token number">37</span>   <span class="token number">23</span>     <span class="token number">76</span>    <span class="token number">23</span>Jessica   <span class="token number">56</span>   <span class="token number">98</span>     <span class="token number">34</span>    <span class="token number">87</span>data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span>       threeJack     <span class="token number">76</span>data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">:</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token string">'one'</span><span class="token punctuation">:</span><span class="token string">'three'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span>         one  two  threeDarren   <span class="token number">21</span>   <span class="token number">34</span>     <span class="token number">12</span>Jack     <span class="token number">37</span>   <span class="token number">23</span>     <span class="token number">76</span><span class="token comment">#任何用于处理Numpy形式的方法都可用于这些索引器比如掩码和花哨</span><span class="token comment">#结合使用来筛选一部分，先筛选行，再筛选列噢</span>In <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>data<span class="token punctuation">.</span>one<span class="token operator">></span><span class="token number">22</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">:</span>         two  fourJack      <span class="token number">23</span>    <span class="token number">23</span>Jessica   <span class="token number">98</span>    <span class="token number">87</span><span class="token comment">#记住一定要加loc索引器，不然报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他的取值方法</strong></p><p>有点奇怪但是很好用。对单个标签取值就是选择列，对<strong>多个标签</strong>用切片就选择行</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">#隐式切片Out[21]:          one  two  three  fourJack      37   23     76    23Jessica   56   98     34    87data['Darren':'Jessica'] #显式切片Out[22]:          one  two  three  fourDarren    21   34     12    45Jack      37   23     76    23Jessica   56   98     34    87data['two']Out[23]: Darren     34Jack       23Jessica    98Name: two, dtype: int32#掩码操作起到筛选某些 行 的作用data[data.three>20]Out[24]:          one  two  three  fourJack      37   23     76    23Jessica   56   98     34    87# 这两种操作方法其实和Numpy数组的语法类似，虽然它们与Pandas的操作习惯不太一致，但是非常好用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><p>Pandas继承了Numpy的功能，可以对元素进行快速运算</p><p>但是Pandas实现了一些高效的技巧：</p><ol><li>对于一元计算，通用函数在输出结果中<u>保留索引和列标签。</u></li><li>对于二元计算，Pandas在传递通用函数时会<strong>自动对齐索引</strong>进行计算</li></ol><p><strong>这意味着：保存数据内容  组合不同来源的数据  这两处在Numpy里容易出错的地方，成了Pandas杀手锏</strong></p><p>ps：补充一下伪随机数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span>这个设置的是全局随机数种子rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment">#设置单独的随机数种子</span>arr <span class="token operator">=</span> rng<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">#这样生成的就是独立的</span>seedpermutation<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">#返回一个序列的随机排列</span>shuffle <span class="token comment"># 随机排列一个序列,直接更改原来的</span>rand <span class="token comment">#从均匀分布[0,1)中抽取样本</span>uniform <span class="token comment">#选定区间【】均匀分布</span>randint <span class="token comment">#根据给定的从低到高（左闭右开，左边省略为0）的范围抽取随机一个整数，如果给一个元组，则在0-元组每一项之间取，输出一个列表</span>randn <span class="token comment">#从均值0方差1的正态分布</span>normal<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#平均值，标准差，</span>shapebinomial <span class="token comment">#从二项分布中抽取样本</span>beta <span class="token comment">#从beta分布中抽取样本</span>chisquare <span class="token comment">#从卡方分布中抽取样本uniform(x1,x2,(shape)) #从均匀分布中抽取样本</span>gamma <span class="token comment">#从伽马分布中抽取样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引对齐"><a href="#索引对齐" class="headerlink" title="索引对齐"></a>索引对齐</h3><p><strong>当在两个Series或DataFrame对象上进行二元计算时，Pandas会在计算过程中对齐两个对象的索引，在处理不完整的数据时，这一点非常方便</strong></p><p>结果数组的索引是两个输入数组索引的<strong>并集</strong>，缺失位置填充NaN，这是通过python内置集合运算规则实现的</p><p>我们也可以通过a.index | b.index 来获得这个新索引</p><p>两个对象的行列顺序可以是不一样的，结果的索引会<strong>自动排序</strong></p><p>当然也能自行设置缺失值，A.add(B,fill_value = 0) 这样会相加A和B并用0来填充</p><p>对于DataFrame其实大同小异：(下面有一些骚操作)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">:</span> rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'AB'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">:</span> B <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'BAC'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span> AOut<span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    A   B<span class="token number">0</span>   <span class="token number">6</span>  <span class="token number">19</span><span class="token number">1</span>  <span class="token number">14</span>  <span class="token number">10</span>In <span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span> BOut<span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   B  A  C<span class="token number">0</span>  <span class="token number">7</span>  <span class="token number">4</span>  <span class="token number">6</span><span class="token number">1</span>  <span class="token number">9</span>  <span class="token number">2</span>  <span class="token number">6</span><span class="token number">2</span>  <span class="token number">7</span>  <span class="token number">4</span>  <span class="token number">3</span>In <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A<span class="token operator">+</span>BOut<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span>      A     B   C<span class="token number">0</span>  <span class="token number">10.0</span>  <span class="token number">26.0</span> NaN<span class="token number">1</span>  <span class="token number">16.0</span>  <span class="token number">19.0</span> NaN<span class="token number">2</span>   NaN   NaN NaN<span class="token comment">#如果想要设置fill_value得用A.add(B,fill_value = x)</span>python运算符   映射  Pandas方法<span class="token operator">+</span>     add<span class="token operator">-</span>     sub<span class="token operator">*</span>     mul<span class="token operator">/</span>     div<span class="token operator">//</span>    floordiv<span class="token operator">%</span>     mod<span class="token operator">**</span>    <span class="token builtin">pow</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>DataFrame和Series的混合运算</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dfOut<span class="token punctuation">[</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   Q  R  S  T<span class="token number">0</span>  <span class="token number">7</span>  <span class="token number">7</span>  <span class="token number">2</span>  <span class="token number">5</span><span class="token number">1</span>  <span class="token number">4</span>  <span class="token number">1</span>  <span class="token number">7</span>  <span class="token number">5</span><span class="token number">2</span>  <span class="token number">1</span>  <span class="token number">4</span>  <span class="token number">0</span>  <span class="token number">9</span><span class="token comment">#df.iloc[0]选取的是第一列，有点类似广播，默认是按行计算！</span>In <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   Q  R  S  T<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">1</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">-</span><span class="token number">6</span>  <span class="token number">5</span>  <span class="token number">0</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">6</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">-</span><span class="token number">2</span>  <span class="token number">4</span><span class="token comment">#按列计算就得调一下轴</span>In <span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'R'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   Q  R  S  T<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token operator">-</span><span class="token number">5</span> <span class="token operator">-</span><span class="token number">2</span><span class="token number">1</span>  <span class="token number">3</span>  <span class="token number">0</span>  <span class="token number">6</span>  <span class="token number">4</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">0</span> <span class="token operator">-</span><span class="token number">4</span>  <span class="token number">5</span><span class="token comment">#否则结果会很坑爹</span>In <span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> df<span class="token punctuation">[</span><span class="token string">'R'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    Q   R   S   T   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span><span class="token number">0</span> NaN NaN NaN NaN NaN NaN NaN<span class="token number">1</span> NaN NaN NaN NaN NaN NaN NaN<span class="token number">2</span> NaN NaN NaN NaN NaN NaN NaN<span class="token comment">#值得注意的是在二元运算中缺失的直接判定为NaN而不是不进行操作</span><span class="token comment">#还是得注意“按行操作”的含义。Series翻转成水平后的标签是否为dataframe的columns的子集</span>In <span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">:</span> halfrowOut<span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">:</span>Q    <span class="token number">7</span>S    <span class="token number">2</span>Name<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32In <span class="token punctuation">[</span><span class="token number">71</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> halfrowOut<span class="token punctuation">[</span><span class="token number">71</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     Q   R    S   T<span class="token number">0</span>  <span class="token number">0.0</span> NaN  <span class="token number">0.0</span> NaN<span class="token number">1</span> <span class="token operator">-</span><span class="token number">3.0</span> NaN  <span class="token number">5.0</span> NaN<span class="token number">2</span> <span class="token operator">-</span><span class="token number">6.0</span> NaN <span class="token operator">-</span><span class="token number">2.0</span> NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>缺失值的问题十分普遍，处理不同数据源缺失值的方法不同</p><p>本节介绍一些处理缺失值的通用规则，Pandas对缺失值的表现形式，并演示Pandas自带的几个处理缺失值的工具</p><p>本书涉及的缺失值主要有三种形式：<strong>null 、NaN、 NA</strong></p><p>不愧是作者，列举了他在创建pandas时对于这个问题的看法，最终他选择了<strong>用标签方法表示缺失值</strong></p><p>这包括两种python原有的缺失值：浮点数据的NaN值，还有None对象</p><p>当然，Numpy支持掩码数据，Pandas也集成了这个功能，但由于存储、维护的资源浪费，并不可取</p><hr><p>P106</p><p><strong>None</strong></p><p>这是一个Python单体对象，不能作为任何Numpy/Pandas数组类型的缺失值，只能用于’object’数组类型</p><p>即由python对象构成的数组，dtype = object 就是这个意思。</p><p>这样的类型对数据的任何操作最终都会在python层面完成，进行常见快速操作时会消耗更多资源。</p><p>同时，python没有定义整数与None之间的加减运算，Sum和min（）这些都会出错。</p><p><strong>NaN</strong></p><p>这是一种按照IEEE浮点数标准设计，在任何系统中都兼容的<strong>特殊浮点数</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals1Out<span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">object</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals2<span class="token punctuation">.</span>dtypeOut<span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dtype<span class="token punctuation">(</span><span class="token string">'float64'</span><span class="token punctuation">)</span><span class="token comment">#Numpy会自动为这个数组选择一个原生浮点类型，这意味着与object不同，该数组会被编译成C代码从而实现快速操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且NaN无论进行何种操作，结果都是NaN，跟病毒一样。</p><p>但还记得Numpy提供了一些特殊的累计函数来规避NaN，np.nansum(vals2) == 8</p><p><strong>NA</strong></p><p>Pandas把NaN和None看作是可以等价交换的</p><p>Pandas会将没有标签的数据类型自动转换为NA，规则见P109</p><table><thead><tr><th>类型</th><th>存在缺失值时转换</th><th>NA标签值</th></tr></thead><tbody><tr><td>float</td><td>无变化</td><td>np.nan</td></tr><tr><td>object</td><td>无变化</td><td>np.nan或None</td></tr><tr><td>integer</td><td>强制转换为float64</td><td>np.nan</td></tr><tr><td>boolean</td><td>强制转换为object</td><td>np.nan或None</td></tr></tbody></table><p>*Pandas中字符串类型的数据通常是用object类型存储的</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p><strong>发现缺失值</strong></p><p>isnull 和notnull 会返回布尔类型的掩码数组，以此可以直接用作索引</p><p><strong>剔除缺失值</strong></p><p>dropna </p><p>这两个操作在Series里没有什么问题</p><p>但在DataFrame中就需要注意，并没有办法单独剔除一个值，只能剔除缺失值所在整行或整列</p><p>dropna<strong>默认剔除整行</strong>（因为数据按行为一条），如果加参数df.dropna(axis = 1)或者axis = ‘columns’那就是整列，或者是“1”，但是有点诡异。</p><p>可以用how或参数设置阈值，默认是how =’any’，可以是all(必须整行、列都是缺失值才剔除)</p><p><u>thresh参数可以设置非缺失值的最小数量</u>，thresh = 3则正常数据&lt;3的行、列被剔除。</p><p><strong>填充缺失值</strong></p><p>fillna返回填充了缺失值后的数组副本</p><p>参数可以选择method = ‘ffill/bfill’ 用缺失值前/后的有效值来依次填充，也可以改axis来左右填充。</p><p>但是如果前面一直找不到有效值填充，那就还是缺失值。。。</p><h2 id="层级索引"><a href="#层级索引" class="headerlink" title="层级索引"></a>层级索引</h2><p>当我们遇到存储多维数据需求时，数据索引超过一两个键。</p><p>Pandas提供了Panel和Panel4D对象解决三维数据和四维数据。</p><p>这两种对象采用密集存储，在维度增加的情况下效率越来越低，作者更推荐层级索引</p><p>但更直观的形式是hierarchical indexing，层级索引，配合多个不同等级的以及索引一起用，将高维数组转换成类似一维和二维对象的形式。</p><p>P114有解释层级索引便利性的例子</p><h3 id="创建层级索引"><a href="#创建层级索引" class="headerlink" title="创建层级索引"></a>创建层级索引</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#最直接的方法是将index的参数设置为至少二维的索引数组</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>columns <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'data1'</span><span class="token punctuation">,</span><span class="token string">'data2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dfOut<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        data1     data2a <span class="token number">1</span>  <span class="token number">0.290846</span>  <span class="token number">0.466652</span>  <span class="token number">2</span>  <span class="token number">0.245400</span>  <span class="token number">0.860682</span>b <span class="token number">1</span>  <span class="token number">0.697193</span>  <span class="token number">0.100121</span>  <span class="token number">2</span>  <span class="token number">0.028793</span>  <span class="token number">0.633941</span>    <span class="token comment">#输出按照index顺序来，但是如果重复就会自动少显示，所以要手动确认哪个在前合适。</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>indexOut<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>MultiIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token punctuation">)</span><span class="token comment">#index的类型变为了MultiIndex</span><span class="token comment">#第二种方法是把元组作为键的字典传递给Pandas</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">32432</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">312312</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3241332</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3243252</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">32434532</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3223432</span><span class="token punctuation">&#125;</span>In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span>a  <span class="token number">2000</span>       <span class="token number">32432</span>   <span class="token number">2010</span>      <span class="token number">312312</span>b  <span class="token number">2000</span>     <span class="token number">3241332</span>   <span class="token number">2010</span>     <span class="token number">3243252</span>c  <span class="token number">2000</span>    <span class="token number">32434532</span>   <span class="token number">2010</span>     <span class="token number">3223432</span>dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unstack可以把一个多级索引的Series转化为DataFrame，而stack相反（用level来选择处理的层数）不过注意，unstack和stack默认竟然是后面那层，可以用level = 0 来选第一层。</p><p>注意DataFrame是用于二维的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#显式创建MultiIndex也是很有用的#可以用不同等级的数组来创建In [17]: pd.MultiIndex.from_arrays([['a','a','b','b'],[1,2,1,2]])#可以用包含不同等级索引值的元组构成的列表来创建In [18]: pd.MultiIndex.from_tuples([('a',1),('a',2),('b',1),('b',2)])#可以用两个索引序列的笛卡尔积来创建（这个逻辑上妙一点）In [19]: pd.MultiIndex.from_product([['a','b'],[1,2]])#原有的levels和labels属性好像被删掉了？#可以加名字来方便管理In [29]: bOut[29]:a  2000       32432   2010      312312b  2000     3241332   2010     3243252c  2000    32434532   2010     3223432dtype: int64In [30]: b.index.names = ['owner','year']In [31]: bOut[31]:owner  yeara      2000       32432       2010      312312b      2000     3241332       2010     3243252c      2000    32434532       2010     3223432dtype: int64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#多级列索引</span>In <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> index <span class="token operator">=</span> pd<span class="token punctuation">.</span>MultiIndex<span class="token punctuation">.</span>from_product<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">2014</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'year'</span><span class="token punctuation">,</span><span class="token string">'visit_time'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> columns <span class="token operator">=</span> pd<span class="token punctuation">.</span>MultiIndex<span class="token punctuation">.</span>from_product<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Bob'</span><span class="token punctuation">,</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'HR'</span><span class="token punctuation">,</span><span class="token string">'Temp'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#round是保留小数位，此处为1</span>In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dataOut<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">,</span>  <span class="token number">2.4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.1</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">1.6</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.3</span><span class="token punctuation">,</span>  <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">2.4</span><span class="token punctuation">,</span>  <span class="token number">0.9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1</span><span class="token punctuation">,</span>  <span class="token number">2.2</span><span class="token punctuation">,</span>  <span class="token number">0.1</span><span class="token punctuation">,</span>  <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*=</span><span class="token number">10</span>In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token operator">+=</span><span class="token number">37</span>In <span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span>index <span class="token operator">=</span> index<span class="token punctuation">,</span>columns <span class="token operator">=</span> columns<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_dataOut<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span>name              Bob       Darren        Jack<span class="token builtin">type</span>               HR  Temp     HR  Temp    HR  Tempyear visit_time<span class="token number">2013</span> <span class="token number">1</span>           <span class="token number">30.0</span>  <span class="token number">37.0</span>   <span class="token number">29.0</span>  <span class="token number">36.1</span>  <span class="token number">37.0</span>  <span class="token number">39.4</span>     <span class="token number">2</span>           <span class="token number">16.0</span>  <span class="token number">37.5</span>   <span class="token number">53.0</span>  <span class="token number">37.2</span>  <span class="token number">24.0</span>  <span class="token number">36.6</span><span class="token number">2014</span> <span class="token number">1</span>           <span class="token number">41.0</span>  <span class="token number">35.7</span>   <span class="token number">43.0</span>  <span class="token number">36.5</span>  <span class="token number">61.0</span>  <span class="token number">37.9</span>     <span class="token number">2</span>           <span class="token number">36.0</span>  <span class="token number">39.2</span>   <span class="token number">38.0</span>  <span class="token number">37.9</span>  <span class="token number">28.0</span>  <span class="token number">35.6</span>columns名字       多级columnsindex名字          内容多级index          内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多级索引取值、切片"><a href="#多级索引取值、切片" class="headerlink" title="多级索引取值、切片"></a>多级索引取值、切片</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#Series</span>In <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> oneOut<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span>year  visit_time<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">53.0</span>      <span class="token number">2</span>             <span class="token number">35.3</span><span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">34.0</span>      <span class="token number">2</span>             <span class="token number">36.9</span>dtype<span class="token punctuation">:</span> float64<span class="token comment">#可以通过指定所有级别的索引值来获取单个元素</span>In <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">53.0</span><span class="token comment">#也可以“局部取值”，取出来还是Series，不过貌似必须得从前到后</span>In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span>visit_time<span class="token number">1</span>    <span class="token number">53.0</span><span class="token number">2</span>    <span class="token number">35.3</span>dtype<span class="token punctuation">:</span> float64<span class="token comment">#切片类似</span>In <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">:</span><span class="token number">2014</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span>year  visit_time<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">53.0</span>      <span class="token number">2</span>             <span class="token number">35.3</span><span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">34.0</span>      <span class="token number">2</span>             <span class="token number">36.9</span>dtype<span class="token punctuation">:</span> float64<span class="token comment">#巧妙</span>In <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span>year<span class="token number">2013</span>    <span class="token number">35.3</span><span class="token number">2014</span>    <span class="token number">36.9</span>dtype<span class="token punctuation">:</span> float64<span class="token comment">#布尔和花哨的使用方法类似，并无太大变化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#DateFrame</span>单独取是列索引<span class="token punctuation">,</span>类似SeriesIn <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_dataOut<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span>name              Bob       Darren        Jack<span class="token builtin">type</span>               HR  Temp     HR  Temp    HR  Tempyear visit_time<span class="token number">2013</span> <span class="token number">1</span>           <span class="token number">53.0</span>  <span class="token number">35.3</span>   <span class="token number">34.0</span>  <span class="token number">36.9</span>  <span class="token number">37.0</span>  <span class="token number">37.0</span>     <span class="token number">2</span>           <span class="token number">20.0</span>  <span class="token number">35.8</span>   <span class="token number">47.0</span>  <span class="token number">37.2</span>  <span class="token number">42.0</span>  <span class="token number">37.0</span><span class="token number">2014</span> <span class="token number">1</span>           <span class="token number">36.0</span>  <span class="token number">36.3</span>   <span class="token number">44.0</span>  <span class="token number">37.7</span>  <span class="token number">35.0</span>  <span class="token number">37.4</span>     <span class="token number">2</span>           <span class="token number">28.0</span>  <span class="token number">37.4</span>   <span class="token number">32.0</span>  <span class="token number">33.7</span>  <span class="token number">40.0</span>  <span class="token number">38.0</span><span class="token comment">#对索引器来说，他们还是按照先行后列来操作，而且在loc和iloc中可以传递多个层级的索引元组，👇先取所有行，再对列进行层级索引，但在元组中使用切片会导致语法错误（不能确定范围），不是很方便</span>In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Temp'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span>year  visit_time<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">36.9</span>      <span class="token number">2</span>             <span class="token number">37.2</span><span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">37.7</span>      <span class="token number">2</span>             <span class="token number">33.7</span>Name<span class="token punctuation">:</span> <span class="token punctuation">(</span>Darren<span class="token punctuation">,</span> Temp<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64 <span class="token comment">#更好的方法时使用IndexSlice对象而不是python自带的slice函数，这样可以在内部使用切片</span>In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>idx<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span>name    <span class="token builtin">type</span>Darren  HR      <span class="token number">47.0</span>        Temp    <span class="token number">37.2</span>Name<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">2013</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64<span class="token comment">#ps：不要忘记使用loc，不然会报错而且错误贼长</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h3><p>局部切片和其他很多类似操作都要求<strong>MultiIndex的各级索引是有序</strong>的，否则大部分操作都会失败。</p><p>可以用data = data.sort_index() 或者<a href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index">data.sortlevel</a>()来搞定</p><p>sort_index有个参数ascending  True代表升序</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> popOut<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span>California  <span class="token number">2000</span>    <span class="token number">3234234</span>            <span class="token number">2010</span>     324322NewYork     <span class="token number">2000</span>    <span class="token number">6434634</span>            <span class="token number">2010</span>      52364Texas       <span class="token number">2000</span>      <span class="token number">67573</span>            <span class="token number">2010</span>      43525dtype<span class="token punctuation">:</span> int32    <span class="token comment">#level设置转换的层数In [22]: stack = pop.unstack(level = 0)In [23]: stackOut[23]:      California  NewYork  Texas2000     3234234  6434634  675732010      324322    52364  43525In [24]: stack2 = pop.unstack(level = 1)In [25]: stack2Out[25]:               2000    2010California  3234234  324322NewYork     6434634   52364Texas         67573   43525In [26]: stack2.stack()Out[26]:California  2000    3234234            2010     324322NewYork     2000    6434634            2010      52364Texas       2000      67573            2010      43525dtype: int32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在实践中处理数据集非常好用的方法：</p><p><strong>行列标签转换</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#reset_index可以生成一个DataFrame，之前的行索引将变成内容，行名变列名，可以指定name来设置原来内容的列名称</span>In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pop<span class="token punctuation">.</span>index<span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">,</span><span class="token string">'year'</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pop<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'population'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        state  year  population<span class="token number">0</span>  California  <span class="token number">2000</span>     <span class="token number">3234234</span><span class="token number">1</span>  California  <span class="token number">2010</span>      <span class="token number">324322</span><span class="token number">2</span>     NewYork  <span class="token number">2000</span>     <span class="token number">6434634</span><span class="token number">3</span>     NewYork  <span class="token number">2010</span>       <span class="token number">52364</span><span class="token number">4</span>       Texas  <span class="token number">2000</span>       <span class="token number">67573</span><span class="token number">5</span>       Texas  <span class="token number">2010</span>       <span class="token number">43525</span><span class="token comment">#反过来，也可以这样，将其中的几列变为行索引</span>In <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> pop<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'population'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>set_index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">,</span><span class="token string">'year'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                 populationstate      yearCalifornia <span class="token number">2000</span>     <span class="token number">3234234</span>           <span class="token number">2010</span>      <span class="token number">324322</span>NewYork    <span class="token number">2000</span>     <span class="token number">6434634</span>           <span class="token number">2010</span>       <span class="token number">52364</span>Texas      <span class="token number">2000</span>       <span class="token number">67573</span>           <span class="token number">2010</span>       <span class="token number">43525</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多级索引数据累计"><a href="#多级索引数据累计" class="headerlink" title="多级索引数据累计"></a>多级索引数据累计</h3><p>数据累计方法，如mean()、sum()、max()之类的，其实就是结合level参数，level取的是index的名字，表明保留该列、行，其他合并，通过axis表明沿行、列</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> pop<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>level <span class="token operator">=</span> <span class="token string">'state'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span> aOut<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span>stateCalifornia    <span class="token number">1779278</span>NewYork       <span class="token number">3243499</span>Texas           <span class="token number">55549</span>dtype<span class="token punctuation">:</span> int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h2><p>这是非常有趣的事情，既包括简单拼接，也包括处理重叠片段，pandas提供了高效的函数</p><p><strong>concat 和 append</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>AxisError                                 Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">77</span><span class="token operator">-</span>cdd90a57a401<span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>__array_function__ internals<span class="token operator">></span> <span class="token keyword">in</span> concatenate<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>AxisError<span class="token punctuation">:</span> axis <span class="token number">1</span> <span class="token keyword">is</span> out of bounds <span class="token keyword">for</span> array of dimension <span class="token number">1</span><span class="token comment">#对于一维数组的concatenate好像是个特例。</span><span class="token comment">#pd.concat与np.concatenate语法类似，参数更多，功能更强</span>DataFrame默认逐行合并<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>可以设置成axis <span class="token operator">=</span> <span class="token string">'col'</span><span class="token operator">/</span><span class="token number">1</span>差异：<span class="token number">1</span><span class="token punctuation">.</span> 索引重复，合并时保留哪怕是重复的索引   可以设置verify_integrity <span class="token operator">=</span> <span class="token boolean">True</span> 来引发异常   可以设置igonre_index <span class="token operator">=</span> <span class="token boolean">True</span> 会无视原有的索引，直接新建一个<span class="token number">0</span>，<span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">.</span>。。   可以设置keys <span class="token operator">=</span> <span class="token punctuation">[</span>xxxx<span class="token punctuation">]</span>，keys会作为数据源的索引，就是高一层的多级索引。<span class="token number">2</span><span class="token punctuation">.</span> 合并   join <span class="token operator">=</span> <span class="token string">'outer'</span>取并集（默认），会出现NAN<span class="token punctuation">,</span>   inner 取交集   join_axes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>xxx<span class="token punctuation">,</span>xx<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>直接确定结果使用的列名。append语法方便<span class="token punctuation">:</span>df1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>df2<span class="token punctuation">)</span>，和pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">)</span>效果一样但是不像原生的append可以直接更新原有对象，而是新建，所以效率不高，不如建立DF列表然后一次性concat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge(合并) and join(连接)</p><p>高性能的内存式数据连接是Pandas的卖点之一。</p><p><strong>关系代数</strong>是处理关系型数据的通用理论，绝大部分数据库的可用操作都以此为理论基础。</p><p>关系代数方法论的强大之处在于，它提出的若干简单操作规则经过组合就可以为任意数据集构建十分复杂的操作。Pandas 在 pd.merge() 函数与 Series 和 DataFrame 的 join() 方法里实现了这些基本操作规则。</p><h2 id="合并与链接"><a href="#合并与链接" class="headerlink" title="合并与链接"></a>合并与链接</h2><p>pd.merge() 函数实现了三种数据连接的类型：一对一、多对一和多对多。</p><p>一对一就是一对一呗。。merge至少要有一列是一样的</p><p>多对一连接是指，在需要连接的两个列中，有一列的值有重复。通过多对一连接获得的结果 DataFrame <strong>将会保留重复值</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910143623978.png" alt="image-20210910143623978"></p><p>在结果 DataFrame 中多了一个“supervisor”列，里面有些值会因为输入数据的对应关系而有所重复</p><p>多对多连接是个有点儿复杂的概念，不过也可以理解。如果左右两个输入的共同列都包含重复值，那么合并的结果就是一种多对多连接。来看下面的例子，里面有一个 DataFrame 显示不同岗位人员的一种或多种能力。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910143833746.png" alt="image-20210910143833746"></p><p>真实数据集往往没有那么干净、整洁，下面介绍merge的一些功能。</p><h3 id="数据合并参数"><a href="#数据合并参数" class="headerlink" title="数据合并参数"></a>数据合并参数</h3><p>on = ‘列名’  两边都有的</p><p>left_on =  ‘’   right_on =  ‘’  分别指定左右的<strong>共同列作为键进行合并</strong></p><p>获取的结果中会有一个多余的列，可以通过 DataFrame 的 drop() 方法将这列去掉：</p><p><code>pd.merge(df1, df3, left_on=&quot;employee&quot;, right_on=&quot;name&quot;).drop(&#39;name&#39;, axis=1)</code>（drop的1是列）</p><p>除了合并列，你也可以把索引作为键来合并</p><p>left_index 和 right_index = True</p><p>也可以混合使用，<code>print(pd.merge(df1a, df3, left_index=True, right_on=&#39;name&#39;))</code></p><p>当然，这些参数都适用于多个索引和 / 或多个列名，函数接口非常简单，<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">点我</a></p><p>当一个值出现在一列，却没有出现在另一列时，就需要考虑<strong>集合操作规则</strong>了。</p><p>默认outer  还有inner  left   right  表示行保留哪一边输入列的值</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910145946446.png" alt="image-20210910145946446"></p><p><strong>重复列名</strong></p><p>由于输出结果中有两个重复的列名(这一列<strong>没有作为合并的键</strong>，所以多了一列)，因此 pd.merge() 函数会自动为它们增加后缀 _x 或 _y </p><p>可以通过 suffixes 参数自定义后缀名：pd.merge(df8, df9, on=”name”, suffixes=[“_L”, “_R”])</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911194551123.png" alt="image-20210911194551123"></p><p><strong>3.8的例子</strong>太秀了，好好看看</p><p>pd.any()它会检查每一列，然后用 列名  True/False 的格式一行一行打印出来</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911194705665.png" alt="image-20210911194705665"></p><p>pd.unique() 返回独一无二的。。就是集合嘛</p><p>pd.read_csv(‘xxxx.csv’) 通过csv文件生成DataFrame</p><p>pd.head() 查看前五行，tail查看后五行</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910152230379.png" alt="image-20210910152230379"></p><p>有点巧妙，行索引筛选哪些行的数据，列索引筛选state，然后unique一下，然后处理👇</p><p>merged.loc[merged[‘state/region’] == ‘PR’, ‘state’] = ‘Puerto Rico’<br>merged.loc[merged[‘state/region’] == ‘USA’, ‘state’] = ‘United States’</p><p>最巧妙的是随心所欲的操控数据，通过布尔索引和选出某列的某部分当新索引，完成神奇的工作。</p><p>pandas 中 inplace 参数 在很多函数 中 都会有，inplace = True：<strong>不创建新的对象，直接对原始对象进行修改；</strong></p><h2 id="累计与分组"><a href="#累计与分组" class="headerlink" title="累计与分组"></a>累计与分组</h2><p>在对较大的数据进行分析时，一项基本的工作就是有效的数据累计（summarization）：计算累计（aggregation）指标，如 sum() 、 mean() 、 median() 、 min() 和 max() </p><p>有一个非常方便的 describe() 方法可以计算每一列的若干常用统计值。让我们在行星数据上试验一下，首先丢弃有缺失值的行：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154410670.png" alt="image-20210910154410670"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154441931.png" alt="image-20210910154441931"></p><p>但若想深入理解数据，仅仅依靠累计函数是远远不够的。数据累计的下一级别是 groupby操作，它可以让你  <u>快速、有效地计算数据各子集的累计值</u>。</p><h3 id="GroupBy：分割、应用和组合"><a href="#GroupBy：分割、应用和组合" class="headerlink" title="GroupBy：分割、应用和组合"></a>GroupBy：分割、应用和组合</h3><p>简单的累计方法可以让我们对数据集有一个笼统的认识，但是我们经常还需要对某些标签或索引的<strong>局部</strong>进行累计分析</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154840571.png" alt="image-20210910154840571" style="zoom: 33%;" /><p>• 分割步骤将 DataFrame 按照指定的键分割成若干组。<br>• 应用步骤对每个组应用函数，通常是累计、转换或过滤函数。<br>• 组合步骤将每一组的结果合并成一个输出数组。</p><p>虽然我们也可以通过前面介绍的一系列的掩码、累计与合并操作来实现，但是意识到<strong>中间分割过程不需要显式地暴露出来</strong>这一点十分重要。而且 GroupBy （经常）只需要一行代码，就可以计算每组的和、均值、计数、最小值以及其他累计值。 GroupBy 的用处就是<strong>将这些步骤进行抽象</strong>：<u>在底层解决所有难题</u>，用户不需要知道在底层如何计算，只要<strong>把操作看成一个整体就够了</strong>。</p><p>延迟计算：</p><p>groupby的返回值是一个 DataFrameGroupBy 对象。你可以将它看成是一种特殊形式的 DataFrame ，里面隐藏着若干组数据，但是在没有应用累计函数之前不会计算。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dfOut<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  key  data<span class="token number">0</span>   A     <span class="token number">0</span><span class="token number">1</span>   B     <span class="token number">1</span><span class="token number">2</span>   C     <span class="token number">2</span><span class="token number">3</span>   A     <span class="token number">3</span><span class="token number">4</span>   B     <span class="token number">4</span><span class="token number">5</span>   C     <span class="token number">5</span>In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>pandas<span class="token punctuation">.</span>core<span class="token punctuation">.</span>groupby<span class="token punctuation">.</span>generic<span class="token punctuation">.</span>DataFrameGroupBy <span class="token builtin">object</span> at <span class="token number">0x0000022CD3E6B088</span><span class="token operator">></span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     datakeyA       <span class="token number">3</span>B       <span class="token number">5</span>C       <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ol><li><p>支持按列取值，取出的对象叫SeriesGroupBy，也支持延迟计算</p></li><li><p>支持按组迭代，返回的每一组都是 Series 或 DataFrame </p><p>👇method取出的是索引，group取出的是DataFrame或Series</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910161139054.png" alt="image-20210910161139054"></p><ol start="3"><li>调用方法，让任何<strong>不由GroupBy对象直接实现的方法</strong>直接应用到每一组。👇这是因为Python类的魔力，继承。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     datakeyA       <span class="token number">3</span>B       <span class="token number">5</span>C       <span class="token number">7</span>In <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#这个方法本来是pd的，但是直接用在pdGrouoby上了</span>Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     data    count mean      std  <span class="token builtin">min</span>   <span class="token number">25</span><span class="token operator">%</span>  <span class="token number">50</span><span class="token operator">%</span>   <span class="token number">75</span><span class="token operator">%</span>  <span class="token builtin">max</span>keyA     <span class="token number">2.0</span>  <span class="token number">1.5</span>  <span class="token number">2.12132</span>  <span class="token number">0.0</span>  <span class="token number">0.75</span>  <span class="token number">1.5</span>  <span class="token number">2.25</span>  <span class="token number">3.0</span>B     <span class="token number">2.0</span>  <span class="token number">2.5</span>  <span class="token number">2.12132</span>  <span class="token number">1.0</span>  <span class="token number">1.75</span>  <span class="token number">2.5</span>  <span class="token number">3.25</span>  <span class="token number">4.0</span>C     <span class="token number">2.0</span>  <span class="token number">3.5</span>  <span class="token number">2.12132</span>  <span class="token number">2.0</span>  <span class="token number">2.75</span>  <span class="token number">3.5</span>  <span class="token number">4.25</span>  <span class="token number">5.0</span><span class="token comment">#unstack()是将列索引转换为行索引（成列的转换为成行的？）</span><span class="token comment">#但是注意，默认是准换到靠近数据的那一层。</span><span class="token comment">#而且如果没有行索引了，会自动颠倒，就像下面这个一样。</span>In <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unstack<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span>             keydata  count  A      <span class="token number">2.00000</span>             B      <span class="token number">2.00000</span>             C      <span class="token number">2.00000</span>      mean   A      <span class="token number">1.50000</span>             B      <span class="token number">2.50000</span>             C      <span class="token number">3.50000</span>      std    A      <span class="token number">2.12132</span>             B      <span class="token number">2.12132</span>             C      <span class="token number">2.12132</span>      <span class="token builtin">min</span>    A      <span class="token number">0.00000</span>             B      <span class="token number">1.00000</span>             C      <span class="token number">2.00000</span>      <span class="token number">25</span><span class="token operator">%</span>    A      <span class="token number">0.75000</span>             B      <span class="token number">1.75000</span>             C      <span class="token number">2.75000</span>      <span class="token number">50</span><span class="token operator">%</span>    A      <span class="token number">1.50000</span>             B      <span class="token number">2.50000</span>             C      <span class="token number">3.50000</span>      <span class="token number">75</span><span class="token operator">%</span>    A      <span class="token number">2.25000</span>             B      <span class="token number">3.25000</span>             C      <span class="token number">4.25000</span>      <span class="token builtin">max</span>    A      <span class="token number">3.00000</span>             B      <span class="token number">4.00000</span>             C      <span class="token number">5.00000</span>dtype<span class="token punctuation">:</span> float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p><strong>累计</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dfOut<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  key  data1  data2<span class="token number">0</span>   A      <span class="token number">0</span>      <span class="token number">3</span><span class="token number">1</span>   B      <span class="token number">1</span>      <span class="token number">9</span><span class="token number">2</span>   C      <span class="token number">2</span>      <span class="token number">8</span><span class="token number">3</span>   A      <span class="token number">3</span>      <span class="token number">8</span><span class="token number">4</span>   B      <span class="token number">4</span>      <span class="token number">5</span><span class="token number">5</span>   C      <span class="token number">5</span>      <span class="token number">4</span>In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'min'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>median<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    data1            data2      <span class="token builtin">min</span> median <span class="token builtin">max</span>   <span class="token builtin">min</span> median <span class="token builtin">max</span>keyA       <span class="token number">0</span>    <span class="token number">1.5</span>   <span class="token number">3</span>     <span class="token number">3</span>    <span class="token number">5.5</span>   <span class="token number">8</span>B       <span class="token number">1</span>    <span class="token number">2.5</span>   <span class="token number">4</span>     <span class="token number">5</span>    <span class="token number">7.0</span>   <span class="token number">9</span>C       <span class="token number">2</span>    <span class="token number">3.5</span>   <span class="token number">5</span>     <span class="token number">4</span>    <span class="token number">6.0</span>   <span class="token number">8</span><span class="token comment">#支持字符串、函数或函数列表</span><span class="token comment">#也可以通过python字典指定不同列需要的函数</span>In <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'data1'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'min'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>median<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">^</span>M    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token string">'data2'</span><span class="token punctuation">:</span> <span class="token string">'max'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    data1        data2      <span class="token builtin">min</span> median   <span class="token builtin">max</span>keyA       <span class="token number">0</span>    <span class="token number">1.5</span>     <span class="token number">8</span>B       <span class="token number">1</span>    <span class="token number">2.5</span>     <span class="token number">9</span>C       <span class="token number">2</span>    <span class="token number">3.5</span>     <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>过滤</strong></p><p>过滤操作可以让你按照分组的属性丢弃若干数据。例如，我们可能只需要保留标准差超过某个阈值的组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filter_func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token string">'data2'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span>df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>filter_func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>转换</strong></p><p>累计操作返回的是对组内全量数据缩减过的结果，而转换操作会返回一个新的全量数据。数据经过转换之后，其形状与原来的输入数据是一样的，而</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transform<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">-</span> x<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>   data1  data2<span class="token number">0</span>   <span class="token operator">-</span><span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.5</span><span class="token number">1</span>   <span class="token operator">-</span><span class="token number">1.5</span>    <span class="token number">2.0</span><span class="token number">2</span>   <span class="token operator">-</span><span class="token number">1.5</span>    <span class="token number">2.0</span><span class="token number">3</span>    <span class="token number">1.5</span>    <span class="token number">2.5</span><span class="token number">4</span>    <span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.0</span><span class="token number">5</span>    <span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.0</span><span class="token comment">#注意key那个标签没了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>apply（）方法</strong></p><p> apply() 方法让你可以在每个组上应用任意方法。这个<strong>函数输入一个DataFrame</strong> ，<u>返回一个 Pandas 对象（ DataFrame 或 Series ）或一个标量（scalar，单个数值）</u>。组合操作会适应返回结果类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911200326500.png" alt="image-20210911200326500"></p><h4 id="分组方法"><a href="#分组方法" class="headerlink" title="分组方法"></a>分组方法</h4><p>前面的简单例子一直在用列名分割 DataFrame 。这只是众多分组操作中的一种，下面将继续介绍更多的分组方法。</p><ol><li><p>将列表、数组、Series 或索引作为分组键（长度与 DataFrame 匹配）</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911200714468.png" alt="image-20210911200714468"></p><p>这个就是用索引</p></li><li><p>用字典或 Series 将索引映射到分组名称</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span>      data1  data2keyA        <span class="token number">0</span>      <span class="token number">5</span>B        <span class="token number">1</span>      <span class="token number">0</span>C        <span class="token number">2</span>      <span class="token number">3</span>A        <span class="token number">3</span>      <span class="token number">3</span>B        <span class="token number">4</span>      <span class="token number">7</span>C        <span class="token number">5</span>      <span class="token number">9</span>In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> mappingOut<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token string">'vowel'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token string">'consonant'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token string">'consonant'</span><span class="token punctuation">&#125;</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token comment">#索引指代被操作的对象的分组依据。</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A        vowelB    consonantC    consonantdtype<span class="token punctuation">:</span> <span class="token builtin">object</span>    <span class="token comment">#这里的映射后后面的哪个aggfunc不太一样</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            data1  data2consonant     <span class="token number">12</span>     <span class="token number">19</span>vowel          <span class="token number">3</span>      <span class="token number">8</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span>pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            data1  data2consonant     <span class="token number">12</span>     <span class="token number">19</span>vowel          <span class="token number">3</span>      <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>任意 Python 函数。你可以将任意 Python 函数传入 groupby ，函数映射到索引，然后新的分组输出</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911201638120.png" alt="image-20210911201638120"></p><p>我才发现，str list这些原来是顶层对象，也有一般实例的方法，比如list.append是存在的。</p></li><li><p>此外，任意之前有效的键都可以组合起来进行分组，从而返回一个<strong>多级索引</strong>的分组结果</p><p>而且好像是按列表順序組合多級索引的。</p><p>mapping = {‘A’: ‘vowel’, ‘B’: ‘consonant’, ‘C’: ‘consonant’}</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911202123221.png" alt="image-20210911202123221"></p><p>pd.astype(str) #强制转换数据类型。</p></li></ol><h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><p>我们已经介绍过 GroupBy 抽象类是如何探索数据集内部的关联性的了。</p><p>数据透视表（pivot table）是一种类似的操作方法，常见于 Excel 与类似的表格应用中。</p><p>数据透视表更像是一种多维的 GroupBy 累计操作。也就是说，虽然你也可以分割 - 应用 - 组合，但是分割与组合不是发生在一维索引上，而是在二维网格上（行列同时分组）。</p><p>import seaborn as sns<br>titanic = sns.load_dataset(‘titanic’)    #翻墙可以下到</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#关于显示的设定</span><span class="token comment"># 显示所有列</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">#最多显示5列</span><span class="token comment"># 显示所有行</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_rows'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_rows'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#最多显示10行</span><span class="token comment">#显示小数位数</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.float_format'</span><span class="token punctuation">,</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">'%.2f'</span><span class="token operator">%</span>x<span class="token punctuation">)</span> <span class="token comment">#两位</span><span class="token comment">#显示宽度</span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.width'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#这是以前的做法，不过注意，分组的时候是不是列表也会有影响。</span>titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> sexfemale    <span class="token number">0.742038</span>male      <span class="token number">0.188908</span>Name<span class="token punctuation">:</span> survived<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64        titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span>         survivedsex             female  <span class="token number">0.742038</span>male    <span class="token number">0.188908</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然这样就可以更清晰地观察乘客性别、船舱等级对其是否生还的影响，但是代码看上去有点 <strong>复杂</strong>。尽管这个管道命令的每一步都是前面介绍过的，但是要理解这个长长的语句可不是那么容易的事，这个适合就到数据透视表出场的时候了。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token string">'mean'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unstack<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#还是强调一点就是unstack他首先解压的是最后面的那一列，也就是这里的‘class’</span>Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">class</span>      <span class="token class-name">First</span>    Second     Thirdsex                                 female  <span class="token number">0.968085</span>  <span class="token number">0.921053</span>  <span class="token number">0.500000</span>male    <span class="token number">0.368852</span>  <span class="token number">0.157407</span>  <span class="token number">0.135447</span><span class="token comment">#对比一下</span>titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token string">'sex'</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token string">'class'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">class</span>      <span class="token class-name">First</span>    Second     Thirdsex                                 female  <span class="token number">0.968085</span>  <span class="token number">0.921053</span>  <span class="token number">0.500000</span>male    <span class="token number">0.368852</span>  <span class="token number">0.157407</span>  <span class="token number">0.135447</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这行代码可读性更强，而且取得的结果也一样。</p><p><strong>多级数据透视表</strong></p><p>这里面有一个cut函数，可以将数据分段并用相应的数据段来替代，不过左开右闭。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">age <span class="token operator">=</span> pd<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>titanic<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ageOut<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">1</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">2</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">3</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">4</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token number">886</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">887</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">888</span>             NaN<span class="token number">889</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span><span class="token number">890</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>Name<span class="token punctuation">:</span> age<span class="token punctuation">,</span> Length<span class="token punctuation">:</span> <span class="token number">891</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> categoryCategories <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> interval<span class="token punctuation">[</span>int64<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">]</span>                                             <span class="token comment">#然后就可以</span>titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">class</span>               <span class="token class-name">First</span>    Second     Thirdsex    age                                   female <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>   <span class="token number">0.909091</span>  <span class="token number">1.000000</span>  <span class="token number">0.511628</span>       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>  <span class="token number">0.972973</span>  <span class="token number">0.900000</span>  <span class="token number">0.423729</span>male   <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>   <span class="token number">0.800000</span>  <span class="token number">0.600000</span>  <span class="token number">0.215686</span>       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>  <span class="token number">0.375000</span>  <span class="token number">0.071429</span>  <span class="token number">0.133663</span><span class="token comment">#这里可以猜出来，第一个选的是数据，第二个是索引，第三个就是列。</span><span class="token comment">#但是这里自动求了个平均（后面讲）</span>        <span class="token comment">#这里又引出另一个分箱函数，按照分位数（默认等于2）来进行分箱</span>fare <span class="token operator">=</span> pd<span class="token punctuation">.</span>qcut<span class="token punctuation">(</span>titanic<span class="token punctuation">[</span><span class="token string">'fare'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>fareOut<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span><span class="token number">1</span>      <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token number">2</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span><span class="token number">3</span>      <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token number">4</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token number">886</span>     <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span><span class="token number">887</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token number">888</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token number">889</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token number">890</span>     <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>Name<span class="token punctuation">:</span> fare<span class="token punctuation">,</span> Length<span class="token punctuation">:</span> <span class="token number">891</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> categoryCategories <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> interval<span class="token punctuation">[</span>float64<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">#感觉这个函数比前面那个groupby清楚啊                                            </span>pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fare<span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">:</span> fare            <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>          <span class="token keyword">class</span>                      <span class="token class-name">First</span>    Second  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            Second     Thirdsex    age                                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                            female <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>               NaN  <span class="token number">1.000000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">1.000000</span>  <span class="token number">0.318182</span>       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>              NaN  <span class="token number">0.880000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.914286</span>  <span class="token number">0.391304</span>male   <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>               NaN  <span class="token number">0.000000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.818182</span>  <span class="token number">0.178571</span>       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>              <span class="token number">0.0</span>  <span class="token number">0.098039</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.030303</span>  <span class="token number">0.192308</span><span class="token punctuation">[</span><span class="token number">4</span> rows x <span class="token number">6</span> columns<span class="token punctuation">]</span><span class="token comment">#结果是一个四位索引。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他的一些选项</strong></p><p> <strong>fill_value 和 dropna</strong> 这两个参数用于处理缺失值，用法很简单，我们将在后面的示例中演示其用法。</p><p><strong>aggfunc</strong> 参数用于设置累计函数类型，默认值是均值（ mean ），可以用一些常见的字符串（ ‘sum’ 、 ‘mean’ 、 ‘count’ 、 ‘min’ 、 ‘max’ 等）表示，也可以用标准的累计函数（ np.sum() 、 min() 、 sum() 等）表示。</p><p>也可以用字典为不同的列指定不同的累计函数，函数列表。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911224133020.png" alt="image-20210911224133020"></p><p>这个函数和groupby的分组不太一样。但是思想类似。</p><p>不过上面的是以索引形式，这个是更高level的columns。</p><p>这里忽略了一个参数 values 。当我们为 aggfunc 指定映射关系的时候，待透视的数值就已经确定了。</p><p><strong>margins</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911224450628.png" alt="image-20210911224450628"></p><p> margin 的标签可以通过 margins_name 参数进行自定义，默认值是 “<strong>All</strong>“ 。</p><p>3.10.4 <strong>美国人口</strong></p><p>使用%matplotlib后，可以直接在生成的pivot_table后加.plot()来生成图表！！</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911235307984.png" alt="image-20210911235307984"></p><p>到时候回来再看看吧。。</p><h2 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h2><p>使用 Python 的一个优势就是<strong>字符串处理起来比较容易</strong>。在此基础上创建的 Pandas 同样提供了一系列 向量化字符串操作（vectorized string operation），它们都是在处理（清洗）现实工作中的数据时不可或缺的功能</p><p>假如数据中出现了缺失值，那么很多时候就会引起异常</p><p>Pandas 为包含字符串的 Series 和 Index 对象提供的 <strong>str 属性</strong> 堪称两全其美的方法，它既<br>可以满足向量化字符串操作的需求，又可以<strong>正确地处理缺失值</strong>。例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">namesOut<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>    peter<span class="token number">1</span>     Paul<span class="token number">2</span>     <span class="token boolean">None</span><span class="token number">3</span>     MARY<span class="token number">4</span>    gUIDOdtype<span class="token punctuation">:</span> <span class="token builtin">object</span>    names<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>    Peter<span class="token number">1</span>     Paul<span class="token number">2</span>     <span class="token boolean">None</span><span class="token number">3</span>     Mary<span class="token number">4</span>    Guidodtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span class="token comment">#None这个缺失值被跳过了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>包括了python，re模块，和自带的方法</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210912004551786.png" alt="image-20210912004551786"></p><p>但是有些方法返回数值，比如len</p><p>有些方法返回布尔值，比如startwith</p><p>还有些方法返回列表或其他复合值</p><p>在接下来的内容中，我们将进一步学习这类由列表元素构成的 Series <strong>（series-of-lists）</strong>对象。</p><p><strong>正则化方法</strong></p><p>更好的是，str同样支持一些<strong>正则化方法</strong>，采用re模块的语法，太方便了</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912102710571.png" alt="image-20210912102710571"></p><p>里面<strong>参数就填正则化式子（字符串）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912102822647.png" alt="image-20210912102822647"></p><p><strong>其他字符串方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912103033522.png" alt="image-20210912103033522"></p><p><strong>取值</strong>、<strong>切片</strong></p><p>slice取的是字符，比如df.str.slice(0,3)取的是前三个字符。等价于df.str[0:3]</p><p>df.str.get(i) 与 df.str[i] 的按索引取值效果类似</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">get<span class="token punctuation">(</span><span class="token punctuation">)</span> 与 <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 操作还可以在 split<span class="token punctuation">(</span><span class="token punctuation">)</span> 操作之后使用。例如，要获取每个姓名的姓（last name），可以结合使用 split<span class="token punctuation">(</span><span class="token punctuation">)</span> 与 get<span class="token punctuation">(</span><span class="token punctuation">)</span> ：monteOut<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>    Graham Chapman<span class="token number">1</span>       John Cleese<span class="token number">2</span>     Terry Gilliam<span class="token number">3</span>         Eric Idle<span class="token number">4</span>       Terry Jones<span class="token number">5</span>     Michael Palindtype<span class="token punctuation">:</span> <span class="token builtin">object</span>    monte<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span>    Chapman<span class="token number">1</span>     Cleese<span class="token number">2</span>    Gilliam<span class="token number">3</span>       Idle<span class="token number">4</span>      Jones<span class="token number">5</span>      Palindtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>指标变量</strong></p><p>另一个需要多花点儿时间解释的是 get_dummies() 方法。当你的数据有一列包含了若干已被编码的指标（coded indicator）时，这个方法就能派上用场了。(转换成独热码)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">假设有一个包含了某种编码信息的数据集，如 A<span class="token operator">=</span> 出生在美国、B<span class="token operator">=</span> 出生在英国、C<span class="token operator">=</span> 喜欢奶酪、D<span class="token operator">=</span> 喜欢午餐肉：full_monteOut<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span>              name   info<span class="token number">0</span>  Graham Chapman  B<span class="token operator">|</span>C<span class="token operator">|</span>D<span class="token number">1</span>     John Cleese    B<span class="token operator">|</span>D<span class="token number">2</span>   Terry Gilliam    A<span class="token operator">|</span>C<span class="token number">3</span>       Eric Idle    B<span class="token operator">|</span>D<span class="token number">4</span>     Terry Jones    B<span class="token operator">|</span>C<span class="token number">5</span>   Michael Palin  B<span class="token operator">|</span>C<span class="token operator">|</span>Dfull_monte<span class="token punctuation">[</span><span class="token string">'info'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>get_dummies<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span> <span class="token comment">#选择分隔符</span>Out<span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    A  B  C  D<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span><span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span><span class="token number">2</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span><span class="token number">3</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span><span class="token number">4</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">0</span><span class="token number">5</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.11.3<strong>案例</strong></p><p>recipe的每个元素的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912105340844.png" alt="image-20210912105340844"></p><p><code>recipes.ingredients.str.len().describe()</code>  看看菜单食材的名字长度</p><p><code> recipes.name[np.argmax(recipes.ingredients.str.len())]</code>看看这个拥有最长食材列表的究竟是哪道菜</p><p>``recipes.description.str.contains(‘[Bb]reakfast’).sum()` 看看哪些食谱是早餐。</p><p>#以后再看吧，太难了</p><h2 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h2><p> Pandas 最初是为金融模型而创建的，因此它拥有一些功能非常强大的日期、时间、带时间索引数据的处理工具</p><ul><li><p>时间戳表示某个具体的时间点（例如 2015 年 7 月 4 日上午 7 点）。</p></li><li><p>时间间隔与周期表示<strong>开始时间点与结束时间点之间的时间长度</strong>，例如 2015 年（指的是<br>2015 年 1 月 1 日至 2015 年 12 月 31 日这段时间间隔）。</p><p>周期通常是指一种特殊形式的时间间隔，<strong>每个间隔长度相同</strong>，彼此之间不会重叠（例如，以 24 小时为周期构成每一天）。</p></li><li><p>时间增量（time delta）或持续时间（duration）表示精确的时间长度（例如，某程序运行持续时间 22.56 秒）</p></li></ul><h3 id="python原生工具"><a href="#python原生工具" class="headerlink" title="python原生工具"></a>python原生工具</h3><p>在开始介绍 Pandas 的时间序列工具之前，我们先简单介绍一下 <strong>Python</strong> 处理日期与时间数据的工具。</p><p>尽管 Pandas 提供的时间序列工具更适合用来处理数据科学问题，但是了解 Pandas 与 Python 标准库以及第三方库中的其他时间序列工具之间的关联性将大有裨益。</p><ol><li><strong>datatime 和 dateutil</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetimedatetime<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2015</span><span class="token punctuation">,</span> month<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> day<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">51</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#可以利用dateutil对字符串格式的日期进行正确解析</span><span class="token keyword">from</span> dateutil <span class="token keyword">import</span> parserdate <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"4th of July, 2015"</span><span class="token punctuation">)</span>dateOut<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Python 的 datetime 文档（<a href="https://docs.python.org/3/library/datetime.html%EF%BC%89">https://docs.python.org/3/library/datetime.html）</a></p><p> dateutil 的其他日期功能可以通过在线文档（<a href="http://labix.org/python-dateutil%EF%BC%89%E5%AD%A6%E4%B9%A0">http://labix.org/python-dateutil）学习</a></p><p> pytz （<a href="http://pytz.sourceforge.net/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%A7%A3%E5%86%B3%E4%BA%86%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%9A%BE%E9%A2%98%EF%BC%9A**%E6%97%B6%E5%8C%BA">http://pytz.sourceforge.net/），这个工具解决了绝大多数时间序列数据都会遇到的难题：**时区</a>**</p><p>datetime 和 dateutil 模块在灵活性与易用性方面都表现出色，数量大时，速度就会比较慢。</p><ol start="2"><li><strong>基于NumPy的datetime64类型（Numerical Python）</strong></li></ol><p>datetime64 类型将日期编码为 <strong>64 位整数</strong>，这样可以让日期数组非常紧凑（节省内存）。<br>datetime64 需要<strong>在设置日期时确定具体的输入类型</strong>。</p><p>因为 NumPy 的 datetime64 数组内元素的类型是统一的，所以这种数组的运算速度会比Python 的 datetime 对象的运算速度快很多（向量化计算）</p><p>NumPy 的 datetime64 文档（<a href="http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html%EF%BC%89%E6%80%BB%E7%BB%93%E4%BA%86%E6%89%80%E6%9C%89%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E4%B8%8E%E7%BB%9D%E5%AF%B9%E6%97%B6%E9%97%B4%E8%B7%A8%E5%BA%A6%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%8D%95%E4%BD%8D%E6%A0%BC%E5%BC%8F%E4%BB%A3%E7%A0%81">http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html）总结了所有支持相对与绝对时间跨度的时间与日期单位格式代码</a></p><p>datetime64内的位数是固定的，追求的精度越高，能表示的<strong>精度越高，能表示的范围就越小</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912114638942.png" alt="image-20210912114638942"></p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912114650874.png" alt="image-20210912114650874"></p><p>一般工作中用的就是ns，因为用它来表示时间范围精度可以满足绝大部分需求。</p><p>虽然 datetime64 弥补了 Python 原生的 datetime 类型的不足，但它缺少了许多 datetime （尤其是 dateutil ）原本具备的便捷方法与函数</p><ol start="3"><li>Pandas的日期与时间工具：<strong>理想与现实的最佳解决方案</strong></li></ol><p>Pandas 所有关于日期与时间的处理方法全部都是通过 <strong>Timestamp 对象</strong>实现的。</p><p>它利用numpy.datetime64 的<strong>有效存储和向量化接口</strong>将 datetime 和 dateutil 的<strong>易用性</strong>有机结合起来。</p><p>Pandas 通过一组 Timestamp 对象就可以创建一个可以作为 Series 或 DataFrame 索引的DatetimeIndex，既有向量化的高效，又可以灵活的处理数据。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Pandas 时间序列工具非常适合用来处理带时间戳的索引数据，支持切片，取值等。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">index <span class="token operator">=</span> pd<span class="token punctuation">.</span>DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2014-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2014-08-04'</span><span class="token punctuation">,</span><span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-08-04'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span>index<span class="token punctuation">)</span>dataOut<span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">2014</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">0</span><span class="token number">2014</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">1</span><span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span><span class="token number">2015</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">3</span>dtype<span class="token punctuation">:</span> int64data<span class="token punctuation">[</span><span class="token string">'2014-07-04'</span><span class="token punctuation">:</span><span class="token string">'2015-07-04'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">2014</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">0</span><span class="token number">2014</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">1</span><span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span>dtype<span class="token punctuation">:</span> int64data<span class="token punctuation">[</span><span class="token string">'2015'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span><span class="token number">2015</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">3</span>dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间戳数据—— Timestamp 类型。本质上是Python 的原生 datetime 类型的替代品。对应的索引数据结构是 DatetimeIndex 。</li><li>时间周期数据—— Period 类型。将固定频率的时间间隔进行编码。对应的索引数据结构是 PeriodIndex 。</li><li>时间增量或持续时间—— Timedelta 类型代替 Python原生 datetime.timedelta 类型的高性能数据结构。对应的索引数据结构是 TimedeltaIndex 。</li></ul><p><strong>以上都基于np.datetime64类型</strong></p><p>最基础的日期 / 时间对象是 Timestamp 和 DatetimeIndex 。这两种对象可以直接使用</p><p> pd.to_datetime() 函数，它可以解析许多日期与时间格式,传递一个日期会返回一个Timestamp 类型，传递一个时间序列会返回一个 DatetimeIndex 类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetimedates <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_datetime<span class="token punctuation">(</span><span class="token punctuation">[</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'4th of July, 2015'</span><span class="token punctuation">,</span><span class="token string">'2015-Jul-6'</span><span class="token punctuation">,</span> <span class="token string">'07-07-2015'</span><span class="token punctuation">,</span> <span class="token string">'20150708'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#这个厉害</span>datesOut<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span> DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-08'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment"># 用带分秒的康康</span>dates <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_datetime<span class="token punctuation">(</span><span class="token punctuation">[</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'4th of July, 2015'</span><span class="token punctuation">,</span><span class="token string">'2015-Jul-6'</span><span class="token punctuation">,</span> <span class="token string">'07-07-2015'</span><span class="token punctuation">,</span> <span class="token string">'20150708'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>datesOut<span class="token punctuation">[</span><span class="token number">45</span><span class="token punctuation">]</span><span class="token punctuation">:</span> DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03 18:30:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04 00:00:00'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-06 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07 00:00:00'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-08 00:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>dates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">47</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Timestamp<span class="token punctuation">(</span><span class="token string">'2015-07-03 18:30:00'</span><span class="token punctuation">)</span><span class="token comment">#单个就是TimeStamp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> DatetimeIndex 类型都可以通过 to_period() 方法和一个频率代码转换成 PeriodIndex类型。下面用 ‘D’ 将数据转换成单日的时间序列</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dates<span class="token punctuation">.</span>to_period<span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">:</span> PeriodIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span>             <span class="token string">'2015-07-08'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            dtype<span class="token operator">=</span><span class="token string">'period[D]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment">#我的小时和秒都没了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当用一个日期减去另一个日期时，返回的结果是 TimedeltaIndex 类型：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dates <span class="token operator">-</span> dates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">49</span><span class="token punctuation">]</span><span class="token punctuation">:</span> TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:30:00'</span><span class="token punctuation">,</span> <span class="token string">'2 days 05:30:00'</span><span class="token punctuation">,</span>                <span class="token string">'3 days 05:30:00'</span><span class="token punctuation">,</span> <span class="token string">'4 days 05:30:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="间隔和频率"><a href="#间隔和频率" class="headerlink" title="间隔和频率"></a>间隔和频率</h3><p>为了能更简便地创建有规律的时间序列，Pandas 提供了一些方法： pd.date_range() 可以处理时间戳、 pd.period_range() 可以处理周期、 pd.timedelta_range() 可以处理时间间隔。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span> DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-05'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment">#左闭右闭，默认freq是‘D’</span>pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span> DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-05'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment">#第二种方法</span>pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">61</span><span class="token punctuation">]</span><span class="token punctuation">:</span> DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 01:00:00'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-03 02:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 03:00:00'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-03 04:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 05:00:00'</span><span class="token punctuation">,</span>               <span class="token string">'2015-07-03 06:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 07:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>pd<span class="token punctuation">.</span>period_range<span class="token punctuation">(</span><span class="token string">'2015-07'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">]</span><span class="token punctuation">:</span> PeriodIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-10'</span><span class="token punctuation">,</span> <span class="token string">'2015-11'</span><span class="token punctuation">,</span> <span class="token string">'2015-12'</span><span class="token punctuation">,</span>             <span class="token string">'2016-01'</span><span class="token punctuation">,</span> <span class="token string">'2016-02'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            dtype<span class="token operator">=</span><span class="token string">'period[M]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">)</span>pd<span class="token punctuation">.</span>timedelta_range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 01:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 02:00:00'</span><span class="token punctuation">,</span>                <span class="token string">'0 days 03:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 04:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:00:00'</span><span class="token punctuation">,</span>                <span class="token string">'0 days 06:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 07:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 08:00:00'</span><span class="token punctuation">,</span>                <span class="token string">'0 days 09:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>掌握 Pandas 频率代码是使用所有这些时间序列创建方法的必要条件。</p><p>Pandas 时间序列工具的基础是时间频率或偏移量（offset）代码。我们可以用这些代码设置任意需要的时间间隔。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912132206207.png" alt="image-20210912132206207"></p><p>发现有一些是period，有一些是时间戳</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912132256107.png" alt="image-20210912132256107"></p><p>在这些代码的基础上，还可以将频率组合起来创建的新的周期</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>timedelta_range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">"2H30T"</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 02:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:00:00'</span><span class="token punctuation">,</span>                <span class="token string">'0 days 07:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 10:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 12:30:00'</span><span class="token punctuation">,</span>                <span class="token string">'0 days 15:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 17:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 20:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'150T'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="重新取样、迁移和窗口"><a href="#重新取样、迁移和窗口" class="headerlink" title="重新取样、迁移和窗口"></a>重新取样、迁移和窗口</h4><p>用日期和时间直观地组织与获取数据是 Pandas 时间序列工具最重要的功能之一。</p><p>Pandas不仅支持普通索引功能（合并数据时自动索引对齐、直观的数据切片和取值方法等），还专为时间序列提供了额外的操作。</p><p>由于 Pandas 最初是为金融数据模型服务的，因此可以用它非常方便地获取金融数据。例如， pandas-datareader 程序包知道如何从一些可用的数据源导入金融数据，包含 Yahoo 财经、Google 财经和其他数据源。</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">更多资料</a></p><ol><li>重新取样与频率转换</li></ol><p>处理时间序列数据时，经常需要按照新的频率（更高频率、更低频率）对数据进行重新取样。</p><p>你可以通过 resample() 方法解决这个问题，或者用更简单的 asfreq() 方法。</p><p> resample() 方法是以数据累计（data aggregation）为基础，而asfreq() 方法是以数据选择（data selection）为基础。</p><p>（由于下载数据出了问题，只能截图）原始数据👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145112857.png" alt="image-20210912145112857"></p><p>对于收盘价进行可视化结果👇</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145127584.png" alt="image-20210912145127584"></p><p><strong>向后取样，和向前取样大体相同。</strong></p><p>goog.resample(‘BA’).mean().plot(style=’:’)</p><p>goog.asfreq(‘BA’).plot(style=’–’);</p><p>重选频率（BA是每个年末）以后，如图，但是注意取样方式的差异，上一条是平均值，下一条是最后一个工作日。</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145205838.png" alt="image-20210912145205838"></p><p>感觉没看懂，不管了，以后再查resample和asfreq吧，还要配合一些填充。</p><ol start="2"><li>时间迁移</li></ol><p>另一种常用的时间序列操作是对数据按时间进行迁移。Pandas 有两种解决这类问题的方法： shift() 和 tshift() 。简单来说， <strong>shift() 就是迁移数据，而 tshift() 就是迁移索引</strong>。两种方法都是按照频率代码进行迁移</p><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912151509737.png" alt="image-20210912151509737"></p><p> shift(900) 将数据向前推进了 900 天，这样图形中的一段就消失了（最左侧就变成了缺失值），而 tshift(900) 方法是将时间索引值向前推进了 900 天。</p><ol start="3"><li>移动时间窗口</li></ol><p>移动统计值（rolling statistics）。这些指标可以通过 Series 和 DataFrame 的 rolling() 属性来实现，它会返回与 groupby 操作类似的结果（详情请参见 3.9 节）。移动视图（rolling view）使得许多累计操作成为可能。</p><p><strong>3.12.7 案例：美国西雅图自行车统计数据的可视化。</strong></p><h2 id="高性能Pandas-eval-、query"><a href="#高性能Pandas-eval-、query" class="headerlink" title="高性能Pandas:eval()、query()"></a>高性能Pandas:eval()、query()</h2><p>Python 数据科学生态环境的强大力量建立在 NumPy 与 Pandas 的基础之上，并通过直观的语法将基本操作转换成 C 语言：在 NumPy 里是向量化 / 广播运算，在 Pandas 里是分组型的运算。虽然这些抽象功能可以简洁高效地解决许多问题，但是它们经常需要<strong>创建临时中间对象，这样就会占用大量的计算时间与内存。</strong></p><p>Pandas 从 0.13 版开始（2014 年 1 月）就引入了实验性工具，让用户可以直接运行 C 语言速度的操作，不需要十分费力地配置中间数组。它们就是 eval() 和 query() 函数，都依赖于 Numexpr (<a href="https://github.com/pydata/numexpr">https://github.com/pydata/numexpr</a>) 程序包。</p><h3 id="设计动机：复合代数式"><a href="#设计动机：复合代数式" class="headerlink" title="设计动机：复合代数式"></a>设计动机：复合代数式</h3><p>在进行复合代数式运算时，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>x <span class="token operator">=</span> rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y <span class="token operator">=</span> rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>mask <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment">#在进行这个运算的时候，由于Numpy会计算每一个代数子式，相当于</span>tmp1 <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span>tmp2 <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>mask <span class="token operator">=</span> tmp1 <span class="token operator">&amp;</span> tmp2<span class="token comment">#每段中间过程都需要显式地分配内存。Numexpr 程序库可以让你在不为中间过程分配全部内</span><span class="token comment">#存的前提下，完成元素到元素的复合代数式运算。</span><span class="token keyword">import</span> numexprmask_numexpr <span class="token operator">=</span> numexpr<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span><span class="token string">'(x > 0.5) &amp; (y &lt; 0.5)'</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask_numexpr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>马上要介绍的 Pandas 的 eval() 和 query()工具其实也是<strong>基于 Numexpr 实现</strong>的。</p><h3 id="eval实现高性能运算"><a href="#eval实现高性能运算" class="headerlink" title="eval实现高性能运算"></a>eval实现高性能运算</h3><p>就我自己试验的结果，还不如不优化。。可能是pandas已经内置了更厉害的吧。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdnrows<span class="token punctuation">,</span> ncols <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">100</span>rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>df1<span class="token punctuation">,</span> df2<span class="token punctuation">,</span> df3<span class="token punctuation">,</span> df4 <span class="token operator">=</span> <span class="token punctuation">(</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>timeit df1 <span class="token operator">+</span> df2 <span class="token operator">+</span> df3 <span class="token operator">+</span> df4<span class="token number">100</span> ms ± <span class="token number">15.4</span> ms per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">10</span> loops each<span class="token punctuation">)</span><span class="token operator">%</span>timeit pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df1 + df2 + df3 + df4'</span><span class="token punctuation">)</span><span class="token number">99.2</span> ms ± <span class="token number">2.41</span> ms per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">10</span> loops each<span class="token punctuation">)</span><span class="token comment">#而且内存消耗更少</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持的运算</strong>：</p><ol><li><p>算术运算符</p><p> pd.eval() 支持所有的算术运算符</p><p>np.allclose()这个是用来确认两者相等的。</p></li><li><p>比较运算符</p><p>支持所有的比较运算符，包括链式代数式</p></li><li><p> 位运算符</p></li></ol><p>   另外，你还可以在布尔类型的代数式中使用 and 和 or 等字面值</p><p>   <code>result3 = pd.eval(&#39;(df1 &lt; 0.5) and (df2 &lt; 0.5) or (df3 &lt; df4)&#39;)</code></p><ol start="4"><li> 对象属性与索引</li></ol><p>   可以通过 obj.attr 语法获取对象属性，通过 obj[index] 语法获取对象索引</p>   <pre class="line-numbers language-python" data-language="python"><code class="language-python">result1 <span class="token operator">=</span> df2<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> df3<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df2.T[0] + df3.iloc[1]'</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span>——<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p>目前 pd.eval() 还不支持函数调用、条件语句、循环以及更复杂的运算。如果你想要进行这些运算，可以借助 Numexpr 来实现。</p></li><li><p>用DataFrame.eval()实现列间计算。</p></li></ol><p>由于 pd.eval() 是 Pandas 的顶层函数，因此 DataFrame 有一个 eval() 方法可以做类似的运算。使用 eval() 方法的好处是可以借助列名称进行运算，示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">:</span>           A         B         C<span class="token number">0</span>  <span class="token number">0.375506</span>  <span class="token number">0.406939</span>  <span class="token number">0.069938</span><span class="token number">1</span>  <span class="token number">0.069087</span>  <span class="token number">0.235615</span>  <span class="token number">0.154374</span><span class="token number">2</span>  <span class="token number">0.677945</span>  <span class="token number">0.433839</span>  <span class="token number">0.652324</span><span class="token number">3</span>  <span class="token number">0.264038</span>  <span class="token number">0.808055</span>  <span class="token number">0.347197</span><span class="token number">4</span>  <span class="token number">0.589161</span>  <span class="token number">0.252418</span>  <span class="token number">0.557789</span>result1 <span class="token operator">=</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">+</span> df<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">"(df.A + df.B) / (df.C - 1)"</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>        <span class="token comment"># 不知道为啥还是负优化。。。还是这个inplace的用法有价值</span>df<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'D = (A + B) / C'</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">102</span><span class="token punctuation">]</span><span class="token punctuation">:</span>           A         B         C          D<span class="token number">0</span>  <span class="token number">0.375506</span>  <span class="token number">0.406939</span>  <span class="token number">0.069938</span>  <span class="token number">11.187620</span><span class="token number">1</span>  <span class="token number">0.069087</span>  <span class="token number">0.235615</span>  <span class="token number">0.154374</span>   <span class="token number">1.973796</span><span class="token number">2</span>  <span class="token number">0.677945</span>  <span class="token number">0.433839</span>  <span class="token number">0.652324</span>   <span class="token number">1.704344</span><span class="token number">3</span>  <span class="token number">0.264038</span>  <span class="token number">0.808055</span>  <span class="token number">0.347197</span>   <span class="token number">3.087857</span><span class="token number">4</span>  <span class="token number">0.589161</span>  <span class="token number">0.252418</span>  <span class="token number">0.557789</span>   <span class="token number">1.508776</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DataFrame-query-方法"><a href="#DataFrame-query-方法" class="headerlink" title="DataFrame.query() 方法"></a>DataFrame.query() 方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)]'</span><span class="token punctuation">)</span><span class="token comment">#相当于</span>result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; 0.5 and B &lt; 0.5'</span><span class="token punctuation">)</span><span class="token comment">#除了计算性能更优之外，这种方法的语法也比掩码代数式语法更好理解。</span><span class="token comment">#需要注意的是，query() 方法也支持用 @ 符号引用局部变量，eval不支持！</span>Cmean <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>result1 <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>A <span class="token operator">&lt;</span> Cmean<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">.</span>B <span class="token operator">&lt;</span> Cmean<span class="token punctuation">)</span><span class="token punctuation">]</span>result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; @Cmean and B &lt; @Cmean'</span><span class="token punctuation">)</span><span class="token comment">#什么叫反向优化啊草</span><span class="token operator">%</span>timeit result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)]'</span><span class="token punctuation">)</span><span class="token number">20.8</span> ms ± <span class="token number">943</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1</span> loop each<span class="token punctuation">)</span><span class="token operator">%</span>timeit  result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; 0.5 and B &lt; 0.5'</span><span class="token punctuation">)</span><span class="token number">1.37</span> ms ± <span class="token number">9.18</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1000</span> loops each<span class="token punctuation">)</span><span class="token operator">%</span>timeit  result2 <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>A <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">.</span>B <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token number">520</span> µs ± <span class="token number">3.46</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1000</span> loops each<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在考虑要不要用这两个函数时，需要思考两个方面：计算时间和内存消耗，而<strong>内存消耗是更重要的影响因素。</strong></p><p>如果临时 DataFrame 的内存需求比你的系统内存还大（通常是几吉字节），那么最好还是使用 eval() 和 query() 代数式。</p><p>可以用<code>df.value.nbytes</code>大概估算一下</p><p>在实际工作中，我发现普通的计算方法与 eval /  query 计算方法在计算时间上的差异并非总是那么明显，普通方法在处理较小的数组时反而速度更快！ eval /  query 方法的优点主要是节省内存，有时语法也更加简洁。</p><p>尤其需要注意的是，可以通过设置不同的解析器和引擎来执行这些查询，相关细节请 参 考 Pandas 文 档 中“Enhancing Performance”（<a href="http://pandas.pydata.org/pandas-docs/dev/enhancingperf.html%EF%BC%89%E8%8A%82%E3%80%82">http://pandas.pydata.org/pandas-docs/dev/enhancingperf.html）节。</a></p><p>剩下的东西放在notebook跑吧！！！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>但因篇幅有限，仍有许多知识无法介绍到</p><p>如果你想学习更多的 Pandas 知识，推荐参考下面的资源。</p><p>《利用 Python 进行数据分析》</p><p>PyVideo 上关于 Pandas 的教学视频（<a href="http://pyvideo.org/tag/pandas/%EF%BC%89">http://pyvideo.org/tag/pandas/）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言和环境&quot;&gt;&lt;a href=&quot;#前言和环境&quot; class=&quot;headerlink&quot; title=&quot;前言和环境&quot;&gt;&lt;/a&gt;前言和环境&lt;/h1&gt;&lt;p&gt;跨学科是数据科学的关键&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Darr</summary>
      
    
    
    
    <category term="data" scheme="https://darren-dong.com/categories/data/"/>
    
    
    <category term="data-sience" scheme="https://darren-dong.com/tags/data-sience/"/>
    
  </entry>
  
  <entry>
    <title>复变函数和积分应用</title>
    <link href="https://darren-dong.com/2021/05/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    <id>https://darren-dong.com/2021/05/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</id>
    <published>2021-05-12T04:38:47.000Z</published>
    <updated>2021-09-12T09:12:23.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言和资源"><a href="#前言和资源" class="headerlink" title="前言和资源"></a>前言和资源</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130415.png"  style="zoom: 67%;" /><p>推荐一个宝藏up主  “乐乐老师的网络课堂”，是个狼灭</p><p>华中科技大学的慕课</p><h1 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h1><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130633.png"  style="zoom: 33%;" /><p><strong>实数域是复数域的一个真子集，实数是有序数，复数不是，因此复数不可比较</strong></p><p>*四则运算</p><p>z*z共轭 = z模长的平方</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131813.png"  style="zoom:33%;" /><h3 id="极坐标形式"><a href="#极坐标形式" class="headerlink" title="极坐标形式"></a>极坐标形式</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131923.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132008.png"  style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132027.png"  style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132647.png"  style="zoom:33%;" /><p><strong>结合arctany/x的图会比较好理解，起到一个调整范围的作用。</strong></p><p>两个复数相等≠模和辐角分别相等，前不能推后，后可以推前，可能差了2npi，<strong>模和辐角主值相等则复数相等</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514143939.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144025.png"  style="zoom:33%;" /><h3 id="乘幂与方根"><a href="#乘幂与方根" class="headerlink" title="乘幂与方根"></a>乘幂与方根</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144329.png"></p><p>由乘法直接看出</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144805.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144826.png"  style="zoom: 50%;" /><p>方根</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145219.png"  style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145319.png"  style="zoom:33%;" /><p><strong>单位根：</strong></p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145634.png"  style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130456.png"  style="zoom: 25%;" /><p>给一个例子：</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145958.png"  style="zoom: 33%;" /><h3 id="复数域扩充"><a href="#复数域扩充" class="headerlink" title="复数域扩充"></a>复数域扩充</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150150.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150310.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150548.png"  style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150705.png"  style="zoom:33%;" /><p>复球面</p><p>由古老的测地投影法（绘制世界地图），衍生出复球面</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150941.png"  style="zoom: 33%;" /><p>这样全体复数都可以被球面的点表示，N点表示无穷远点，这称为黎曼球面</p><h3 id="平面点集补充"><a href="#平面点集补充" class="headerlink" title="平面点集补充"></a>平面点集补充</h3><p>复变函数的基础，邻域，去心邻域</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151404.png"  style="zoom: 33%;" /><p>内点，开集，闭集，边界点以及边界，孤立点（孤立一定是边界），有界集，无界集，连通集</p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151735.png"  style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514152143.png"  style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言和资源&quot;&gt;&lt;a href=&quot;#前言和资源&quot; class=&quot;headerlink&quot; title=&quot;前言和资源&quot;&gt;&lt;/a&gt;前言和资源&lt;/h1&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren</summary>
      
    
    
    
    <category term="Math" scheme="https://darren-dong.com/categories/Math/"/>
    
    
    <category term="复变" scheme="https://darren-dong.com/tags/%E5%A4%8D%E5%8F%98/"/>
    
  </entry>
  
</feed>
