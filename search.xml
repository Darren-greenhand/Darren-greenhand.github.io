<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DS-Source</title>
    <url>/2021/09/08/DS-Source/</url>
    <content><![CDATA[<h1 id="数据科学资源"><a href="#数据科学资源" class="headerlink" title="数据科学资源"></a>数据科学资源</h1><p>存放一些DS学习的资源</p>
<p>[toc]</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h3><ul>
<li><p>各类统计年鉴</p>
<p><a href="http://www.stats.gov.cn/tjsj./ndsj/">中国统计年鉴 </a>基本有中国历年各方面的所有数据</p>
</li>
<li><p>统计数据库</p>
<p><a href="https://www.un.org/zh/databases/#stats">联合国数据库</a></p>
</li>
<li><p>统计学领域论文或书籍中的数据集</p>
</li>
<li><p>政府网站</p>
<p><a href="https://data.stats.gov.cn/">中国数据集</a></p>
<p><a href="https://www.data.gov/">美国数据集</a></p>
<p><a href="https://data.gov.in/">印度数据集</a></p>
<p><a href="https://data.gov.uk/">英国数据集</a></p>
</li>
<li><p>其他</p>
<p>R包中的数据集，比如women、mtcars</p>
<p>开放数据搜索引擎，如<a href="https://marketplace.namara.io/">namara</a></p>
</li>
</ul>
<h3 id="企业提供"><a href="#企业提供" class="headerlink" title="企业提供"></a>企业提供</h3><p><a href="https://archive.ics.uci.edu/ml/index.php">加州大学欧文分校机器学习库</a></p>
<p><a href="https://www.cs.toronto.edu/~delve/data/datasets.html">Delve数据库</a></p>
<p><a href="https://registry.opendata.aws/">Amazon Web Services(AWS) datasets</a></p>
<p><a href="https://cloud.google.com/bigquery/public-data">Google Datasets</a> 里面也有商用的数据库</p>
<p><a href="http://research.google.com/youtube8m/">Youtube labeled</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210609194754.png" alt="image-20210609194747163"></p>
<hr>
<p><a href="https://data.nasa.gov/">NASA</a></p>
<p><a href="https://data.worldbank.org.cn/">世界银行</a> 免费并公开获取世界各国的发展数据.</p>
<h3 id="门户网站"><a href="#门户网站" class="headerlink" title="门户网站"></a>门户网站</h3><p><a href="https://dataportals.org/">列出了全世界许多开放数据库</a></p>
<p><a href="https://opendatamonitor.eu/frontend/web/index.php?r=dashboard/index">各国开放数据集集成</a></p>
<p><a href="https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research">机器学习数据库大集成！！</a></p>
<p><a href="https://www.reddit.com/r/datasets/">论坛提供的数据库</a></p>
<h3 id="竞赛平台"><a href="#竞赛平台" class="headerlink" title="竞赛平台"></a>竞赛平台</h3><p><a href="https://www.kaggle.com/datasets">Kaggle</a> 提供一个数据搜索引擎</p>
<p><a href="https://kdd.org/">KDD Cups</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://data.world/">Data world</a> 有很多公开数据集，很方便管理协作，提供许多数据管理工具的API</p>
<p><a href="https://marketplace.namara.io/">namara数据搜索引擎</a></p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><a href="https://www.tableau.com/products/desktop">Tableau</a></p>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul>
<li><p>数据科学语言</p>
<p>python、R、Scala、Clojure、Haskell</p>
</li>
<li><p>NoSQL工具</p>
<p>NoSQL、MongoDB、Couchbase、Cassandra</p>
</li>
<li><p>传统数据库/数据仓库</p>
<p>SQL、RDMS、DW、OLAP</p>
</li>
<li><p>大数据计算工具</p>
<p>HadoopHDFS&amp;MapReduce、Spark、Storm</p>
</li>
<li><p>大数据管理、存储、查询</p>
<p>HBase、Pig、Hive、Impala、Cascalog</p>
</li>
<li><p>数据采集、聚合、传递</p>
<p>Webscraper、Flume Avro、Sqoop、Hume</p>
</li>
<li><p>数据挖掘</p>
<p>Weka、KNIME、RapidMiner、SciPy、Pandas</p>
</li>
<li><p>数据统计分析</p>
<p>SAS、SPSS、Matlab</p>
</li>
</ul>
<h2 id="论坛、平台"><a href="#论坛、平台" class="headerlink" title="论坛、平台"></a>论坛、平台</h2><p><a href="https://www.kaggle.com/">Kaggle</a></p>
<p><a href="https://kdd.org/">KDD 数据挖掘、数据科学和分析社区</a></p>
<p><a href="https://www.drivendata.org/">Driven Data</a></p>
]]></content>
  </entry>
  <entry>
    <title>Javascript理论</title>
    <url>/2021/03/18/Javascript/</url>
    <content><![CDATA[<p>[toc]</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327151203222.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327151652147.png"  style="zoom:50%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327153158993.png"></p>
<p>第一门课主要学习JS语法，但是最好还是之后看一下JS红宝书</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327153407994.png"></p>
<h2 id="1-简史"><a href="#1-简史" class="headerlink" title="1.简史"></a>1.简史</h2><p>这是我去先看了看红宝书第一章</p>
<p>JS被用于处理表单内容，但让网景公司成为了老大，微软眼红并仿写出了JScript，这是一个基于JS的实现，但由于两者不统一，最后1997年Ecma（欧洲计算机制造商协会）的TC39委员会制定出标准，花费数月时间出台了传说中的ECMA-262,也就是ECMAScript伪语言，<strong>此后，各浏览器以此作为实现的依据，但是他们的实现仍有偏好性</strong></p>
<p>虽然JS和ECMAScript基本是同义词，但是完整的JS实现应包含：</p>
<ol>
<li>核心  ECMAScript</li>
<li>文档对象模型  DOM</li>
<li>浏览器对象模型  BOM</li>
</ol>
<p>ECMAScript连输入输出都没有，他只是一个基准</p>
<p><strong>Web浏览器是其实现的一种宿主环境（node.js也是一种），提供ECMAScript的基准实现和与环境自身交互必须的拓展！</strong></p>
<p>拓展，比如DOM，使用ECMAScript核心类型和语法，提供特定于环境的额外功能，</p>
<p>ESMAScript描述了这门语言的：<strong>语法，类型，语句，关键字，保留字，操作符，全局对象</strong></p>
<p>现在都到ES12了。。。。</p>
<p>ECMAScript的符合性具备极大的自由度，给了实现开发者很大的权限！</p>
<p><strong>好多东西没写，一定要到时候好好看看红宝书，太棒了！</strong></p>
<h2 id="2-Html中的JS"><a href="#2-Html中的JS" class="headerlink" title="2.Html中的JS"></a>2.Html中的JS</h2><p>看不懂。。等以后</p>
<h2 id="3-语言基础"><a href="#3-语言基础" class="headerlink" title="3.语言基础"></a>3.语言基础</h2><p>我还是结合着看吧，红宝书全，但是视频有实战经验。</p>
<h3 id="嵌入HTML"><a href="#嵌入HTML" class="headerlink" title="嵌入HTML"></a>嵌入HTML</h3><p>主要方法是&lt;script&gt;方法，后来被正式加入到HTML规范，他有8个属性，没几个看得懂</p>
<p>但是defer这个属性使得script不用放在body前（兼容性不好，而且有时候可能出现顺序错乱，最好是只有一个这样的脚本，<strong>更好还是放在body的最后。。。</strong>），src允许使用外部js文件，integrity防止你在引用其他网站js文件时接受到恶意内容，async有很多限制，不推荐使用。。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327163947742.png" alt="image-20210327163947742"></p>
<p>从上到下解释，浏览器解析行内脚本的方式决定了即使字符串出现&lt;/script&gt;也会结束！</p>
<p>浏览器按照script出现的顺序解释他们，除了defer和async属性。</p>
<p>引用外部时，script标签之间绝对不能写代码</p>
<p>还有一些比如“文档模式”啥的鬼东西，看不懂。。。</p>
<p>&lt;noscript&gt;元素用于优雅降级，先用于那些金庸JS的浏览器，在浏览器不支持脚本或者支持被关闭时，将会渲染在noscript标签中的内容，否则则会被忽视掉，</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>单行注释//   对应快捷键 ctrl + /</p>
<p>多行注释和c语言一样，是/* <em>/ ,对应快捷键*<em>ctrl+shift+/</em></em>  改了以后</p>
<p>左下角设置可以直接更改快捷方式</p>
<p><strong>Js标识符可使用 字母  数字   下划线   美元符号   但是开头不能是数字，惯例是驼峰大小写！</strong></p>
<p>严格模式</p>
<p>所有浏览器都支持严格模式，会在遇到不规范写法时抛出错误</p>
<p>在整个脚本或者某个具体函数开头加上 <code>“use strict”;</code> 来开启</p>
<p>分号不是必须，但是有助于防止很多问题，也有利于压缩代码，提升性能等</p>
<p>和C一样，也用{}标识一个代码块</p>
<p>if类语句和C一样在多条时，必须要代码块，但好习惯是一句也要加代码块</p>
<p>很多关键字都在各个语言见过，没见过的有</p>
<p>catch   delete   extends   finally   instanceof   super   throw </p>
<p>还有一些未来的保留字</p>
<p>enum  implements  interface  let  package  protected  await</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量松散，可以存储任何类型数据，ES6之后才可以用let  const ，var啥时都能用</p>
<p>基本使用无二，不知道为啥说不推荐改变变量存储的类型，但是完全有效</p>
<p>在函数内部var会创建局部变量，但是省略var可以创建一个全局变量！</p>
<p>但是这种做法不被推荐，甚至在严格模式下会抛出ReferenceError</p>
<p>*<strong>var声明提升！</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    语句<span class="token number">1</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
实际上被ECMAScript理解为
<span class="token keyword">var</span> age<span class="token punctuation">;</span>
语句<span class="token number">1</span><span class="token punctuation">;</span>
age <span class="token operator">=</span> <span class="token number">26</span>
这使得变量可以后声明，也使得变量可以重复声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>var的作用域是函数作用域，if块中声明的var可在外面调用</p>
<p>let声明的范围是块作用域，而且<strong>不允许冗余声明</strong>（<strong>SyntaxError</strong>）</p>
<p>但是由于JS引擎会记录变量声明的标识符和所在的块作用域，可以嵌套使用相同的标签</p>
<p><strong>冗余报错会发生在同时使用var和let时，两个关键字声明的变量是相同的，只是指出变量在相关作用域如何存在。</strong></p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
  <span class="token keyword">let</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，<strong>使用<code>let</code>命令声明变量之前，该变量都是不可用的</strong>。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<p>这甚至会导致typeof出错，</p>
<p><strong>与var关键字不同，let在全局作用域中声明的变量不会成为window对象的属性？不懂。。</strong></p>
<p>const声明时必须同时初始化，而且不能修改，限制只适用于它指向的变量的引用，跟python一样</p>
<p>对for-of  for-in循环中的不会修改的变量特别有意义</p>
<h4 id="风格和最佳实践！"><a href="#风格和最佳实践！" class="headerlink" title="风格和最佳实践！"></a>风格和最佳实践！</h4><ol>
<li>不使用var</li>
<li>const优先，let次之</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>对象的转换：<em><strong>如果操作数是对象，则这个对象将先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换；</strong></em></p>
<p>6种原始(简单)数据类型：Undefined Null Boolean Number String Symbol(ES6)</p>
<p>1种复杂数据类型：Object，这是一种无序名值对的集合</p>
<p>ES中不能定义自己的数据类型，但这些类型很灵活，一种能当多种数据类型用</p>
<p>typeof <strong>操作符，它不是函数</strong>，返回数据类型，也可以判断函数（返回’function’）</p>
<p>虽然函数也被ES认为是对象，但它们有特殊的属性，因此被typeof独立区分</p>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>只有一个值undefined, var/let声明对象但未初始化就会赋予undefined</p>
<p>他理论上永远不用与显式赋值，只是为了<em><strong>区别空对象指针null和未初始化指针</strong></em></p>
<p><strong>但由于未声明的变量typeof也会返回undefined，所以最好还是在声明时就初始化</strong></p>
<p>这是一个假值，但是也有很多其他的假值，所以不要依靠真假判断是否是undefined</p>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>只有一个值null，<strong>逻辑上讲，null值表示一个空对象指针，</strong>所以typeof null返回object</p>
<p>null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p>
<p>声明时如果暂时不用赋值，最好赋一个null</p>
<p>undefined是由null值派生的，所以表面相等(null == undifined)</p>
<p>这是一个假值，但是也有很多其他的假值，所以不要依靠真假判断是否是null</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>俩值，true  false，但是此处的布尔值不同于数值，所以不再是等于 1 和 0（哈哈，特意提醒）</p>
<p>所有类型的值都有相应布尔值的等价形式，通过Boolean（）转型函数转换</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>true值</th>
<th>false值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>非零值（<strong>包括无穷</strong>）</td>
<td>0  NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td></td>
<td>undefined</td>
</tr>
</tbody></table>
<p>非常重要，因为if等流控制语句会自动执行该转换</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>整数</p>
<p>八进制和十六进制规则和C一样，但是八进制如果写错了直接忽略0当成十进制，数学操作中都当成十进制</p>
<p><strong>严格模式不能使用八进制前缀0，要用0o</strong></p>
<p>由于JS保存数值的方式，会存在正零，负零，是等价的</p>
<p>浮点数</p>
<p>存储空间是整数两倍，所以JS会尽可能把它们变成整数，如果小数点后为0，<strong>直接给你改成整数</strong>(如21.0)</p>
<p>ES会将小数点后至少6个0的浮点数转换为科学计数法</p>
<p>浮点数精确度高达17位小数，但是也存在如C般很小的偏差问题，因此不要用 == 对待浮点数</p>
<p>这是IEEE 754数值标准导致的。。</p>
<p>最小值Number.MIN_VALUE  5e-324  再小 -Infinity（Number.NEGATIVE_INFINITY）</p>
<p>最大值Number.Max_VALUE 1.79………………e+308, 再大 Infinity（Number.POSITIVE_INFINITY）</p>
<p>0作分子返回NaN（not a number） 作分母返回正负Infinity</p>
<p>NaN有一些诡异的属性：</p>
<ol>
<li>任何涉及NaN的操作始终返回NaN(如NaN/10)</li>
<li>NaN不等于包括自己在内的任何值！</li>
</ol>
<p>数值转换：</p>
<p>Number()   parseInt()   parseFloat()</p>
<p>Number的转换规则和一元加操作符一样，值得注意的是：</p>
<p>null返回0，undefined返回null。空字符串返回0</p>
<p>字符串包含有效的16进制，会转化成对应的<strong>十进制值。</strong></p>
<p>如果字符串包含正常情况外的词，返回NaN。</p>
<p>对于对象：先调用valueof（）方法，再按照正常规则转换，如果结果是NaN，则先调用toString，再按字符串规则转换。</p>
<p>所以必须用于十分标准的字符串才能得到合适输出，所以一般优先采用下面俩方法</p>
<p>parseInt规则：</p>
<p>跳过空白，开始检索，第一个不是数值，加减号，返回NaN,否则开始检索至结束或非法。</p>
<p>未加第二个参数则检索0x开头，0开头，最好加上，可以省略前缀</p>
<p>parseInt(“10100101”, 2),表示按<strong>二进制解析！</strong></p>
<p>parseFloat类似，但忽略开头的0，只用于十进制，若结果为整数，会返回整数</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>可用单，双，没有语法意义。。。pink推荐使用单引号</p>
<p>转义字符（字符字面量）（算一个字符）基本无二，\xnn ASCII   \unnnn  nnnn表示Unicode字符</p>
<p>字符串是不可变的！任何更改都导致原字符串销毁</p>
<p>toString方法可用于数值，布尔值，对象，字符串值（返回副本），</p>
<p><strong>null/undefined没有,调用则返回本身的字符串null-&gt;”null”</strong></p>
<p>在对待数值时可以指定显示的进制 </p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">-</span><span class="token string">"1010"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>模板字面量</strong></p>
<p>通过<strong>反引号定义（但是这里书写用单引号。。不然变成代码块我靠）</strong>，保留内部的空白结构</p>
<p>技术上讲，模板字面量不是字符串而是一种特殊的JS句法表达式，只不过求之后得到的是字符串</p>
<p><strong>字符串插值</strong></p>
<p>模板字面量求值时立刻转换成字符串实例，任何插入的变量也会从它们最接近的作用域中提取</p>
<p>‘${}’来进行调用，可以变量，会将表达式用toString转化成字符串，可以调用函数和方法，可以插入自己以前的值</p>
<p>value = ‘${value}abc’  附加abc</p>
<p><strong>标签函数</strong></p>
<p>用来自定义插值行为，直接把定义的函数放在模板字面量前即可</p>
<p>function xxx(){}</p>
<p>let a = xxx’….’</p>
<p>注意传进去的第一个参量是[“”,”+”,]这种，其中所有的$被换成空字符串，符号保留，经常采用“剩余操作符”收集不确定的参数</p>
<p>原始字符串则调用了默认的String.raw标签函数,也可通过string(某字符串变量).raw来取得原始内容</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ES6新增，符号是原始值，符号实例唯一，不可变</p>
<p>用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
<p>符号需要使用Symbol（）函数初始化，</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>JS对象实质是一组数据和功能的集合，通过new+对象类型的名称来创建</p>
<p>可以通过创建Object实例来创建对象，再添加属性和方法</p>
<p>每个对象内置了一大堆方法，<strong>p56</strong></p>
<p>valueof方法将对象转换为原始值。你很少需要自己调用<code>valueOf</code>方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。如果对象没有原始值，则<code>valueOf</code>将返回对象本身。JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。此外你也可以自己写valueof来覆盖</p>
<table>
<thead>
<tr>
<th align="left"><strong>对象</strong></th>
<th align="left"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回数组对象本身。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符串值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Math 和 Error 对象没有 valueOf 方法。</td>
</tr>
</tbody></table>
<p>你可以在自己的代码中使用<code>valueOf</code>将内置对象转换为原始值。 创建自定义对象时，可以覆盖<code>Object.prototype.valueOf()</code>来调用自定义方法，而不是默认<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>方法。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">MyNumberType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">valueOf</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> customPrimitiveValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>ES中的操作符可用于各种类型的值，在处理对象时会调用valueOf和toString来处理（C++重构吗）</p>
<p>因为数据类型有限，不会出现重构等问题，因此符号的所有规则都可以列出来！</p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>++  – 和C差不多，可用于任意值，应用后均变为数值类型</p>
<p>字符串非法则NaN,false和true变成0和1，对象先调用valueof（）方法，再按照正常规则转换，如果结果是NaN，则先调用toString，再按字符串规则转换。</p>
<p>+ and  - 会对非数值进行Number（）转换，</p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>虽然实际64位，但位操作时仅应用32位，第32位<strong>0正1负</strong>，无符号数就大一倍。</p>
<p>正值前31位正常，负值则是补码。（这里称二补数）</p>
<p><strong>但特殊值NaN和Infinity在位操作中被当成0</strong></p>
<p>C有的这里都有！右移使用符号位来填补空位，无符号右移<code>&gt;&gt;&gt;</code>则用0来填补！</p>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><p>非操作符 ！ 无论对什么数据类型，先转换成布尔值，然后取反</p>
<p>！！ 相当于调用Boolean（）</p>
<p>&amp;&amp;逻辑与可以用于任何类型的操作数，不限于布尔，同样具有短路特性，如果操作数不全为布尔，则逻辑与并不一定返回布尔值：</p>
<ul>
<li>如果第一个操作数是对象，返回第二个操作数</li>
<li>如果两个操作数都是对象，返回第二个操作数</li>
<li>如果第二个操作数为对象，只有第一个操作数为true时才会返回该对象</li>
<li>只要出现null/NaN,undefined,就返回相应的</li>
</ul>
<p>||逻辑或，也会短路，如果操作数不全为布尔，则同样：</p>
<ul>
<li>如果第一个操作数是对象，返回第一个操作数</li>
<li>如果第一个操作数求值为false，则返回第二个操作数</li>
<li>如果第两个操作数是对象，返回第一个操作数</li>
<li>如果俩都为null/NaN,undefined,就返回相应的</li>
</ul>
<h4 id="乘性运算符"><a href="#乘性运算符" class="headerlink" title="乘性运算符"></a>乘性运算符</h4><p>*  也会在处理非数值自动调用Number（）</p>
<p>特性：</p>
<ul>
<li>任意操作数NaN返回NaN</li>
<li>Infinity * 0  -&gt;NaN</li>
<li>Infinity相乘，或乘有限数，返回+-Infinity</li>
</ul>
<p>/   特性:</p>
<ul>
<li>有NaN,返回NaN</li>
<li>无限除无限返回NaN</li>
<li>无限除有限（包括0）返回对应无穷</li>
<li>0 / 0 返回NaN</li>
<li>有限值 / 0 返回正负无穷</li>
</ul>
<p>% ：</p>
<ul>
<li>无限除任何 NaN</li>
<li>有限除 0 NaN</li>
<li>有限除无限  有限</li>
<li>0除 非0  0</li>
</ul>
<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><p>**  和  **==</p>
<h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><p>+   注意：</p>
<ul>
<li>有NaN 返回NaN</li>
<li>无穷+负无穷  返回NaN</li>
<li>0相加，都是-0返回-0，否则返回+0</li>
<li>俩字符串则拼接</li>
<li>不然就转换成字符串，如果有undefined和null，变为”undefined”然后再拼接</li>
</ul>
<p>-  注意：</p>
<ul>
<li>同类无穷相减（其实就是难以判断正负的时候）为NaN</li>
<li>无穷相减，可判断正负则返回对应无穷</li>
<li>0相减，同号得正0，异号得-0</li>
<li>会转化成数值而不是字符串，对象也是和以前一样的处理</li>
</ul>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>还是四个，只返回布尔值</p>
<ul>
<li>出现数值，全转为数值比较</li>
<li>都是字符串则逐个比较（大写字母比小写字母顺序小）</li>
<li>对象先调用valueof（）方法，再按照正常规则转换，如果没有valueof操作符，则调用toString，再按字符串规则转换。</li>
<li>布尔被转化为0和1</li>
<li><strong>只要出现NaN，结果就为false</strong></li>
<li>null和undefined好像也是</li>
</ul>
<p>1、大于运算符</p>
<p>　　　　大于运算符的操作数可能是任意类型，然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换。规则如下：</p>
<p>　　　　如果操作数是对象，则这个对象将先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换；</p>
<p>　　　　 在对象转换为原始值之后，如果两个操作数都是字符串，则按照字母表的顺序对两个字符串进行比较，这里提到的字母表顺序是指组成这个字符串的16位unicode字符的索引顺序；</p>
<p>　　　　 在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换成数字进行比较。</p>
<p>　　　　需要注意的是Javascript字符串是一个由16位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值比较，由unicode定义的字符编码和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。字符串比较是区分大小写的，所以一般首先会将字符串通过String.toLowerCase()或者是String.toUpperCase()做大小写的转换。</p>
<p>　　　　2、大于等于运算符</p>
<p>　　　　大于等于运算符并不依赖于大于或等于运算符的比较规则，而是遵循小于运算符的比较规则，结果取反</p>
<p>　　　　3、小于等于运算符</p>
<p>　　　　小于等于运算符(&lt;=)并不依赖于小于或等于运算符的比较规则，而是遵循大于运算符的比较规则，结果取反。</p>
<p>　　　　4、小于运算符</p>
<p>　　　　小于运算符(&lt;)用于比较两个操作数，如果第一个操作数小于第二个操作数，则小于运算符的计算结果为true，否则为false。</p>
<hr>
<p>所以要考虑到底是不满足条件，还是出现了NaN</p>
<p>大写字母的排序在小写字母前面，所以偏小</p>
<p>按照规则，null和undifined</p>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><p>两组，等于和不等于 == ，  全等和不全等 ===</p>
<p>第一组进行强转再判断：</p>
<ul>
<li>布尔-&gt;数值</li>
<li>字符串比数值，字符串-&gt;数值</li>
<li>对象，用valueof对象再比较</li>
<li>null ==  undefined</li>
<li>null   undefined不能转化为其他类型的值再比较，因此不等于false，因为false-&gt;0</li>
<li>有NaN就返回false，不相等返回true</li>
</ul>
<p>全等不转换！null !== undefined  因为数据类型不同</p>
<p>条件运算符 () ?  :</p>
<p>赋值运算符 &gt;&gt;&gt;=</p>
<p>逗号运算符</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>也称流控制语句</p>
<p>if中自动调用Boolean，也有do-while，while，swtich(break规则一样的)</p>
<p><strong>for - in</strong>是一种严格的迭代语句，用于枚举对象中的<strong>非符号键属性</strong>（如window对象的属性）</p>
<p>for(const property in expression) {statement;}</p>
<p>这里的const不是必须的，但是为了确保局部变量不被修改，推荐使用const</p>
<p>ES中的对象属性是无序的，for-in不能保证返回的顺序，甚至因浏览器而异</p>
<p>如果迭代的变量是null / undefiend 则不执行循环体</p>
<p><strong>for-of</strong> 是一种严格的迭代语句，用于遍历<strong>可迭代对象的元素</strong>(如数组项)</p>
<p>for(const property of expression) {statement;}若尝试迭代的变量不支持迭代则抛出错误</p>
<p><strong>标签语句</strong></p>
<p>在语句前可以通过标签语句加标签，常用于嵌套循环中</p>
<p>break和continue + 标签可以生效后跳到label位置</p>
<p><strong>with语句</strong>将代码作用域设置为特定的变量</p>
<p>严格模式下不允许使用with</p>
<p>with(location){………}</p>
<p>在with语句内部，每个变量首先被认为是局部变量，如果不是，就搜索location对象，看他是否有一个同名属性，使得话，该变量就被求值为location对象的同名属性</p>
<p>swtich特性：</p>
<p>可以用于所有数据类型，case后面不加括号，可以加表达式！</p>
<p>甚至可以swtich(true)然后case里面放一堆判别式，<em><strong>不过case判断是全等！</strong></em></p>
<p>与多if相比，switch效率高，适合情况较多且比较确定，多if适合范围判断，情况较少</p>
<p>函数</p>
<h2 id="4-变量，作用域-内存"><a href="#4-变量，作用域-内存" class="headerlink" title="4.变量，作用域/内存"></a>4.变量，作用域/内存</h2><p>变量可存储两种类型的数据：原始值，引用值（由多个值构成的对象）</p>
<p>分别采用按值访问和按引用访问,<strong>很多语言中字符串是使用对象访问的,因此被认为是引用类型,但是ES不是</strong></p>
<p>引用值可以随意添加,修改和删除属性和方法</p>
<p>原始值不能有属性,但是添加时不会报错,但试图引用会返回undefined.</p>
<p>复制的时候,原始值是复制,引用值是引用原来内存里的变量,而不是创建副本</p>
<p><strong>但是所有函数的参数都是按值传递的</strong>,只不过引用值传进去的时候传的是一个指向（类似指针），所以在里面修改外面也能体现，但仍然是按值传递。</p>
<p>typeof能区分是否是对象,但是它却不能区分对象的具体类型，对引用值意义不大</p>
<p>instanceof对给定引用类型的对象十分有用,比如 person instanceof Object  变量person是Object吗?</p>
<p>所以该操作符检测任何引用值和Object构造函数都会返回true,但是检测原始值则始终返回false</p>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>变量或者函数的上下文决定了可以访问的数据和行为.全局，函数，块级</p>
<p><strong>每个上下文都有一个关联的变量对象</strong>，虽然代码无法访问，但是后台处理数据可能用到</p>
<p>全局上下文是最外层的，根据实现的宿主，可能对象不一样，在<strong>浏览器中全局上下文是window对象</strong></p>
<p><strong>所有通过var方法定义的全局变量和函数都会成为对象的属性和方法</strong></p>
<p>上下文在其所有代码执行完成后会销毁，包括所有定义在它上面的变量和函数，全局上下文则在应用程序退出前才会销毁，比如关闭网页或者退出浏览器，函数参数被视为当前上下文的变量</p>
<p>上下文的代码在执行的时候，会创建变量对象的一个作用域链，从当前上下文往外直到全局上下文</p>
<p>自己理解下吧。。。</p>
<p><a href="https://knightyun.github.io/2019/09/02/js-hoisting#:~:text=%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%20%E6%98%AF%20JavaScript,%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A4%A7%E8%87%B4%E5%B0%B1%E6%98%AF%E5%AD%97%E9%9D%A2%E6%84%8F%E6%80%9D%EF%BC%8C%E5%B0%86%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%89%8D%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%8C%87%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E6%94%B9%E5%8F%98%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E8%80%8C%E6%98%AF%E5%B0%86%E5%8F%98%E9%87%8F%20%E6%8F%90%E5%89%8D%20%E6%94%BE%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E4%BE%9B%E5%90%8E%E7%BB%AD%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%8B%E9%9D%A2%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%9B">变量提升</a></p>
<p>个人理解，声明被提升到最前面，而赋值仍留在原地</p>
<p><strong>作用域增强？</strong></p>
<p>通常有两种情况：</p>
<ul>
<li>with(location)的location对象会被添加到作用域链的前端。</li>
<li>try/catch 回创建一个新的变量对象，该对象包含即将抛出的错误的声明。</li>
</ul>
<p><strong>执行上下文的生命周期</strong></p>
<p>执行上下文的生命周期包括三个阶段：<strong>创建阶段 → 执行阶段 → 回收阶段</strong>，本文重点介绍创建阶段。</p>
<ol>
<li>创建阶段</li>
</ol>
<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>
<ul>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。下文会详细说明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>
<li>确定 this 指向：包括多种情况，下文会详细说明</li>
</ul>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p>
<ol start="2">
<li>执行阶段</li>
</ol>
<p>执行变量赋值、代码执行</p>
<ol start="3">
<li>回收阶段</li>
</ol>
<p>执行上下文出栈等待虚拟机回收执行上下文</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>和之前一样，赋值为const的对象变量不能被重新赋值为引用值，但对象的键却不受限制</p>
<p>要想对象不能修改，可以 const variable = Object.freeze({})</p>
<p>这样会“静默失败”，即不提示出错，但是调用则返回undefined</p>
<p>应该尽可能使用const，除非确实需要一个将来会重新赋值的变量，以从根本上保证提前发现重新赋值导致的bug，由const声明的实例可被JS运行编译器替换成实际的值，而不会通过查询表进行变量查找，谷歌V8就是这种优化</p>
<p><strong>标识符查找</strong></p>
<p>使用块级作用域不会改变搜索流程，但会添加额外的层次</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>垃圾回收有可能明显拖慢渲染的速度和帧速度</p>
<p>JS使用垃圾回收，即执行环境负责在代码执行时管理内存</p>
<p>周期性执行垃圾回收程序以处理不再使用的变量并释放其内存（<strong>近似且不完美</strong>）</p>
<p>历史上两种主要的标记策略：</p>
<ol>
<li><p>标记清理（常用）</p>
<p>运行时首先标记内存中存储的所有变量，然后将所有上下文中的变量以及被上下文的变量引用的变量的标记清理掉，在此之后再被加上标记或存在标记就会被清理，标记的实现并不重要，关键是打标记的策略</p>
</li>
<li><p>引用标记</p>
<p>记录每个值被引用的次数，当次数为0时清除，但可能导致循环引用，神之间接导致DOM,BOM由JS实现</p>
</li>
</ol>
<p>这对性能影响很大，如今IE7以后更新了回收的策略，极大提升了浏览器中JS性能</p>
<p>某些浏览器可以（不推荐）主动触发垃圾回收</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>由于系统给浏览器分配内存远少于桌面应用（移动浏览器更少）所以有必要限制内存</p>
<p>这会影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量</p>
<p>最佳策略是只保存必要的数据再运行期间，如果数据不在必要，把它设置为null，解除引用，在垃圾回收时清理</p>
<p>局部变量在离开上下文时会自动解除引用，<strong>全局变量和对象要手动解除，设为null</strong></p>
<ol>
<li><p>尽量使用let和const</p>
</li>
<li><p>利用隐藏类</p>
<p>V8在将代码编译为实际的机器码时会利用“隐藏类”，共享隐藏类效果会更好</p>
<p><strong>最好的方法是在构造函数中一次性声明所有属性，把不再需要的属性设置为null</strong></p>
<p><strong>避免先创建再单独给实例创建或删除属性</strong></p>
</li>
<li><p>内存泄漏</p>
<p>可能有函数内部全局变量，定时器调用，闭包。。</p>
</li>
<li><p>静态分配和对象池（优化的极端形式，不太常见）</p>
<p>压榨浏览器，一个关键问题是如何减少浏览器回收垃圾的次数，可以间接触发回收条件。浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度，如果有很多对象一下被初始化，马上又超出作用域，那么就会被浏览器用更激进的方式回收。</p>
<p><strong>如果函数会初始化变量，而马上又失去引用，则会被“盯上”，一个方案是函数调用已存在的对象，给他赋值</strong></p>
<p>那在哪里新建第一个已存在的对象才不会被盯上呢？一个策略是对象池：</p>
<p>在初始化的某一刻创建一个对象池，用来管理一组可回收的对象，其他代码可以向这里请求对象，更改或使用，然后返还它。这样垃圾回收检测就不会发现有对象更替，也就不会那么频繁地运行。</p>
</li>
</ol>
<h2 id="5-基本引用类型"><a href="#5-基本引用类型" class="headerlink" title="5.基本引用类型"></a>5.基本引用类型</h2><p>JS没有类，虽然是面向对象，但缺少某些基本结构比如类和接口，<strong>引用类型是把数据和功能组织到一起的结构</strong>，也被称<strong>对象定义</strong>，它们描述了自己的对象应有的属性和方法。</p>
<p>引用值（或对象）是某个特定引用类型的实例，新对象通过new操作符后+一个构造函数来创建。</p>
<p><em>构造函数是用来创建新对象的函数，负责创建一个只有默认属性和方法的简单对象</em></p>
<p>函数也是一种引用，但是内容好多，放在第十章</p>
<h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="2-3文档模式"><a href="#2-3文档模式" class="headerlink" title="2.3文档模式"></a>2.3文档模式</h3><h3 id="3-32-条件-amp-for声明"><a href="#3-32-条件-amp-for声明" class="headerlink" title="3.32 条件&amp;for声明"></a>3.32 条件&amp;for声明</h3><h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>crawler</title>
    <url>/2021/04/10/crawler/</url>
    <content><![CDATA[<h1 id="网络爬虫实战3"><a href="#网络爬虫实战3" class="headerlink" title="网络爬虫实战3"></a>网络爬虫实战3</h1><p>对大数据的获取，处理和分析，以及基于大数据的智能应用，已成为提高竞争力的关键因素</p>
<p>我们需要的数据大多源于各个网站，但是不同网站结构不一，布局复杂，渲染方式多样</p>
<p>有的网站还采取了一系列“反爬”，我们也需要针对的反制措施！</p>
<p>爬虫是服务机器学习和人工智能发展非常重要的技术！为其提供优质的数据</p>
<p>崔佬提供了多种安装python库的方式：</p>
<ul>
<li>pip/conda</li>
<li>wheel</li>
<li>去官网/github下载源码再安装</li>
</ul>
<p>爬虫可以简单分为：爬取页面，分析页面，存储数据</p>
<p><strong>请求库：</strong></p>
<ol>
<li><p>requests:  爬取html</p>
</li>
<li><p>Selenium  自动化测试，驱动浏览器执行某些（点击，下拉）操作，渗透JS渲染</p>
<p>但还要配置浏览器，此处用最好的ChromeDriver，先更新chrome</p>
<p>下载后直接放进环境的Scripts里面，或者单独设置环境变量</p>
</li>
<li><p>PhantomJS 无界面，可脚本编程的webkit浏览器引擎，被selenium弃用了，推荐chrome无界面模式</p>
</li>
<li><p>aiohttp  提供异步web服务，顺便安装cchardet aiodns</p>
</li>
</ol>
<p>下面装解析库，虽然提取信息方式多样，但写起来麻烦，不如强大的库，库还提供解析</p>
<p><strong>解析库：</strong></p>
<ol>
<li><p>lxml 解析HTML /XML  支持XPath解析方式，且效率非常高</p>
</li>
<li><p>beautiful soup 解析HTML /XML，可以很方便的提取数据，有强大的API和多样的解析方式</p>
</li>
<li><p>pyquery  提供了和jQuery类似的语法来解析HTML文档，还支持CSS选择器</p>
</li>
<li><p>tesserocr  通过OCR对抗验证码，是对<a href="https://github.com/UB-Mannheim/tesseract/wiki">tesseract</a>的再封装，先装后者</p>
<p>ps:(Optical Character Recognition 光学字符识别)扫描字符并转换成电子文本</p>
<p>一直失败。。。选择了替代的pytesseract</p>
</li>
</ol>
<p><strong>数据库</strong></p>
<p>关系型如SQLite  ,<strong>MySQL</strong>  ,Oracle   ,SQL Server  ,DB2     按表存储</p>
<p>非关系型如 <strong>MongoDB   Redis</strong>    键值对，更灵活</p>
<ol>
<li>MySQL  官网</li>
<li>mongodb懒得装了</li>
<li>redis还是装一下，还有可视化管理工具redis desktop manager</li>
</ol>
<p><strong>存储库</strong></p>
<p>用来和python交互，MySQL需要PyMySQL,  MongoDB需要PyMongo</p>
<p>我只下了PyMySQL</p>
<p><strong>web库</strong></p>
<p>搭建一些API接口供爬虫使用，比如维护一个代理池</p>
<ol>
<li>flask   轻量级web服务程序</li>
<li>tornado   支持异步的web框架</li>
</ol>
<p><strong>APP爬取库</strong></p>
<p>先不装了。。。</p>
<p>又是一堆。。。。还跟Android有关</p>
<p><strong>爬虫框架</strong></p>
<p>我们直接用requests , selenium等库写爬虫，当小型时很好，但写多了就有些麻烦和凌乱</p>
<p>上框架！这样我们只用关心爬取逻辑，而不是具体功能的实现！</p>
<ol>
<li><strong>pyspider  失败。。。</strong></li>
<li>Scrapy要配合splash和其python库  成功。。</li>
<li>scrapy-redius  成功。。</li>
</ol>
<p><strong>部署库</strong></p>
<ol>
<li><p>Docker  成功</p>
<p>容器技术，打包应用和环境，极大方便了应用服务的部署，</p>
</li>
<li><p>Scrapyd  部署和运行Scrapy的工具，针对linux，那没事了</p>
</li>
</ol>
<p>cao</p>
<p>没装的有：</p>
<p>tessorocr 图形识别码,有替代</p>
<p>mongodb 和配套的，。。希望别用这破玩意</p>
<p>app 爬取库  。。我吐了</p>
<p>scrapyd 部署工具。。应该用不着吧</p>
<p>pyspider bug  。。还早</p>
<h1 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a>github项目</h1><p><a href="https://github.com/wistbean/learn_python3_spider">https://github.com/wistbean/learn_python3_spider</a></p>
<h1 id="MOOC课程"><a href="#MOOC课程" class="headerlink" title="MOOC课程"></a>MOOC课程</h1><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210916004253383.png" alt="image-20210916004253383" style="zoom: 67%;" />

]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(basic)</title>
    <url>/2021/03/13/Linux/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>一个操作系统是一种软件，在计算设备上运行和管理硬件和软件组件，使一个功能性计算系统。</p>
<p>现代操作系统不仅管理硬件和软件资源，还计划将程序以多任务方式运行（共享处理器，以便显然可以同时发生多个任务），提供允许用户和程序请求发生某些事情的标准服务。 （例如打印作业），并在正确请求的情况下，操作系统将接受该请求并执行所需的功能。</p>
<p>桌面和服务器操作系统本质上比在诸如防火墙或移动电话之类的专用设备上运行的操作系统更为复杂。从提供电缆菜单菜单界面的简单机顶盒到超级计算机和大规模并行计算集群，通用术语“操作系统”用于描述在该设备上启动和运行的任何软件。</p>
<p>如今，计算机用户主要在以下三种主要操作系统之间进行选择：<strong>Microsoft Windows</strong>，<strong>Apple macOS</strong>和<strong>Linux</strong>。</p>
<p>在列出的三个主要操作系统中，只有Microsoft Windows在其基础代码中是唯一的。苹果的macOS是基于BSD Unix（直到1995年才发行的操作系统）的完全合格的UNIX发行版，并辅以大量的专有代码。它在经过专门优化以与Apple软件配合使用的硬件上运行。Linux可以是数百种针对任何任务而设计或优化的分发软件包中的任何一种。仅Microsoft Windows基于不基于UNIX或Linux的专有代码库。</p>
<p>用户可以通过日常工作任务指向并单击自己的方式来轻松地与任何这些系统进行交互，而无论底层操作系统如何，这些任务的行为都相似。除了主要通过GUI管理的Windows外，大多数系统管理任务都是使用终端中的键入命令来执行的。熟悉UNIX的管理员通常可以在Linux系统上执行任务，反之亦然。许多Linux命令行功能还具有Microsoft等效项，管理员可以使用这些等效项来有效地完成工作。</p>
<p>决定你需要什么操作系统前，需要考虑很多因素：</p>
<p>角色，功能，生命周期</p>
<p>稳定性，兼容性，成本，界面</p>
<p><strong>Microsoft</strong>根据计算机的角色提供不同的操作系统：台式机还是服务器？Windows的桌面版本经历了各种命名方案，当前版本（在撰写本文时）仅为<strong>Windows 10</strong>。此操作系统的新版本每3-5年发布一次，并且往往会得到很多年的支持。向后兼容性是Microsoft的首要任务，甚至可以捆绑虚拟机技术，使用户可以运行较早的软件。</p>
<p><strong>Windows Server</strong>当前（截至撰写本文时）的版本为<strong>2019，</strong>以指示发布日期。该服务器可以运行GUI，但是最近，Microsoft（主要是对Linux的竞争）在通过PowerShell的命令行脚本功能方面取得了不可思议的进步。还有一个可选的Desktop Experience软件包，它模仿了标准的生产率计算机。微软还积极鼓励企业客户整合其Azure云服务。</p>
<p><strong>苹果公司</strong>生产的<strong>macOS</strong>操作系统部分基于FreeBSD项目中的软件，并且已经过UNIX认证。macOS以“易于使用”而著称，因此继续受到访问学校和小型企业等IT资源有限的用户的青睐。由于其强大的UNIX基础，它在程序员中也非常受欢迎。</p>
<p>在服务器方面，<strong>macOS Server</strong>主要针对较小的组织。macOS桌面的这种低成本添加使用户可以进行协作，而管理员可以控制对共享资源的访问。它还提供与iPhone和iPad等iOS设备的集成。</p>
<p>一些大型公司的IT部门允许用户选择macOS，因为与标准的Microsoft生产力部署相比，用户所需的支持通常更少。macOS的持续流行确保了软件供应商的健康支持。macOS在图形和视频制作等创意产业中也很受欢迎。对于许多这样的用户，应用程序的选择决定了操作系统的决定。与操作系统紧密集成的Apple硬件及其在应用程序编程中坚持遵守标准的能力，为这些富有创造力的专业人士提供了一个稳定的平台，可以执行许多具有计算能力的功能，而对兼容性的顾虑则很少。</p>
<p>Linux用户通常通过<strong>下载发行版</strong>来获得操作系统。Linux发行版是一包软件，通常包含Linux内核，实用程序，管理工具，甚至包括一些应用程序软件，它们都包含在软件包中，该软件包还包括更新核心软件和安装其他应用程序的方法。</p>
<p><strong>该发行版负责设置存储，构建内核和安装硬件驱动程序，以及安装应用程序和实用程序以构成功能齐全的计算机系统。创建发行版的组织还包括用于管理系统的工具，用于添加和删除软件的程序包管理器以及用于提供安全性和功能补丁的更新程序。</strong></p>
<p>Linux发行版的可用数量达数百种，因此一开始的选择似乎令人生畏。但是，决策点与选择操作系统时突出显示的决策点基本相同。</p>
<p><strong>强烈建议自己看一下LINUX第二章背景知识<a href="https://lms-cn.netacad.com/course/view.php?id=12987">戳我</a></strong></p>
<h2 id="各种发行版"><a href="#各种发行版" class="headerlink" title="各种发行版"></a>各种发行版</h2><h3 id="Red-Hat"><a href="#Red-Hat" class="headerlink" title="Red Hat"></a><strong>Red Hat</strong></h3><p> Over time, Red Hat started to focus more on the server applications, such as web- and file-serving and released <strong>Red Hat Enterprise Linux (RHEL)</strong>, which was a paid service on a long release cycle.</p>
<p><strong>Scientific Linux</strong> </p>
<p>is an example of a specific-use distribution based on Red Hat，The project is a Fermilab-sponsored distribution designed to enable scientific computing.</p>
<p><strong>Centos</strong></p>
<p>Because everything in Red Hat Enterprise Linux is open source, a project called <strong>CentOS</strong> came to be， It recompiled all the RHEL packages，and gave them away for free.</p>
<h3 id="SUSE"><a href="#SUSE" class="headerlink" title="SUSE"></a><strong>SUSE</strong></h3><p>originally derived from <strong>Slackware</strong>, </p>
<p>While SUSE Linux Enterprise contains proprietary code and is sold as a server product, <strong>openSUSE</strong> is a completely open, free version with multiple desktop packages similar to CentOS and Linux Min</p>
<h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a><strong>Debian</strong></h3><p>is more of a community effort, and as such, also promotes the use of open source software and adherence to standards，Debian came up with its own package management system based on the <code>.deb</code> file format. While Red Hat leaves non-Intel and AMD platform support to derivative projects, Debian supports many of these platforms directly. respect！！</p>
<p><strong>Ubuntu</strong> </p>
<p>is the most popular Debian-derived distribution. It is the creation of <strong>Canonical</strong>，They also offer an LTS version that is kept up-to-date for 3 years on desktops and 5 years on servers, which gives developers and the companies they work for confidence to build solutions based on a stable distribution.</p>
<p><strong>‌⁠⁠Linux Mint</strong> </p>
<p>was started as a fork of Ubuntu Linux, while still relying upon the Ubuntu repositories. There are various versions, all free of cost, but some include proprietary codecs, which cannot be distributed without license restrictions in certain countries.</p>
<p><em>Linux is a kernel, and many of the commands covered in this course are actually part of the GNU package. That is why some people insist on using the term <strong>GNU/Linux</strong> instead of Linux alone. Linux仅仅是一个内核，他的功能都是由开源项目GNU实现的，他们（开源）被我们和Linux系统视为一体，我们要对这些开源的先驱充满敬意！</em></p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p><strong>Android</strong>, sponsored by Google, is the world’s most popular Linux distribution. It is fundamentally different from its counterparts. Android uses the <strong>Dalvik</strong> virtual machine with Linux, providing a robust platform for mobile devices such as phones and tablets. However, lacking the traditional packages that are often distributed with Linux (such as GNU and Xorg), Android is generally incompatible with desktop Linux distributions.</p>
<p>use <strong>BusyBox</strong> with Android to enable most commands to work.</p>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p><strong>Raspbian</strong> is a specialized Linux distribution optimized to run on <strong>Raspberry Pi</strong> hardware， Its low cost and ease of use have made it a favorite of educators worldwide, and many add-on devices are available to extend its capabilities into the physical world.</p>
<p><strong>Linux From Scratch (LFS)</strong> is more of a learning tool than a working distribution。This project consists of an online book, and source code, with “step-by-step instructions” for building a custom Linux distribution from the source code up. This “distribution” embodies the true spirit of Linux whereby users can modify any aspect of the operating system and learn how all the pieces work together. It’s also a good starting point for anyone who needs specialized functionality or an ultra-compact build for an embedded system project.</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210316171316621.png"></p>
<h2 id="Linux嵌入无处不在！"><a href="#Linux嵌入无处不在！" class="headerlink" title="Linux嵌入无处不在！"></a>Linux嵌入无处不在！</h2><p>Linux最初只能在Linus Torvald的计算机上运行：具有特定硬盘驱动器控制器的Intel 386 PC，但是由于任何人都可以添加或更改Linux，人们开始构建对其他硬件的支持。最终，Linux开始支持其他注重小尺寸和低功耗的芯片。</p>
<p>由于这种灵活性，许多设备制造商已将Linux用作其硬件产品的操作系统。今天，我们将这些嵌入式系统称为“嵌入式系统”，是因为它们被设计为仅针对此目的在经过优化的硬件上执行特定任务。这些系统涵盖了当今使用的各种设备，从手机到智能电视和家电，再到用于管道和工厂的远程监控系统。</p>
<p>随着Linux的发展，专门为消费类和工业设备开发了专用处理器芯片，以利用其功能。对Linux的支持已经变得无处不在，因此可以使用现成的组件来进行原型设计并将新设备推向市场。像Raspberry Pi这样的廉价，小型，适应性强的单板计算机的兴起，为实验人员和企业家提供了各种工具，可以快速构建基于Linux的自定义解决方案，而几年前，专门团队需要花费数月的时间。</p>
<p>尽管消费者熟悉嵌入式Linux娱乐设备，如数字录像机（DVR）和“智能电视”，但嵌入式Linux的真正影响才刚刚开始意识到。在物联网（IOT）只是斜了便宜，部署在一切从油井到太阳能发电场无处不在的设备。这些智能传感器和控制器网络使工程师能够实时调整关键过程，同时监视并报告给中央控制站。随着越来越多的流程被监视以及更多的数据与机器学习和人工智能（AI）集成，我们可以预期效率，安全性和生产率的提高仅是前几代人梦dream以求的。</p>
<h1 id="使用Linux工作"><a href="#使用Linux工作" class="headerlink" title="使用Linux工作"></a>使用Linux工作</h1><h2 id="主要应用"><a href="#主要应用" class="headerlink" title="主要应用"></a>主要应用</h2><p>Linux内核可以在许多硬件平台上运行各种软件。计算机可以充当服务器，这意味着它主要代表他人处理数据，也可以充当台式机，这意味着用户直接与计算机进行交互。该计算机可以运行软件，也可以在创建软件的过程中用作开发计算机。一台机器甚至可以扮演多个角色，<strong>因为Linux没有区别。这仅是配置运行哪些应用程序的问题。</strong></p>
<p>由此带来的一个优势是，Linux可以模拟生产环境的几乎所有方面，从开发到测试，再到按比例缩小的硬件进行验证，从而节省了成本和时间。Linux管理员可以在台式机或大型互联网服务提供商运行的廉价虚拟服务器上运行相同的服务器应用程序。当然，台式机将无法处理与主要提供商相同的卷，但是几乎可以模拟任何配置，而无需强大的硬件或服务器许可。</p>
<p>Linux软件通常分为以下三类之一：</p>
<ul>
<li><p>服务器应用</p>
<p>与运行机器的显示器和键盘没有直接交互作用的软件。其目的是将信息提供给称为客户端的其他计算机。有时服务器应用程序可能不与其他计算机通信，而只能坐在那里处理数据。</p>
</li>
<li><p>桌面应用</p>
<p>用户直接与之交互的Web浏览器，文本编辑器，音乐播放器或其他应用程序。在许多情况下，例如Web浏览器，应用程序正在与另一端的服务器通信并解释数据。这是客户端/服务器应用程序的“客户端”端。</p>
</li>
<li><p>工具</p>
<p>存在的松散类别的软件，可以更轻松地管理计算机系统。工具可以帮助配置显示，提供用户输入命令的Linux shell或什至是更复杂的工具（称为编译器），这些工具可以将源代码转换为计算机可以执行的应用程序。</p>
</li>
</ul>
<p>封闭源代码和开放源代码软件世界之间存在几个显着差异，一个是将其他项目作为项目或程序包的组件包含在内。在封闭源代码世界中，<strong>Microsoft Exchange</strong>主要作为包含以下内容的软件包/套件提供：所有必需的或已批准的组件，均来自Microsoft，因此几乎没有（如果有的话）进行单独选择的选项。在开源世界中，很多选项都可以模块化地包含在组件中或换成组件组件，实际上，某些软件包或套件只是一组包装良好的组件，否则各个组件都可以和谐地协同工作。</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>Linux由于其可靠性和效率而擅长于运行服务器应用程序。利用仅需的组件来优化服务器操作系统的能力使管理员可以用更少的钱做更多的事情，这是初创企业和大型企业都喜欢的功能。</p>
<p><strong>Web服务器</strong></p>
<p><strong>Apache</strong>是当今使用的主要<strong>Web服务器</strong>。Apache最初是一个独立的项目，但此后成立了<strong>Apache Software Foundation，</strong>并维护了一百多个开源软件项目。<strong>Apache HTTPD</strong>是守护程序或服务器应用程序，用于“服务”网页请求。</p>
<p>另一个Web服务器是<strong>NGINX</strong>，它位于俄罗斯之外。它通过使用更现代的UNIX内核来专注于性能，并且仅提供Apache可以执行的工作的一部分。超过65％的网站由NGINX或Apache提供支持。</p>
<p><strong>私有云服务器软件</strong></p>
<p>随着个人，组织和公司开始将其数据移动到云中，对可以在内部部署和管理的<strong>私有云服务器软件</strong>的需求日益增长。</p>
<p>该<strong>ownCloud</strong>项目于2010年推出由弗兰克·卡利切从私有云服务器提供软件来存储，同步和共享数据。它有标准的开源GNU AGPLv3许可证和带有商业许可证的企业版。</p>
<p>该<strong>Nextcloud</strong>项目从ownCloud在2016年由Karlitschek分叉，从那时起一直稳步增长。它是在GNU AGPLv3下提供的，旨在“开放，透明的开发过程”。</p>
<p>这两个项目都致力于提供满足大型和小型组织需求的私有云软件，这些组织需要安全性，隐私和法规遵从性。尽管其他几个项目旨在为相同的用户提供服务，但就部署和项目成员而言，这两个是迄今为止最大的项目。</p>
<p><strong>数据库服务器</strong></p>
<p>MariaDB是<strong>MySQL</strong>关系数据库管理系统的社区开发分支。它只是用于Web开发的许多数据库服务器之一，因为不同的要求决定了执行所需任务的最佳应用程序。</p>
<p>数据库存储信息，并且还允许轻松检索和查询。其他一些流行的数据库是<strong>Firebird</strong>和<strong>PostgreSQL</strong>。您可以将原始销售数据输入数据库，然后使用称为<strong>结构化查询语言（SQL）的语言</strong>按产品和日期汇总销售以生成报告。</p>
<p><strong>电子邮件服务器</strong></p>
<p><strong>Dovecot</strong>由于其易用性和低维护性而成为流行的POP / IMAP服务器。<strong>赛勒斯IMAP</strong>是另一种选择</p>
<p><strong>文件共享</strong></p>
<p>对于以Windows为中心的文件共享，<strong>Samba</strong>无疑是赢家。Samba允许Linux机器的外观和行为类似于Windows机器，以便它可以共享文件并参与Windows域。Samba实现服务器组件，例如使文件可用于共享和某些Windows服务器角色，并实现客户端，以便Linux机器可以使用Windows文件共享。</p>
<p><strong>Netatalk</strong>项目可让Linux机器成为苹果Macintosh文件服务器执行。UNIX / Linux的本机文件共享协议称为<strong>网络文件系统（NFS）</strong>。NFS通常是内核的一部分，这意味着可以像安装常规磁盘一样安装（可访问）远程文件系统，从而使文件访问对其他应用程序透明。</p>
<p>DNS主要集中在计算机名称和IP地址上，不易搜索。出现了其他目录来存储信息，例如用户帐户和安全角色。在<strong>轻量级目录访问协议（LDAP）</strong>是一个共同的目录系统，同样支持微软的Active Directory。在LDAP中，对象存储在树中，并且该对象在树上的位置可用于派生有关该对象及其存储内容的信息。例如，Linux管理员可以存储在名为“ IT Department”的树的分支中，该分支位于名为“ Operations”的分支之下。因此，通过在“ IT部门”分支下进行搜索，可以找到所有技术人员。<strong>OpenLDAP</strong>是Linux基础结构中使用的主要程序。</p>
<h3 id="桌面应用"><a href="#桌面应用" class="headerlink" title="桌面应用"></a>桌面应用</h3><p><strong>电子邮件</strong></p>
<p>Mozilla基金会推出了功能齐全的桌面电子邮件客户端<strong>Thunderbird</strong>。Thunderbird连接到POP或IMAP服务器，在本地显示电子邮件，并通过外部SMTP服务器发送电子邮件。</p>
<p>其他值得注意的电子邮件客户端是<strong>Evolution</strong>和<strong>KMail</strong>，它们是GNOME和KDE项目的电子邮件客户端。通过POP和IMAP以及本地电子邮件格式进行标准化意味着可以轻松地在电子邮件客户端之间进行切换而不会丢失数据。</p>
<p><strong>创意</strong></p>
<p>有<strong>Blender</strong>，<strong>GIMP（GNU图像处理程序）</strong>和<strong>Audacity</strong>分别处理3D电影创建，2D图像处理和音频编辑。Audacity是免费的开源音频编辑工具，可在多个操作系统上使用。（甚至ctf都用）</p>
<p><strong>生产力</strong></p>
<p>在演示文稿和项目中<strong>使用通用的开源应用程序</strong>是增强Linux技能的一种方法。基本的生产力应用程序（例如文字处理器，电子表格和演示文稿包）是宝贵的资产。总的来说，它们被称为办公套件，这主要是由于市场上占主导地位的Microsoft Office所致。</p>
<p><strong>LibreOffice</strong>是<strong>OpenOffice</strong>（有时称为<strong>OpenOffice.org</strong>）应用程序套件的分支。两者都提供完整的办公套件，包括力求在功能和文件格式上与Microsoft Office兼容的工具。</p>
<p>LibreOffice还可以使用其他文件格式，例如Microsoft Office或<strong>Adobe可移植文档格式（PDF）</strong>文件。此外，通过使用扩展，可以使LibreOffice与Wiki软件集成，从而为您提供功能强大的Intranet解决方案。</p>
<p><strong>Web浏览器</strong></p>
<p>Linux是<strong>Mozilla Firefox</strong>和<strong>Google Chrome</strong>浏览器的一等公民。两者都是开源的Web浏览器，它们快速，功能丰富，并且对Web开发人员具有出色的支持</p>
<h3 id="控制台工具"><a href="#控制台工具" class="headerlink" title="控制台工具"></a>控制台工具</h3><p>从历史上看，UNIX的开发表明软件开发和系统管理的技能之间存在相当多的重叠。用于管理系统的工具具有诸如循环（允许重复执行命令）之类的计算机语言功能，并且某些计算机编程语言已广泛用于自动化系统管理任务。因此，应该认为这些技能是互补的，并且主管系统管理员至少需要对编程有基本的了解。</p>
<p><em><strong>Shell</strong></em></p>
<p>Shell的工作是接受命令，例如文件操作和启动应用程序，并将这些命令传递给Linux内核以执行。shell⁠ ⁠Linux外壳提供了丰富的语言来遍历文件和自定义环境，而这一切都无需离开外壳。</p>
<p>Linux提供了多种外壳供您选择，它们的主要区别在于如何自定义方式和自定义内容以及内置脚本语言的语法。两个主要的族是<strong>Bourne壳</strong>和<strong>C壳</strong>。Bourne外壳以其创建者Bell Labs的Stephen Bourne命名。之所以如此命名C外壳，是因为其语法是从C语言大量借用的。由于这两种外壳都是在1970年代发明的，因此出现了更多现代版本，包括<strong>Bourne Again Shell（Bash）</strong>和<strong>tcsh</strong>（发音为tee-cee-shell）。Bash是大多数系统上的默认Shell，尽管通常也可以使用tcsh。</p>
<p>程序员从Bash和tcsh获得了喜欢的功能，并制作了其他shell，例如<strong>Korn shell（ksh）</strong>和<strong>Z shell（zsh）</strong>。壳的选择主要是个人的。熟悉Bash的用户可以在大多数Linux系统上有效运行。其他外壳可能会提供可在特定使用情况下提高生产率的功能。</p>
<p><strong>文本编辑</strong></p>
<p><strong>Vi</strong>（或者更现代的<strong>Vim</strong>）和<strong>Emacs</strong>是两个主要的应用程序。两者都是编辑文本文件的强大工具。它们在命令格式以及为它们编写插件的方式方面有所不同，Vi和Emacs都很复杂，学习曲线也很陡，这对于简单编辑小文本文件没有帮助。</p>
<p>因此<strong>Pico</strong>和<strong>Nano</strong>提供非常基本的文本编辑</p>
<p>不过，管理员应该努力使自己对Vi有一些基本的了解，因为它几乎可以在现有的每个Linux系统上使用。通过在发行版的恢复模式下运行来恢复已损坏的Linux系统时，Vi可能是至关重要的工具</p>
<h3 id="包管理器！！"><a href="#包管理器！！" class="headerlink" title="包管理器！！"></a>包管理器！！</h3><p>每个Linux系统都需要添加，删除和更新软件。在过去，这意味着需要下载源代码，进行设置，编译以及将文件复制到需要更新的每个系统上。值得庆幸的是，现代发行版使用的包是压缩文件，这些文件将应用程序及其依赖项（或所需文件）捆绑在一起，通过创建正确的目录，将适当的文件复制到其中以及创建诸如符号链接之类的所需项来大大简化安装过程</p>
<p>包管理器负责跟踪的哪些文件属于哪个包，甚至从存储库下载更新，通常是远程服务器共享出去分配相应的更新。在Linux中，有许多不同的软件包管理系统，但是最受欢迎的两个是Debian和Red Hat的软件包。</p>
<p><strong>Debian</strong></p>
<p>Debian软件包管理的核心是软件包，这些软件包以<code>.deb</code>扩展名结尾的文件的形式分发。</p>
<p>用于管理这些文件的最底层工具是<code>dpkg</code>命令。该命令可能难倒新手Linux用户，所以<strong>先进的包装工具</strong>，<code>apt-get</code>（<code>dpkg</code>工具的前端程序），使封装的管理更加容易。用作<code>dpkg</code>前端的其他命令行工具包括<code>aptitude</code>和<strong>Synaptic</strong>和<strong>Software Center之</strong>类的GUI前端。</p>
<p><strong>RPM</strong></p>
<p>在<strong>Linux标准基础</strong>，这是<strong>Linux基金会</strong>的项目，旨在指定（通过共识）的一套标准增加符合Linux系统之间的兼容性。根据Linux Standards Base，标准软件包管理系统是RPM。</p>
<p>RPM<code>.rpm</code>为每个软件包使用一个文件。这个系统是从Red Hat（包括Centos和Fedora）派生的发行版用于管理软件的。不是Red Hat派生的其他几个发行版，例如SUSE，OpenSUSE和Arch，也使用RPM。</p>
<p>与Debian系统一样，RPM软件包管理系统跟踪软件包之间的依赖关系。跟踪相关性可确保在安装软件包时，系统还会安装该软件包正常运行所需的所有软件包。依赖关系还确保正确执行软件更新和删除。</p>
<p>该<code>rpm</code>命令最常用于RPM软件包管理的后端工具。虽然<code>rpm</code>命令可以安装，更新，查询和删除软件包，但命令行的前端工具，如<code>yum</code>和<code>up2date</code>使得解决依赖问题的过程自动化</p>
<p>还有一些基于GUI的前端工具，例如<strong>Yumex</strong>和<strong>Gnome PackageKit</strong>，它们也使RPM软件包管理更加容易</p>
<h2 id="云与LINUX"><a href="#云与LINUX" class="headerlink" title="云与LINUX"></a>云与LINUX</h2><p>从物理上讲，云可以描述为来自一个或多个异地数据中心的计算资源，这些资源可以通过Internet进行访问。云基于数据中心的优势，并为需要存储和处理数据的组织提供计算解决方案，并允许他们将IT基础架构的管理委派给第三方。组织存储在云中的数据和资源可以包括数据，服务器，存储，应用程序托管，分析和众多其他服务。</p>
<p>云部署模型为如何构建，管理和访问云基础架构提供了基础。有四种主要的云部署模型：</p>
<ul>
<li><strong>公共云</strong>：公共云是提供商所部署的云基础结构，用于通过Internet向公众和组织提供云服务。在公共云模型中，可能有多个租户（消费者）共享公共云资源。我们中的许多人很可能在某些时候通过诸如Amazon，Google和其他流行的公共云提供商之类的提供商访问了公共云资源。</li>
<li><strong>私有云</strong>：私有云是专门为特定组织而建立的云基础架构。与公共云相比，私有云为组织提供了更高程度的隐私，并可以控制云基础架构，应用程序和数据。它可以托管在使用它的公司管理的服务器上，也可以托管在托管的私有云提供商（例如Rackspace或IBM）中。</li>
<li><strong>社区云</strong>：社区云是一种云基础结构，由一组具有共同目标或要求的组织专用。参与社区的组织通常分担社区云服务的成本。此选项可能比公共云贵。但是，与公共云相比，它可以提供更高级别的控制和防御外部威胁。</li>
<li><strong>混合云</strong>：混合云由两个或多个单独的云组成，每个云可以是私有云，社区云或公共云。随着组件云的加入和离开，混合云可能会随时间而变化。使用这种技术可以实现数据和应用程序的可移植性。它还允许公司利用外部资源，同时保留对敏感资源的控制权。</li>
</ul>
<p>Linux在云计算中起着举足轻重的作用。它为90％的公共云工作负载提供动力，大多数虚拟服务器基于Linux内核的某个版本，并且Linux通常用于承载云计算服务背后的应用程序。那么，什么使Linux特别适合实现云计算呢？</p>
<p><strong>灵活性</strong></p>
<p>Linux在这里脱颖而出，因为它具有高度的适应性。对于初学者来说，Linux是设计上模块化的，并且在庞大的开源应用程序生态系统的中心，提供了无休止的配置选项以适合各种系统和用例。最重要的是，Linux可以高效地扩展，从而可以运行从微小的远程传感器到整个服务器场的所有内容。</p>
<p><strong>辅助功能</strong></p>
<p>在传统环境中，可从专用设备（例如台式机或笔记本电脑）访问IT资源。在云计算中，应用程序和数据驻留在中央，并且可以通过网络从任何设备（例如台式机，移动设备或瘦客户端）从网络上的任何位置进行访问，并且这些设备中的每一个都有一个Linux版本。</p>
<p><strong>具有成本效益</strong></p>
<p>云计算之所以具有吸引力，是因为它具有降低消费者IT成本的潜力。在云计算中，消费者可以单方面自动扩展IT资源以满足工作负载需求，从而消除未充分利用资源的开销。此外，减少了与IT配置，管理，占地面积，电源和冷却相关的费用。</p>
<p>云提供商承担了这些基础架构成本，但必须保持低成本的替代方案。选择Linux是提供商可以部署的最具成本效益的解决方案之一。Linux是最省电的操作系统之一，Linux内核以及许多相关的应用程序，实用程序和其他软件组件都是完全免费的。</p>
<p>企业和政府组织可以选择购买商业支持的发行版，与经许可的竞争对手相比，这种发行版更具成本效益。对于许多组织来说，支持云计算的非商业发行版也是一个可行的选择。</p>
<p>供应商不仅可以将这些节省的资金转嫁给客户，而且提供基于Linux的解决方案对于客户来说可以更便宜地实现。在自己的系统上安装Linux可以消除与竞争性操作系统相关的昂贵的用户许可费用。</p>
<p><strong>可管理性</strong></p>
<p>尽管Linux最初只是一个小众的操作系统，但它在IT行业中的广泛存在使Linux的使用和管理成为IT专业人员的必备技能。云供应商和消费者变得越来越容易获得必要的人才或重新分配现有的团队成员。</p>
<p>建立在C编程语言上的Linux的性质也使其适用于自动化管理工具。在云中运行的Linux服务器的很大一部分是由自动化管理程序而不是人工操作人员创建和管理的。此过程使管理员可以腾出时间来监视计算操作，而不必手动配置和更新系统。</p>
<p><strong>安全</strong></p>
<p>当使用云解决方案时，尤其是公共云，组织可能会担心与隐私，外部威胁以及对IT资源和数据的控制不足有关。</p>
<p>Linux可帮助抵消这些问题，因为它是可用的最安全和可靠的操作系统之一。Linux是开源的，这意味着其源代码可供任何人获取，查看和修改。这也意味着可以检查该代码中的漏洞和兼容性问题，从而导致社区进行了广泛的工作来纠正这些问题并维护Linux的良好声誉。</p>
<p><em><strong>虚拟化</strong></em></p>
<p>虚拟化是促成计算支持云的最重要进步之一。</p>
<p>Linux是一个多用户操作系统，这意味着许多不同的用户可以同时在同一个系统上工作，并且在大多数情况下不能做损害其他用户的事情。但是，这确实有局限性–用户可能会占用磁盘空间或占用过多的内存或CPU资源，并使每个人的系统运行缓慢。在多用户模式下共享系统还要求每个人都以非特权用户身份运行，因此，例如，让每个用户运行自己的Web服务器都是一项挑战。</p>
<p>虚拟化是一个过程，其中一台称为主机的物理计算机运行一个操作系统的多个副本，每个副本称为guest虚拟机。可以为特定功能预先配置这些来宾映像，以在需要时允许自动快速部署。<strong>主机系统运行称为Hypervisor的软件，该软件可在各种来宾之间切换资源</strong>，就像Linux内核对单个进程所做的一样。使用裸机管理程序，管理程序直接在计算机硬件上运行，而不是在操作系统之上运行，从而释放了更多的资源用于来宾映像。</p>
<p>虚拟化之所以有效，是因为服务器将大部分时间都花在了闲置时间上，并且不需要诸如显示器和键盘之类的物理资源。借助来自<strong>VMWare</strong>和<strong>Openbox之</strong>类的公司的软件，您现在可以使用功能强大的CPU，并通过使用它运行多个虚拟机，管理员可以优化物理资源的使用并大大降低以前的单机，单操作系统数据中心模型的成本。主要限制通常是内存，但是，随着虚拟机监控程序技术和CPU的发展，可以在一台主机上放置比以往更多的虚拟机。</p>
<p>在虚拟化环境中，一台主机可以运行许多来宾操作系统，并且在CPU本身的支持下，来宾甚至都不知道它们在虚拟机上运行。每个来宾都拥有自己的虚拟资源，并与自己的网络进行通信。甚至没有必要在所有客户机上运行相同的操作系统，这进一步减少了所需的物理服务器的数量。</p>
<p>虚拟化为企业提供了一种方法，可以通过等效的物理服务器群来降低能耗并减少数据中心空间。来宾现在仅是软件配置，因此很容易启动新机器进行测试，并在其有用性过去时将其销毁。</p>
<p>由于可以在一台物理计算机上运行一个操作系统的多个实例并通过网络连接到它，因此计算机的位置无关紧要。云计算采用这种方法，并允许管理员在另一家公司拥有的远程数据中心中拥有虚拟机，并且仅需为使用的资源付费。云计算供应商可以利用经济规模来以比运营现场数据中心低得多的价格提供计算资源。</p>
<p><strong>集装箱和裸机部署</strong></p>
<p>随着诸如<strong>Docker</strong>和<strong>Kubernetes之</strong>类的容器化技术的兴起，如今正在编写可在无服务器环境中运行的应用程序软件。本质上，程序员正在创建一种软件，该软件执行在容器中运行的系统的一项功能（例如数据库处理或存储）。这些容器组织在节点内运行的Pod中，可以相互通信，并且可以根据需要与外界通信。节点又由主节点组织和控制为结构中的每个组件提供服务。通过这种方式构建应用程序，可以使每个组件彼此分离，并避免运行OS的开销。由于难题的每个部分都可以由主节点自动销毁并重新创建，因此不再需要像在OS顶部运行的软件那样强大。尽管这些新的编程体系结构在许多方面都绕过了对传统OS的需求，但使它们起作用的底层技术仍然是Linux。因此，在Linux中工作的开发团队将越来越多地利用编程，数据库设计，网络和系统管理的学科来创建未来的系统。？？？？看不懂。。</p>
<h1 id="开源项目和许可"><a href="#开源项目和许可" class="headerlink" title="开源项目和许可"></a>开源项目和许可</h1><p>Software projects take the form of source code, which is a human-readable set of computer instructions. Since source code is not understood directly by the computer, it must be compiled into machine instructions by a compiler. The compiler is a special program that gathers all of the source code files and generates instructions that can be run on the computer, such as by the Linux kernel.</p>
<p>（个人强烈建议在学习Linux前查看GNU宣言及相关历史）</p>
<p>在谈论购买软件时，有三个不同的组件：</p>
<ul>
<li><strong>所有权</strong>–谁拥有该软件背后的知识产权？</li>
<li><strong>汇款</strong>–<strong>资金</strong>如何转手（如果有的话）？</li>
<li><strong>许可</strong>–您会得到什么？您可以使用该软件做什么？您只能在一台计算机上使用它吗？你能把它给别人吗？</li>
<li>Linux由Linus Torvalds拥有。他已将代码置于称为<strong>GNU通用公共许可证版本2（GPLv2）的许可证下</strong>。该许可证除其他外，规定必须向任何提出要求的人提供源代码，并且允许任何人进行更改。一个警告是，如果有人进行更改并将其分发，则他们必须将更改置于相同的许可下，以便其他人可以从中受益。GPLv2还说，除分发源代码的实际成本（例如将其复制到可移动媒体）外，任何人都不得收取分发源代码的费用。</li>
</ul>
<p>通常，当某人创建某物时，他们也有权决定如何使用和分发它。<strong>自由和开源软件（FOSS）</strong>是指已放弃此权利的软件；任何人都可以查看源代码并重新分发。Linus Torvalds使用Linux做到了这一点–即使他创建了Linux，但他也不能禁止某人在其计算机上使用它，因为他已经通过GPLv2许可证放弃了该权利。</p>
<h2 id="开源计划"><a href="#开源计划" class="headerlink" title="开源计划"></a>开源计划</h2><p>The <strong>Open Source Initiative (OSI)</strong> was founded in 1998 by Bruce Perens and Eric Raymond. They believed that the Free Software Foundation was too politically charged and that less extreme licenses were necessary, particularly around the copyleft aspects of FSF licenses. OSI believes that not only should the source be freely available, but also that no restrictions should be placed on the use of the software, no matter what the intended use. Unlike the FSF, the OSI does not have its own set of licenses. Instead, the OSI has a set of principles and adds licenses to that list if they meet those principles, called open source licenses. Software that conforms to an Open Source license is, therefore, open source software.</p>
<p>One type of Open Source license is the <strong>BSD (Berkeley Software Distribution)</strong> and its derivatives, which are much simpler than GPL. There are currently two actual “BSD” licenses approved by OSI, a 2-Clause and a 3-Clause. These licenses state that you may redistribute the source and binaries as long as you maintain copyright notices and don’t imply that the original creator endorses your version. In other words “do what you want with this software, just don’t say you wrote it.” According to FSF, the original BSD license had a serious flaw in that it required developers to add a clause acknowledging the University of California, Berkeley in every advertisement for software licensed this way. As others copied this simple license, they included acknowledgment for their own institutions which led to over 75 such acknowledgments in some cases.</p>
<p>FSF licenses, such as GPLv2, are also open source licenses. However, many open source licenses such as BSD and MIT do not contain the copyleft provisions and are thus not acceptable to the FSF. These licenses are called permissive free software licenses because they are permissive in how you can redistribute the software. You can take BSD licensed software and include it in a closed software product as long as you give proper attribution.</p>
<p>Rather than dwell over the finer points of Open Source and Free Software, the community has started referring to them collectively as <strong>Free and Open Source Software (FOSS)</strong>. The English word “free” can mean “free as in lunch” (as in no cost) or “free as in speech” (as in no restrictions). This ambiguity led to the inclusion of the word “libre” to refer to the latter definition. Thus, we end up with <strong>Free/Libre/Open Source Software (FLOSS)</strong>.</p>
<p>The <strong>Creative Commons (CC)</strong> organization has created the Creative Commons Licenses which try to address the intentions behind FOSS licenses for non-software entities. CC licenses can also be used to restrict commercial use if that is the desire of the copyright holder. The CC licenses are made up of the following set of conditions the creator can apply to their work:</p>
<p>These conditions are then combined to create the six main licenses offered by Creative Commons:</p>
<ul>
<li><strong>Attribution (CC BY)</strong> – Much like the BSD license, you can use CC BY content for any use but must credit the copyright holder.</li>
<li><strong>Attribution ShareAlike (CC BY-SA)</strong> – A copyleft version of the Attribution license. Derived works must be shared under the same license, much like in the Free Software ideals.</li>
<li><strong>Attribution NoDerivs (CC BY-ND)</strong> – You may redistribute the content under the same conditions as CC-BY but may not change it.</li>
<li><strong>Attribution-NonCommercial (CC BY-NC)</strong> – Just like CC BY, but you may not use it for commercial purposes.</li>
<li><strong>Attribution-NonCommercial-ShareAlike (CC BY-NC-SA)</strong> – Builds on the CC BY-NC license but requires that your changes be shared under the same license.</li>
<li><strong>Attribution-NonCommercial-NoDerivs (CC BY-NC-ND)</strong> – You are sharing the content to be used for non-commercial purposes, but people may not change the content.</li>
<li><strong>No Rights Reserved (CC0)</strong> – This is the Creative Commons version of public domain.</li>
</ul>
<h2 id="开源业务模型"><a href="#开源业务模型" class="headerlink" title="开源业务模型"></a>开源业务模型</h2><p>如果所有这些软件都是免费的，那么谁能从中赚钱呢？</p>
<p>首先，您必须了解GPL中没有禁止销售软件的任何内容。实际上，销售软件的权利是GPL许可的一部分。同样，请记住，“自由”一词是指自由，而不是价格。鼓励为这些免费程序增加价值的公司赚取尽可能多的钱，并将这些利润重新投入到开发更多更好的软件中。</p>
<p>赚钱的最简单方法之一是在软件周围出售支持或保修。诸如Canonical，Ubuntu的开发者和Redhat之类的公司已经通过创建Linux发行版和工具来发展为大型企业，这些发行版和工具使商业用户能够管理其企业并为他们的客户提供产品和服务。</p>
<p>许多其他开源项目也已扩展为大量业务。在1990年代，Gerald Combs在一家互联网服务提供商处工作，并开始编写自己的网络分析工具，因为当时的类似工具价格昂贵。现在有600多人为这个名为Wireshark的项目做出了贡献。现在，它通常被认为比商业产品更好，并导致成立了一家销售产品和支持的公司。与许多其他公司一样，该公司被一家支持其持续发展的大型企业收购。</p>
<p>像Tivo这样的公司已经打包了硬件或添加了额外的封闭源代码软件，以与免费软件一起出售。使用Linux的设备和嵌入式系统是一项价值数十亿美元的业务，涵盖了从家用DVR到安全摄像机和可穿戴健身设备的所有内容。许多消费者防火墙和娱乐设备都遵循此模型。</p>
<p>如今，大型和小型雇主都有个人，有时甚至整个团体都致力于开源项目。科技公司争夺机会来影响将改变其行业未来的项目。其他公司则将资源专用于内部使用所需的项目。随着在云资源上完成更多的业务，开源程序员的机会将继续扩大。</p>
<p>‌⁠</p>
<hr>
<p>我吐了</p>
<h1 id="命令行之始"><a href="#命令行之始" class="headerlink" title="命令行之始"></a>命令行之始</h1><ol>
<li><p><strong>用户名：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin @localhost：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><strong>系统名称：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin @本地主机：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><strong>当前目录：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin @ localhost：〜 $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<p>该<code>~</code>符号用作用户主目录的简写。通常，用户的主目录位于该<code>/home</code>目录下，并以用户帐户名命名；例如，<code>/home/sysadmin</code>。</p>
<p>命令的典型格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">命令[选项] [参数]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>选项用于修改命令的核心行为，而参数用于提供其他信息</p>
<p>请记住，Linux区分大小写。命令，选项，参数，变量和文件名必须完全按照所示输入。</p>
<p>组合选项的顺序并不重要。所有这些示例的输出将是相同的：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -l -r 
ls -rl 
ls -lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>选项通常是单个字母；但是，有时它们也是单词或短语。通常，较旧的命令使用单个字母，而较新的命令使用完整的单词作为选项。<code>-</code>像该<code>-h</code>选项一样，单字母选项前面带有一个破折号。全字选项前面有两个破折号<code>--</code>。该<code>-h</code>选项还具有等效的全字形式；该<code>--human-readable</code>选项。</p>
<p>Bash shell中使用了两种类型的变量：local和environment。</p>
<p>Bash在解释命令和执行任务时使用的所有shell中，环境变量（也称为全局变量）在系统范围内可用。当打开新的外壳程序时，系统会自动重新创建环境变量</p>
<p>要理解的最重要的Bash shell变量之一是<code>PATH</code>变量。它包含一个列表，该列表定义了外壳程序在哪些目录中查找命令。如果输入了有效命令，并且外壳程序返回“找不到命令”错误，那是因为Bash Shell无法在路径中包含的任何目录中以该名称找到命令</p>
<p>列表中的每个目录都用冒号分隔<code>:</code>。根据前面的输出，该路径包含以下目录。Shell将按照列出的顺序检查目录：</p>
<p>更新<code>PATH</code>变量时，<strong>请始终包含当前路径</strong>，以免失去对这些目录中命令的访问权限。这可以通过<code>$PATH</code>在赋值表达式中附加值来实现。回想一下，以美元符号开头的变量名称表示该变量的值。<strong>而且最后那个分隔符冒号是要自己加的！</strong><code>$ PATH = / usr / bin / custom：$ PATH  </code></p>
<h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><p>There are several different sources of commands within the shell of your CLI including internal commands, external commands, aliases, and functions.内部命令，外部命令，别名，函数</p>
<p>一个别名可以用于映射到更短的按键序列长的命令。当外壳程序看到别名正在执行时，它将替换较长的序列，然后继续解释命令。</p>
<p>例如，该命令<code>ls -l</code>通常别名为<code>l</code>或<code>ll</code>。由于这些较小的命令更易于键入，因此运行<code>ls -l</code>命令行的速度会更快。</p>
<p>也可以使用现有命令来构建函数，以创建新命令，或覆盖Shell内置命令或存储在文件中的命令。通常在外壳程序首次启动时从初始化文件中加载别名和函数。</p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="quoting引号"><a href="#quoting引号" class="headerlink" title="quoting引号"></a>quoting引号</h3><p>double “  single ‘  back  `</p>
<p>双引号阻止外壳程序解释某些元字符（特殊字符），包括全局字符。</p>
<p>Glob字符，也称为通配符（wild cards），是对shell具有特殊含义的符号；<em><strong>它们会在尝试运行任何命令之前由外壳程序本身解释</strong></em>。球形字符包括星号<code>*</code>，<code>?</code>问号字符和方括号<code>[ ]</code>等。</p>
<p>稍后将在本课程中更详细地介绍globbing。</p>
<p>双引号仍然允许命令替换，变量替换（$），并允许一些尚未讨论的其他shell元字符</p>
<p>单引号可防止外壳对特殊字符进行任何解释，包括glob，变量，命令替换和其他尚未讨论的元字符。</p>
<p>反引号，或反引号，用于指定一个命令内的命令时，<strong>这个过程被称为命令替换</strong>。这允许强大而复杂的命令使用</p>
<p>echo data 和 echo back data back</p>
<h3 id="Control-Statement"><a href="#Control-Statement" class="headerlink" title="Control Statement"></a>Control Statement</h3><p>控制语句允许您一次使用多个命令或运行其他命令，具体取决于上一个命令的成功。通常，这些控制语句在脚本内使用，但是它们也可以在命令行上使用。</p>
<p>分号；依次执行，彼此独立。</p>
<p>双“＆”号<code>&amp;&amp;</code>充当逻辑“与”；如果第一个命令成功执行，则第二个命令也将运行。如果第一个命令失败，则第二个命令将不会运行。</p>
<p>使用双管道，如果第一个命令成功运行，则第二个命令将被跳过；如果第一个命令失败，则运行第二个命令。换句话说，您实际上是在告诉Shell，“要么运行第一个命令，要么运行第二个命令”。 </p>
<h1 id="内置帮助"><a href="#内置帮助" class="headerlink" title="内置帮助"></a>内置帮助</h1><h2 id="Man-Pages"><a href="#Man-Pages" class="headerlink" title="Man Pages"></a>Man Pages</h2><p>man + 命令</p>
<p>The <code>man</code> command uses a pager to display documents. Usually, <strong>this pager is the <code>less</code> command</strong>, but on some distributions, it may be the <code>more</code> command. Both are very similar in how they perform.</p>
<p>To view the various movement commands that are available, use the <em><strong>H key</strong></em> while viewing a man page. This displays a help page.</p>
<p>man手册使用less命令，less和more是查看文件的方法命令，less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。那些操作都是less命令提供的，用</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Commands marked with * may be preceded by a number, N.     
   Notes in parentheses indicate the behavior if N is given.        
   A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>请注意，手册页现在可能对您来说还是个谜，但是随着您对Linux的更多了解，您会发现它们是非常有价值的资源</p>
<p><strong>Name</strong></p>
<p><strong>SYNOPSIS</strong></p>
<p>好像是使用类似正则表达式规则，[bda]表示b,d,a都可用，均为可选</p>
<p>可能会显示多组用法，参数各自独立  <code>a|b</code>表示或，a和b等价</p>
<p><strong>DESCRIPTION</strong></p>
<p><strong>OPTIONS</strong></p>
<p><strong>FILES</strong></p>
<p>Lists the files that are associated with the command as well as a description of how they are used. These files may be used to configure the command’s more advanced features. Often this information is found in the <code>DESCRIPTION</code> section and not in a separate <code>FILES</code> section.（description装不下就单独文件）</p>
<p><strong>AUTHOR</strong></p>
<p><strong>REPORTING BUGS</strong></p>
<p><strong>COPYRIGHT</strong></p>
<p><strong>SEE ALSO</strong></p>
<p>Provides you with an idea of where you can find additional information. This often includes other commands that are related to this command.</p>
<p>By default, there are nine sections of man pages:</p>
<ol>
<li>General Commands</li>
<li>System Calls</li>
<li>Library Calls</li>
<li>Special Files</li>
<li>File Formats and Conventions</li>
<li>Games</li>
<li>Miscellaneous</li>
<li>System Administration Commands</li>
<li>Kernel Routines</li>
</ol>
<p>不同的手册页由“部分”区分。默认情况下，手册页有九个部分：</p>
<ul>
<li>可执行程序或外壳命令</li>
<li>系统调用（内核提供的功能）</li>
<li>库调用（程序库中的函数）</li>
<li>特殊文件（通常在中找到<code>/dev</code>）</li>
<li>文件格式和约定，例如 <code>/etc/passwd</code></li>
<li>游戏类</li>
<li>其他（包括宏包和约定），例如<code>man(7)&gt;</code>，<code>groff(7)</code></li>
<li>系统管理命令（通常仅用于root用户）</li>
<li>内核例程</li>
</ul>
<p>搜索指令时依次搜索</p>
<p>默认输出第一个找到的手册页</p>
<p>该<code>whereis</code>命令专门用于<strong>查找命令和手册页</strong>。尽管这很有用，但通常需要查找文件或目录，而不仅仅是查找命令或手册页文件。</p>
<p>要查找任何文件或目录，请使用<code>locate</code>命令。创建数据库时，此命令将搜索系统中所有文件和目录的数据库。通常，生成该数据库的命令每晚运行一次。</p>
<h2 id="INFO文档"><a href="#INFO文档" class="headerlink" title="INFO文档"></a>INFO文档</h2><p>手册页是很好的信息来源，但是它们确实有一些缺点。一个示例是，每个手册页都是单独的文档，与任何其他手册页都不相关。尽管某些手册页的某个<code>SEE ALSO</code>部分可能引用其他手册页，但它们往往是独立的文档来源。</p>
<p>该<code>info</code>命令还提供有关操作系统命令和功能的文档。目标与手册页略有不同：提供一个文档资源，该文档资源给出了合理的组织结构，使阅读文档更加容易。</p>
<p>所有文档都合并到一个代表所有可用文档的“书”中。在信息文档中，信息分为几类，其工作方式与书中的目录非常相似。为页面提供超链接，其中包含有关特定命令或功能的各个主题的信息。</p>
<p>信息相对于手册页的另一个优点是，信息文档的写作风格通常更有利于学习主题。手册页更多地是参考资源，而信息文档更多地是学习指南。</p>
<p>首行显示了索引信息，下一章/上一章</p>
<p>尾行显示了当前节点</p>
<p>菜单列出了相关话题的超链接，选择+enter可选择</p>
<p>请注意，进入有关排序的节点会将线索带入原始节点的子节点。要返回上一个节点，请使用<strong>U</strong>键。当<strong>U</strong>导致上一级节点的开始时，<strong>L</strong>键返回到与进入排序节点之前相同的位置。U是上级，L是来回</p>
<p>shift+H是移动命令列表</p>
<p>L返回当前文档，Q退出info</p>
<p><strong>与其使用信息文档来查找有关特定命令或功能的信息，不如考虑通过阅读信息文档来探索Linux的功能。执行<code>info</code>不带任何参数的命令，将其带入文档的顶层。这是探索许多功能的一个很好的起点：</strong></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Many commands will provide basic information, very similar to the <code>SYNOPSIS</code> found in man pages, by simply using the <code>--help</code> option to the command. This option is useful to learn the basic usage of a command quickly而且不用离开终端</p>
<p>在大多数系统上，存在一个目录，在该目录中可以找到其他文档（例如，第三方软件供应商存储的文档文件）。</p>
<p>这些文档文件通常称为自述文件，因为这些文件通常具有诸如<code>README</code>或的名称<code>readme.txt</code>。这些文件的位置可能会有所不同，具体取决于您所使用的分发。典型的位置包括<code>/usr/share/doc</code>和<code>/usr/doc</code>。</p>
<p>通常，此目录是系统管理员用来学习如何设置更复杂的软件服务的目录。但是，有时普通用户也会发现此文档很有用。</p>
<h1 id="文件系统导航"><a href="#文件系统导航" class="headerlink" title="文件系统导航"></a>文件系统导航</h1><p>在Linux中，所有内容均视为文件。文件用于存储文本，图形和程序等数据。目录是一种用于存储其他文件的文件；Windows和Mac OS X用户通常将它们称为文件夹。在任何情况下，目录都用于提供分层的组织结构。但是，此结构可能会有所不同，具体取决于使用的系统类型。</p>
<p>与Windows一样，Linux目录结构（通常称为文件系统）也具有顶层。但是，它而不是“我的电脑”被称为根目录，**并且用斜杠符号表示<code>/</code>**。此外，Linux中没有驱动器。每个物理设备都可在目录（而不是驱动器号）下访问。</p>
<p>请注意，有许多目录具有描述性名称，包括<code>/boot</code>，其中包含用于引导计算机的文件。</p>
<p>主目录（home directory）一词通常会使新的Linux用户感到困惑。首先，在大多数Linux发行版中<code>home</code>，根<code>/</code>目录下有一个目录。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/LEv2_7_4.png" alt="根目录中有一个名为home的目录。"></p>
<p>在此<code>/home</code>目录下，为系统上的每个用户提供一个目录。目录名与用户名相同，因此名为的用户<code>sysadmin</code>将具有一个名为<code>/home/sysadmin</code>的主目录</p>
<p><img src="https://ndg-content-dev.s3.amazonaws.com/media/images/linux-essentials-v2/LEv2_7_5.png" alt="用户的主目录位于/ home目录中，该目录又位于/字符表示的根目录中。 例如，sysadmin用户在/ home目录中有一个主目录（也称为sysadmin）。">首先，当用户打开shell程序时，应将其自动放置在其主目录中，因为通常这是他们执行大部分工作的地方。</p>
<p>此外，主目录是用户可以完全控制创建和删除其他文件和目录的少数目录之一。在大多数Linux发行版中，唯一可以访问主目录中文件的用户是系统的所有者和管理员。Linux文件系统中的大多数其他目录受文件权限保护。</p>
<p>主目录的特殊符号是 <code>~</code></p>
<p>父目录<code>..</code> 当前目录<code>.</code></p>
<p>~username 可以引用别的用户的主目录</p>
<p>pwd    </p>
<p>cd 如果不加参数，则回到主目录</p>
<p>绝对路径·总是从根目录开始 /   相对路径则从现在的目录开始</p>
<h2 id="powerful-ls"><a href="#powerful-ls" class="headerlink" title="powerful ls"></a>powerful ls</h2><p>在许多Linux发行版中，包括在我们的虚拟机中使用的发行版，该<code>ls</code>命令使用颜色按文件类型进行区分。例如，目录可以显示为蓝色，可执行文件可以显示为绿色，符号链接可以显示为青色。</p>
<p>彩色输出不是<code>ls</code>命令的默认行为，而是该<code>--color</code>选项的效果。在<code>ls</code>似乎因为对于一个别名来自动执行此着色<code>ls</code>指令，因此它与运行<code>--color</code>选项。</p>
<p>ls -l属性</p>
<p>每行的第一个字符表示文件的类型。文件类型为：</p>
<table>
<thead>
<tr>
<th align="left">象征</th>
<th align="left">文件类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>d</code></td>
<td align="left">目录</td>
<td align="left">用于存储其他文件的文件。</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">常规文件</td>
<td align="left">包括可读文件，图像文件，二进制文件和压缩文件。</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">符号链接</td>
<td align="left">指向另一个文件。</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">插座socket</td>
<td align="left">允许进程之间的通信。</td>
</tr>
<tr>
<td align="left"><code>p</code></td>
<td align="left">管道pipe</td>
<td align="left">允许进程之间的通信。</td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">block文件</td>
<td align="left">用于与硬件通信。</td>
</tr>
<tr>
<td align="left"><code>c</code></td>
<td align="left">字符文件</td>
<td align="left">用于与硬件通信。</td>
</tr>
</tbody></table>
<p>随后是权限，硬连接数，用户所有者，小组所有者，文件大小，时间戳，文档名称</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-rw-r--r-- 1 root   root  35330 May 26  2018 bootstrap.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于符号链接，将显示链接名称以及箭头和原始文件的路径名。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lrwxrwxrwx。1 root root 2018年11月22日&#x2F;etc&#x2F;grub.conf- &gt; ..&#x2F;boot&#x2F;grub&#x2F;grub.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用该<code>-d</code>选项时，它引用的是当前目录，而不是其中的内容。如果没有其他选择，那就毫无意义。</p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin@localhost:~$ ls -ld                                           
drwxr-xr-x 1 sysadmin sysadmin 224 Nov  7 17:07 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>详细的看命令集[]</p>
<p>颜色指示该项目是什么类型。下表描述了一些较常见的颜色：</p>
<table>
<thead>
<tr>
<th align="left">颜色</th>
<th align="left">档案类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">黑或白</td>
<td align="left">常规文件</td>
</tr>
<tr>
<td align="left">蓝色</td>
<td align="left">目录文件</td>
</tr>
<tr>
<td align="left">青色</td>
<td align="left">符号链接文件（指向另一个文件的文件）</td>
</tr>
<tr>
<td align="left">绿色的</td>
<td align="left">可执行文件（程序）</td>
</tr>
</tbody></table>
<h1 id="管理文件和目录"><a href="#管理文件和目录" class="headerlink" title="管理文件和目录"></a>管理文件和目录</h1><p>Linux中的所有内容都区分大小写</p>
<p>Glob字符 are often referred to as wild cards（通配符）.</p>
<p>Globs功能强大，因为它们允许您指定与目录中的文件名匹配的模式。因此，您可以轻松地执行影响多个文件的命令，而不必一次处理一个文件。例如，通过使用全局字符，可以处理具有特定扩展名或特定文件名长度的所有文件。</p>
<p>与shell运行的命令或shell传递给命令的选项和参数不同，<strong>glob字符在尝试运行任何命令之前由shell本身解释</strong>。结果，全局字符可以与任何命令一起使用。</p>
<p>*  匹配任意个字符（包括0个）</p>
<p>？ 匹配单个字符</p>
<p>*+n？搭配表示匹配至少n个字符</p>
<p>[ ]匹配一系列，也可以[ ]*,这不就是正则表达式吗</p>
<p>但是取反是[!xx]而不是 ^</p>
<p>请记住，是将shell（而不是<code>echo</code>or<code>ls</code>命令）将全局模式扩展为相应的文件名。换句话说，如果<code>echo /etc/a*</code>执行了该命令，则在执行echo命令之前，外壳程序将<code>a*</code>用<code>/etc</code>与该模式匹配的目录中的所有文件和目录替换。</p>
<p><strong>ls 在使用通配符时你可能不知道他到底显示的是哪里的文件夹，可以用 -d来显示路径而不是内容</strong></p>
<p><strong>cp</strong>是复制 cp sour des  </p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin @ localhost：〜 $ cp -v &#x2F; etc &#x2F; hosts〜                              
&#96;&#x2F; etc &#x2F; hosts&#39;-&gt;&#96;&#x2F; home &#x2F; sysadmin &#x2F; hosts&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认同名，新名字可以加在路径里，<strong>默认覆盖重名文件！</strong></p>
<p>-v可以显示具体操作</p>
<p>-i会提供交互式警戒，确认后才会覆盖  -n选项则代表 no clobber（没有破坏力）不会覆盖！</p>
<p><strong>默认不能复制目录</strong>，-r可以递归复制整个目录，-p保留时间戳</p>
<p><strong>mv</strong> 语法类似 cp用于移动</p>
<p>还可以用来重命名，mv former newer如果在相同目录，就是<strong>重命名</strong></p>
<p>-i  -n  -v作用类似，但没有-r因为<strong>默认可以移动目录</strong>，-p保留时间戳</p>
<p>创建文件touch</p>
<p>rm命令，小心使用</p>
<p><strong>警告：</strong>文件将被永久删除。没有取消删除文件的命令，也没有从中恢复已删除文件的垃圾桶。</p>
<p>在删除搭配通配符时还是最好使用-i   </p>
<p>rm -r删除目录 最好-i</p>
<p>rmdir删除空目录，mkdir创建空目录</p>
<h1 id="存档和压缩"><a href="#存档和压缩" class="headerlink" title="存档和压缩"></a>存档和压缩</h1><p>archiving and compression</p>
<ul>
<li>归档：将多个文件合并为一个，从而消除了单个文件的开销，并使文件更易于传输。</li>
<li>压缩：通过删除冗余信息来缩小文件的大小。</li>
<li>Files can be compressed individually, or multiple files can be combined into a single archive and then subsequently compressed. The latter is still referred to as archiving.</li>
</ul>
<p>即使磁盘空间相对便宜，归档和压缩仍然有价值：</p>
<ul>
<li>当提供大量文件（例如应用程序的源代码或文档集合）时，与单独下载文件相比，人们下载压缩的存档要容易得多。</li>
<li>日志文件有填充磁盘的习惯，因此按日期拆分日志并压缩较旧的版本很有帮助。</li>
<li>备份目录时，将其全部保存在一个存档中比对每个文件进行版本控制（更新）要容易得多。</li>
<li>如果您发送的是数据流而不是单个文件，则某些流式传输设备（例如磁带）的性能会更好。</li>
<li>通常，在将文件发送到磁带驱动器或通过较慢的网络进行压缩之前，在另一端进行压缩比在不压缩的情况下进行压缩通常会更快。</li>
</ul>
<p>压缩算法是一个计算机使用来编码原始文件的过程，并且作为结果，使其变小。计算机科学家研究了这些算法，并提出了更好的算法，它们可以更快地工作或使输入文件更小。</p>
<p>在谈论压缩时，有两种类型：</p>
<ul>
<li>无损：不会从文件中删除任何信息。压缩文件并解压缩后，会留下与原始文件相同的内容。</li>
<li>有损：信息可能已从文件中删除。它的压缩方式是，解压缩文件将导致文件与原始文件略有不同。例如，可以通过将这两个阴影视为相同来缩小具有两个略微不同的绿色阴影的图像。通常，眼睛总是无法分辨出差异。</li>
</ul>
<p>压缩已经压缩的文件不会使其变小。当涉及到图像时，通常会忘记这一事实，因为它们已经以压缩格式存储。使用无损压缩，这种多重压缩不是问题，但是，如果使用有损算法多次压缩和解压缩文件，最终将导致无法识别的内容。</p>
<h2 id="压缩工具"><a href="#压缩工具" class="headerlink" title="压缩工具"></a>压缩工具</h2><p>Linux提供了几种工具来压缩文件。最常见的是<code>gzip</code>。</p>
<p>gzip xxx 将压缩xxx并加上.gz后缀  </p>
<p> -l 选项将提供压缩信息，压缩前/后大小，压缩率</p>
<p>gunzip 或 gzip -d 是解压缩</p>
<p>The <code>gunzip</code> command is just a script that calls <code>gzip</code> with the right parameters.</p>
<p>使用<strong>Lempel-Ziv</strong>数据压缩算法，</p>
<p>bzip2  bunzip2     它们具有<code>.bz</code>或<code>.bz2</code>扩展名,  <code>bzip</code>实用程序使用另一种称为<strong>Burrows-Wheeler</strong>块排序的压缩算法，该算法可以<strong>压缩较小</strong>的文件，而不用<code>gzip</code>花费那么多多的CPU时间。</p>
<p>xz unxz   .xz拓展名   <strong>Lempel-Ziv-Markov (LZMA)</strong> chain algorithm，</p>
<p>同时拥有比gzip快的时间和比bzip2快的压缩率</p>
<h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><p><code>tar</code>命令接收多个文件，并创建一个输出文件，该文件可在传输的另一端再次拆分为原始文件。</p>
<p>该<code>tar</code>命令具有三种有助于熟悉的模式：</p>
<ul>
<li>创建c：从一系列文件中创建一个新的存档。</li>
<li>提取x：从存档中提取一个或多个文件。</li>
<li>列表t：显示存档的内容而不进行提取。</li>
</ul>
<p>记住模式是弄清执行所需操作所需的命令行选项的关键。除了该模式外，还请记住在何处指定档案名称，因为您可能会在命令行上输入多个文件名。</p>
<p>虽然文件扩展名不会影响文件的处理方式，但约定是将其<code>.tar</code>用于tarball</p>
<p><code>.tar.gz</code>或<code>.tgz</code>称呼用gzip压缩的tarball。</p>
<p><code>.tar.bz2</code>，<code>.tbz</code>或者<code>.tbz2</code>称呼用bzip2压缩的tarball</p>
<p><code>tar</code> stands for <strong>Tape ARchive</strong></p>
<p><strong>将<code>–f</code>标志保留在末尾很重要，因为<code>tar</code>假定此选项后的所有内容均为文件名。如果放错了位置，导致<code>tar</code>将该命令解释为对名为的文件的操作，该文件<code>v</code>不存在</strong>。</p>
<h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-c</code></td>
<td align="left">创建一个档案。</td>
</tr>
<tr>
<td align="left"><code>-f ARCHIVE</code></td>
<td align="left">使用存档文件。参数<code>ARCHIVE</code>将是生成的存档文件的名称。</td>
</tr>
<tr>
<td align="left"><code>-z</code></td>
<td align="left">使用<code>gzip</code>命令压缩（或解压缩）归档文件。</td>
</tr>
<tr>
<td align="left"><code>-j</code></td>
<td align="left">使用<code>bzip2</code>命令压缩（或解压缩）归档文件。</td>
</tr>
</tbody></table>
<h3 id="列表模式"><a href="#列表模式" class="headerlink" title="列表模式"></a>列表模式</h3><p>给定一个<code>tar</code>压缩的或未压缩的存档，您可以使用该<code>-t</code>选项查看其中的内容。下一个示例使用三个选项：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-t</code></td>
<td align="left">列出档案中的文件。</td>
</tr>
<tr>
<td align="left"><code>-j</code></td>
<td align="left">用<code>bzip2</code>命令解压缩。</td>
</tr>
<tr>
<td align="left"><code>-f ARCHIVE</code></td>
<td align="left">在给定的存档上进行操作。</td>
</tr>
</tbody></table>
<p><strong>默认使用递归查看子目录</strong></p>
<h3 id="提取模式"><a href="#提取模式" class="headerlink" title="提取模式"></a>提取模式</h3><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-x</code></td>
<td align="left">从存档中提取文件。</td>
</tr>
<tr>
<td align="left"><code>-j</code></td>
<td align="left">使用<code>bzip2</code>命令解压缩。</td>
</tr>
<tr>
<td align="left"><code>-f ARCHIVE</code></td>
<td align="left">在给定的存档上进行操作。</td>
</tr>
<tr>
<td align="left"><code>-v</code></td>
<td align="left">详细列出已处理的文件。</td>
</tr>
</tbody></table>
<p>提取时原始文件未更改，并创建了新目录。目录内是原始目录和文件</p>
<p>如果后面加了完全正确的路径名，则可以提取单个文件</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -xjvf folders.tbz School&#x2F;Art&#x2F;linux.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="ZIP文件"><a href="#ZIP文件" class="headerlink" title="ZIP文件"></a>ZIP文件</h2><p>Microsoft中的事实上的归档实用程序是ZIP文件。ZIP在Linux中并不普遍，但是<code>zip</code>and<code>unzip</code>命令很好地支持ZIP 。尽管和<code>tar</code>和<code>gzip</code>/<code>gunzip</code>相同的命令和选项可以互换使用来进行创建和提取，但是并非如此<code>zip</code>。对于两个不同的命令，相同的选项具有不同的含义。</p>
<p><code>zip</code>的默认模式是将文件添加到存档并进行压缩。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">zip [OPTIONS] [zipfile [file…]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>应当注意的是，<code>tar</code>需要使用<code>–f</code>选项来指示正在传递文件名，而需要<code>zip</code>并<code>unzip</code>使用文件名，因此不需要您通知命令正在传递文件名。</p>
<p><code>zip</code>默认情况下，该命令不会递归到子目录中，这与<code>tar</code>命令的行为不同。也就是说，仅添加<code>School</code>将仅添加空目录，而不添加其下的文件。如果您想要<code>tar</code>类似的行为，则必须使用该<code>–r</code>选项指示要使用递归：</p>
<p>unzip的 -l选项是列出文件</p>
<p>提取文件就像创建存档一样，因为<code>unzip</code>命令的默认操作是提取。如果解压缩文件会覆盖现有文件，它将提供几个选项：</p>
<p>也可以加上具体路径提取具体的</p>
<h1 id="使用文本"><a href="#使用文本" class="headerlink" title="使用文本"></a>使用文本</h1><p>典型文件系统中的大量文件是文本文件(text files)。文本文件仅包含文本，不包含您可能在文字处理文件中看到的额外增加的格式。</p>
<p>因为在典型的Linux系统上有许多这样的文件，所以存在大量命令来帮助用户操纵文本文件。有用于以各种方式查看和修改这些文件的命令。</p>
<p>此外，外壳程序还提供一些功能来控制命令的输出，因此可以将输出重定向到另一个文件或另一个命令中，而不是将输出放置在终端窗口中。这些重定向功能为用户提供了更加灵活和强大的工作环境。</p>
<p><code>cat</code>命令是concatenate的缩写，是一个简单但有用的命令，其功能包括创建和显示文本文件，以及合并文本文件的副本。最受欢迎的用途之一<code>cat</code>是显示文本文件的内容。要使用<code>cat</code>命令在标准输出中显示文件，请键入命令，然后输入文件名</p>
<p>尽管终端是此命令的默认输出，但是该<code>cat</code>命令也可以用于将文件内容重定向到其他文件，或者通过使用重定向字符输入另一个命令。</p>
<h2 id="Pager"><a href="#Pager" class="headerlink" title="Pager"></a>Pager</h2><p>尽管使用<code>cat</code>命令查看小文件没有问题，但对于大文件而言，这不是理想的选择。<code>cat</code>命令没有提供任何简单的方法来暂停和重新开始显示，因此整个文件内容都转储到了屏幕上。</p>
<p>对于较大的文件，请使用Pager命令来查看内容。分页器pager命令一次显示一页数据，允许您使用移动键在文件中前后移动。</p>
<p>有两种常用的Pager命令：</p>
<ul>
<li><code>less</code>命令提供了非常高级的分页功能。它通常是命令（例如<code>man</code>命令）使用的默认Pager。</li>
<li><code>more</code>自UNIX成立以来，该命令就已存在。尽管它的功能少于<code>less</code>命令，但是该<code>less</code>命令并不包含在所有Linux发行版中。该<code>more</code>命令始终可用。Use the <code>more</code> command to display the entire contents of the <code>/etc/passwd</code> file:</li>
</ul>
<p><code>more</code>和<code>less</code>命令允许用户使用按键命令文件走动。因为开发人员基于<code>less</code>命令的功能来使用<code>more</code>命令，所以该命令中可用的所有击键命令<code>more</code>也可以在<code>less</code>命令中使用。</p>
<p>我们内容的重点是更高级的<code>less</code>命令。在<code>more</code>命令<code>less</code>不可用时，该命令对于记住该命令仍然很有用。请记住，大多数击键命令都可用于这两个命令!</p>
<p>less filename</p>
<p>use the <strong>H</strong> key or <strong>Shift</strong>+<strong>H</strong> to display a help screen:</p>
<p>最常用的几个：</p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">Movement</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Spacebar</strong></td>
<td align="left">Window forward</td>
</tr>
<tr>
<td align="left"><strong>B</strong></td>
<td align="left">Window backward</td>
</tr>
<tr>
<td align="left"><strong>Enter</strong></td>
<td align="left">Line forward</td>
</tr>
<tr>
<td align="left"><strong>Q</strong></td>
<td align="left">Exit</td>
</tr>
<tr>
<td align="left"><strong>H</strong></td>
<td align="left">Help</td>
</tr>
</tbody></table>
<p>/从头开始找  ？从现在位置开始找  n下一个  shift+n 上一个</p>
<p>head和tail用来显示文件头尾，默认10行</p>
<table>
<thead>
<tr>
<th>command</th>
<th>head</th>
<th>tail</th>
</tr>
</thead>
<tbody><tr>
<td>-number</td>
<td>显示前n行</td>
<td>显示后n行</td>
</tr>
<tr>
<td>-n  -3</td>
<td>从头到倒数第三行（负值期权）</td>
<td>显示后3行</td>
</tr>
<tr>
<td>-n  (+)3</td>
<td>显示前3行</td>
<td>从第三行显示到结尾（正值期权）</td>
</tr>
</tbody></table>
<p>加上-f 选项则变成可以实时观测更改。。可以用来检查日志啥的</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>pipe <code>|</code>字符可以被用于将一个命令的输出发送到另一个。通常，当命令有输出或产生错误时，输出将显示在屏幕上。但是，并非必须如此。一条命令的输出而不是打印到屏幕上，而成为下一条命令的输入。该工具功能强大，尤其是在查找特定数据时；管道通常用于优化初始命令的结果。</p>
<p>例如<code>ls | head</code> 查看当前目录的前十个</p>
<p>可以连续使用多个管道将多个命令链接在一起。依次传输</p>
<p>nl 会将输入按行编号并显示在屏幕上</p>
<p>输出</p>
<p>STDIN STDOUT STDEER</p>
<p>I/O redirection allows the user to redirect STDIN so that <strong>data comes from a file</strong> and STDOUT/STDERR so that <strong>output goes to a file.</strong> Redirection is achieved by using the arrow <code>&lt;</code> <code>&gt;</code> characters.</p>
<p>但是<code>1&gt; 或 &gt;</code>重定向到文件会覆盖原内容，&gt;&gt;是附加</p>
<p>而STDEER的重定向是<code>2&gt;</code>，虽然它和STDOUT都默认显示在屏幕上，但是流是不一样的</p>
<p>而<code>&amp;&gt;</code>将两者同时重定向.，下面这种诡异的写法也可以定向到同一个文件</p>
<pre class="line-numbers language-none"><code class="language-none">find &#x2F;etc -name hosts &gt; find.out 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以分开放，如下所示：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">~$ ls &#x2F;fake &#x2F;etc&#x2F;ppp &gt; example.txt 2&gt; error.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>输入</p>
<p>重定向STDIN的概念很困难，因为很难理解为什么要重定向STDIN。使用STDOUT和STDERR，它们的目的很简单。有时将输出存储到文件中以备将来使用会很有帮助。</p>
<p>对于某些命令，如果您未指定文件名作为参数，则它们将恢复为使用STDIN来获取数据。例如，cat</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ cat
hello
hello
how are you?
how are you?
ctrl+c终止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tr 接受一个字符集并将它们转化为另一个字符集<code>tr &#39;a-z&#39; &#39;A-Z&#39;</code>该命令不支持跟文件</p>
<p>只能<code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt;file &gt;save</code> 可对文件进行处理</p>
<p>Most commands do accept file names as arguments, so this use case is relatively rare. </p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><em><strong>sort</strong></em></p>
<p>The <code>sort</code> command can rearrange the output based on the contents of one or more fields. Fields are determined by a field delimiter contained on each line.</p>
<p>-t 指定分界符<em>delimiter</em>（默认空格）比如按照 : 分界，就 -t:</p>
<p>-kn 指定根据哪一项排序，项间以分界符隔开</p>
<p>-n 指定排序类型为数字的</p>
<p>-r 反向排序</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ sort -t: -n -k3 mypasswd
root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash
daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin
bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin
sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin
sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用逗号可以依次指定多次排序</p>
<p>To sort first by the operating system (field #2) and then year (field #1) and then by last name (field #3), use the following command:</p>
<pre class="line-numbers language-none"><code class="language-none">sysadmin@localhost:~$ sort -t, -k2 -k1n -k3 os.csv
1991,Linux,Torvalds
1987,Minix,Tanenbaum
1970,Unix,Richie
1970,Unix,Thompson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>wc</strong></p>
<p>分别打印行数，单词数，字符数和文件名</p>
<p>如果提供了多个文件还会打印一行总的</p>
<p>-l 只显示行数   -w单词数  -c字节数</p>
<p><strong>cut</strong></p>
<p><code>cut</code>命令可以从文件或标准输入中提取文本列。它主要用于处理带分隔符的数据库文件。同样，定界文件(delimited flies)是包含由定界符分隔的列的文件。这些文件在Linux系统上非常常见。</p>
<p>-d 也是指定分界符（默认tab）</p>
<p>-f 指定范围</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ cut -d: -f1,5-7 mypasswd
root:root:&#x2F;root:&#x2F;bin&#x2F;bash
daemon:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin
bin:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin
sys:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin
sync:sync:&#x2F;bin:&#x2F;bin&#x2F;sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>-c 选项根据字符位置提取文本列-在使用固定宽度的数据库文件或命令输出时很有用。</p>
<p>The following will display just the file type (character 1), permissions (characters 2-10), a space (character 11), and filename (characters 50+):</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ ls -l | cut -c1-11,50-
total 44
drwxr-xr-x Desktop
drwxr-xr-x Documents
drwxr-xr-x Downloads
drwxr-xr-x Music
drwxr-xr-x Pictures
drwxr-xr-x Public
drwxr-xr-x Templates
drwxr-xr-x Videos
-rw-rw-r-- all.txt
-rw-rw-r-- example.txt
-rw-rw-r-- mypasswd
-rw-rw-r-- new.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>grep</strong></p>
<p><code>grep</code>命令可用于过滤文件中的行或与指定模式匹配的另一个命令的输出。该模式可以与您要匹配的确切文本一样简单，也可以通过使用正则表达式来使其更加先进。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ grep bash &#x2F;etc&#x2F;passwd
root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash
sysadmin:x:1001:1001:System Administrator,,,,:&#x2F;home&#x2F;sysadmin:&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>–color 会用红色高亮匹配到的项，上文中的bash就会变成红色</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323185628820.png"></p>
<p>-c 会显示匹配的行数而不会输出内容</p>
<p>-n会在每行前面加上原始行号</p>
<p><code>-v</code>选项反转匹配，输出不包含模式的所有行</p>
<p>-i 将忽略大小写</p>
<p>-w 会显示完全匹配该单词的，比如are只匹配are 不然会匹配ware</p>
<p><strong>可以使用基本的正则表达式，但是多了一个  <code>.</code>表示匹配单个字符！</strong></p>
<p>请注意<code>grep</code>，默认情况下该命令不会将管道识别为交替运算符。该<code>grep</code>命令实际上是将管道作为普通字符包含在要匹配的模式中。使用<code>grep -E</code>或<code>egrep</code>允许使用扩展的正则表达式，包括交替。像{3}这种东西也是需要拓展模式使用。。</p>
<h1 id="基本脚本"><a href="#基本脚本" class="headerlink" title="基本脚本"></a>基本脚本</h1><p>一个shell脚本是已被存储在一个文本文件，可执行命令的文件。运行文件时，将执行每个命令。Shell脚本可以访问Shell的所有命令，包括逻辑。因此，脚本可以测试文件的存在或寻找特定的输出并相应地更改其行为。您可以构建脚本来自动化重复的工作，这可以节省您的时间并确保每次使用脚本时的一致性。例如，如果您每天运行相同的五个命令，则可以将它们转换为shell脚本，从而将您的工作减少为一个命令</p>
<p>脚本后缀名.sh 两种运行方法：</p>
<p>1.命令 sh 文件名  2. 直接输入路径（因为很少会有脚本文件放到PATH里，所以直接引用相对路径./）</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ sh test.sh
Hello, World!
sysadmin@localhost:~$ .&#x2F;test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为很多shell都有他们各自的语法，因此很多复杂的脚本会<em><strong>指定特定的shell</strong></em>来执行本文件，他们会在第一行首先添加绝对路径，并加上前缀<code>#!</code></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;sh  也可以#!&#x2F;bin&#x2F;bash
echo &quot;Hello, World!&quot;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>The two characters <code>#!</code> are traditionally called the hash and the bang respectively, which leads to the shortened form of “shebang” when they’re used at the beginning of a script.</p>
<p>顺便说一句，shebang（或crunchbang）用于传统的shell脚本和其他基于文本的语言，如Perl，Ruby和Python。只要直接运行脚本，任何标记为可执行文件的文本文件都将在第一行中指定的解释器下运行。如果直接将脚本作为解释器的参数, 例如<code>sh script</code>或调用<code>bash script</code>，则无论shebang行中的内容如何，都将使用给定的shell。</p>
<h2 id="编辑shell脚本"><a href="#编辑shell脚本" class="headerlink" title="编辑shell脚本"></a>编辑shell脚本</h2><p>LPI Essentials教学大纲中特别提到了两个：GNU nano编辑器是一个非常简单的编辑器，非常适合编辑小文本文件。可视编辑器（<code>vi</code>或更高版本，VI改进（<code>vim</code>））是一种功能强大的编辑器，但学习曲线陡峭。我们将专注于<code>nano</code>。</p>
<p>nano filename</p>
<p><code>nano</code>编辑器的功能很少，可以助您一臂之力。您只需使用键盘输入内容，即可使用<strong>箭头键</strong>四处移动，并使用<strong>Delete</strong> / <strong>Backspace</strong>按钮删除文本。在屏幕底部，您可以看到一些可用的命令，这些命令是上下文相关的，并且会根据您的操作进行更改。如果您直接在Linux机器上，而不是通过网络进行连接，则还可以使用鼠标移动光标并突出显示文本。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Ctrl</strong> + <strong>W</strong></td>
<td align="left">搜索文件</td>
</tr>
<tr>
<td align="left"><strong>Ctrl</strong> + <strong>W</strong>，然后按<strong>Control</strong> + <strong>R</strong></td>
<td align="left">搜索并替换</td>
</tr>
<tr>
<td align="left"><strong>Ctrl</strong> + <strong>G</strong></td>
<td align="left">显示所有可能的命令</td>
</tr>
<tr>
<td align="left"><strong>Ctrl</strong> + <strong>Y</strong> / <strong>V</strong></td>
<td align="left">向上/向下翻页</td>
</tr>
<tr>
<td align="left"><strong>Ctrl</strong> + <strong>C</strong></td>
<td align="left">显示文件中的当前位置和文件的大小</td>
</tr>
<tr>
<td align="left">Ctrl+ X</td>
<td align="left">退出</td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">不退出的情况下保存</td>
</tr>
<tr>
<td align="left">Ctrl + K   +U</td>
<td align="left">剪贴本行，释放剪贴板</td>
</tr>
</tbody></table>
<p>除了运行命令之外，您还必须熟悉3个主题：</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>variable_name=value   <strong>不准有空格在 = 两边！！</strong></p>
<p>$variable_name调用</p>
<p>read命令从STDIN接受一个参数，当然也可以重定向</p>
<p>程序运行后（无论是二进制程序还是脚本程序），它将返回退出代码，该退出代码是0到255之间的整数。您可以通过<code>$?</code>变量进行测试，以查看前一个命令是否成功完成。</p>
<p><code>grep</code>命令用于在带有<code>–q</code>标志的文件中查找字符串，这意味着“安静”的<code>grep</code>，而在安静模式下运行，如果字符串被发现则返回<code>0</code>如果是<code>1</code>代表其他情况。此信息可以在条件中用于根据另一个命令的输出执行操作。</p>
<p>注释是#，保持一行，可以手动exit number 来设定退出代码</p>
<p>按照惯例，退出代码的<code>0</code>意思是“一切都OK”。任何大于该退出代码的代码<code>0</code>均表示发生了某种错误，这是该程序所特有的</p>
<p>$number表示传给脚本的第n个参数,$0是脚本名，这和c命令行argv一样，传的是字符串</p>
<h2 id="判断和分支"><a href="#判断和分支" class="headerlink" title="判断和分支"></a>判断和分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if grep -q root &#x2F;etc&#x2F;passwd; then
  echo root is in the password file
else
  echo root is missing from the password file
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>语法有点诡异，要用fi闭合</p>
<p><code>test</code>命令使您可以轻松访问比较和文件测试运算符。例如：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>test –f /dev/ttyS0</code></td>
<td align="left"><code>0</code> 如果文件存在</td>
</tr>
<tr>
<td align="left"><code>test ! –f /dev/ttyS0</code></td>
<td align="left"><code>0</code> 如果文件不存在</td>
</tr>
<tr>
<td align="left"><code>test –d /tmp</code></td>
<td align="left"><code>0</code> 如果目录存在</td>
</tr>
<tr>
<td align="left"><code>test –x </code> ‘ which ls’</td>
<td align="left">查看命令ls并判断能否被用户执行</td>
</tr>
<tr>
<td align="left"><code>test 1 –eq 1</code></td>
<td align="left"><code>0</code> 如果数值比较成功</td>
</tr>
<tr>
<td align="left"><code>test ! 1 –eq 1</code></td>
<td align="left"><code>NOT – 0</code> 如果比较失败</td>
</tr>
<tr>
<td align="left"><code>test 1 –ne 1</code></td>
<td align="left">同上，不相同返回0，其实是OP</td>
</tr>
<tr>
<td align="left"><code>test “a” = “a”</code></td>
<td align="left"><code>0</code> 如果字符串比较成功</td>
</tr>
<tr>
<td align="left"><code>test “a” != “a”</code></td>
<td align="left"><code>0</code> 如果字符串不同</td>
</tr>
<tr>
<td align="left"><code>test 1 –eq 1 –o 2 –eq 2</code></td>
<td align="left"><code>-o</code> 是OR：可以相同</td>
</tr>
<tr>
<td align="left"><code>test 1 –eq 1 –a 2 –eq 2</code></td>
<td align="left"><code>-a</code> 是AND：两者必须相同</td>
</tr>
</tbody></table>
<p><em><strong>OP是 -eq，-ne，-lt，-le，-gt，-ge的一个，分别代表</strong></em></p>
<p><em><strong>相等，不等, 小于，小于等于，大于，大于等于</strong></em></p>
<p><code>test</code> is fairly verbose for a command that gets used so frequently, so there is an alias for it called <code>[</code> (left square bracket). If you enclose your conditions in square brackets, it’s the same as running <code>test</code>. So, these statements are identical.</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if test –f &#x2F;tmp&#x2F;foo; then
if [ -f &#x2F;tmp&#x2F;foo]; then<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong>Important</strong></em></p>
<p><em><strong>There must be spaces around the square brackets. <code>[$age -lt 16]</code> would fail, but <code>[ $age -lt 16 ]</code> would work.</strong></em></p>
<p>The <code>if</code> statement has a final form that lets you do multiple comparisons at one time using <code>elif</code> (short for <code>else</code> <code>if</code>).</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

if [ &quot;$1&quot; &#x3D; &quot;hello&quot; ]; then
  echo &quot;hello yourself&quot;
elif [ &quot;$1&quot; &#x3D; &quot;goodbye&quot; ]; then
  echo &quot;nice to have met you&quot;
  echo &quot;I hope to see you again&quot;
else
  echo &quot;I didn&#39;t understand that&quot;
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有诡异的case语法</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

case &quot;$1&quot; in
hello|hi)
  echo &quot;hello yourself&quot;
  ;;
goodbye)
  echo &quot;nice to have met you&quot;
  echo &quot;I hope to see you again&quot;
  ;;
*)
  echo &quot;I didn&#39;t understand that&quot;
esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>for循环</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

for NAME in Sean Jon Isaac David; do
  echo &quot;Hello $NAME&quot;
done

for S in *; do
  echo &quot;Doing something to $S&quot;
done
&#x2F;&#x2F;Shell将*其扩展到当前目录中的所有文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>while循环</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

i&#x3D;0
while [ $i -lt 10 ]; do
  echo $i
  i&#x3D;$(( $i + 1))
done
echo “Done counting”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以直接在命令行使用</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysadmin@localhost:~$ for name in &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;hosts &#x2F;etc&#x2F;group           
&gt; do                                                                          
&gt;     wc $name                                                                
&gt; done                                                                        
  24   30 1001 &#x2F;etc&#x2F;passwd                                                    
  7  15 161 &#x2F;etc&#x2F;hosts                                                        
  46  46 561 &#x2F;etc&#x2F;group                                                        
sysadmin@localhost:~$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>seq用来生成列表。。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">for num in &#96;seq 1 12&#96;
do
          touch test$num
done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="vi基本"><a href="#vi基本" class="headerlink" title="vi基本"></a>vi基本</h2><p><code>vi</code>编辑器有两种模式：插入和命令。在插入模式下，您将文本添加到文档中。在命令模式下，可以执行导航，搜索，保存和退出编辑器之类的操作。</p>
<p>vi filename 创建或开始处理一个文本文件</p>
<p>Insert modes include: <code>i</code>, <code>I</code>, <code>a</code>, <code>A</code>, <code>o</code>, and <code>O</code>.</p>
<p>i 直接进入插入模式，a光标右移一格进入，<code>I</code>从本行首进入插入模式，A在行尾进入</p>
<p><code>o</code>  在当前行的下一行开始新的一行并进入输入模式</p>
<p>cw进入替换模式，将依次替换该单词内的字符，完成后进入普通插入</p>
<p><em><strong>大写字母既可以用大写，也可以用shift+小写代替</strong></em></p>
<p>搜索/ 和 ？ n/N用法和less一致</p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>j</code></td>
<td align="left">到下一行</td>
</tr>
<tr>
<td align="left"><code>k</code></td>
<td align="left">上一行</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">后移字符</td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left">前移字符</td>
</tr>
<tr>
<td align="left"><code>w</code></td>
<td align="left">下n个单词的开头</td>
</tr>
<tr>
<td align="left"><code>e</code></td>
<td align="left">单词的结尾</td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">前n个单词开头</td>
</tr>
<tr>
<td align="left"><code>$</code></td>
<td align="left">当前行尾</td>
</tr>
<tr>
<td align="left"><code>0</code> (zero)</td>
<td align="left">当前行首</td>
</tr>
<tr>
<td align="left"><code>3G</code></td>
<td align="left">Jumps to third line (<code>nG</code> jumps to the nth line)(要大写G)</td>
</tr>
<tr>
<td align="left"><strong>Shift</strong>+<strong>G</strong></td>
<td align="left">Jumps to the last line</td>
</tr>
<tr>
<td align="left"><code>3dw</code></td>
<td align="left">删除该光标后的第三个单词，不完整则删掉下个空格前，不加数字默认1</td>
</tr>
<tr>
<td align="left"><code>4u</code></td>
<td align="left">取消4次操作，同时该4u命令将成为上一个命令</td>
</tr>
<tr>
<td align="left"><code>14x</code></td>
<td align="left">同delete，删除，而backspace是向前移动一位</td>
</tr>
<tr>
<td align="left"><code>5X</code></td>
<td align="left">删除前面的</td>
</tr>
<tr>
<td align="left"><code>2dd</code></td>
<td align="left">删除两行</td>
</tr>
<tr>
<td align="left"><code>p P</code></td>
<td align="left">凡是最后删除或复制的都被加到黏贴栏，用u可以黏贴 P为插在光标前</td>
</tr>
<tr>
<td align="left"><code>D/d$</code></td>
<td align="left">删除从光标到行末</td>
</tr>
<tr>
<td align="left"><code>J</code></td>
<td align="left">将下一行合并到本行尾</td>
</tr>
<tr>
<td align="left"><code>yw</code></td>
<td align="left">复制当前单词</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>5~</code></td>
<td align="left">转换大小写</td>
</tr>
</tbody></table>
<p>还有保存的：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能/按键</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:x</code></td>
<td align="left">将保存并关闭文件。</td>
</tr>
<tr>
<td align="left"><code>:wq</code></td>
<td align="left">将写入文件并退出。</td>
</tr>
<tr>
<td align="left"><code>:wq!</code></td>
<td align="left">如果可能，将写入一个只读文件，然后退出。</td>
</tr>
<tr>
<td align="left"><code>ZZ</code></td>
<td align="left">将保存并关闭。请注意，<code>:</code>在这种情况下不使用冒号。</td>
</tr>
<tr>
<td align="left"><code>:q!</code></td>
<td align="left">退出而不保存更改</td>
</tr>
<tr>
<td align="left"><code>:e!</code></td>
<td align="left">放弃更改并重新加载文件</td>
</tr>
<tr>
<td align="left"><code>:w!</code></td>
<td align="left">如果可能，写为只读。</td>
</tr>
</tbody></table>
<h1 id="操作集？"><a href="#操作集？" class="headerlink" title="操作集？"></a>操作集？</h1><ol>
<li><p>variable = value创建局部变量，引用时前面加$</p>
</li>
<li><p>info里用less命令shift+H或H是移动命令列表</p>
<p>L返回当前文档，Q退出info</p>
<p>/从头开始找  ？从现在位置开始找  n下一个  shift+n 上一个</p>
</li>
<li></li>
</ol>
<h1 id="命令集"><a href="#命令集" class="headerlink" title="命令集"></a>命令集</h1><ol>
<li><p>ls 可加多个参数则依次打印</p>
<p>-l详细模式  -r 反顺序打印（默认字母顺序）ls -a 打印包括隐藏文件</p>
<p>-h == –human-readable   该<code>-h</code>选项必须与该<code>-l</code>选项一起使用。</p>
<p>-d引用当前目录 -r 递归</p>
<p>ls 在使用通配符时你可能不知道他到底显示的是哪里的文件夹，可以用 -d来显示路径而不是内容</p>
<p>-s按文件大小排序 -t按时间，大的/新的放前面</p>
<p><code>--full-time</code>选项显示完整的时间戳（包括小时，分钟，秒）。它将自动采用<code>-l</code>选项：</p>
<p>仅为创建较早的文件提供</p>
<p>ls也可查看文件信息，最好跟着 -l不然没啥用</p>
</li>
<li><p>history+5 显示最后5个指令</p>
<p>感叹号!+数字（负号倒数）来选择历史命令</p>
<p>！！执行最新</p>
<p>！+命令 为特定命令的最新迭代</p>
</li>
<li><p>echo  ascii</p>
</li>
<li><p>data / env /whoami </p>
</li>
<li><p>uname（系统名）uname -n/–nodename 显示network node hostname</p>
</li>
<li><p>clear</p>
</li>
<li><p>export / unset 设置/删除导出变量（全局）</p>
</li>
<li><p>which 查看命令路径   whereis command查看手册页位置</p>
</li>
<li><p>type </p>
</li>
</ol>
<p>   shell builtin(internal commands)</p>
<p>   路径（external commands）</p>
<p>   a is aliased to “b”(alias)</p>
<p>   -a 输出所有（因为有时会有多种）</p>
<ol start="11">
<li><p>alias 显示所有别名</p>
<p>alias a = “b” 设置别名</p>
<p>/+别名可以使别名失效</p>
</li>
<li><p>man +command</p>
<p>man -f command 显示所有包含该命令的手册(==whatis)</p>
<p>man 5 password 在5部分查看该命令</p>
<p>man -k key-words在手册页的名称和描述中搜索关键字!(==apropos)</p>
</li>
<li><p>locate 查找所有文件和目录</p>
<p>updatedb更新数据库，免得晚上才更新</p>
<p>不加参数则匹配包含字符串的，输出一堆</p>
<p>-c  显示有多少匹配</p>
<p>locate -b仅匹配包含基本名,不然目录里面的杂项都会出来</p>
<p>如果 locate -b “\….”加上破折号就是完全匹配，连后缀都没有那种</p>
</li>
<li><p>find是搜索实时文件系统，而不是静态数据库</p>
</li>
<li><p>info command    </p>
</li>
<li><p>less/more filename</p>
</li>
<li><p>cat</p>
</li>
<li><p>head和tail用来显示文件头尾，默认10行</p>
<table>
<thead>
<tr>
<th>command</th>
<th>head</th>
<th>tail</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>显示前n行</td>
<td>显示后n行</td>
</tr>
<tr>
<td>-n  -3</td>
<td>从头到倒数第三行（负值期权）</td>
<td>显示后3行</td>
</tr>
<tr>
<td>-n  (+)3</td>
<td>显示前3行</td>
<td>从第三行显示到结尾（正值期权）</td>
</tr>
</tbody></table>
<p>加上-f 选项则变成可以实时观测更改。。可以用来检查日志啥的</p>
</li>
<li><p>nl 会将输入按行编号并显示在屏幕上</p>
</li>
<li><p>tr 接受一个字符集并将它们转化为另一个字符集<code>tr &#39;a-z&#39; &#39;A-Z&#39;该命令不支持跟文件</code>只能重定向</p>
<p>只能<code>tr &#39;a-z&#39; &#39;A-Z&#39; &lt;file &gt;save</code> 可对文件进行处理</p>
</li>
<li><p>sort 排序（ASCII？？）详细在使用文本-&gt;重定向那里</p>
</li>
<li><p><strong>wc</strong></p>
<p>分别打印行数，单词数，字符数和文件名</p>
<p>如果提供了多个文件还会打印一行总的</p>
<p>-l 只显示行数   -w单词数  -c字节数</p>
</li>
</ol>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>cisco</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/03/06/git/</url>
    <content><![CDATA[<p>git init</p>
<p>git status</p>
<p>git add file</p>
<p>git commit -m “”</p>
<p>git log –oneline</p>
<p>git reflog</p>
<p>git reset –hard HEAD^(版本号)</p>
<p>HEAD^^  HEAD~100</p>
<p>git diff HEAD – file</p>
<p>查看工作区和版本库不同</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>checkout  -&gt; restore</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>
<p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage）</p>
<p> `git reset HEAD -&gt; git restore –staged</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<p>远程</p>
<p><a href="https://blog.csdn.net/zhongzunfa/article/details/80344585">这个链接告诉我们如何同步更新fork别人的库</a></p>
<p>git remote -v</p>
<p>git remote remove origin</p>
<p>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;</a>:git_username/repository_name.git</p>
<p>git pull origin main –allow-unrelated-histories</p>
<pre class="line-numbers language-none"><code class="language-none">git push -u origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>git push origin main</p>
<p>git push -u origin main -f 强制push！！</p>
<p>git clone url</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;创建 &lt;name&gt; 的分支并切换
git switch -c &lt;name&gt;

&#x2F;&#x2F;创建
git branch &lt;name&gt;

&#x2F;&#x2F;切换到&lt;name&gt;分支
git checkout &lt;name&gt;
git switch &lt;name&gt;

&#x2F;&#x2F;查看分支树
git branch 

&#x2F;&#x2F;删除分支
git branch -d &lt;name&gt;

&#x2F;&#x2F;合并分支 假设这里存在 master ， dev 分支
  &#x2F;&#x2F; 1 切换到要保留的分支——这里是master
  git checkout master
  &#x2F;&#x2F; 2 合并掉分支dev
  git merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><code>git log --graph</code>命令可以看到分支合并图</p>
]]></content>
      <categories>
        <category>basic</category>
      </categories>
  </entry>
  <entry>
    <title>css-mdn</title>
    <url>/2021/03/13/css-mdn/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h1><p>在MDN上每个属性都有单独的页面，不论你是忘记了某个属性，还是想要知道一个属性还能接受什么其它的值，这些页面都可以帮助你。</p>
<p><strong>注意</strong>：在MDN上的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference">CSS reference</a> 页面列举了所有的 CSS属性页面（同时也包括其它的CSS特性）。 另外，当你想要寻找一个CSS特性的更多内容时，多使用你的搜索引擎来搜索 “mdn <em>css-feature-name</em>“ 。例如，搜索 “mdn color” 和 “mdn font-size”！</p>
<p>查看特性的实现状态(implementation status)是非常有用的。在 MDN 上的每个属性的页面中都标有它们对应的状态，你可以通过这种方法来查看你是否可以去使用它。</p>
<p><strong>重要事项：</strong>如果属性未知或某个值对给定属性无效，则声明被视为无效，并被浏览器的CSS引擎完全忽略。</p>
<p><strong>重要：</strong>在CSS(和其他网络标准)中，当语言表达存在不确定性时，美国的拼写被视作公认的标准。例如，颜色应该始终拼写为color。colour是不起作用的。</p>
<p>虽然大多数值是相对简单的关键字或数值，但也有一些可能的值以函数的形式出现。一个例子是calc()函数。这个函数允许您在CSS中进行简单的计算，例如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">width: calc(90% - 30px);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-html" data-language="html"><code class="language-html">transform: rotate(0.8turn);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一个函数由函数名和一些括号组成，其中放置了该函数的允许值。在上面的calc()示例中，我要求此框的宽度为包含块宽度的90%，减去30像素。这不是我可以提前计算的东西，只是在CSS中输入值，因为我不知道90%会是什么。与所有值一样，MDN上的相关页面将有使用示例，这样您就可以看到函数是如何工作的。</p>
<h2 id="构建CSS"><a href="#构建CSS" class="headerlink" title="构建CSS"></a>构建CSS</h2><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E8%A7%84%E5%88%99">@规则</a></h3><p>到目前为止，我们还没有遇到 <code>@rules</code> (pronounced “at-rules”). 这是一些特殊的规则，为 CSS提供了一些关于如何表现的指导。 有些<code>@rules</code> 规则很简单，有规则名和值。例如，要将额外的样式表导入主CSS样式表，可以使用<code>@import</code>:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@import</span> <span class="token string">'styles2.css'</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>您将遇到的最常见的 <code>@rules</code> 之一是@media，它允许您使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries">媒体查询 </a>来应用CSS，仅当某些条件成立(例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时)。</p>
<p>在下面的 CSS中，我们将给 <code>&lt;body&gt;</code> 元素一个粉红色的背景色。但是，我们随后使用@media创建样式表的一个部分，该部分仅适用于视口大于30em的浏览器。如果浏览器的宽度大于30em，则背景色将为蓝色。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">&#123;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 30em<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
  <span class="token selector">body</span> <span class="token punctuation">&#123;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="速记属性"><a href="#速记属性" class="headerlink" title="速记属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_is_structured#%E9%80%9F%E8%AE%B0%E5%B1%9E%E6%80%A7">速记属性</a></h3><p>一些属性，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 等属性称为速记属性–这是因为它们允许您在一行中设置多个属性值，从而节省时间并使代码更整洁。</p>
<p><strong>Warning</strong>: One less obvious aspect of using CSS shorthand is how omitted values reset. A value not specified in CSS shorthand reverts to its initial value. This means an omission in CSS shorthand can <strong>override previously set values</strong>.</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>您选择的代码布局通常是个人偏好，尽管当您开始在团队中工作时，您可能会发现现有团队有自己的样式指南，指定要遵循的约定。　</p>
<p>如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。</p>
<p>相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个CSS选择器。</p>
<p>这样做好处多多，代表着你使用最新的CSS优化的过程中浏览器遇到无法解析的规则也不会报错。当你为一个元素指定多个CSS样式的时候，浏览器会加载样式表中的最后的CSS代码进行渲染（样式表，优先级等请读者自行了解），也正因为如此，你可以为同一个元素指定多个CSS样式来解决有些浏览器不兼容新特性的问题（比如指定两个<code>width</code>）。</p>
<p>这一特点在你想使用一个很新的CSS特性但是不是所有浏览器都支持的时候（浏览器兼容）非常有用，举例来说，一些老的浏览器不接收<code>calc()</code>(calculate的缩写，CSS3新增，为元素指定动态宽度、长度等，注意此处的动态是计算之后得一个值)作为一个值。我可能使用它结合像素为一个元素设置了动态宽度（如下），老式的浏览器由于无法解析忽略这一行；新式的浏览器则会把这一行解析成像素值，并且覆盖第一行指定的宽度。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a></li>
</ul>
<h1 id="CSS构建"><a href="#CSS构建" class="headerlink" title="CSS构建"></a>CSS构建</h1><p>开始进入真正学习</p>
<h2 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h2><p>同级后者优先</p>
<h3 id="控制继承"><a href="#控制继承" class="headerlink" title="控制继承"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E6%8E%A7%E5%88%B6%E7%BB%A7%E6%89%BF">控制继承</a></h3><p>CSS 为控制继承提供了四个特殊的通用<em><strong>属性值</strong></em>。每个css属性都接收这些值。</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inherit"><code>inherit</code></a></p>
<p>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial"><code>initial</code></a></p>
<p>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 <code>inherit</code> 。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset"><code>unset</code></a></p>
<p>将属性重置为自然值，也就是如果属性是自然继承那么就是 <code>inherit</code>，否则和 <code>initial</code>一样</p>
</li>
</ul>
<p><strong>注</strong>: 还有一个新的属性, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/revert"><code>revert</code> (en-US)</a>， 只有很少的浏览器支持。</p>
<p>CSS 的 shorthand 属性 <code>all</code> 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(<code>inherit</code>, <code>initial</code>, <code>unset</code>, or <code>revert</code>)。这是一种撤销对样式所做更改的简便方法，以便回到之前已知的起点。</p>
<p><em><strong>现在，我们将要了解层叠如何定义在不止一个元素的时候怎么应用css规则。</strong></em></p>
<p>有三个因素需要考虑，根据重要性排序如下，前面的更重要：</p>
<ol>
<li>重要程度</li>
<li>优先级</li>
<li>资源顺序</li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E8%B5%84%E6%BA%90%E9%A1%BA%E5%BA%8F">资源顺序</a></p>
<p>我们已经看到了顺序对于层叠的重要性。如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#%E4%BC%98%E5%85%88%E7%BA%A7_2">优先级</a></h3><p>一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</p>
<ol>
<li><strong>千位</strong>： 如果声明在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style"><code>style</code></a> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</li>
<li><strong>百位</strong>： 选择器中包含ID选择器则该位得一分。</li>
<li><strong>十位</strong>： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li>
<li><strong>个位</strong>：选择器中包含元素、伪元素选择器则该位得一分。</li>
</ol>
<p><strong>注</strong>: 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
<p><strong>警告:</strong> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
<p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — <code>!important</code>。</p>
<p>这是个属性值！！用于修改特定属性的值， 能够覆盖普通规则的层叠。</p>
<p><strong>注</strong>： 覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有 相同<em>优先级</em> 而且顺序靠后，或者更高优先级。</p>
<p>了解 <code>!important</code> 是为了在阅读别人代码的时候知道有什么作用。 <strong>但是，强烈建议除了非常情况不要使用它。</strong> <code>!important</code> 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难，特别是在大型样式表中。</p>
<p><em><strong>相互冲突的声明将按以下顺序适用，后一种声明将覆盖前一种声明</strong></em>：</p>
<ol>
<li>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</li>
<li>用户样式表中的常规声明(由用户设置的自定义样式)。</li>
<li>作者样式表中的常规声明(这些是我们web开发人员设置的样式)。</li>
<li>作者样式表中的<code>!important</code>声明</li>
<li>用户样式表中的<code>!important</code> 声明</li>
</ol>
<p>对于web开发人员的样式表来说，覆盖用户样式表是有意义的，因此设计可以按预期进行，但是有时用户充足的理由覆盖web开发人员样式，正如上面提到的—这可以通过在他们的规则中使用<code>!important</code>来实现。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p>
<p>但是在被组合起来以后，整个规则都会失效，无论是<code>h1</code>还是这个class都不会被样式化。</p>
<pre class="line-numbers language-none"><code class="language-none">h1, ..special &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这组选择器包含了伪类，用来样式化一个元素的特定状态。</p>
<p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">学习CSS的教程</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">类型选择器</a></td>
<td align="left"><code>h1 &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Type_selectors">类型选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通配选择器</a></td>
<td align="left"><code>* &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#The_universal_selector">通配选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a></td>
<td align="left"><code>.box &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Class_selectors">类选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID选择器</a></td>
<td align="left"><code>#unique &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#ID_Selectors">ID选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">标签属性选择器</a></td>
<td align="left"><code>a[title] &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Attribute_selectors">标签属性选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类选择器</a></td>
<td align="left"><code>p:first-child &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-class">伪类</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素选择器</a></td>
<td align="left"><code>p::first-line &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-element">伪元素</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代选择器</a></td>
<td align="left"><code>article p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Descendant_Selector">后代运算符</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">子代选择器</a></td>
<td align="left"><code>article &gt; p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Child_combinator">子代选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">相邻兄弟选择器</a></td>
<td align="left"><code>h1 + p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Adjacent_sibling">相邻兄弟</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器</a></td>
<td align="left"><code>h1 ~ p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#General_sibling">通用兄弟</a></td>
</tr>
</tbody></table>
<p>将所有类连成一串代表匹配包含所有这些类的元素</p>
<p>.a.b.c{}匹配同时含有a,b,c类的标签</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>a b<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>此处li拥有a和b类<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[*attr*]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[*attr*=*value*]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[*attr*~=*value*]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">`[<em>attr</em></td>
<td align="left">=<em>value</em>]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<p>子字符串匹配选择器</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[*attr*^=*value*]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[*attr*$=*value*]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[*attr**=*value*]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<p>普通伪类如：first-child   invaild使用 :</p>
<p><strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong></p>
<p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">::pseudo-element-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p>
<p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">li[class^="a" i]</span> <span class="token punctuation">&#123;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="“伪“"><a href="#“伪“" class="headerlink" title="“伪“"></a>“伪“</h3><p>:first-child 表示选择的对象是其父元素的首个子元素，而不是选择它的首个子元素,伪类表状态！！！</p>
<p>：：before和：：after可以使用content属性插入字符串，而无法被阅读器识别，一般插入符号</p>
<p>也可以将该伪元素设置为block，然后对其进行css修饰</p>
<p>在CSS中被叫做“生成内容”</p>
<p>这种链接伪类先后顺序被称为 <em>LVHA 顺序</em>：<code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E4%BC%AA%E7%B1%BB">参考列表</a></p>
<h3 id="关系选择"><a href="#关系选择" class="headerlink" title="关系选择"></a>关系选择</h3><p>空格-所有后代</p>
<p>‘&gt;’    -  直系儿子</p>
<p>a+b  -  b必须紧跟a后且同级，插入br都不行</p>
<p>a ~b - 选择！后面的！所有兄弟</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级****盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)<strong>。</strong>这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p>
<p>一个被定义成块级的（block）盒子会表现出以下行为:</p>
<ul>
<li><p>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</p>
</li>
<li><p>每个盒子都会换行</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</p>
</li>
<li><p>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</p>
<p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p>
</li>
</ul>
<p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p>
<ul>
<li>盒子不会产生换行。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
<p><code>inline-block</code>：</p>
<ul>
<li>盒子不会换行</li>
<li>width和height起作用</li>
<li>垂直起作用，会推开</li>
<li>水平起作用，会推开</li>
</ul>
<p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p>
<p>我们通过对盒子<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的 <strong>外部</strong> 显示类型</p>
<p>​    同样盒模型还有 <strong>内部</strong> 显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 <strong><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流</a></strong> 布局，也意味着它们和其他块元素以及内联元素一样(如上所述).</p>
<p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。 </p>
<p>​    你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px).</p>
<p>​    这种模型设定了总大小后，增加边距会压缩内容，换算时注意*2的关系</p>
<p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">the CSS Tricks article on box-sizing</a>。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">html</span> <span class="token punctuation">&#123;</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">*, *::before, *::after</span> <span class="token punctuation">&#123;</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a><strong>外边距折叠</strong></h3><p>理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h3><p>是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p>
<p>分别设置每边的宽度、颜色和样式，可以使用：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li>
</ul>
<p>设置所有边的颜色、样式或宽度，请使用以下属性：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li>
</ul>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></p>
<p>…………………….</p>
</li>
</ul>
<p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code>是像<code>&lt;span</code>&gt;一样的内联元素；你可以使用<code>display: inline-block</code>来设置内边距，让用户更容易点击链接。</p>
<p>一般直接一个border：就好啦</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>border-radius</code></strong> 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/border-radius-sh.png" alt="Images of CSS3 rounded corners: no rounding, rounding w/ an arc of circle, rounding w/ an arc of ellipse"></p>
<p>border-radius: a b 是指定a:左上+右下 b剩下俩,4个值是顺时针指定</p>
<p>然而 a/b 是分别指定椭圆的长轴和短轴</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>屏幕阅读者不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是HTML页面的一部分，而不是包含在背景中。！！！！！</p>
<p><strong>backgroung-color</strong></p>
<p><strong>background-image</strong>: 小图平铺循环  大图不会缩小（。。）</p>
<p>图像会覆盖在颜色顶部</p>
<p>控制背景平铺</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>属性用于控制图像的平铺行为。可用的值是:</p>
<ul>
<li><code>no-repeat</code> — 不重复。</li>
<li><code>repeat-x</code> —水平重复。</li>
<li><code>repeat-y</code> —垂直重复。</li>
<li><code>repeat</code> — 在两个方向重复。</li>
</ul>
<p>调整背景图像的大小</p>
<p>在上面的例子中，我们有一个很大的图像，由于它比作为背景的元素大，所以最后被裁剪掉了。在这种情况下，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。</p>
<p>你也可以使用关键字:</p>
<ul>
<li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li>
<li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li>
</ul>
<p><strong>background-position:</strong></p>
<p><strong>注意：</strong><code>background-position</code>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-x"><code>background-position-x</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-y"><code>background-position-y</code></a>的简写，它们允许您分别设置不同的坐标轴的值。</p>
<p>参数都在这：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position</a></p>
<p>有关键字：长度值.百分比，可混用</p>
<p>最后，您还可以使用4-value语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的CSS中，我们将背景从顶部调整20px，从右侧调整10px:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">&#123;</span>
  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>star.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span>
  <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>
  <span class="token property">background-position</span><span class="token punctuation">:</span> top 20px right 10px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>background-image可用于渐变背景</p>
<p><a href="https://cssgradient.io/%E7%94%9F%E6%88%90%E5%99%A8%F0%9F%91%88">https://cssgradient.io/生成器👈</a></p>
<p>也可以有多个背景图像——在单个属性值中指定多个<code>background-image</code>值，用逗号分隔每个值。</p>
<p>当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p>
<p><strong>background-attachment</strong></p>
<p><code>background-attachment: scroll</code>使元素的背景固定在<strong>页面</strong>上，以便在滚动页面时滚动。如果滚动元素内容，则背景不会移动。</p>
<p><code>background-attachment: fixed</code>导致将元素的背景固定到<strong>视口（你看到的？）</strong>，以便在滚动页面或元素内容时不会滚动。它将始终保持在屏幕上的相同位置。</p>
<p><code>background-attachment: local</code>，是CSS3的新增功能，可将元素的背景固定为实际的元素本身。因此，当滚动页面时，仅当元素这样做时，元素的背景才会随之移动（对于带有<code>position: fixed</code>。的元素则不会）。滚动元素的内容时，背景将与其一起滚动。</p>
<p>看这个很清晰。。个屁啊视口是啥</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment</a></p>
<p><code>background-clip</code> 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下</p>
<p>border-box,padding-box,content-box,text</p>
<p>background-origin</p>
<pre class="line-numbers language-none"><code class="language-none">border-box<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>背景图片的摆放以border区域为参考</p>
<pre class="line-numbers language-none"><code class="language-none">padding-box<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>背景图片的摆放以padding区域为参考</p>
<pre class="line-numbers language-none"><code class="language-none">content-box<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>背景图片的摆放以content区域为参考</p>
<h3 id="background简写"><a href="#background简写" class="headerlink" title="background简写"></a>background简写</h3><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。</p>
<p>对于所有简写属性，任何没有被指定的值都会被设定为它们的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial_value">初始值</a></p>
<ul>
<li><code>&lt;bg-size&gt;</code> 只能紧接着 <code>&lt;position&gt;</code> 出现，以”/“分割，如： “<code>center/80%</code>“.</li>
<li><code>&lt;box&gt;</code> 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。如果出现 2 次，第一次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a>，第二次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。</li>
<li><code>&lt;background-color&gt;</code> 只能被包含在最后一层！！。</li>
</ul>
<p><strong>注意:</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a> 只能在background的最后一个属性上定义，因为整个元素只有一种背景颜色。</p>
<p>其他顺序随意</p>
<h2 id="处理文本"><a href="#处理文本" class="headerlink" title="处理文本"></a>处理文本</h2><p>writing-mode</p>
<p>a-b：a可取horizontal 和vertical 代表文本方向（内联布局）</p>
<p>horizontal有tb和bt  vertical有rl和lr代表块流向（块布局）</p>
<p>我们想要的实际上是使宽和高随着书写模式一起变化。当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。</p>
<p>为了更容易实现这样的转变，CSS最近开发了一系列映射属性。这些属性用逻辑（<strong>logical</strong>）和相对变化（<strong>flow relative</strong>）代替了像宽<code>width</code>和高<code>height</code>一样的物理属性。</p>
<p>横向书写模式下，映射到<code>width</code>的属性被称作内联尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a>）——内联维度的尺寸。而映射<code>height</code>的属性被称为块级尺寸（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>），这是块级维度的尺寸。牛啊！</p>
<p><code>margin-top</code>属性的映射是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-block-start"><code>margin-block-start</code></a>——总是指向块级维度开始处的边距。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>属性映射到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-inline-start"><code>padding-inline-start</code></a>，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>属性映射到的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-block-end"><code>border-block-end</code></a>，也就是块级维度结尾处的边框。</p>
<p>挺好理解的，不需要死记</p>
<p>但此时你的物理属性仍然适用</p>
<h2 id="CSS溢出"><a href="#CSS溢出" class="headerlink" title="CSS溢出"></a>CSS溢出</h2><p>溢出是在盒子无法容纳下太多的内容的时候发生的。在这篇教程里面，你将会学习到什么是溢出，以及如何控制它。<strong>CSS中万物皆盒</strong>，因此我们可以通过给<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>（或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inline-size"><code>inline-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/block-size"><code>block-size</code></a>）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着，CSS给了你好几种工具来控制溢出</p>
<p>CSS的默认原则是“尽力减少数据损失”，所以你溢出就是溢出了。不然很难debug是吧</p>
<p>由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>默认visible  可以hidden  scroll（滚动条）</p>
<p>scroll会加x和y，只要一边可以用overflow-y : scroll</p>
<p>你可以用<code>overflow</code>属性指定x轴和y轴方向的滚动，同时使用两个值进行传递。如果指定了两个关键字，第一个对<code>overflow-x</code>生效而第二个对<code>overflow-y</code>生效</p>
<p>overflow-wrap：</p>
<p>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。</p>
<pre class="line-numbers language-none"><code class="language-none">normal 行只能在正常的单词断点处中断。（例如两个单词之间的空格）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>现代网页布局的方式（正如<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout">CSS layout</a>模块中所介绍的那些）可以很好地处理溢出。我们不一定能预料到网页上会有多少内容，人们很好地设计它们，使得它们能与这种现状协调。但是在以往，开发者会更多地使用固定高度，尽力让毫无关联的盒子的底部对齐。这是很脆弱的，在旧时的应用里面，你偶尔会遇到一些盒子，它们的内容遮到了页面上的其他内容。如果你看到了，那么你现在应该知道，这就是溢出，理论上你应该能重新排布这些布局，使得它不必依赖于盒子尺寸的调整。</p>
<p>在开发网站的时候，你应该一直把溢出的问题挂在心头，你应该用或多或少的内容测试设计，增加文本的字号，确保你的CSS可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是你仅仅在少数特别情况下需要的，例如在你确实需要一个可滚动盒子的时候。</p>
<h2 id="CSS值"><a href="#CSS值" class="headerlink" title="CSS值"></a>CSS值</h2><p>在CSS规范和MDN的属性页上，您将能够发现值的存在，因为它们将被尖括号包围</p>
<p><strong>Note</strong>: You’ll also see CSS values referred to as <em>data types</em>. The terms are basically interchangeable — when you see something in CSS referred to as a data type, it is really just a fancy way of saying value type. The term <em>value</em> refers to any particular expression supported by a value type that you choose to use.</p>
<p><strong>注意</strong>：您还将看到被称为数据类型的CSS值。这些术语基本上是可以互换的——当你在CSS中看到一些被称为数据类型的东西时，它实际上只是一种表示值的奇特方式。</p>
<p><strong>CSS中的值是一种定义允许子值集合的方法。</strong>这意味着如果您看到<code>&lt;color&gt;</code>是有效的，那么您就不需要考虑可以使用哪些不同类型的颜色值—关键字、十六进制值、<code>rgb()</code>函数等等。</p>
<p>您可能会发现自己在CSS中使用了各种数值数据类型。 以下全部归类为数值：</p>
<table>
<thead>
<tr>
<th align="left">数值类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;integer&gt;</code></td>
<td align="left"><code>&lt;integer&gt;</code>是一个整数，比如1024或-55。</td>
</tr>
<tr>
<td align="left"><code>&lt;number&gt;</code></td>
<td align="left"><code>&lt;number&gt;</code>表示一个小数——它可能有小数点后面的部分，也可能没有，例如0.255、128或-1.2。</td>
</tr>
<tr>
<td align="left"><code>&lt;dimension&gt;</code></td>
<td align="left"><code>&lt;dimension&gt;</code>是一个<code>&lt;number&gt;</code>，它有一个附加的单位，例如45deg、5s或10px。<code>&lt;dimension&gt;</code>是一个<strong>伞形类别</strong>，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td>
</tr>
<tr>
<td align="left"><code>&lt;percentage&gt;</code></td>
<td align="left"><code>&lt;percentage&gt;</code>表示一些其他值的一部分，例如50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td>
</tr>
</tbody></table>
<h3 id="长度length"><a href="#长度length" class="headerlink" title="长度length"></a>长度length</h3><p>以下都是<strong>绝对</strong>长度单位——它们与其他任何东西都没有关系，通常被认为总是相同的大小。</p>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">名称</th>
<th align="left">等价换算</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cm</code></td>
<td align="left">厘米</td>
<td align="left">1cm = 96px/2.54</td>
</tr>
<tr>
<td align="left"><code>mm</code></td>
<td align="left">毫米</td>
<td align="left">1mm = 1/10th of 1cm</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">四分之一毫米</td>
<td align="left">1Q = 1/40th of 1cm</td>
</tr>
<tr>
<td align="left"><code>in</code></td>
<td align="left">英寸</td>
<td align="left">1in = 2.54cm = 96px</td>
</tr>
<tr>
<td align="left"><code>pc</code></td>
<td align="left">十二点活字</td>
<td align="left">1pc = 1/16th of 1in</td>
</tr>
<tr>
<td align="left"><code>pt</code></td>
<td align="left">点</td>
<td align="left">1pt = 1/72th of 1in</td>
</tr>
<tr>
<td align="left"><code>px</code></td>
<td align="left">像素</td>
<td align="left">1px = 1/96th of 1in</td>
</tr>
</tbody></table>
<p>这些值中的大多数在用于打印时比用于屏幕输出时更有用。例如，我们通常不会在屏幕上使用cm。惟一一个您经常使用的值，估计就是px(像素)</p>
<p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了web开发中一些最有用的单位。</p>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">相对于</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>em</code></td>
<td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td>
</tr>
<tr>
<td align="left"><code>ex</code></td>
<td align="left">字符“x”的高度</td>
</tr>
<tr>
<td align="left"><code>ch</code></td>
<td align="left">数字“0”的宽度</td>
</tr>
<tr>
<td align="left"><code>rem</code></td>
<td align="left">根元素的字体大小</td>
</tr>
<tr>
<td align="left"><code>lh</code></td>
<td align="left">元素的line-height</td>
</tr>
<tr>
<td align="left"><code>vw</code></td>
<td align="left">视窗宽度的1%</td>
</tr>
<tr>
<td align="left"><code>vh</code></td>
<td align="left">视窗高度的1%</td>
</tr>
<tr>
<td align="left"><code>vmin</code></td>
<td align="left">视窗较小尺寸的1%</td>
</tr>
<tr>
<td align="left"><code>vmax</code></td>
<td align="left">视图大尺寸的1%</td>
</tr>
</tbody></table>
<p>ems and rems</p>
<p><code>em</code>和<code>rem</code>是您在从框到文本调整大小时最常遇到的两个相对长度。</p>
<p><strong>概括地说，在排版属性中 em 单位的意思是“父元素的字体大小”</strong>。</p>
<p><strong>概括地说，rem单位的意思是“根元素的字体大小”</strong>。</p>
<p><strong>百分比</strong></p>
<p>百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p>
<p>注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。您可以在MDN属性引用页面上看到它能接受哪些值。如果允许的值包括<code>&lt;length-percent&gt;</code>，则可以使用长度或百分比。如果允许的值只包含<length>，则不可能使用百分比。</p>
<h3 id="颜色color"><a href="#颜色color" class="headerlink" title="颜色color"></a>颜色color</h3><p>在CSS中指定颜色的方法有很多，其中一些是最近才实现的。在CSS中，相同的颜色值可以在任何地方使用，无论您指定的是文本颜色、背景颜色还是其他颜色。</p>
<p><strong>颜色关键词</strong></p>
<p>是一种指定颜色的简单易懂的方式。有一些关键词，其中一些有相当有趣的名字！您可以在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">这里</a>看到 <code>&lt;color&gt;</code>值的完整列表。</p>
<p><strong>十六进制RGB值</strong></p>
<p>每两个值表示一个通道（channels）—红色、绿色和蓝色—并允许我们为每个通道指定256个可用值中的任意一个(16 x 16 = 256)。#128a7d;</p>
<p><strong>RGB和RGBA值</strong></p>
<p>RGB值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似</p>
<p>您还可以使用RGBA颜色——它们的工作方式与RGB颜色完全相同，因此您可以使用任何RGB值，但是有第四个值表示颜色的alpha通道，它控制不透明度。如果将这个值设置为<code>0</code>，它将使颜色完全透明（默认0），而设置为<code>1</code>将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p>
<p><strong>注意</strong>: 在颜色上设置alpha通道与使用我们前面看到的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>属性有一个关键区别。当你使用不透明度时，你让元素和它里面的所有东西都不透明，而使用RGBA颜色只让你指定的颜色不透明。</p>
<p><strong>HSL和HSLA值</strong></p>
<p>与RGB相比，HSL颜色模型的支持稍差一些(在旧版本的IE中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分1670万种颜色：</p>
<ul>
<li><strong>色调</strong>： 颜色的底色。这个值在0和360之间，表示色轮周围的角度。</li>
<li><strong>饱和度</strong>： 颜色有多饱和？ 它的值为0 - 100%，其中0为无颜色(它将显示为灰色阴影)，100%为全色饱和度</li>
<li><strong>亮度</strong>：颜色有多亮？ 它从0 - 100%中获取一个值，其中0表示没有光(它将完全显示为黑色)，100%表示完全亮(它将完全显示为白色)</li>
</ul>
<p>HSLA类似RGBA</p>
<h3 id="其他value"><a href="#其他value" class="headerlink" title="其他value"></a>其他value</h3><p><code>&lt;image&gt;</code> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code>函数指向的实际图像文件，也可以是一个渐变。<a href="https://cssgradient.io/">https://cssgradient.io/</a></p>
<p><code>&lt;position&gt;</code> 数据类型表示一组2D坐标，用于定位一个元素，如背景图像(通过 <code>background-position</code>)。它可以使用关键字(如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, 以及<code>center</code> )将元素与2D框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p>
<p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 <code>center</code>。</p>
<h3 id="字符串vs标识符"><a href="#字符串vs标识符" class="headerlink" title="字符串vs标识符"></a>字符串vs标识符</h3><p>我们看到关键字被用作值的地方(例如<code>&lt;color&gt;</code>关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个CSS可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。</p>
<p>在某些地方可以使用CSS中的字符串，例如 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#Generating_content_with_before_and_after">在指定生成的内容时</a>。content比如</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>我们将查看的最后一种类型的值是一组称为函数的值。在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与JavaScript、Python或c++等语言相关联，但它们也以属性值的形式存在于CSS中。我们已经在颜色部分看到了函数的作用——<code>rgb()</code>、<code>hsl()</code>等。用于从文件返回图像的值——<code>url()</code>——也是一个函数。</p>
<p>行为更类似于传统编程语言的值是<code>calc()</code>函数。这个函数使您能够在CSS中进行简单的计算。如果您希望计算出在为项目编写CSS时<strong>无法定义的值</strong>，并且需要浏览器在运行时为您计算出这些值，那么它特别有用。直接把参数表达式按照正常表达式输入就好了</p>
<p>你可以看看所有不同类型的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Values_and_Units">CSS的值和单位</a> 参考页面</p>
<h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>在受CSS设置影响之前，HTML元素有其原始的尺寸。一个直观的例子就是图像。一副图像的长和宽由这个图像文件自身确定。这个尺寸就是<strong>固有尺寸</strong>。</p>
<p>一个空的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div">``</a>是没有尺寸的。如果你在你的HTML文件中添加一个空&lt;div&gt;并给予其边框（就像刚才我们为图像做的那样），你会在页面上看到一条线。这是边框被压缩后的效果— 它内部没有内容。边框宽度扩展到整个容器宽度，因为它是块级元素，而块级元素的行为就是这样的。它没有高度，或者说高度为0，因为内部没有内容。</p>
<p><strong>再强调一次，这就是元素的固有尺寸 — 由其所包含的内容决定。</strong></p>
<p><strong>我们当然可以给设计中的元素指定具体大小。 当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为外部尺寸</strong></p>
<h3 id="百分数"><a href="#百分数" class="headerlink" title="百分数"></a>百分数</h3><p>当使用百分数时，你需要清楚，它是<strong>什么</strong>东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。</p>
<p>这是因为百分数是以包含盒子的块为根据解析的。如果我们的<code>&lt;div&gt;</code>没有被指定百分数的值，<strong>那么它会占据100%的可用空间</strong>，因为它是块级别的元素。如果我们给了它一个百分数作为宽度，那么这就是它原来情况下可以占据空间的百分数。</p>
<p>例如，你也许会希望上下的外边距是元素高的一个百分数，左右外边距是元素宽的百分数。但是，情况不是这样的！</p>
<p>当你用百分数设定内外边距的时候，值是以<strong>内联尺寸</strong>进行计算的，也即对于左右书写的语言来说的宽度。在我们的例子里面，所有的内外边距是这一宽度的10%，也就是说，你可以让盒子周围的内外边距大小相同。在你以这种方式使用百分数的时候，这是一个需要记住的事实。</p>
<h3 id="min-和max"><a href="#min-和max" class="headerlink" title="min-和max-"></a>min-和max-</h3><p>除了让万物都有一个确定的大小以外，我们可以让CSS给定一个元素的最大或最小尺寸。如果你有一个包含了变化容量的内容的盒子，而且你总是想让它<strong>至少</strong>有个确定的高度，你应该给它设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。</p>
<p>max-width 属性用来给元素设置最大宽度值. 定义了max-width的元素会在达到max-width值之后避免进一步按照width属性设置变大.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> 会覆盖<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>设置, 但 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-width"><code>min-width</code></a>设置会覆盖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a></p>
<p>如果你使用了<code>max-width: 100%</code>，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的100%。</p>
<p>如果你设定一个图像的属性为<code>width: 100%</code>，而且它的原始宽度小于容器，图像会被强制拉伸以变大</p>
<p>这个技术是用来让图片<strong>可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。你无论怎样都不应该用这个技术先载入大原始尺寸的图片，再对它们在浏览器中进行缩放。图像应该合适地调整尺寸，以使它们不会比预计中展示时所需要的最大尺寸大。下载过大的图像会造成你的网站变慢，如果用户使用按量收费的网络连接，会让用户花更多钱。</p>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口，即你在浏览器中看到的部分页面，也是有尺寸的。在CSS中，我们有与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。<code>1vh</code>等于视口高度的1%，<code>1vw</code>则为视口宽度的1%.</p>
<h2 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h2><p>图像和视频被描述为**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">替换元素</a>**。 这意味着CSS不能影响这些元素的内部布局-仅影响它们在页面上于其他元素中的位置。 但是，正如我们将看到的，CSS可以对图像执行多种操作。</p>
<p>某些替换元素（例如图像和视频）也被描述为具有宽高比。 这意味着它在水平（x）和垂直（y）尺寸上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。</p>
<p>object-fit 你可以使用关键字:</p>
<ul>
<li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li>
<li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li>
<li><code>fill</code>–调整比例以适应盒子</li>
</ul>
<p>如果你是按顺序读这些课，那么你可能还没有看到布局的部分，只要记住替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为，这很必要，避免了他们被布局奇怪地拉伸。</p>
<pre class="line-numbers language-none"><code class="language-none">width: 100%;
height: 100%;&#x2F;&#x2F;要拉伸的话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>正如在本教程的HTML部分的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Styling_web_forms">form styling</a>课里解释的那样，许多更加复杂的输入类型是由操作系统渲染的，无法进行样式化。因而你应该总是假设表单在不同的访客看来十分不同，并在许多浏览器上测试复杂的表单。</p>
<h3 id="文本输入元素"><a href="#文本输入元素" class="headerlink" title="文本输入元素"></a>文本输入元素</h3><p>允许文本输入的元素，例如<code>&lt;input type=&quot;text&quot;&gt;</code>，特定的类型例如<code>&lt;input type=&quot;email&quot;&gt;</code>以及<code>&lt;textarea&gt;</code>元素，是相当容易样式化的，它们会试图表现得和在你的页面上其他盒子一样。不过这些元素默认的样式化方式会改变，取决于你的用户访问站点时所使用的操作系统和浏览器。</p>
<p>在一些浏览器中，表单元素默认不会继承字体样式，因此如果你想要确保你的表单填入区域使用body中或者一个父元素中定义的字体，你需要向你的CSS中加入这条规则。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">button,
input,
select,
textarea</span> <span class="token punctuation">&#123;</span>
  <span class="token property">font-family</span> <span class="token punctuation">:</span> inherit<span class="token punctuation">;</span>
  <span class="token property">font-size</span> <span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h2><p>通常情况下，表列的尺寸会根据所包含的内容大小而变化，这会产生一些奇怪的结果。通过 <code>table-layout: fixed</code>，您可以根据<strong>列标题的宽度来规定列的宽度</strong>，然后适当地处理它们的内容。整个列宽度与列标题的宽度是一样的，这是一种很好的设定表列尺寸的方式。Chris Coyier在<a href="https://css-tricks.com/fixing-tables-long-strings/">Fixed Table Layouts</a>中更详细地讨论了这一技术。</p>
<ul>
<li>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a>属性的<code>collapse</code>值对于任何表样式的工作来说都是一个标准的最佳实践。默认情况下，当您在表元素上设置边框时，它们之间将会有间隔，如下图所示：<img src="https://mdn.mozillademos.org/files/13068/no-border-collapse.png" alt="img">这看起来不太好(虽然可能是你想要的样子，谁知道呢?)。使用 <code>border-collapse: collapse;</code> ，让边框合为一条，现在看起来好多了：<img src="https://mdn.mozillademos.org/files/13066/border-collapse.png" alt="img"></li>
</ul>
<p>collapese是共享边框，separate是传统模式，各自拥有边框，边框间的距离通过CSS属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-spacing"><code>border-spacing</code></a> 来确定的</p>
<ul>
<li>我们在整个表设置了一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>，这是必要的，因为我们将在表页眉和页脚后面设置一些边框——当你在表格外面没有一个边界而且以空隙结尾的时候，它看起来很奇怪，而且是不连贯的。</li>
<li>我们在《th》和《td》元素上设置了一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>——这些元素使数据项有了一些空间，使表看起来更加清晰。</li>
<li>用letter-spaceing属性设置字体间距</li>
</ul>
<pre class="line-numbers language-选择标题位置" data-language="选择标题位置"><code class="language-选择标题位置">caption-side: bottom;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="调试CSS"><a href="#调试CSS" class="headerlink" title="调试CSS"></a>调试CSS</h2><p>善用web开发者工具，审查元素并修改值，选择满意的代码copy掉，查看同时应用的选择器并比较优先级，可以先放到检测网站检验，浏览器的支持性，</p>
<p>如果上述步骤未能解决问题，则您需要做更多调查。 此时最好的做法是创建一个称为简化测试用例的东西。</p>
<p><em><strong>创建一个简化测试用例:</strong></em></p>
<ol>
<li>如果您的标记是动态生成的（例如通过 CMS），请生成显示该问题的静态版本。 诸如 CodePen 之类的代码共享站点可用于托管简化的测试用例，因为它们可以在线访问，并且您可以轻松地与同事共享它们。 您可以先在页面上执行“查看源代码”，然后将 HTML 复制到 CodePen 中，然后获取所有相关的 CSS 和 JavaScript 并将其包括在内。 之后，您可以检查问题是否仍然明显。</li>
<li>如果删除 JavaScript 不能解决问题，请不要包含 JavaScript。 如果删除 JavaScript 确实消除了问题，那么请尽可能多地删除与问题无关的 JavaScript，保留导致问题的原因。</li>
<li>删除所有不会导致此问题的 HTML。 删除布局中的组件甚至主要元素。 在保留问题可重现的情况下把代码量尽量减少。</li>
<li>删除掉任何不影响问题的 CSS。</li>
</ol>
<p>在执行此操作的过程中，您可能会发现导致问题的原因，或者至少能够通过删除特定的东西来打开和关闭它。 当发现一些东西时，应该在代码中添加一些注释。 如果您需要帮助，这些注释将向帮助您的人显示您已经做了哪些尝试。 这很可能会为您提供足够的信息，以便能够搜索可能存在的问题和解决方法。</p>
<h2 id="组织CSS"><a href="#组织CSS" class="headerlink" title="组织CSS"></a>组织CSS</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>如果你在和一个小组共同协作完成一个已有的项目，需要检查的第一件事是这一项目是否已经有了CSS的代码风格规范。小组的代码风格规范应当总是优先于的个人喜好。做事情很多时候没有对错之分，但是统一是很重要的。</p>
<p>例如你可以看下<a href="https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/CSS">MDN的CSS代码规范的示例。 (en-US)</a>.（偏教学）</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在你的样式表里面的逻辑段落之间，加入一块注释，是个好技巧。在你快速掠过的时候，这些注释可以帮你快速定位不同的段落，甚至给了你搜索或者跳转到那段CSS的关键词。如果你使用了一个不存在于代码里面的字符串，你可以从段落到段落间跳转，只需要搜索一下，下面我们用的是<code>||</code>。</p>
<p>你不必在你的CSS中给每个东西都加上注释，因为它们很多都是自解释的。你应该加上注释的是那些你因为某些原因做的特殊决定。</p>
<h3 id="逻辑段落"><a href="#逻辑段落" class="headerlink" title="逻辑段落"></a>逻辑段落</h3><p><em><strong>根据你html的布局逻辑用注释分块，在相应的块中添加CSS元素！</strong></em></p>
<h3 id="避免太特定的选择器"><a href="#避免太特定的选择器" class="headerlink" title="避免太特定的选择器"></a>避免太特定的选择器</h3><p>这样会导致在需要复用时复制粘贴，造成代码冗长</p>
<h3 id="分成几个小样式表"><a href="#分成几个小样式表" class="headerlink" title="分成几个小样式表"></a>分成几个小样式表</h3><p>尤其在你对站点的不同部分设置了很不同的样式的时候，你会想要有个包含了所有普适规则的样式表，还有包含了某些段落所需要的特定规则的更小的样式表。你可以将一个页面连接到多个样式表，层叠的一般规则会在这里生效，即连接的靠前的样式表里面的规则会比后面的有更高优先级。</p>
<p>例如我们会将我们站点的一部分作为一个在线商店，许多CSS只会用于样式化商店需要的产品列表和表单。将这些东西放在另外一张样式表里面，只在商店页面进行连接，这会是合理的做法。</p>
<p>这可以让你更容易保持CSS的组织性，也意味着如果有多人在写CSS，你会更少遇到有两个人需要同时编写相同的样式表的情况，防止在源代码的控制上产生冲突。</p>
<h3 id="OOCSS"><a href="#OOCSS" class="headerlink" title="*OOCSS"></a>*OOCSS</h3><p>你会遇到的大多数方式都有一部分归功于面向对象的CSS（OOCSS）的概念，这是一种因<a href="https://github.com/stubbornella/oocss/wiki">Nicole Sullivan的努力</a>而流行的方式。OOCSS的基本理念是将你的CSS分解成可复用的对象，于是你可以在你的站点上任何需要的地方使用。OOCSS的标准示例是在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Media_objects">The Media Object</a>中所描述的排布。这一排布一方面让图片、视频或者其他元素保持固定尺寸，而另一方面也让其他内容可伸缩。这是我们在用于评论、列表等网站随处可见的排布。</p>
<p>Nicole Sullivan在描述这种方式和推广上所做的工作导致，即使是那些不严格遵守OOCSS方式的人，今天也可以大致以这种方式复用CSS，它已经普遍地进入到我们的理解当中，成为了与事物交互的好办法。</p>
<h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p>BEM即为块级元素修饰字符（Block Element Modifier）。在BEM中，一个块，例如一个按钮、菜单或者标志，就是独立的实体。一个元素就像一个列表项或者标题一样，被绑定到它所在的块。修饰字符是标记到一个块或者元素的标识，能够改变样式或者行为。你能认出使用BEM的代码，因为代码中在CSS的类里使用了多余的一个下划线和连字符</p>
<p>增加的类和应用到OOCSS例子里面的相似，但是它们遵守了BEM严格的命名常规。</p>
<p>BEM在大些的Web项目中被广泛使用，许多人用这种方式写他们的CSS。你可能会在没有提及为何CSS如此布局的时候，遇到BEM语法的例子，甚至是在教程中</p>
<h3 id="CSS构建体系"><a href="#CSS构建体系" class="headerlink" title="CSS构建体系"></a>CSS构建体系</h3><p>另一种组织CSS的方法是利用一些对于前端开发者可用的工具，它们让你可以稍微更程式化地编写CSS。有很多工具，我们将它们分成<strong>预处理工具</strong>和<strong>后处理工具</strong>。预处理工具以你的原文件为基础运行，将它们转化为样式表；后处理工具使用你已完成的样式表，然后对它做点手脚——也许是优化它以使它加载得更快。</p>
<p>使用这些工具的任何一部分都需要你的开发环境能运行进行处理工作的脚本。许多代码编辑器能为你做这项工作，或者你也可以安装一个命令行工具来辅助工作。</p>
<p>最为流行的预处理工具是<a href="https://sass-lang.com/">Sass</a>，这里不是Sass的教程，所以我只会简要地解释一些Sass能做的事情，在组织的时候真的会帮到你，即使你没有用到Sass的任何其他的独特功能。</p>
<h3 id="CSS自定义属性！"><a href="#CSS自定义属性！" class="headerlink" title="CSS自定义属性！"></a>CSS自定义属性！</h3><p>通过在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a> 伪类上设置自定义属性，然后在整个文档需要的地方使用</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">:root</span> <span class="token punctuation">&#123;</span>
  <span class="token property">--main-bg-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在属性里用var（–xxx）使用，如：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--main-bg-color<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意，这些是自定义属性，并不是你在其他编程语言中遇到的实际的变量。这些值仅当需要的时候才会计算，而并不会按其他规则进行保存。比如，你不能为元素设置一个属性，然后让它从兄弟或旁支子孙规则上获取值。属性仅用于匹配当前选择器及其子孙，这和通常的CSS是一样的。</p>
<p>可以指定备用值</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--my-var<span class="token punctuation">,</span> <span class="token function">var</span><span class="token punctuation">(</span>--my-background<span class="token punctuation">,</span> pink，blue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>本例展示了如何处理一个以上的 fallback。该技术可能会导致性能问题，它花了更多的时间在处理这些变量上。</p>
<p>像<a href="https://www.w3.org/TR/css-variables/#custom-property">自定义属性</a>这些 fallback 语法允许使用逗号。比如 <code>var(--foo, red, blue)</code> 定义了一个 <code>red, blue</code> 的备用值——从第一个逗号到最后的全部内容，都会被作为备用值的一部分。</p>
<p>当浏览器遇到无效的 <code>var()</code> 时，会使用继承值或初始值代替。</p>
<p>在 JavaScript 中获取或者修改 CSS 变量和操作普通 CSS 属性是一样的：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 获取一个 Dom 节点上的 CSS 变量</span>
element<span class="token punctuation">.</span>style<span class="token punctuation">.</span><span class="token function">getPropertyValue</span><span class="token punctuation">(</span><span class="token string">"--my-var"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="样式化文本"><a href="#样式化文本" class="headerlink" title="样式化文本"></a>样式化文本</h2><h1 id="以后要补"><a href="#以后要补" class="headerlink" title="以后要补"></a>以后要补</h1><h2 id="OOCSS-BEM"><a href="#OOCSS-BEM" class="headerlink" title="OOCSS/BEM"></a>OOCSS/BEM</h2><h2 id="css层叠"><a href="#css层叠" class="headerlink" title="css层叠"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade#origin_of_css_declarations">css层叠</a></h2><h2 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">外边距重叠</a></h2><h2 id="视口-视口概念-CSS（层叠样式表）-MDN-mozilla-org"><a href="#视口-视口概念-CSS（层叠样式表）-MDN-mozilla-org" class="headerlink" title="[视口](视口概念 - CSS（层叠样式表） | MDN (mozilla.org))"></a>[视口](<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Viewport_concepts">视口概念 - CSS（层叠样式表） | MDN (mozilla.org)</a>)</h2><h2 id="样式化表单"><a href="#样式化表单" class="headerlink" title="样式化表单"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Images_media_form_elements">样式化表单</a></h2><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a><a href="https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector#how_to">开发者工具</a></h2>]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>html-mdn</title>
    <url>/2021/03/11/html-mdn/</url>
    <content><![CDATA[<h1 id="HTML基础排版"><a href="#HTML基础排版" class="headerlink" title="HTML基础排版"></a>HTML基础排版</h1><p>[toc]</p>
<h2 id="html简介和语义"><a href="#html简介和语义" class="headerlink" title="html简介和语义"></a>html简介和语义</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Chris Mills<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
&lt;meta name="description" content="The MDN Web Docs Learning Area。。。这是搜索引擎显示的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><a href="http://ogp.me/">Open Graph Data</a>是Facebook发明的一种元数据协议，旨在为网站提供更丰富的元数据</p>
<p>可以通过以下方式将收藏夹图标添加到您的页面：</p>
<ol>
<li><p>将其保存在与网站的索引页相同的目录中，并以<code>.ico</code>格式保存（大多数浏览器将以更常见的格式（例如<code>.gif</code>或）支持网站<code>.png</code>图标，但使用ICO格式将确保其可追溯至Internet Explorer6。）</p>
</li>
<li><p>将以下行添加到您的HTML</p>
<p><code>&lt;head&gt;</code></p>
<p>块中以引用它：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>shortcut icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>favicon.ico<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/x-icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<p>在外部示例中，我们使用一种更现代的JavaScript功能来解决问题，即<code>defer</code>属性，该属性告诉浏览器<code>&lt;script&gt;</code>在到达tag元素后继续下载HTML内容。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>script.js<span class="token punctuation">"</span></span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在这种情况下，脚本和HTML将同时加载，并且代码将起作用。</p>
<p><strong>注意</strong>：在外部情况下，我们不需要使用<code>DOMContentLoaded</code>事件，因为该<code>defer</code>属性为我们解决了问题。<code>defer</code>对于内部JavaScript示例，我们没有使用该解决方案，因为它<code>defer</code>仅适用于外部脚本。</p>
<p>这个问题的老式解决方案曾经是将脚本元素放在正文的底部（例如，紧接在<code>&lt;/body&gt;</code>标记之前），以便在解析所有HTML之后将其加载。该解决方案的问题在于，脚本的加载/解析被完全阻止，直到HTML DOM被加载为止。在具有许多JavaScript的大型网站上，这可能会导致严重的性能问题，从而降低您的网站速度。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en-US<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--设置文档主要语言--></span>zh-Hans （简体中文）zh-CN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>html重要的是含义！</p>
<p>em强调</p>
<p>strong特别重要</p>
<ul>
<li>i&gt;用于传达传统上由斜体表示的含义：外来词，分类名称，技术术语，思想…</li>
<li>b&gt;用于传达传统上由粗体表示的含义：关键字，产品名称，主句…</li>
<li>u&gt;用于传达传统上由下划线传达的含义：专有名称，拼写错误…</li>
</ul>
<p>关于下划线的一种警告：<strong>人们将下划线与超链接紧密关联。</strong>因此，在Web上，最好仅对链接加下划线。在<code>&lt;u&gt;</code>语义上适当时使用该元素，但请考虑使用CSS将默认下划线更改为Web上更合适的内容。</p>
<h2 id="html超链接"><a href="#html超链接" class="headerlink" title="html超链接"></a>html超链接</h2><p>href：’url’</p>
<p>title：提醒，当鼠标hover时显示</p>
<p>在a&gt;标签中加入别的元素可使用区块级链接，省略url则是当前网站</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.mozilla.org/en-US/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mozilla-image.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mozilla logo that links to the mozilla homepage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在src后紧跟选择器可以选择链接道文件片段</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>contacts.html#Mailing_address<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token comment">&lt;!-->链接到id是Mailing_address的地方&lt;/--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em><strong>好的</strong>连结文字：</em><a href="https://firefox.com/">下载Firefox</a></p>
<p><em><strong>不好的</strong>连结文字：</em><a href="https://firefox.com/">点这里</a>来下载Firefox</p>
<ul>
<li><p>让你的连结越短越好— 太长的连结会使萤幕阅读器的使用者蒙受其害，因为他们必须从头听到尾。</p>
</li>
<li><p>尽量让连结的文字不一样，太多重复的连结文字会带给萤幕阅读器的使用者麻烦，因为他们可能会从一个连结表中选择连结，因此若有许多重复的「点这里」会让他们相当困惑。</p>
</li>
<li><p>尽可能使用相对连接来增强代码可读性和效率</p>
</li>
<li><p>连接到非HTML资源时要说明</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.example.com/large-report.pdf<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  下載銷售報告(PDF, 10MB)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.example.com/car-game<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  遊玩賽車遊戲(需要 Flash)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>当你连结一个需要下载的资源时，你可以使用<code>download</code>属性来提供一个预设的储存档名。以下范例是最新版的Windows版Firefox的下载连结：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=en-US<span class="token punctuation">"</span></span>
   <span class="token attr-name">download</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firefox-latest-64bit-installer.exe<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  下載Windows上的最新版Firefox (64-bit) (English, US)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>你可以建立一个连结或按钮，使得它被点击之后，开启一个正在撰写中的电子邮件讯息。这可以透过<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a">``</a>元素和<code>mailto:</code>URL scheme来达成。</p>
<p>多数情况<code>mailto:</code>会填入收信人的电子邮件地址。例如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mailto:nowhere@mozilla.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Send email to nowhere<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>你可以建立一个连结或按钮，使得它被点击之后，开启一个正在撰写中的电子邮件讯息。这可以透过<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a">``</a>元素和<code>mailto:</code>URL scheme来达成。</p>
<p>多数情况<code>mailto:</code>会填入收信人的电子邮件地址。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;mailto:nowhere@mozilla.org&quot;&gt;Send email to nowhere&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>它的结果会像是这样：<a href="mailto:nowhere@mozilla.org">Send email to nowhere</a>。</p>
<p>事实上，电子邮件地址是选填的。如果你将它留空(也就是说，你的<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/a#attr-href"><code>href</code></a>只写了”mailto:”)，使用者的mail client会开启一个寄信视窗，其中并没有指定收信人，这在使用「分享」连结时非常有用，使用者可以自行决定要寄给谁。</p>
</li>
<li><p>除了电子邮件地址之外，你还可以提供其他资讯，事实上，任何标准的邮件标头栏位都能被加到 <code>mailto</code>URL中，常见的有主旨(subject)、副本(cc)以及主体(body) (这个虽然不是真的标头栏位，但能让你放一条简短的讯息在新邮件的主体中)。每个栏位与它的值被定义成一组查询项(query term)。</p>
<p>下面是一个包含cc、bcc(密件副本)、subject 和body 的范例：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mailto:nowhere@mozilla.org?cc=name2@rapidtables.com&amp;bcc=name3@rapidtables.com&amp;subject=The%20subject%20of%20the%20email&amp;body=The%20body%20of%20the%20email<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  Send mail with cc, bcc, subject and body
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>**Note:**每一个栏位的值必须以URL编码，也就是将空白及不可印字元(不可见的字元如缩排(tabs)、回车(carriage return )、换页(page breaks)等等)转换成<a href="http://en.wikipedia.org/wiki/Percent-encoding">百分号编码</a>。也请注意这里使用问号( <code>?</code>)来分隔主要URL和其他栏位；以&amp;来分隔<code>mailto:</code>URL中的不同的栏位，这是标准的URL查询记号(query notation)。你可以阅读<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data#the_get_method">GET方法</a>来得知有那些常用的查询记号。</p>
</li>
</ul>
<h2 id="html高级文本"><a href="#html高级文本" class="headerlink" title="html高级文本"></a>html高级文本</h2><ul>
<li><p>说明列表使用与其他列表类型不同的包装器- <dl>另外，每个术语都包装在<dt>（描述术语）元素中，每个描述都包装在<dd>（描述描述）元素中。</p>
</li>
<li><p>Quatation（块）</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span> <span class="token attr-name">cite</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>HTML <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span>blockquote<span class="token entity named-entity" title="&gt;">&amp;gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> Element<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span> (or <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>HTML Block
  Quotation Element<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span>) indicates that the enclosed text is an extended quotation.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>表明引用自cite所示网页</p>
<p>Browser default styling will render this as an indented paragraph, as an indicator that it is a quote;</p>
</li>
<li><p>Quatation（inline）</p>
<p>replace blockquote with q</p>
<p>Browser default styling will render this as normal text put in quotes to indicate a quotation</p>
<p>由于cite属性并没有提供什么链接功能，需要我们自己最好提供链接，有效的方法是将cite标签嵌套于a标签内</p>
</li>
<li><p><abbr>— this is used to wrap around an abbreviation or acronym, and provide a full expansion of the term (included inside a <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Global_attributes#attr-title"><code>title</code></a> attribute.) </p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>abbr</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Reverend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Rev.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>abbr</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>HTML有一个用于标记联系方式的元素<address>。这只是将html文档开发者的联系方式包括在内，例如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Chris Mills, Manchester, The Grim North, UK<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>address</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>上下标<sup><sub></p>
</li>
<li><p>code&gt;：用于组成通用的计算机代码。</p>
</li>
<li><pre>：用于标记固定宽度的文本块，其中保留空白（通常是代码块）。</li>
<li><p>var&gt;：用于专门标记变量名。</p>
</li>
<li><p>kbd&gt;：用于标记输入到计算机中的键盘（和其他类型的）输入。</p>
</li>
<li><p>samp&gt;：用于标记计算机程序的输出。</p>
</li>
<li><p>time&gt;：datetime属性标记元素时间</p>
</li>
</ul>
<h2 id="html结构布局"><a href="#html结构布局" class="headerlink" title="html结构布局"></a>html结构布局</h2><p><em><strong>信息架构</strong></em></p>
<p>应用于网站设计和开发的信息体系结构是一种组织网站的信息/内容/功能的实践，以便它可以提供最佳的用户体验，并且信息和服务易于使用和发现。</p>
<ul>
<li><h2 id="HTML5中的Section元素"><a href="#HTML5中的Section元素" class="headerlink" title="HTML5中的Section元素"></a><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines#section_elements_in_html5">HTML5中的Section元素</a></h2><ul>
<li><strong>HTML导航元素</strong>《nav》定义了一个部分，其中包含经常出现在网站上的导航链接。您可以具有主菜单和辅助菜单，但是不能将一个<code>&lt;nav&gt;</code>元素嵌套在另一个 <code>&lt;nav&gt;</code>元素中。</li>
<li><strong>HTML文章元素</strong>《article》定义了一条独立的内容。它不单指主要内容，而是可以用于注释和小部件。</li>
<li><strong>HTML Section Element</strong>《section》定义了文档的一部分，以指示语义含义的相关分组。使用section元素为父元素提供额外的上下文是有意义的。</li>
<li><strong>HTML Aside Element</strong>《aside》定义了一个部分，尽管该部分与main元素相关，但不属于主流，例如说明框或广告。aside元素具有自己的轮廓，但不属于主要元素。</li>
</ul>
<h3 id="分区中使用的其他语义HTML元素"><a href="#分区中使用的其他语义HTML元素" class="headerlink" title="分区中使用的其他语义HTML元素"></a><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines#other_semantic_html_elements_used_in_sectioning">分区中使用的其他语义HTML元素</a></h3><ul>
<li><strong>HTML正文元素</strong>《body》定义了文档的所有内容。它包含所有内容和HTML标记。</li>
<li><strong>HTML标头元素</strong>《header》定义了一个页面区域，通常包含徽标，标题和导航。标头也可以在其他语义元素（例如<code>&lt;article&gt;</code>，<code>&lt;section&gt;</code>，《aside》，《nav》都行）可以放一些作者信息啊什么的东西，</li>
<li><strong>HTML页脚元素</strong>《footer》定义了页脚，通常包含版权或法律声明，有时还包含一些链接。在节的上下文中，页脚可能包含节内容的发布日期，许可证信息等，同样，上述标间也均可以自己的页脚，尽管有页脚的名称，页脚也不一定位于页面或节的末尾。</li>
</ul>
</li>
<li><p>无语义元素：块级div  内敛span</p>
</li>
</ul>
<p><strong>警告：</strong><code>&lt;div&gt;</code> 非常便利但容易被滥用。由于它们没有语义值，会使 HTML 代码变得混乱。要小心使用，只有在没有更好的语义方案时才选择它，而且要尽可能少用， 否则文档的升级和维护工作会非常困难。</p>
<p><strong>重要提示</strong>：Web浏览器中没有拟议大纲算法的实现，也没有辅助技术。它从来都不是最终的W3C规范的一部分。因此，<a href="https://www.w3.org/TR/html5/sections.html#outline">大纲</a>算法<em>不应用于</em>将文档结构传达给用户。建议作者使用标题<a href="https://www.w3.org/TR/html5/sections.html#rank">等级</a>（<code>h1</code>- <code>h6</code>）传达文档结构。</p>
<p>大纲算法是神马？？？</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML_sections_and_outlines">用法指导</a>规定了各个部分的建议使用方法</p>
<p><em><strong>兼容古老浏览器</strong></em>：</p>
<p>HTML5语义元素不需要特殊的DOM接口，但是在较旧的浏览器中，它们将需要特定的CSS样式，这些样式不明确支持它们。<code>display: inline</code>默认情况下，未知元素的样式设置为默认样式，因此您需要将其设置为<code>display: block</code>：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">article, aside, footer, header, nav, section</span> <span class="token punctuation">&#123;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  当你的受众可能用那些鬼浏览器时</p>
<p>The <strong>HTML <code>&lt;noscript&gt;</code> element</strong> defines a section of HTML to be inserted if a script type on the page is unsupported or if scripting is currently turned off in the browser.</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--[if lt IE 9]>
  &lt;script>
    document.createElement("article");
    document.createElement("aside");
    document.createElement("footer");
    document.createElement("header");
    document.createElement("nav");
    document.createElement("section");
    document.createElement("time");
  &lt;/script>
&lt;![endif]--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>This web page requires JavaScript to be enabled.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>JavaScript is an object-oriented computer programming language
    commonly used to create interactive effects within web browsers.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://goo.gl/koeeaJ<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>How to enable JavaScript?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="HTML多媒体"><a href="#HTML多媒体" class="headerlink" title="HTML多媒体"></a>HTML多媒体</h1><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>你不应该使用HTML属性来改变图片的大小。如果你把尺寸设定的太大，最终图片看起来会模糊；如果太小，会在下载远远大于你需要的图片时浪费带宽。如果你没有保持正确的<a href="https://zh.wikipedia.org/wiki/%E9%95%B7%E5%AF%AC%E6%AF%94_(%E5%BD%B1%E5%83%8F)">宽高比</a>，图片可能看起来会扭曲。在把图片放到你的网站页面之前，你应该使用图形编辑器使图片的尺寸正确。</p>
<p>善用alt属性</p>
<p>使用 HTML5 的 figure和figcaption元素，它正是为此而被创造出来的：为图片提供一个语义容器，在标题和图片之间建立清晰的关联。我们之前的例子可以重写为:</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>figure</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg<span class="token punctuation">"</span></span>
     <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。<span class="token punctuation">"</span></span>
     <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span>
     <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>341<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>figcaption</span><span class="token punctuation">></span></span>曼彻斯特大学博物馆展出的一只霸王龙的化石<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>figcaption</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>figure</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：</strong>从无障碍的角度来说，说明文字和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-alt"><code>alt</code></a> 文本扮演着不同的角色。看得见图片的人们同样可以受益于说明文字，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-alt"><code>alt</code></a> 文字只有在图片无法显示时才这样。 所以，说明文字和 <code>alt</code> 的内容不应该一样，因为当图片无法显示时，它们会同时出现。尝试让你的图片不显示，看看效果如何。</p>
<p><strong>如果图像对您的内容里有意义，则应使用HTML图像。 如果图像纯粹是装饰，则应使用CSS背景图片</strong></p>
<p>ps: 谷歌搜索引擎把连字符当作单词的分隔符， 但不会识别下划线。基于此，最好在一开始就养成习惯，文件夹和文件名使用小写，用短横线而不是空格来分隔。可以避免许多问题。</p>
<h2 id="Video-amp-Audio"><a href="#Video-amp-Audio" class="headerlink" title="Video&amp;Audio"></a>Video&amp;Audio</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rabbit320.webm<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>你的浏览器不支持 HTML5 视频。可点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rabbit320.mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>此链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>观看<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当中的一些属性如下:<br>src同 <img> 标签使用方式相同，src 属性指向你想要嵌入网页当中的视频资源，他们的使用方式完全相同。controls用户必须能够控制视频和音频的回放功能。你可以使用 controls 来包含浏览器提供的控件界面，同时你也可以使用合适的 JavaScript API 创建自己的界面。界面中至少要包含开始、停止以及调整音量的功能。</p>
<p>video 标签内的内容这个叫做后备内容 — 当浏览器不支持 video标签的时候，就会显示这段内容，这使得我们能够对旧的浏览器提供回退内容。你可以添加任何后备内容，在这个例子中我们提供了一个指向这个视频文件的链接，从而使用户至少可以访问到这个文件，而不会局限于浏览器的支持。</p>
<p>像 MP3、MP4、WebM这些术语叫做<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers">容器格式</a>。他们定义了构成媒体文件的音频轨道和视频轨道的储存结构，其中还包含描述这个媒体文件的元数据，以及用于编码的编码译码器等等。</p>
<p>刚刚所说的格式主要用于将音频和视频压缩成可管理的文件（原始的音频和视频文件非常大）。浏览器包含了不同的 <strong><a href="https://developer.mozilla.org/en-US/docs/Glossary/Codec">Codecs</a></strong>,，如 Vorbis 和 H.264，它们用来将已压缩的音频和视频转化成二进制数字。不同的编码器和不同的容器都有各自的优缺点，在你更了解它们后，你可以自己选择使用哪个编码器和容器。</p>
<!-- 注：这并没有那么简单，你可以从这里看到 [音视频编码兼容表](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/Media/Formats#浏览器兼容情况)。此外，许多移动平台的浏览器能够播放一些不支持的格式，但是它们用的却是底层系统的媒体播放器。但这也仅是现在支持。-->

<p>我们该怎么做呢？请看如下例子（你可以点击这里<a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/video-and-audio-content/multiple-video-formats.html">查看</a>网页，或者点击这里<a href="https://github.com/mdn/learning-area/blob/gh-pages/html/multimedia-and-embedding/video-and-audio-content/multiple-video-formats.html">查看</a>源代码）：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rabbit320.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>video/mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rabbit320.webm<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>video/webm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>你的浏览器不支持 HTML5 视频。可点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rabbit320.mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>此链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>观看<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在我们将 <code>src</code> 属性从 <code>&lt;video&gt;</code> 标签中移除，转而将它放在几个单独的标签 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source">``</a> 当中。在这个例子当中，浏览器将会检查 <code>&lt;source&gt;</code> 标签，并且播放第一个与其自身 codec 相匹配的媒体。你的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。</p>
<p>每个 <code>&lt;source&gt;</code> 标签页含有一个 <code>type</code> 属性，这个属性是可选的</p>
<p>新的特性：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-height"><code>height</code></a></p>
<p>你可以用属性控制视频的尺寸，也可以用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS">CSS</a> 来控制视频尺寸。 无论使用哪种方式，视频都会保持它原始的长宽比 — 也叫做<strong>纵横比</strong>。如果你设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-autoplay"><code>autoplay</code></a></p>
<p>这个属性会使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。建议不要应用这个属性在你的网站上，因为用户们会比较反感自动播放的媒体文件。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-loop"><code>loop</code></a></p>
<p>这个属性可以让音频或者视频文件循环播放。同样不建议使用，除非有必要。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-muted"><code>muted</code></a></p>
<p>这个属性会导致媒体播放时，默认关闭声音。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-poster"><code>poster</code></a></p>
<p>这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video#attr-preload"><code>preload</code></a></p>
<p>这个属性被用来缓冲较大的文件，有3个值可选：<code>&quot;none&quot;</code> ：不缓冲<code>&quot;auto&quot;</code> ：页面加载后缓存媒体文件<code>&quot;metadata&quot;</code> ：仅缓冲文件的元数据</p>
</li>
</ul>
<p>你可以点击<a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/video-and-audio-content/extra-video-features.html">这里</a>查看以上的例子，也可以点击<a href="https://github.com/mdn/learning-area/blob/gh-pages/html/multimedia-and-embedding/video-and-audio-content/extra-video-features.html">这里</a>查看源代码。注意我们并没有使用 autoplay 属性在这个版本的例子中 — 如果当页面一加载就开始播放视频的话，就不会看到 poster 属性的效果了。</p>
<p>audio和video几乎完全一样，但不支持width/height和poster</p>
<h2 id="嵌入iframe"><a href="#嵌入iframe" class="headerlink" title="嵌入iframe"></a>嵌入iframe</h2><p>以前，插件在网络上是不可或缺的。还记得你必须安装Adobe Flash Player才能在线观看电影的日子吗？并且你还会不断地收到关于更新Flash Player和Java运行环境的烦人警报。Web技术已经变得更加强大，那些日子已经结束了。对于大多数应用程序，现在是停止依赖插件传播内容，开始利用Web技术的时候了</p>
<p>iframe元素出现了（连同其他嵌入内容的方式，如canvas&gt;，video&gt;等），它提供了一种将整个web页嵌入到另一个网页的方法，看起来就像那个web页是另一个网页的一个<img>或其他元素一样。iframe&gt;现在经常被使用。</p>
<pre class="line-numbers language-none"><code class="language-none">allowfullscreen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果设置，<code>&lt;iframe&gt;</code>则可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fullscreen_API">全屏API</a>设置为全屏模式（稍微超出本文的范围）。</p>
<pre class="line-numbers language-none"><code class="language-none">frameborder<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0删除边框。不推荐这样设置，因为在<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS">CSS中</a>可以更好地实现相同的效果。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border"><code>border</code></a><code>: none;</code></p>
<pre class="line-numbers language-none"><code class="language-none">src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该属性与<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video">``</a>/<code>&lt;img&gt;</code>一样包含指向要嵌入文档的URL路径。</p>
<pre class="line-numbers language-none"><code class="language-none">width&#96; 和 &#96;height<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这些属性指定您想要的iframe的宽度和高度。</p>
<p>备选内容</p>
<p>与video &amp; audio等其他类似元素相同，您可以在<code>&lt;iframe&gt;&lt;/iframe&gt;</code>标签之间包含备选内容，如果浏览器不支持<code>&lt;iframe&gt;</code>，将会显示备选内容，这种情况下，我们已经添加了一个到该页面的链接。现在您几乎不可能遇到任何不支持<code>&lt;iframe&gt;</code>的浏览器。</p>
<pre class="line-numbers language-none"><code class="language-none">sandbox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该属性需要在已经支持其他<code>&lt;iframe&gt;</code>功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置; 我们将在下一节中更加详细地谈到。</p>
<p><strong>注意</strong>：为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的<code>src</code>属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间（重要的<a href="https://developer.mozilla.org/en-US/docs/Glossary/SEO">SEO</a>指标）。</p>
<p>未沙盒化(Unsandboxed)内容可以做得太多（执行JavaScript，提交表单，弹出窗口等）默认情况下，您应该使用没有参数的<code>sandbox</code>属性来强制执行所有可用的限制，如我们前面的示例所示。</p>
<p>如果绝对需要，您可以逐个添加权限（<code>sandbox=&quot;&quot;</code>属性值内） - 请参阅<code>sandbox</code>所有可用选项的参考条目。其中重要的一点是，你<em>永远不</em>应该同时添加<code>allow-scripts</code>和<code>allow-same-origin</code>到你的<code>sandbox</code>属性中-在这种情况下，嵌入式内容可以绕过阻止站点执行脚本的同源安全策略，并使用JavaScript完全关闭沙盒。</p>
<p>但还有其它的有待关注，如 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">``</a>用于JavaScript生成的2D和3D图形，<code>&lt;svg&gt;</code>用于嵌入矢量图形</p>
<h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><ul>
<li>位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (<code>.bmp</code>), PNG (<code>.png</code>), JPEG (<code>.jpg</code>), and GIF (<code>.gif</code>.)</li>
<li>矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 <a href="https://developer.mozilla.org/en-US/docs/Glossary/SVG">SVG</a> 格式可以让我们创造用于 Web 的精彩的矢量图形。</li>
</ul>
<p>此外，矢量图形相较于同样的位图，通常拥有更小的体积，因为它们仅需储存少量的算法，而不是逐个储存每个像素的信息。</p>
<p>SVG很容易手工编码。 是的，您可以在文本编辑器中手动编写简单的SVG，但是对于复杂的图像，这很快就开始变得非常困难。 为了创建SVG图像，大多数人使用矢量图形编辑器，如 <a href="https://inkscape.org/en/">Inkscape</a> 或 <a href="https://en.wikipedia.org/wiki/Adobe_Illustrator">Illustrator</a>。 这些软件包允许您使用各种图形工具创建各种插图，并创建照片的近似值（例如Inkscape的跟踪位图功能）。</p>
<p>SVG除了迄今为止所描述的以外还有其他优点：</p>
<ul>
<li>矢量图像中的文本仍然可访问（这也有利于 <a href="https://developer.mozilla.org/en-US/docs/Glossary/SEO">SEO</a>)）。</li>
<li>SVG 可以很好地适应样式/脚本，因为图像的每个组件都是可以通过CSS或通过JavaScript编写的样式的元素。</li>
</ul>
<p>那么为什么会有人想使用光栅图形而不是SVG？ 其实 SVG 确实有一些缺点：</p>
<ul>
<li>SVG非常容易变得复杂，这意味着文件大小会增加; 复杂的SVG也会在浏览器中占用很长的处理时间。</li>
<li>SVG可能比栅格图像更难创建，具体取决于您尝试创建哪种图像。</li>
<li>旧版浏览器不支持SVG，因此如果您需要在网站上支持旧版本的 IE，则可能不适合（SVG从IE9开始得到支持）。</li>
</ul>
<p>由于上述原因，光栅图形更适合照片那样复杂精密的图像</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>
    <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>equilateral.svg<span class="token punctuation">"</span></span>
    <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>triangle with all three sides equal<span class="token punctuation">"</span></span>
    <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>87px<span class="token punctuation">"</span></span>
    <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100px<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优点</p>
<ul>
<li>快速，熟悉的图像语法与<code>alt</code>属性中提供的内置文本等效。</li>
<li>可以通过在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">``</a>元素嵌套<code>&lt;img&gt;</code>，使图像轻松地成为超链接。</li>
</ul>
<p>缺点</p>
<ul>
<li>无法使用JavaScript操作图像。</li>
<li>如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 （从SVG文件调用的外部样式表不起作用）</li>
<li>不能用CSS伪类来重设图像样式（如<code>:focus</code>）。</li>
</ul>
<p>！！你还可以在文本编辑器中打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中 - 这有时称为将<strong>SVG内联</strong>或<strong>内联SVG</strong>。确保您的SVG代码在<code>&lt;svg&gt;&lt;/svg&gt;</code>标签中（不要在外面添加任何内容）。这是一个非常简单的示例，您可以粘贴到文档中：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;svg width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt;
    &lt;rect width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot; fill&#x3D;&quot;green&quot; &#x2F;&gt;
&lt;&#x2F;svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>优点</p>
<ul>
<li>将 SVG 内联减少 HTTP 请求，可以减少加载时间。</li>
<li>您可以为 SVG 元素分配<code>class</code>和<code>id</code>，并使用 CSS 修改样式，无论是在SVG中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute#presentation_attributes">SVG外观属性</a> 作为CSS属性。</li>
<li>内联SVG是唯一可以让您在SVG图像上使用CSS交互（如<code>:focus</code>）和CSS动画的方法（即使在常规样式表中）。</li>
<li>您可以通过将 SVG 标记包在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">``</a>元素中，使其成为超链接。</li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>一个改进的方法是，当网站在狭窄的屏幕上观看时，显示一幅图片的包含了重要细节的裁剪版本，第二个被裁剪的图片会在像平板电脑这样的中等宽度的屏幕设备上显示，这就是众所周知的<strong>美术设计问题（art direction problem）</strong>。</p>
<p>另外，如果是在小屏手机屏幕上显示网页，那么没有必要在网页上嵌入这样大的图片。这被称之为<strong>分辨率切换问题（resolution switching problem）</strong>。位图有固定数量的像素宽，固定数量的像素高，与 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web">矢量图</a> 外观相同，但本质不同。如果显示尺寸大于原始尺寸，一张自身较小的位图看起来会有颗粒感（矢量图则不会）。</p>
<p>相反，没有必要在比图片实际尺寸小的屏幕上显示一张大图，这样做会浪费带宽——当可以在设备上使用小图像时，手机用户尤其不愿意因为下载用于桌面的大图像而浪费带宽。理想的情况是当访问网站时依靠不同的设备来提供不同的分辨率图片和不同尺寸的图片。</p>
<p>让事情变得复杂的是，有些设备有很高的分辨率，为了显示的更出色，可能需要超出你预料的更大的图像。这从本质上是一样的问题，但在环境上有一些不同。</p>
<p>你可能会认为矢量图形能解决这些问题，在某种程度上是这样的——它们无论是文件大小还是比例都合适，无论在哪里你都应该尽可能的使用它们。然而，它们并不适合所有的图片类型，虽然在简单图形、图案、界面元素等方面较好，但如果是有大量的细节的照片，创建矢量图像会变得非常复杂。像JPEG格式这样的位图会更适合上面例子中的图像。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-fairy-320w.jpg 320w,
             elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w<span class="token punctuation">"</span></span>
     <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px<span class="token punctuation">"</span></span>
     <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-fairy-800w.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Elva dressed as a fairy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>srcset</code>和<code>sizes</code>属性看起来很复杂，但是如果你按照上图所示进行格式化，那么他们并不是很难理解，每一行有不同的属性值。每个值都包含逗号分隔的列表。列表的每一部分由三个子部分组成。让我们来看看现在的每一个内容：</p>
<p><strong>srcset</strong>定义了我们允许浏览器选择的图像集，以及每个图像的大小。在每个逗号之前，我们写：</p>
<ol>
<li>一个<strong>文件名</strong> (<code>elva-fairy-480w.jpg</code>.)</li>
<li>一个空格</li>
<li><strong>图像的固有宽度</strong>（以像素为单位）（480w）——注意到这里使用<code>w</code>单位，而不是你预计的<code>px</code>。这是图像的真实大小，可以通过检查你电脑上的图片文件找到（例如，在Mac上，你可以在Finder上选择这个图像，然后按 Cmd + I 来显示信息）。</li>
</ol>
<p><code>**sizes**</code>定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择—我们在之前已经讨论了一些提示。在这种情况下，在每个逗号之前，我们写：</p>
<ol>
<li>一个<strong>媒体条件</strong>（<code>(max-width:480px)</code>）——你会在 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS">CSS topic</a>中学到更多的。但是现在我们仅仅讨论的是媒体条件描述了屏幕可能处于的状态。在这里，我们说“当可视窗口的宽度是480像素或更少”。</li>
<li>一个空格</li>
<li>当媒体条件为真时，图像将填充的<strong>槽的宽度</strong>（<code>440px</code>）</li>
</ol>
<p><strong>注意</strong>: 对于槽的宽度，你也许会提供一个固定值 (<code>px</code>, <code>em</code>) 或者是一个相对于视口的长度(<code>vw</code>)，但不是百分比。你也许已经注意到最后一个槽的宽度是没有媒体条件的，它是默认的，当没有任何一个媒体条件为真时，它就会生效。 当浏览器成功匹配第一个媒体条件的时候，剩下所有的东西都会被忽略，所以要注意媒体条件的顺序。</p>
<p>所以，有了这些属性，浏览器会：</p>
<ol>
<li>查看设备宽度</li>
<li>检查<code>sizes</code>列表中哪个媒体条件是第一个为真</li>
<li>查看给予该媒体查询的槽大小</li>
<li>加载<code>srcset</code>列表中引用的最接近所选的槽大小的图像</li>
</ol>
<p>如果你支持多种分辨率显示，但希望每个人在屏幕上看到的图片的实际尺寸是相同的，你可以让浏览器通过<code>srcset</code>和x语法结合——一种更简单的语法——而不用<code>sizes</code>，来选择适当分辨率的图片。你可以看一个例子 <a href="https://mdn.github.io/learning-area/html/multimedia-and-embedding/responsive-images/srcset-resolutions.html">srcset-resolutions.html</a>（或 <a href="https://github.com/mdn/learning-area/blob/master/html/multimedia-and-embedding/responsive-images/srcset-resolutions.html">the source code</a>）：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-fairy-320w.jpg,
             elva-fairy-480w.jpg 1.5x,
             elva-fairy-640w.jpg 2x<span class="token punctuation">"</span></span>
     <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-fairy-640w.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Elva dressed as a fairy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这种情况下，<code>sizes</code>并不需要——浏览器只是计算出正在显示的显示器的分辨率，然后提供<code>srcset</code>引用的最适合的图像。因此，如果访问页面的设备具有标准/低分辨率显示，一个设备像素表示一个CSS像素，<code>elva-fairy-320w.jpg</code>会被加载（1x 是默认值，所以你不需要写出来）。如果设备有高分辨率，两个或更多的设备像素表示一个CSS像素，<code>elva-fairy-640w.jpg</code> 会被加载。640px的图像大小为93KB，320px的图像的大小仅仅有39KB。</p>
<p><em><strong>美术设计问题</strong></em></p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(max-width: 799px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-480w-close-portrait.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(min-width: 800px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-800w.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elva-800w.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Chris standing up holding his daughter Elva<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li> <code>&lt;source&gt;</code>元素包含一个<code>media</code>属性，这一属性包含一个媒体条件——就像第一个<code>srcset</code>例子，这些条件来决定哪张图片会显示——第一个条件返回真，那么就会显示这张图片。在这种情况下，如果视窗的宽度为799px或更少，第一个<code>&lt;source&gt;</code>元素的图片就会显示。如果视窗的宽度是800px或更大，就显示第二张图片。</li>
<li> <code>srcset</code>属性包含要显示图片的路径。请注意，正如我们在<code>&lt;img&gt;</code>上面看到的那样，<code>&lt;source&gt;</code>可以使用引用多个图像的<code>srcset</code>属性，还有<code>sizes</code>属性。所以你可以通过一个 <code>&lt;picture&gt;</code>元素提供多个图片，不过也可以给每个图片提供多分辨率的图片。实际上，你可能不想经常做这样的事情。</li>
<li> 在任何情况下，你都必须在 <code>&lt;/picture&gt;</code>之前正确提供一个<code>&lt;img&gt;</code>元素以及它的<code>src</code>和<code>alt</code>属性，否则不会有图片显示。当媒体条件都不返回真的时候（你可以在这个例子中删除第二个<code>&lt;source&gt;</code> 元素），它会提供图片；如果浏览器不支持 <code>&lt;picture&gt;</code>元素时，它可以作为后备方案。</li>
</ul>
<p>为了保证效率，响应式设计最好不用JavaScript</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images#%E5%A4%A7%E8%83%86%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F">大胆的使用现代图像格式</a></p>
<p>有很多令人激动的新图像格式（例如WebP和JPEG-2000）可以在有高质量的同时有较低的文件大小。然而，浏览器对其的支持参差不齐。</p>
<p><code>&lt;picture&gt;</code>让我们能继续满足老式浏览器的需要。你可以在<code>type</code>属性中提供MIME类型，这样浏览器就能立即拒绝其不支持的文件类型：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/svg+xml<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pyramid.svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/webp<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pyramid.webp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pyramid.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>regular pyramid built from four equilateral triangles<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>不要使用<code>media</code>属性，除非你也需要美术设计。</li>
<li>在<code>&lt;source&gt;</code> 元素中，你只可以引用在<code>type</code>中声明的文件类型。</li>
<li>像之前一样，如果必要，你可以在<code>srcset</code>和<code>sizes</code>中使用逗号分割的列表。</li>
</ul>
<h1 id="表格设计"><a href="#表格设计" class="headerlink" title="表格设计"></a>表格设计</h1><p>table<br>tr表格行<br>th表格小标题<br>td表格基础单元</p>
<p>rowspan 调高度</p>
<p>colspan = “2” 宽度是两个单元格</p>
<p>为了舍弃这种做法，我们可以只定义一次，在 <code>&lt;col&gt;</code> 元素中。<code>&lt;col&gt;</code> 元素被规定包含在 <code>&lt;colgroup&gt;</code> 容器中，而 <code>&lt;colgroup&gt;</code>就在 <code>&lt;table&gt;</code> 标签的下方。我们可以通过如下的做法来创建与上面相同的效果:</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>colgroup</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> yellow</span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>colgroup</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>Data 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>Data 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>Calcutta<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>Orange<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>Robots<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>Jazz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们使用了两个 <code>&lt;col&gt;</code>来定义“列的样式”，每一个<code>&lt;col&gt;</code>都会制定每列的样式，对于第一列，我们没有采取任何样式，但是我们仍然需要添加一个空的 <code>&lt;col&gt;</code> 元素，如果不这样做，那么我们的样式就会应用到第一列上，这和我们预想的不一样。</p>
<p>如果你想把这种样式信息应用到每一列，我们可以只使用一个 <code>&lt;col&gt;</code> 元素，不过需要包含 span 属性，像这样：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>colgroup</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> yellow</span><span class="token punctuation">"</span></span></span> <span class="token attr-name">span</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>colgroup</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>标题属性caption</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caption</span><span class="token punctuation">></span></span>Dinosaurs in the Jurassic period<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>caption</span><span class="token punctuation">></span></span>

  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li> <code>&lt;thead&gt;</code> 需要嵌套在 table 元素中，放置在头部的位置，因为它通常代表第一行，第一行中往往都是每列的标题，但是不是每种情况都是这样的。如果你使用了 / 元素，那么 <code>&lt;thead&gt;</code>元素就需要放在它们的下面。</li>
<li> <code>&lt;tfoot&gt;</code> 需要嵌套在 table 元素中，放置在底部 (页脚)的位置，一般是最后一行，往往是对前面所有行的总结，比如，你可以按照预想的方式将<code>&lt;tfoot&gt;</code>放在表格的底部，或者就放在 <code>&lt;thead&gt;</code> 的下面。(浏览器仍将它呈现在表格的底部)</li>
<li> <code>&lt;tbody&gt;</code> 需要嵌套在 table 元素中，放置在 <code>&lt;thead&gt;</code>的下面或者是 <code>&lt;tfoot&gt;</code> 的下面，这取决于你如何设计你的结构。(<code>&lt;tfoot&gt;</code>放在<code>&lt;thead&gt;</code>下面也可以生效.)</li>
</ul>
<p><strong>注意</strong>: <code>&lt;tbody&gt;</code> 总是包含在每个表中，如果你没有在代码中指定它，那就是隐式的。可以来验证一下，打开一个你之前没有包含 <code>&lt;tbody&gt;</code> 的例子，然后在你的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">browser developer tools</a> 中观察你的代码，你会看到浏览器为你添加了这个标签。你也许会想问，为什么你应该在所有表中都需要这个元素，因为它可以让你更好地控制表格结构和样式。</p>
<p><strong>表格可以嵌套，虽然通常不建议</strong></p>
<p>为了帮助屏幕阅读器，赋予行，列标题scole属性</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;th scope&#x3D;&quot;col&quot;&gt;Purchase&lt;&#x2F;th&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&lt;th scope&#x3D;&quot;row&quot;&gt;Haircut&lt;&#x2F;th&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>&lt;th colspan=&quot;3&quot; scope=&quot;colgroup&quot;&gt;Clothes&lt;/th&gt;</code></p>
<p>colgroup和rowgroup结合colspan和rowspan使用</p>
<p>也可以用这个精细但是很麻烦的id+headers</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thead</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>purchase<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Purchase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>location<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Location<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Date<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>evaluation<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Evaluation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cost<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cost (€)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thead</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>haircut<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Haircut<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">headers</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>location haircut<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hairdresser<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">headers</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>date haircut<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>12/09<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">headers</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>evaluation haircut<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Great idea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">headers</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cost haircut<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>

  ...

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="以后再看"><a href="#以后再看" class="headerlink" title="以后再看"></a>以后再看</h1><p>这些内容有一丢丢难</p>
<h2 id="配置CSP指令"><a href="#配置CSP指令" class="headerlink" title="配置CSP指令"></a>配置CSP指令</h2><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>代表**<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP">内容安全策略</a>*<em>，它提供<a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives">一组HTTP标头</a>（由web服务器发送时与元数据一起发送的元数据），旨在提高HTML文档的安全性。在<code>&lt;iframe&gt;</code>s安全性方面，您可以</em><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/X-Frame-Options">将服务器配置为发送适当的<code>X-Frame-Options</code> 标题。</a>*这样做可以防止其他网站在其网页中嵌入您的内容（这将导致<a href="https://en.wikipedia.org/wiki/clickjacking">点击</a>和一系列其他攻击），正如我们之前看到的那样，MDN开发人员已经做了这些工作。</p>
<h2 id="添加字幕"><a href="#添加字幕" class="headerlink" title="添加字幕"></a>添加字幕</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Video_and_audio_content#%E6%98%BE%E7%A4%BA%E9%9F%B3%E8%BD%A8%E6%96%87%E6%9C%AC">添加字幕操作</a></p>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>object&gt;<code>元素的功能不同于</code>iframe&gt;`—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容！</p>
<p><strong>注意</strong>：<strong>插件</strong>是一种对浏览器原生无法读取的内容提供访问权限的软件。</p>
<p>然而，您不太可能使用这些元素 - Applet几年来一直没有被使用；由于许多原因，Flash不再受欢迎（见下面的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#The_case_against_plugins">插件案例</a>）；PDF更倾向于被链接而不是被嵌入；其他内容，如图像和视频都有更优秀、更容易元素来处理。插件和这些嵌入方法真的是一种传统技术，我们提及它们主要是为了以防您在某些情况下遇到问题，比如内部网或企业项目等。</p>
<p>如果您发现自己需要嵌入插件内容，那么您至少需要一些这样的信息：</p>
<p>|                                                              | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed">``</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">``</a> |<br>| :———————————————————– | :———————————————————– |<br>| 嵌入内容的<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">网址</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-src"><code>src</code></a> |<br>| 嵌入内容的<em>准确</em><a href="https://developer.mozilla.org/en-US/docs/Glossary/MIME_type">媒体类型</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-type"><code>type</code></a> |<br>| 由插件控制的框的高度和宽度（以CSS像素为单位）                | <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-height"><code>height</code></a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed#attr-width"><code>width</code></a> |<br>| 名称和值，将插件作为参数提供                                 | 具有这些名称和值的ad hoc属性                                 |<br>| 独立的HTML内容作为不可用资源的回退                           | 不支持（<code>&lt;noembed&gt;</code>已过时）                                  |</p>
<p><strong>注意</strong>：<code>&lt;object&gt;</code>需要<code>data</code>属性，<code>type</code>属性或两者。如果您同时使用这两个，您也可以使用该<code>typemustmatch</code>属性（仅在Firefox中实现，在本文中）。<code>typemustmatch</code>保持嵌入文件不运行，除非<code>type</code>属性提供正确的媒体类型。<code>typemustmatch</code>因此，当您嵌入来自不同<a href="https://developer.mozilla.org/en-US/docs/Glossary/origin">来源的</a>内容（可以防止攻击者通过插件运行任意脚本）时，可以赋予重要的安全优势。</p>
<h2 id="SVG元素参考"><a href="#SVG元素参考" class="headerlink" title="SVG元素参考"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">SVG元素参考</a></h2><h2 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web#see_also">See also</a></h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started">SVG tutorial</a> on MDN</li>
<li><a href="http://thenewcode.com/744/Making-SVG-Responsive">Quick tips for responsive SVGs</a></li>
<li><a href="https://tympanus.net/codrops/2014/08/19/making-svgs-responsive-with-css/">Sara Soueidan’s tutorial on responsive SVG images</a></li>
<li><a href="https://www.w3.org/TR/SVG-access/">Accessibility benefits of SVG</a></li>
<li><a href="https://css-tricks.com/scale-svg/">How to scale SVGs </a>(it’s not as simple as raster graphics!)</li>
</ul>
<h2 id="响应者适应模式"><a href="#响应者适应模式" class="headerlink" title="响应者适应模式"></a><a href="https://developer.mozilla.org/en-US/docs/Tools/Responsive_Design_Mode">响应者适应模式</a></h2>]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议基础</title>
    <url>/2021/03/13/http/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>[toc]</p>
<h2 id="几个知识"><a href="#几个知识" class="headerlink" title="几个知识"></a>几个知识</h2><p>http2已经越来越普及：</p>
<p>二进制编码报文，仍采用TCP，分为若干个帧，来加快传输</p>
<p>HPACK算法压缩大量重复的http头</p>
<p>用服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间</p>
<p>http-&gt;SPDY-&gt;舍弃-&gt;http2.0-&gt;http2</p>
<p>HTTPS完全在TLS之上搭载HTTP，因此可以对整个基础HTTP协议进行加密</p>
<p>有大致相同的语法，</p>
<p><strong>MDN Web Docs</strong>，以前是<strong>Mozilla开发人员网络</strong>，以前是<strong>Mozilla开发人员中心</strong>，是<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>，<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft</a>，<a href="https://en.wikipedia.org/wiki/Google">Google</a>和<a href="https://en.wikipedia.org/wiki/Samsung">Samsung</a>使用的Web开发人员的文档资料库和学习资源。该项目由<a href="https://en.wikipedia.org/wiki/Mozilla">Mozilla</a>于2005年启动[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-MitchellBlog-2">2]</a>，是有关开放式Web标准，Mozilla自己的项目和开发人员指南的统一场所。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-3">3]</a>在2017年，微软，谷歌和三星宣布将关闭自己的文档项目，并将所有文档移至MDN Web Docs。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-:0-4">4]</a></p>
<p>MDN Web文档的内容由Mozilla和Google的员工和志愿者（开发人员和技术作家的社区）维护。主题包括<a href="https://en.wikipedia.org/wiki/HTML5">HTML5</a>，<a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>，<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>，<a href="https://en.wikipedia.org/wiki/Web_API">Web API</a>，<a href="https://en.wikipedia.org/wiki/Django_(web_framework)">Django</a>，<a href="https://en.wikipedia.org/wiki/Node.js">Node.js</a>，<a href="https://en.wikipedia.org/wiki/WebExtension">WebExtensions</a>，<a href="https://en.wikipedia.org/wiki/MathML">MathML</a>等。[<a href="https://en.wikipedia.org/wiki/MDN_Web_Docs#cite_note-5">5]</a></p>
<p>TCP是<a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">面向连接的</a>，并且可以在发送数据之前在客户端和服务器之间建立连接。建立连接之前，服务器必须正在侦听（被动打开）来自客户端的连接请求。三向握手（主动打开），<a href="https://en.wikipedia.org/wiki/Retransmission_(data_networks)">重传</a>和错误检测可增加可靠性，但会延长<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">等待时间</a>。不需要可靠<a href="https://en.wikipedia.org/wiki/Data_stream">数据流</a>服务的应用程序可以使用<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">用户数据报协议</a>（UDP），该<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">协议</a>提供无<a href="https://en.wikipedia.org/wiki/Connectionless_communication">连接</a> <a href="https://en.wikipedia.org/wiki/Datagram">数据报</a>服务，该服务优先考虑时间而不是可靠性。TCP采用<a href="https://en.wikipedia.org/wiki/TCP_congestion_control">避免网络拥塞的方法</a>。但是，TCP存在一些漏洞，包括<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">拒绝服务</a>，<a href="https://en.wikipedia.org/wiki/TCP_sequence_prediction_attack">连接劫持</a>，TCP否决权和<a href="https://en.wikipedia.org/wiki/TCP_reset_attack">重置攻击</a>。</p>
<p><strong>握手</strong>是在通信电路建立之后，信息传输开始之前。 握手用于达成参数，如信息传输率，字母表，奇偶校验， 中断过程，和其他协议特性。TCP三握手：</p>
<p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN—SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=i+j)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN—RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包．向服务器发送确认包ACK(ack=k+1)．此包发送完毕．客户端和服务器进入ESTABI．ISHED状态。完成三次握手。完成三次握手．客户端与服务器开始传送数据 [1]</p>
<h2 id="标识互联网内容"><a href="#标识互联网内容" class="headerlink" title="标识互联网内容"></a>标识互联网内容</h2><p>每个资源都由一个 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URI">URI</a>) 来进行标识。</p>
<p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p>
<p>URI 的最常见形式是统一资源定位符 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL">URL</a>)，它也被称为 <em>Web 地址</em>。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">https:</span>//developer.mozilla.org
<span class="token header-name keyword">https:</span>//developer.mozilla.org/en-US/docs/Learn/
<span class="token header-name keyword">https:</span>//developer.mozilla.org/en-US/search?q=URL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">urn:</span><span class="token header-name keyword">isbn:</span>9780141036144
<span class="token header-name keyword">urn:</span><span class="token header-name keyword">ietf:</span><span class="token header-name keyword">rfc:</span>7230<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="URI语法"><a href="#URI语法" class="headerlink" title="URI语法"></a>URI语法</h3><ol>
<li><p>“://“前是方案或协议</p>
<p><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">websocket协议</a>全双工的兼容http的协议</p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">data</td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URIs</a></td>
</tr>
<tr>
<td align="left">file</td>
<td align="left">指定主机上文件的名称</td>
</tr>
<tr>
<td align="left">ftp</td>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/FTP">文件传输协议</a></td>
</tr>
<tr>
<td align="left">http/https</td>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">超文本传输协议／安全的超文本传输协议</a></td>
</tr>
<tr>
<td align="left">mailto</td>
<td align="left">电子邮件地址</td>
</tr>
<tr>
<td align="left">ssh</td>
<td align="left">安全 shell</td>
</tr>
<tr>
<td align="left">tel</td>
<td align="left">电话</td>
</tr>
<tr>
<td align="left">urn</td>
<td align="left">统一资源名称</td>
</tr>
<tr>
<td align="left">view-source</td>
<td align="left">资源的源代码</td>
</tr>
<tr>
<td align="left">ws/wss</td>
<td align="left">（加密的） <a href="https://developer.mozilla.org/zh-CN/docs/WebSockets">WebSocket</a> 连接</td>
</tr>
</tbody></table>
</li>
<li><p>“//到:之间的域名”</p>
<p>这既是域名，也代表管理域名的机构，指示了一台主机</p>
</li>
<li><p>”：xx“是端口</p>
<p>它表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p>
</li>
<li><p>后面跟着一串路径</p>
</li>
<li><p>查询字符串</p>
<p><code>?key1=value1&amp;key2=value2</code> 是提供给 Web 服务器的额外参数。这些参数是用 &amp; 符号分隔的键/值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。</p>
</li>
<li><p>片段</p>
<p><code>#SomewhereInTheDocument</code> 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p>
</li>
</ol>
<h3 id="Data-URLs"><a href="#Data-URLs" class="headerlink" title="Data URLs"></a>Data URLs</h3><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、如果非文本则为可选的<code>base64</code>标记、数据本身：</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header-name keyword">data:</span>[&lt;mediatype>][;base64],&lt;data>
mediatype `是个 MIME 类型的字符串，例如 "`image/jpeg`" 表示 JPEG 图像文件。如果被省略，则默认值为 `text/plain;charset=US-ASCII<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>有很多问题：</p>
<ol>
<li>语法容易出错</li>
<li>html代码若转化成base64可能有问题</li>
<li>长度限制</li>
<li>缺乏错误处理</li>
<li>不支持查询字符串</li>
</ol>
<h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><p><strong>媒体类型</strong>（通常称为 <strong>Multipurpose Internet Mail Extensions</strong> 或 <strong>MIME</strong> 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在<a href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>中进行了定义和标准化。</p>
<p>互联网号码分配机构（<a href="https://www.iana.org/">IANA</a>）是负责跟踪所有官方MIME类型的官方机构，您可以在<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">媒体类型</a>页面中找到最新的完整列表。</p>
<p><strong>重要：</strong>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p>
<p>type/subtype  </p>
<p>独立（离散）类型/子类型</p>
<ul>
<li><p><code>application</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#application">在IANA上列出</a></p>
<p>没有明确属于其他类型之一的任何类型的二进制数据；或者将以某种方式执行或解释的数据，或者需要特定应用程序或应用程序类别使用的二进制数据。通用二进制数据（或真实类型未知的二进制数据）为<code>application/octet-stream</code>。其他常见的例子包括<code>application/pdf</code>， <code>application/pkcs8</code>，和<code>application/zip</code>。</p>
</li>
<li><p><code>audio</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio">在IANA上列出</a></p>
<p>音频或音乐数据。例子包括<code>audio/mpeg</code>， <code>audio/vorbis</code>。</p>
</li>
<li><p><code>example</code></p>
<p>保留用作展示如何使用MIME类型的示例中的占位符。这些代码绝对不能在示例代码清单和文档之外使用。 <code>example</code>也可以用作子类型；例如，在一个与在Web上处理音频有关的示例中，MIME类型<code>audio/example</code>可用于指示该类型是占位符，并且在现实世界中使用代码时应使用适当的占位符替换。</p>
</li>
<li><p><code>font</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#font">在IANA上列出</a></p>
<p>字体/字体数据。常见的例子包括<code>font/woff</code>， <code>font/ttf</code>，和<code>font/otf</code>。</p>
</li>
<li><p><code>image</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#image">在IANA上列出</a></p>
<p>图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本，例如动画<a href="https://developer.mozilla.org/en-US/docs/Glossary/gif">GIF</a>或APNG。常见的例子是<code>image/jpeg</code>，<code>image/png</code>和 <code>image/svg+xml</code>。</p>
</li>
<li><p><code>model</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#model">在IANA上列出</a></p>
<p>3D对象或场景的模型数据。示例包括<code>model/3mf</code>和 <code>model/vml</code>。</p>
</li>
<li><p><code>text</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#text">在IANA上列出</a></p>
<p>纯文本数据，包括任何人类可读的内容，源代码或文本数据，例如逗号分隔值（CSV）格式的数据。实例包括 <code>text/plain</code>，<code>text/csv</code>，和<code>text/html</code>。</p>
</li>
<li><p><code>video</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video">在IANA上列出</a></p>
<p>视频数据或文件，例如MP4电影（<code>video/mp4</code>）。</p>
</li>
</ul>
<p>对于没有特定子类型的文本文档，<code>text/plain</code>应使用。同样，对于没有特定或已知子类型的二进制文件， <code>application/octet-stream</code>应使用。</p>
<p><strong>多部分</strong>类型表示文档的分类，通常分为不同的MIME类型。它们也可以用来表示多个独立的文件，尤其是在电子邮件场景中，这些文件都是同一笔交易的一部分。它们代表一个<strong>复合文档</strong>。</p>
<p>除了<code>multipart/form-data</code>用于 <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML Forms</a><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST"><code>POST</code></a>方法中的和用于发送文档的一部分外，HTTP不会以特殊方式处理多部分文档：消息会传输到浏览器（可能会显示“另存为”窗口（如果它不知道如何显示文档）。<code>multipart/byteranges</code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> <code>Partial Content</code></p>
<p>有两种多部分类型：</p>
<ul>
<li><p><code>message</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">在IANA上列出</a></p>
<p>包含其他消息的消息。例如，它可以用来表示包含转发的消息作为其数据一部分的电子邮件，或者允许以块的形式发送非常大的消息，就像它是多条消息一样。示例包括<code>message/rfc822</code>（用于转发或回复的消息引用），并 <code>message/partial</code>允许将大消息分解为较小的消息，以便收件人自动进行重组。</p>
</li>
<li><p><code>multipart</code><a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">在IANA上列出</a></p>
<p>由多个组件组成的数据，这些组件可能分别具有不同的MIME类型。示例包括<code>multipart/form-data</code>（对于使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a>API生成的数据）和<code>multipart/byteranges</code>（在<a href="https://tools.ietf.org/html/rfc7233">RFC 7233：5.4.1中</a>定义 ），并与<a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"><code>206</code></a> “部分内容”响应一起使用，当获取的数据仅是内容的一部分（例如使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"><code>Range</code></a>标头传递的内容）时返回）。</p>
</li>
</ul>
<p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#%E9%87%8D%E8%A6%81%E7%9A%84mime%E7%B1%BB%E5%9E%8B">常用的</a></strong></em>*</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">常见MIME类型列表</a></p>
<p>很多web服务器使用默认的 <code>application/octet-stream</code> 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，导致用户必须存储到本地以使用。常见的导致服务器配置错误的文件类型如下所示：</p>
<ul>
<li>RAR编码文件。在这种情况，理想状态是，设置真实的编码文件类型；但这通常不可能（可能是服务器所未知的类型或者这个文件包含许多其他的不同的文件类型）。这这种情况服务器将发送 <code>application/x-rar-compressed</code> 作为MIME类型，用户不会将其定义为有用的默认操作。</li>
<li>音频或视频文件。只有正确设置了MIME类型的文件才能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">``</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">``</a> 识别和播放。 可参照  <a href="https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements">use the correct type for audio and video</a>。</li>
<li>专有文件类型。是专有文件时需要特别注意。使用 <code>application/octet-stream</code> 作为特殊处理是不被允许的：对于一般的MIME类型浏览器不允许定义默认行为（比如“在Word中打开”）</li>
</ul>
<p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 来设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> 以阻止MIME嗅探。</p>
<p>MIME类型不是传达文档类型信息的唯一方式：</p>
<ul>
<li>有时会使用名称后缀，特别是在Microsoft Windows系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是Linux和Mac OS），并且像外部MIME类型一样，不能保证它们是正确的。</li>
<li>魔术数字。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个GIF文件以47 49 46 38十六进制值[GIF89]或89 50 4E 47 [.PNG]的PNG文件开头。 并非所有类型的文件都有幻数，所以这也不是100％可靠的方式。</li>
</ul>
<h3 id="选择www吗"><a href="#选择www吗" class="headerlink" title="选择www吗"></a>选择www吗</h3><p>一个服务器不一定是一个独立的物理机：几台服务器可以驻留在同一台物理机器上，或者一台服务器可以通过几台机器进行处理，协作处理并响应或负载均衡它们之间的请求。关键点在于语义上<strong>一个域名代表一个单独的服务器</strong>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Choosing_between_www_and_non-www_URLs">两种设定非官方网站的方法</a>：HTTP301 和&lt;link rel =”canonical”</p>
<h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>![概念图](<a href="https://mdn.mozillademos.org/files/13673/HTTP">https://mdn.mozillademos.org/files/13673/HTTP</a> &amp; layers.png)</p>
<p>ps:TLS是传输层安全协议，建立在TCP之上</p>
<p>HTTP被设计于20世纪90年代初期，是一种可扩展的协议。它是应用层的协议，通过<a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP">TCP</a>，或者是<a href="https://developer.mozilla.org/en-US/docs/Glossary/TLS">TLS</a>－加密的TCP连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。</p>
<p>实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 …）发起请求来获取部分或全部资源。</p>
<p>Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a>头部中，它们甚至可以共享同一个IP地址。</p>
<h3 id="代理（Proxies）（这是思科学的东西吧）"><a href="#代理（Proxies）（这是思科学的东西吧）" class="headerlink" title="代理（Proxies）（这是思科学的东西吧）"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#%E4%BB%A3%E7%90%86%EF%BC%88proxies%EF%BC%89">代理（Proxies）（这是思科学的东西吧）</a></h3><p>在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为<strong>代理（Proxies）</strong>。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用：</p>
<ul>
<li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li>
<li>过滤（像反病毒扫描，家长控制…）</li>
<li>负载均衡（让多个服务器服务不同的请求）</li>
<li>认证（对不同资源进行权限管理）</li>
<li>日志记录（允许存储历史信息）</li>
</ul>
<p>http简单，可扩展，无状态有会话</p>
<h3 id="HTTP-是无状态，有会话的"><a href="#HTTP-是无状态，有会话的" class="headerlink" title="HTTP 是无状态，有会话的"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84">HTTP 是无状态，有会话的</a></h3><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p>
<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>
<p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误），HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p>
<p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议<em><a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>。</em></p>
<h3 id="HTTP-能控制什么"><a href="#HTTP-能控制什么" class="headerlink" title="HTTP 能控制什么"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview#http_%E8%83%BD%E6%8E%A7%E5%88%B6%E4%BB%80%E4%B9%88">HTTP 能控制什么</a></h3><p>多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。</p>
<p>以下是可以被HTTP控制的常见特性。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">缓存 </a><br>文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。</li>
<li><em>开放同源限制</em><br>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于<strong>相同来源</strong>的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。</li>
<li><em>认证</em><br>一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authenticate"><code>Authenticate</code></a>相似的头部即可，或用HTTP Cookies来设置指定的会话。</li>
<li><em><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling">代理和隧道</a></em><br>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。</li>
<li><em>会话</em><br>使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。</li>
</ul>
<p>当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的 <strong>帧 </strong>所取代。</p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。</p>
<p>即使HTTP/2为了提高性能将HTTP报文嵌入到帧中这一举措增加了复杂度，但是从Web应用的角度看，报文的基本结构没有变化，从HTTP/1.0发布起就是这样的结构。会话流依旧简单，通过一个简单的 <a href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">HTTP message monitor</a>就可以查看和纠错。</p>
<p>请求由以下元素组成：</p>
<ul>
<li>一个HTTP的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">method</a>，经常是由一个动词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 或者一个名词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送<a href="https://developer.mozilla.org/en-US/docs/Learn/Forms">HTML form</a>表单值（POST方法），虽然在一些情况下也会有其他操作。</li>
<li>要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有<a href="https://developer.mozilla.org/en-US/docs/Glossary/Protocol">protocol</a> （<code>http://</code>），<a href="https://developer.mozilla.org/en-US/docs/Glossary/Domain">domain</a>（<code>developer.mozilla.org</code>），或是TCP的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port</a>（HTTP一般在80端口）。</li>
<li>HTTP协议版本号。</li>
<li>为服务端表达其他信息的可选头部<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>。</li>
<li>对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。</li>
</ul>
<p>响应报文包含了下面的元素：</p>
<ul>
<li>HTTP协议版本号。</li>
<li>一个状态码（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li>
<li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li>
<li>HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>，与请求头部类似。</li>
<li>可选项，比起请求报文，响应报文中更常见地包含获取的资源body。</li>
</ul>
<h3 id="基于HTTP的APIs"><a href="#基于HTTP的APIs" class="headerlink" title="基于HTTP的APIs"></a>基于HTTP的APIs</h3><p>基于HTTP的最常用API是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> API，可用于在<a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent">user agent</a>和服务器之间交换数据。 现代<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API"><code>Fetch API</code></a>提供相同的功能，具有更强大和灵活的功能集。双工</p>
<p>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a>接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a>对象，并将它们传递给专门处理这类<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/type"><code>type</code></a>事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage"><code>onmessage</code> (en-US)</a>事件处理程序处理</p>
<h2 id="HTTP信息"><a href="#HTTP信息" class="headerlink" title="HTTP信息"></a>HTTP信息</h2><p>HTTP消息由采用ASCII编码的多行文本构成。在HTTP/1.1及早期版本中，这些消息通过连接公开地发送。在HTTP/2中，为了优化和性能方面的改进，曾经可人工阅读的消息被分到多个HTTP帧中。</p>
<p>Web 开发人员或网站管理员，很少自己手工创建这些原始的HTTP消息︰ 由软件、浏览器、 代理或服务器完成。他们通过配置文件（用于代理服务器或服务器），API （用于浏览器）或其他接口提供HTTP消息</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsg2.png" alt="From a user-, script-, or server- generated event, an HTTP/1.x msg is generated, and if HTTP/2 is in use, it is binary framed into an HTTP/2 stream, then sent."></p>
<p>HTTP/2二进制框架机制被设计为不需要改动任何API或配置文件即可应用︰ 它大体上对用户是透明的。</p>
<p>HTTP 请求和响应具有相似的结构，由以下部分组成︰</p>
<ol>
<li>一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</li>
<li>一个可选的HTTP头集合指明请求或描述消息正文。</li>
<li>一个空行指示所有关于请求的元数据已经发送完毕。</li>
<li>一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。</li>
</ol>
<p>起始行和 HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/HTTPMsgStructure2.png" alt="Requests and responses share a common structure in HTTP"></p>
<p><em><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages#http_%E8%AF%B7%E6%B1%82">HTTP请求详细在这里</a></strong></em></p>
<p>HTTP/1.x 报文有一些性能上的缺点：</p>
<ul>
<li>Header 不像 body，它不会被压缩。</li>
<li>两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。</li>
<li>无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。</li>
</ul>
<p>HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 <em>多路复用 (multiplexing)</em> 的过程，它允许更有效的底层 TCP 连接。</p>
<p>热连接就是活跃的连接，冷连接应该是指新连接的意思。因为 TCP 接连建立需要一定的耗时，还要握手，所以 HTTP 应用保持长连接的话，就可以在多个请求之间复用一个 TCP 连接，这样只需要一次连接和握手，从而大幅度提高资源的加载速度。</p>
<p>从 HTTP1.1 开始，长连接和多路复用就就已经被主流浏览器支持，但是某些网站或者不标准的客户端，还是会在一次请求完成之后关闭连接，变成短连接，从而造成资源的浪费。一般来说，请求头或者响应头字段 Connection: keep-alive 用来告诉另一方自己希望保持连接，并持续复用，直到服务器设定的超时限制达到，或者客户端认为所有资源已经加载完成并主动断开连接。</p>
<p>HTTP2 则在原有长连接和多路复用的基础上，实现了头部压缩和封包发送，以及无序请求-响应模型。HTTP1 的多路复用必须等待前一个请求完成才发送下一个请求，这造成了同步阻塞的问题，而 HTTP2 解决了这个问题，客户端给每一个请求打上序号发给服务器，服务器响应时返回这个序号，客户端就知道这个响应属于那个请求，从而实现了无序异步的多路复用，大大提高了客户端的并发能力并加快了资源的加载。同时 HTTP1 客户端还会在检测当前连接拥塞（被前一个连接长时占用）时开新连接加载其他资源。而HTTP2因为无需等待，则可以永远复用一个连接，减少了连接资源的消耗。–A-yon知乎</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/Binary_framing2.png" alt="HTTP/2 modify the HTTP message to divide them in frames (part of a single stream), allowing for more optimization."></p>
<h2 id="HTTTP-1-x-连接管理"><a href="#HTTTP-1-x-连接管理" class="headerlink" title="HTTTP/1.x 连接管理"></a>HTTTP/1.x 连接管理</h2><p><em>短连接</em>, <em>长连接</em>, 和 <em>HTTP 流水线。</em></p>
<p>都有很多问题，还有莫名诡异的域名分片</p>
<p>好像http2中解决了很多很多的问题</p>
<p>自己看吧</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</a></p>
<h2 id="HTTP内容协商"><a href="#HTTP内容协商" class="headerlink" title="HTTP内容协商"></a>HTTP内容协商</h2><p>在 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">HTTP</a> 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如，文档使用的自然语言，图片的格式，或者内容编码形式）。</p>
<p>注意：HTTP内容协商的一些不好的地方在这篇文章中有介绍<a href="https://wiki.whatwg.org/wiki/Why_not_conneg">a wiki page from WHATWG</a>，HTML5提供其他的选择来进行内容协商，如<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source">source&gt; element</a>。</p>
<p>这个功能好复杂，知道有就好了。。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation</a></p>
<h2 id="HTTP发展"><a href="#HTTP发展" class="headerlink" title="HTTP发展"></a>HTTP发展</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></p>
<h2 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h2><p>非常方便的，可由服务器端或者客户端发起的协议升级</p>
<p>不要看他下面的中文翻译。。。错得离谱</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism</a></p>
<h2 id="MDN暂时没有"><a href="#MDN暂时没有" class="headerlink" title="MDN暂时没有"></a>MDN暂时没有</h2><p>http会话流程</p>
<p>HTTP/2中的帧结构</p>
<p>HTTP/2连接管理</p>
<p>商定http版本</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>python二刷</title>
    <url>/2021/05/21/python%E4%BA%8C%E5%88%B7/</url>
    <content><![CDATA[<h1 id="python课件总结"><a href="#python课件总结" class="headerlink" title="python课件总结"></a>python课件总结</h1><p>[toc]</p>
<p>ps：</p>
<p>这份笔记并不完整，是笔者学了一遍粗糙的python后二刷看课件觉得有用的东西，课件想要的私聊，不贵不贵，一杯奶茶:laughing:</p>
<p>还有那份课件的题目值得一做！</p>
<h2 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.语言基础"></a>1.语言基础</h2><p>面向对象 、 解释型 、 动态数据类型</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101010.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101018.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101003.png"  style="zoom:50%;" />



<h3 id="变量与地址"><a href="#变量与地址" class="headerlink" title="变量与地址"></a>变量与地址</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101121.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101133.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521101142.png"  style="zoom:50%;" />

<p> Python  解释器会为每个出现的对象分配内存单元，即使它们的值相等，也会这样 </p>
<p>为了 提高内存利用效率，对于一些简单的对象，如一些数值 较小（-256~256 ）的 整型（int ）对象，Python  采取重用对象内存的办法</p>
<p>单独的下画线（_ ）是一个特殊变量，用于表示上一次运算的结果</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521110533.png"  style="zoom:50%;" />



<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>整数二进制0b\0B开头,八进制0o\0O开头，十六进制0x\0X开头</p>
<p>对于浮点数，Python 3.x  默认提供17  位有效数字的精度，相当<br>于C  语言中的双精度浮点数</p>
<p>可以通过x.real  和x.imag  来分别获取复数x  的实部和虚部，结果都是浮点型，是j不是i</p>
<p>数学常量：e  pi</p>
<p>函数：</p>
<p>fabs  sqrt  pow(x,y)   exp log(x[,base])（base默认是e）  log10()</p>
<p>ceil floor  </p>
<p>fmod(x,y) # x/y的余数 （浮点）</p>
<p>degrees  &lt;=&gt;  radians</p>
<p>sin cos tan asin acos atan（默认用弧度）</p>
<p>Cmath模块函数基本一致，但是对复数运算</p>
<p>cmath.sqrt(-1)  ij 用的是j不是i</p>
<p> cmath 模块包括复数 运算特有的 函数。</p>
<p>复数x=a+bi ，phase(x) 函数返回复数x 的幅 角，即atan(b/a) 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521111433.png"  style="zoom:50%;" />



<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>seed设置种子，默认将<strong>系统时间</strong>设为种子值</p>
<p>choice(seq) ：从 序列的元素中随机挑选一个 元素 。</p>
<p>sample(seq,k) ：从 序列中随机挑选k 个元素。</p>
<p>shuffle(seq) ：将 序列的所有元素随机排序 ,这个只能用于可更改的，字符串不可用</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521111617.png"  style="zoom:50%;" />



<h3 id="时间和日历"><a href="#时间和日历" class="headerlink" title="时间和日历"></a>时间和日历</h3><p>datetime基于time进行了优化，更方便全面</p>
<h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span>date<span class="token punctuation">,</span>time
dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
dt<span class="token punctuation">.</span>year<span class="token punctuation">,</span>month<span class="token punctuation">,</span>day<span class="token punctuation">,</span>hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>second
dt<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token punctuation">)</span>输出前三个
dt<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>输出后三个

dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%x%x%x'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">'202151'</span><span class="token punctuation">,</span><span class="token string">"%Y%m%d"</span><span class="token punctuation">)</span><span class="token comment">#转换为datetime对象！！这个是datetime下的datetime子类！！！</span>
datetime相减会产生datetime<span class="token punctuation">.</span>delta对象
delta <span class="token operator">=</span> datetime2 <span class="token operator">-</span> datetime1
delta <span class="token operator">==</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">7179</span><span class="token punctuation">)</span> <span class="token comment">#间隔99天,7179秒</span>
timedelta和datetime可以做加减得到新的datetime
<span class="token operator">%</span>y     两位数的年份表示（<span class="token number">00</span><span class="token operator">-</span><span class="token number">99</span>）
<span class="token operator">*</span><span class="token operator">%</span>Y     四位数的年份表示（<span class="token number">000</span><span class="token operator">-</span><span class="token number">9999</span>）
<span class="token operator">*</span><span class="token operator">%</span>m     月份（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>d     月内中的一天（<span class="token number">0</span><span class="token operator">-</span><span class="token number">31</span>）
<span class="token operator">*</span><span class="token operator">%</span>H     <span class="token number">24</span>小时制小时数（<span class="token number">0</span><span class="token operator">-</span><span class="token number">23</span>）
<span class="token operator">*</span><span class="token operator">%</span>I     <span class="token number">12</span>小时制小时数（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>M     分钟数（<span class="token number">00</span><span class="token operator">=</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>S     秒（<span class="token number">00</span><span class="token operator">-</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>a     本地简化星期名称
<span class="token operator">*</span><span class="token operator">%</span>A     本地完整星期名称
<span class="token operator">%</span>b     本地简化的月份名称
<span class="token operator">%</span>B     本地完整的月份名称
<span class="token operator">%</span>c     本地相应的日期表示和时间表示
<span class="token operator">%</span>j     年内的一天（<span class="token number">001</span><span class="token operator">-</span><span class="token number">366</span>）
<span class="token operator">%</span>p     本地A<span class="token punctuation">.</span>M<span class="token punctuation">.</span>或P<span class="token punctuation">.</span>M<span class="token punctuation">.</span>的等价符
<span class="token operator">%</span>U     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期天为星期的开始
<span class="token operator">%</span>w     星期（<span class="token number">0</span><span class="token operator">-</span><span class="token number">6</span>），星期天为星期的开始
<span class="token operator">%</span>W     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期一为星期的开始
<span class="token operator">%</span>x     本地相应的日期表示
<span class="token operator">%</span>X     本地相应的时间表示
<span class="token operator">%</span>Z     当前时区的名称
<span class="token operator">%</span><span class="token operator">%</span>     <span class="token operator">%</span>号本身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://zhuanlan.zhihu.com/p/101939095">详述</a></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112059.png"  style="zoom:50%;" />



<h3 id="python内置"><a href="#python内置" class="headerlink" title="python内置"></a>python内置</h3><p>range  iter</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112219.png"  style="zoom:50%;" />

<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112244.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112255.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112308.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112324.png"  style="zoom:50%;" />

<p> Python 中能表示浮点数的有效数字是有限的，而在实际应用中数据的有效位数并无限制，这种矛盾，势必带来计算时的微小误差。</p>
<h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a>2.顺序结构</h2><p>在Python 中，语句行从解释器提示符后的第一列开始， 前面不能有任何空格 ，否则会产生语法错误</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112701.png"  style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521112733.png"  style="zoom:67%;" />

<p>Python 中的赋值并不是直接将一个值赋给一个变量的，而是通过引用传递的，在赋值时，不管这个对象是新创建的还是一个已经存在的，都是将该对象的 引用（ 并不是值 ）</p>
<p>同步赋值指的是多变量一条式子赋值时，实际上先创建了一个元组，先后顺序不影响</p>
<p>eval（）去掉字符串最外侧的引号</p>
<p>print(xxx[,sep =][,end = ])</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113027.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113057.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113106.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113124.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113149.png"  style="zoom:50%;" />



<h3 id="字符串format方法"><a href="#字符串format方法" class="headerlink" title="字符串format方法"></a>字符串format方法</h3><p>这才是王道</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113226.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113241.png"  style="zoom:50%;" />

<p>用序号调整次序，重复什么的很方便</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113335.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113426.png"  style="zoom:50%;" />

<p>注意这个居中填充，还有居中不对称时左边少一个</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'what &#123;1:&lt;10&#125;&#123;0&#125;the &#123;c:&amp;&lt;10.1f&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token number">21.311</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
what b         athe <span class="token number">21.3</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span>
In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'what &#123;1:&lt;10&#125;&#123;0&#125;the &#123;c:&amp;=+10.1f&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token number">21.311</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
what b         athe <span class="token operator">+</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token number">21.3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113449.png"  style="zoom:50%;" />









<h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706145044.png"  style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706145338.png"  style="zoom:50%;" />

<p>for 语句是通过遍历任意序列的元素进行来建立循环的，针对序列的每一个元素执行一次循环体</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113716.png"  style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521113742.png"  style="zoom: 67%;" />

<p>首先Python 对关键字in 后的对象调用iter() 函数获得迭代 器，然后 调用next() 函数获得迭代器的 元素，直到 抛出stopIteration</p>
<p> while 语句多用于循环次数不确定的情况，而对于循环次数确定的情况，使用for</p>
<p>pass空语句</p>
<p>注意 ：布尔常量True 和False 首字母必须大写 ！</p>
<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h2><p><strong>建议看看原文</strong></p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>万国码Unicode是python选择的标准符号表，它每种语言中的每个字符设定了<strong>统一并且唯一的二进制编码</strong>，以满足跨语言、跨平台进行文本转换、处理的要求（翻译二进制码的方式）</p>
<p>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</p>
<p>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</p>
<p>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p>
<p>字节只是一个单位（8位）罢了，不同的编码中采用不同的规则存储字符，而这些规则实现的时候消耗字节大小不同</p>
<p>UTF-8</p>
<p>​    是 一种为Unicode 字符设计的变长编码系统</p>
<p>对于ASCII 字符，UTF-8 仅使用1 个字节来编码</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123412.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123508.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521123527.png"  style="zoom:50%;" />

<p>Unicode规定了，所有字符<strong>统一由两个字符</strong>来表示，也就是<strong>16位</strong></p>
<p>utf-8就是缩小一点，从4到8到12到16分段</p>
<p><a href="https://zhuanlan.zhihu.com/p/137875615">详述</a>有一点错误就是最后那个中文例子，看我的👇</p>
<p><strong>而python字符串默认是unicode编码</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> <span class="token string">'卧槽'</span>

In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'卧'</span>

In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">b'\xe5\x8d\xa7\xe6\xa7\xbd'</span> <span class="token comment">#一个汉字拆成三个字节</span>
    
In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c <span class="token operator">=</span> <span class="token string">'dnoad'</span>
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> c<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">b'dnoad'</span>
<span class="token comment"># 英文在utf-8中不会发生转换，直接用一个字节表示</span>
In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'我'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">25105</span> <span class="token comment">#unicode</span>
    
In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">25104</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'成'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>分片的操作很灵活，开始和结束 的索引值 可以超<br>过字符串的长度 </p>
<p>字符串用 +  和 *</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130045.png"  style="zoom:50%;" />

<p>但是在解释器里面，都是输出普通的’abc’</p>
<p>Python 的字符串是不可变类型，只能通过新建一<br>个字符串去改变一个字符串的元素</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130119.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130139.png"  style="zoom:50%;" />

<p>字符比较是按其计算机内部字符编码值的大小进<br>行比较，西文字符按ASCII 码值大小进行比较</p>
<p>  比较的基本规则是，空格字符最小，数字比字母<br>小，大写字母比小写字母小（ 对应字母相 差32</p>
<h3 id="函数。。"><a href="#函数。。" class="headerlink" title="函数。。"></a>函数。。</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130239.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130256.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130327.png"  style="zoom:50%;" />

<p>prefix和suffix是字符串，start 可以选择开头位置，end我不知道干嘛的</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130413.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130614.png"  style="zoom:50%;" />

<p>split如果两个分隔符中没东西，也会拆出空字符串,从左右拆顺序不变，可能只影响matsplit参数</p>
<p>那个splitlines试了一下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> <span class="token string">'dada\nwdad'</span>
c
Out<span class="token punctuation">[</span><span class="token number">51</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'dada\nwdad'</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
dada
wdad
c<span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'dada'</span><span class="token punctuation">,</span> <span class="token string">'wdad'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130715.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130738.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130818.png"  style="zoom:50%;" />



<h3 id="字节类型"><a href="#字节类型" class="headerlink" title="字节类型"></a>字节类型</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521130927.png"  style="zoom:50%;" />

<p>和字符串一样，可以使用内置的len() 函数求bytes对象的长度，也可以 使用“+ ” 运算符连接两个bytes 对象，其操作结果是一个新的bytes 对象</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131019.png"  style="zoom:50%;" />

<p>如果需要改变某个字节，可以组合使用字符串的分片和连接操作（效果跟字符串是一样的）， 也可以 将bytes 对象转换为bytearray 对象，bytearray对象是可以被修改的</p>
<p>可以 使用编号给bytearray 对象的某个字节赋值 ， <strong>并且这个值必须是0~255 之间的一个整数</strong></p>
<p>  也 不允许针对bytes 对象的出现次数进行计数，因为字符串里面 根本没有字节字符</p>
<p>encode和decode可以在两者间转换</p>
<h2 id="5-正则"><a href="#5-正则" class="headerlink" title="5.正则"></a>5.正则</h2><p><a href="https://darren-dong.com/2021/03/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">看我的博客了解基础知识</a></p>
<p>  在Python 中，正则表达式的功能通过正则表达式<br>模块re</p>
<p> re 模块提供各种正则表达式 的匹配 操作，在文本解析、复杂字符串分析和信息提取时是一个非常有用的工具。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131633.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131657.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131718.png"  style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131726.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131733.png"  style="zoom:33%;" />



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131810.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131819.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131839.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131907.png"  style="zoom:50%;" />

<p>正则表达式中，group（）用来提出分组截获的字符串<strong>，（）用来分组</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span>  re
a  <span class="token operator">=</span>  <span class="token string">"123abc456"</span>
<span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">#123abc456,返回整体</span>
<span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment">#123</span>
<span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span>    <span class="token comment">#abc</span>
<span class="token keyword">print</span>  re<span class="token punctuation">.</span>search<span class="token punctuation">(</span> <span class="token string">"([0-9]*)([a-z]*)([0-9]*)"</span> <span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span>    <span class="token comment">#456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>正则表达式中的三组<strong>括号</strong>把匹配结果分成三组</li>
</ol>
<ul>
<li> group() 同group（0）就是匹配正则表达式整体结果</li>
<li> group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。</li>
</ul>
<ol start="2">
<li>没有匹配成功的，re.search（）返回None</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521131927.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132000.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132021.png"  style="zoom:50%;" />

<p><strong>注意到匹配模式串使用了原始字符串r’  ‘</strong></p>
<p> match() 方法并不是完全匹配。当正则表达式结束时，若string 还有剩余字符 ，仍然视为 成功</p>
<p>  想 要完全匹配，可以在表达式末尾加上边界匹配符’$</p>
<hr>
<p>match() 函数只是在字符串 的左端位置 尝试匹配正则表达式，也就是只报告从位置0 开始的 匹配情况。</p>
<p>  如果想要搜索整个字符串来寻找匹配，应当用search() 函数 ,使用方法完全一样</p>
<p> findall() 函数搜索字符串，以列表形式返回全部能匹配正则表达式的子串 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132802.png"  style="zoom:50%;" />

<p>finditer()  与findall() 函数类似，在字符串中找到正则表达式所匹配的所有子串，并组成一个迭代器返回。</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132849.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132909.png"  style="zoom:50%;" />

<p> subn() 函数的功能和sub() 函数 相同，但 返回新的字符串以及替换的次数组成的元组 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521132944.png"  style="zoom:50%;" />



<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133009.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133156.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521133228.png"  style="zoom:50%;" />

<p><strong>两个斜杠噢，第一次先让编译器把两个斜杠转成一个斜杠，第二步到正则字符串则把剩下的单斜杠看成是转义</strong></p>
<h2 id="6-列表-amp-元组"><a href="#6-列表-amp-元组" class="headerlink" title="6.列表&amp;元组"></a>6.列表&amp;元组</h2><p>len()  min()  max()</p>
<p>sum()返回序列s中所有元素和，元素必须为数值</p>
<p>reduce 位于functools模块中</p>
<p> reduce(f,s[,n]) ：reduce() 函数把序列s 的前两个元素作为 参数，传 给函数f ，返回 计算的结果和 序列的下一个元素重新作为f 的参数，直到序列的最后一个元素 </p>
<p>enumerate 和 zip不必多言</p>
<p>利用* 号操作符，可以将对象解压 还原</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token operator">=</span><span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有sorted reversed  all any</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141444.png"  style="zoom:50%;" />

<p>加星号的变量只允许一个，否则会出现语法错误syntaxError 。</p>
<p>列表可以进行元素赋值（索引不能超）</p>
<p>元素删除  del   分片赋值  在使用<strong>分片赋值</strong>时，<strong>可使用与原序列不等长的序列将分片替换</strong> </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141731.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706154841.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141802.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141833.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521141849.png"  style="zoom:50%;" />

<p>for前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果，必须加上else，如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h3><ol>
<li><strong>序列都可以用</strong></li>
</ol>
<p>并不改变序列本身，可用于列表，元组，字符串</p>
<p>s.count(x) ：返回x 在序列s 中出现的次数</p>
<p>s.index(x) ：返回x 在s 中第一次出现的下标</p>
<p>不过x是完整的</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521142351.png"  style="zoom:50%;" />



<ol start="2">
<li>仅使用列表</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143101.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143117.png"  style="zoom: 50%;" />

<p>s.reverse() ：将列表s 中的元素逆序排</p>
<p> s.pop([i]) ：删除并返回列表s 中指定位置i 的元素，默认是最后一个元素。若i 超出列表长度 ，则 抛出IndexError 异常 </p>
<p> s.insert(i,x) ：在列表s 的i 位置处插入x 。<strong>如果i 大于列表的长度，则插入到列表最后 。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521143709.png"  style="zoom:50%;" />

<p>可以看看题目</p>
<h2 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144114.png"  style="zoom:50%;" />

<p>更新和创建都用索引，删除则用del，检查关键字用in / not in</p>
<p> len() 函数可以获取字典所包含“关键字: 值”对的数目，即字典长度 。虽然 也支持max() 、min() 、sum() 和sorted() 函数，但只针对字典的关键字进行计算，很多情况下没有实际意义。</p>
<p>  字典不支持连接(+) 和重复操作符(*) ，关系运算中只有“==”  和“!=”  有意义 </p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>dict三用法:</p>
<ol>
<li><p>使用dict() 函数创建一个空字典并给变量赋值</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160413.png"  style="zoom:50%;" />

<p><strong>第二种方法应该是大规模处理中用的多的</strong></p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160432.png"  style="zoom:50%;" /></li>
</ol>
<p>Python 字典和集合实际上也是对象，Python 提供了很多有用的方法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144729.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144739.png"  style="zoom:50%;" />

<p>原先的键会被清除，字符串也可以做序列，   <strong>重复的键会被删除</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">d2 <span class="token operator">=</span> d<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'dwad'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
d2
Out<span class="token punctuation">[</span><span class="token number">92</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144757.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144814.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144833.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144857.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144930.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144948.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521144955.png"  style="zoom:50%;" />



<h2 id="8-集合"><a href="#8-集合" class="headerlink" title="8.集合"></a>8.集合</h2><p>  在Python 中， 集合（ set  ）是 一个无序排列的、不重复的数据集合体，类似于数学中的集合概念 ，可 对其 进行并、 交、 差等 运算</p>
<p>集合和字典都属于无序集合体，有许多操作是一致的 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145206.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145235.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521145238.png"  style="zoom:50%;" />

<p>  在Python 中，用大括号将集合元素括起来，这与字典的创建类似，但{} 表示空字典，空集合用set()表示。</p>
<p>集合 的 自动删除重复元素 这个特性非常有用，例如，要删除列表中大量的重复元素，可以先用set()函数将列表转换成集合，再用list() 函数将集合转换成列表，操作效率非常高。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150012.png"  style="zoom:50%;" />

<p> Python 提供frozenset() 函数来创建不可变集合，不可变集合是不能修改的，因此能作为其他集合的元素，也能作为字典的关键字。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150057.png"  style="zoom:50%;" />



<h3 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150124.png"  style="zoom:50%;" />

<p>比较用 == 和 ！=  还有包含真包含 &lt; &lt;=</p>
<p>当然还有赋值运算符 s1 |= s2</p>
<p>集合与for 循环语句配合使用，可实现对集合各个元素的遍历</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706161507.png"></p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><strong>适用于可变和不可变集合</strong></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150431.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150451.png"  style="zoom:50%;" />

<p> s.copy() ：复制集合s 。</p>
<ol start="2">
<li><strong>适合可变集合的方法</strong></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150621.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150630.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521150705.png"  style="zoom:50%;" />



<h2 id="9-函数与模块"><a href="#9-函数与模块" class="headerlink" title="9.函数与模块"></a>9.函数与模块</h2><p>在Python 中，实参向形参传送数据的方式是“值传递”，即“拷贝”或“复制”</p>
<p>  实参 的值传给形参 ，是对象间整体赋值，是 一种单向传递方式，不能由形参传回给实参。</p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521151042.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521151105.png"  style="zoom:50%;" />



<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">1</span><span class="token punctuation">.</span> 必选参数就是位置参数，必须填，
<span class="token number">2</span><span class="token punctuation">.</span> 默认参数可填可不填。默认参数有个坑，就是每次调用函数，默认参数的指向不便且会保存，所以可修改，每次都不一样，因此定义默认参数要牢记一点：默认参数必须指向不变对象!
<span class="token number">3</span><span class="token punctuation">.</span> 然后就到可变参数，指的是可以接受所有值的元组，<span class="token operator">*</span>args  放在第三位接受所有的
<span class="token number">4</span><span class="token punctuation">.</span> 第四是命名关键字，或者说可变字典<span class="token operator">**</span>kw  接受所有的 a <span class="token operator">=</span> <span class="token string">'xxx'</span> 这样的参数，并赋给字典，但是key不用加引号
<span class="token number">5</span><span class="token punctuation">.</span> 最后是关键字参数，不能省略的键值对！
<span class="token comment">#其实就是无限接受的放在后面。</span>

如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
<span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span>
    
和关键字参数<span class="token operator">**</span>kw不同，命名关键字参数需要一个特殊分隔符<span class="token operator">*</span>，<span class="token operator">*</span>后面的参数被视为命名关键字参数。
调用方式如下：
<span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Beijing'</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Engineer'</span><span class="token punctuation">)</span>
Jack <span class="token number">24</span> Beijing Engineer

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<span class="token operator">*</span>了：
<span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span>
    
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
<span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'Engineer'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> person<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">2</span> positional arguments but <span class="token number">4</span> were given
<span class="token comment">#命名关键字参数可以有缺省值，从而简化调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数参数规则：</p>
<ol>
<li><em><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></em></li>
<li>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</li>
<li><strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
</ol>
<p>注意 **dict解包作为参数时，是复制一份，也就是传值</p>
<hr>
<p>  当在 函数内部修改列表、字典的 元素时，形参的改变会影响实参，即双向传递，类似于“传地址”、“共享内存”、“借”，</p>
<p>匿名函数lambda</p>
<p> lambda [ 参数1[, 参数2,……, 参数n]]: 表达式</p>
<p>  关键字lambda 表示匿名函数，冒号前面是函数参数，可以有多个函数参数，但只有一个返回值 ，所以只能有一个表达式，返回值就是该表达式的结果。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211105121650828.png" alt="image-20211105121650828" style="zoom:50%;" />



<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>这个讲的比一般的清楚一点所以放在这。</p>
<p>  装饰器 （decorator ，[ˈdekəreɪtə(r)] ）可简单地理解为一个函数，这是一个用来包装函数的函数，经常用于为已经存在的函数添加额外的功能</p>
<p>  当多个函数有重复代码时，可以将此部分代码单独拿出来整理成一个 装饰 器，然后对每个函数调用该装饰器，这样可以实现代码的复用，而且可以让原来的函数更轻便 。</p>
<p>  当 需要为多个己经写好的函数添加一个共同功能，例如检查参数的合法性时，就可以单独写一个检查合法性的装饰器，然后在每个需要检查参数合法性的函数处调用即可，而不用去每个函数内部修改 </p>
<h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153116.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153130.png"  style="zoom:50%;" />

<p>  <strong>把@deco 语句放在函数square_sum() 定义之前，实际上是将square_sum 传递给装饰器deco  ，并将deco 返回的新函数对象赋给原来的函数名</strong> square_sum=deco(square_sum)</p>
<p>从本质上，装饰器起到的就是这样一个重新指向函数名的作用，让同一个对象名指向一个新返回的函数，从而达到修改可调用函数的目的 </p>
<p>最外层定义deco的本体，把函数传进去，里面定义新函数，新函数肯定要调用到原来的函数。如果需要传参数，就在本体外面再加一层传递参数的壳。</p>
<h4 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521153708.png"  style="zoom:50%;" />

<p><strong>要注意多重装饰器的执行顺序，应该是先执行后面的装饰器，再执行前面的装饰器。</strong></p>
<p>global</p>
<p>在程序中定义全局变量的主要目的是，为函数间的数据联系提供一个直接传递的通道 。</p>
<p>  因此不要滥用全局变量</p>
<h3 id="模板有条件执行"><a href="#模板有条件执行" class="headerlink" title="模板有条件执行"></a>模板有条件执行</h3><p>模块 中可以是一段 可以 直接执行的 程序（也称为<br>脚本 ） ， 也可以定义一些变量、类或函数，让别的模块导入和调用， 类似于库。</p>
<p>  模块中的定义部分，例如全局变量定义、类定义、函数定义等，因为没有程序执行入口，所以 不能直接运行，但对主程序代码部分有时希望只让它在模块直接执行的时候才执行，被其他模块加载时就不执行。</p>
<p>  在Python 中，可以通过系统变量“__name__”（注意前后都是两个下画线）的值来区分这两种情况。  如果模块是被其他模块导入的，__name__ 的值是模块的名称，主动执行时它的值就是字符串“__main__” 。</p>
<p>  通过__name__ 变量的这个特性，可以将一个模块文件既作为普通的模块库供其他模块使用，又可以作为一个可执行文件进行 执行。</p>
<h2 id="10-面向对象"><a href="#10-面向对象" class="headerlink" title="10.面向对象"></a>10.面向对象</h2><p>  <strong>面向对象程序设计（Object-Oriented programming ，OOP ）则以对象作为程序的主体，将程序和数据封装于其中，以提高软件的重用性、灵活性和扩展性</strong></p>
<p>面向对象程序设计是按照人们认识客观世界的系统思维方式，采用基于对象的概念建立问题模型，模拟客观世界，分析、设计和实现软件的办法</p>
<p>面向对象语言的三大核心内容是封装（类和对象）、 继承（派生）和 多态 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154319.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154329.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154351.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154441.png"  style="zoom:50%;" />

<p>class  A：</p>
<p>   x = 5</p>
<p>我定义了一个类A，这个时候自动出现了个类对象A，我可以使用A.x调用类属性</p>
<p>  <strong>“ .” 运算符：成员运算符</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521154708.png"  style="zoom:50%;" />

<p>  类中的实例方法至少应有 一 个变量 参数，一般命名为“ self ”( 习惯，非语法要求) ) ，而且该参数必须 作为形参表的第一 个参数，即必须放 于形式参数 表的最左边 </p>
<p>实例的方法和对象只能实例调用，不能类调用，这不是废话嘛</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>  类 属性（class attribute ）是类的 属性，它被 所有类对象和实例对象共有 ，在内存中只存在一个副本</p>
<p>公有 的类属性，在类外可以通过类对象和实例对象访问 ，但是不提倡用实例对象访问，容易绕晕</p>
<p>  类属性还可以在类定义结束之后通过类 名（类对象）增加  比如 A.new  = 212</p>
<p>实例对象也 可以在类定义结束之后通过实例对象名增加实例属性</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155315.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155327.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155408.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521160210.png"  style="zoom:50%;" />

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155453.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155458.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155511.png"  style="zoom:50%;" />

<p> 只要创建实例对象，就一定要调用构造方法</p>
<p> 只要调用了构造方法，就一定创建了实例对象</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155619.png"  style="zoom:50%;" />

<p>构造方法重载：</p>
<ol>
<li>使用默认参数</li>
<li>构造方法根据条件调用其他的自定方法</li>
<li>构造方法根据条件执行不同的操作，可以用*arg来接受数量未知的参数</li>
</ol>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155658.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155717.png"  style="zoom:50%;" />



<p><strong>实例方法必须有一个参数放在最左端，self</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521155752.png"  style="zoom:50%;" />

<p><a href="http://c.biancheng.net/view/4552.html">一点详解</a></p>
<p>@staticmethod 静态方法只是名义上归属类管理，但是不能使用类变量和实例变量，是类的工具包<br>放在函数前（该函数不传入self或者cls），所以不能访问类属性和实例属性</p>
<p>静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>  从已有类产生新类的过程就称为类的派生（derivation）（派生是继承的另一种说法）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161333.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161544.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161554.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161602.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161627.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161723.png"  style="zoom:50%;" />

<p>多重 继承（multiple inheritance ）是指一个子类有两个或多个直接父类，子类从两个或多个直接父类中继承所需的 属性和方法。</p>
<p>class  子类名( 父类名1, 父 类名2,…):</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521161843.png"  style="zoom:50%;" />

<p> Python 本身是一种 解释型语言 ，不进行编译，因此它就只在运行时 确定 其状态，故也可以说Python 是一种多态语言 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163054.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163113.png"  style="zoom:50%;" />



<h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><p>__slot__，限制示例对象能自主添加的属性。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211105155310776.png" alt="image-20211105155310776" style="zoom: 50%;" />



<p><code>@property</code>广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查（在setter里），这样，程序运行时就减少了出错的可能性。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208">https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@property</span> <span class="token comment">#相当于getter</span>
    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__width

    <span class="token decorator annotation punctuation">@width<span class="token punctuation">.</span>setter</span>
    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>__width <span class="token operator">=</span> value

    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__height

    <span class="token decorator annotation punctuation">@height<span class="token punctuation">.</span>setter</span>
    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>__height <span class="token operator">=</span> value

    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">resolution</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">786432</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>dir 返回所有的方法和属性，包括私有的和隐藏的，私有的会变成 <code>_类名__属性</code></p>
<p>hasattr  getattr  setattr</p>
<p>还可以将object提供的类的诸多参数比如<code>__len__ \ __call__</code>override来自定义类</p>
<h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><p>这个把我的心态搞炸了一会 </p>
<p>首先python里的默认编码都是Unicode，所有的文件其实本质都是二进制码，二进制文件只能用bytes类型操作，读出来怎么解读自己来，一般都用Unicode规则来decode（  二进制文件 是把数据按其在内存中的存储形式原样输出到磁盘上存放。）</p>
<p>小心那个文件指针位置，你写入了以后会放在最后，再读取啥都读不出来类似的</p>
<p>Python你在读写文件的时候<strong>不要打开</strong>。。不然会出现更改不了。。</p>
<p>理解python的<a href="https://blog.csdn.net/qq_23953717/article/details/78434292">open</a>txt默认是ANSI编码，不是UTF-8，坑死了，解决方案👈</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163612.png"  style="zoom:50%;" />

<p>经常需要用到“终端形式”阅读的，用文本，经常修改的，最好用二进制</p>
<p>  读/ 写操作是相对于磁盘文件而言的，而输入/ 输出操作是相对于内存储器而言的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163715.png"></p>
<p> r+是从最开始开始读的</p>
<p>文件对象=open( 文件说明符[, 打开方式][, 缓冲区])</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706170109.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706170146.png"  style="zoom:50%;" />



<hr>
<p>文件对象有一些属性</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163754.png"  style="zoom:50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521163811.png"></p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>文本文件是指以ASCII 码方式存储的文件：英文、数字等字符存储的是ASCII 码 ，而 汉字存储的是机内码。</p>
<p>  文本文件中除了存储文件有效字符信息（包括能用ASCII 码字符表示的回车、换行等信息）外，不能存储其他任何信息</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164102.png"  style="zoom:50%;" />

<p>文本文件的 优点：方便 阅读和理解，使用常用的文本编辑器或文字处理器就可以对其创建和修改的，文件 对象提供了read() 、readline() 和readlines() 方法 用于读取文本文件的内容</p>
<p>  每次write() 方法 执行完后并不 换行，如果 需要换行则在字符串最后加 换行符“\n</p>
<p>读取中文问题：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">InIn <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'try.txt'</span><span class="token punctuation">,</span><span class="token string">'r+'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
UnicodeDecodeError                        Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">648df9718e18</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>

UnicodeDecodeError<span class="token punctuation">:</span> <span class="token string">'gbk'</span> codec can't decode byte <span class="token number">0xad</span> <span class="token keyword">in</span> position <span class="token number">8</span><span class="token punctuation">:</span> illegal multibyte sequence
    默认gbk

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'try.txt'</span><span class="token punctuation">,</span><span class="token string">'r+'</span><span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'我是中文'</span>
    
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'现在能输中文吗'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">7</span> <span class="token comment">#成功了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164604.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521164625.png"  style="zoom:50%;" />

<p>seek()偏移为正数表示朝文件尾方向移动，偏移为负数表示朝文件头方向移动；</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521165042.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521165103.png"  style="zoom:50%;" />

<p>  文本文件 存放的是与编码对应的字符，而二进制文件直接存储字节编码。</p>
<h3 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185801.png"  style="zoom: 50%;" />

<p>读文件的时候，可以一次读出4 个字节，然后用unpack() 方法转换成Python 的整数 。</p>
<p>注意：<strong>unpack() 方法执行后得到的结果是一个元组。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185829.png"  style="zoom:50%;" />

<p>  如果写入的数据是由多个数据构成的，则需要在pack() 方法中使用格式串</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185901.png"  style="zoom:50%;" />

<p>  此时的bytes 就是二进制形式的数据了，可以直接写入二进制文件 。当需要时可以读出来，再通过struct.unpack() 方法解码成Python 变量</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185938.png"  style="zoom:50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521185948.png"></p>
<h3 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521190026.png"  style="zoom:50%;" />

<p>在pickle 模块中有2 个常用的方法：dump() 和load()</p>
<p>pickle.dump( 数据，文件对象）</p>
<p>  其功能是直接把数据对象转换为字节 字符串，并保存到文件中 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521191834.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521191845.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521192855.png"  style="zoom:50%;" />



<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p> Python 的os 模块提供了类似于操作系统级的文件管理功能，如文件重命名、文件删除、目录管理等 </p>
<p>os.rename(“ 当前文件名”,” 新文件名”)</p>
<p>os.remove(“ 文件名”)</p>
<p>os.mkdir(“ 新目录名”)</p>
<p>os.chdir(“要成为当前目录的目录名”)</p>
<p>getcwd() 方法显示当前的工作目录。</p>
<p>os.rmdir(“ 待删除目录名”) <strong>在用rmdir() 方法删除一个目录前，先要删除目录中的所有内容。</strong></p>
<h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.异常"></a>12.异常</h2><p>程序中的错误通常分为 语法错误 、 运行错误 和 逻辑错误 。</p>
<p>语法 错误是由于程序中使用了不符合 语法规则 的信息而导致的 ，这类错误比较 容易 修改，因为编译器或解释器会指出错误的位置和性质</p>
<p>运行错误则不容易修改，因为其中的错误是 不可预料的，或者可以预料但无法避免 的，  例如：内存 空间不够、数组下标越界、文件打开失败等</p>
<p>逻辑错误 主要表现在程序运行后，得到的结果与设想的结果不一致，通常出现逻辑错误的程序都能正常运行系统 不会给出提示信息，所有很难发现。</p>
<p>良好的程序应该对用户的不当操作做出提示，能识别多种情况下的程序运行状况，并选择适当 的应对 策略 </p>
<p>在程序中，对各种可预见的异常情况进行处理称为异常处理（exception handling）</p>
<p>处理程序异常的方法有很多，最简单和最直接的办法是在发现异常时，由Python 系统进行 默认的异常处理 </p>
<p>如果 异常对象未被处理或者捕捉，程序就会用所谓的 回溯（Traceback ） 终止</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194005.png"  style="zoom:50%;" />

<p>标准错误信息包括两个部分：错误类型（如NameError ）和错误说明（如name ‘A’ is not defined ），两者用冒号分隔</p>
<p> Python 系统还追溯错误发生的位置，并显示有关<br>信息</p>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194142.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194153.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521194218.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521195131.png"  style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521195150.png"  style="zoom:67%;" />



<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    xxx
<span class="token keyword">except</span> 异常类型<span class="token number">1</span><span class="token punctuation">[</span><span class="token keyword">as</span> 错误描述<span class="token punctuation">]</span><span class="token punctuation">:</span>
    xxx
<span class="token keyword">except</span> 异常类型<span class="token number">2</span><span class="token punctuation">[</span><span class="token keyword">as</span> 错误描述<span class="token punctuation">]</span><span class="token punctuation">:</span>
    xx<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">except</span><span class="token punctuation">:</span>
    默认异常处理语句块
<span class="token keyword">else</span><span class="token punctuation">:</span>
    语句块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200428.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200444.png"  style="zoom:50%;" />

<p>当发生异常时，直接跳转到except，try中没执行完的语句会被跳过嗷！</p>
<p>可以嵌套。</p>
<p><strong>finally 子句是指无论是否发生异常都将执行相应的</strong><br><strong>语句块 。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521200807.png"  style="zoom:50%;" />



<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在编写程序时，在程序调试阶段往往需要判断程序执行过程中变量的值，根据变量的值来分析程序的执行情况 </p>
<p>可以 使用print() 函数打印输出结果，也可以通过断点跟踪调试查看变量，但使用断言更加灵活高效 。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201018.png"  style="zoom:50%;" />

<pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'除数不可为0'</span>
c <span class="token operator">=</span> a<span class="token operator">/</span>b
<span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>

Lenovo@LAPTOP<span class="token operator">-</span>08D3H5DC MINGW64 <span class="token operator">~</span><span class="token operator">/</span>Desktop<span class="token operator">/</span>env
$ D<span class="token punctuation">:</span><span class="token operator">/</span>Anaconda3<span class="token operator">/</span>envs<span class="token operator">/</span>TF2<span class="token operator">/</span>python<span class="token punctuation">.</span>exe c<span class="token punctuation">:</span><span class="token operator">/</span>Users<span class="token operator">/</span>Lenovo<span class="token operator">/</span>Desktop<span class="token operator">/</span>env<span class="token operator">/</span>one<span class="token punctuation">.</span>py
<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"c:/Users/Lenovo/Desktop/env/one.py"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    <span class="token keyword">assert</span> b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'除数不可为0'</span>
AssertionError<span class="token punctuation">:</span> 除数不可为<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> AssertionError 异常可以被捕获，并像使用在try-except 语句中的任何其他异常处理，但如果不处理，它们将终止程序并产生回溯</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201713.png"  style="zoom:50%;" />



<h3 id="主动引发异常与自定义类"><a href="#主动引发异常与自定义类" class="headerlink" title="主动引发异常与自定义类"></a>主动引发异常与自定义类</h3><p>前面的异常类都是由Python 库中提供的，产生的异常也都是由Python 解释器引发的</p>
<p>  在程序设计 过程中，有时需要在编写的程序中主动引发异常，还可能需要定义表示特定程序错误的异常类。</p>
<p>  在Python 中，要想自行引发异常，最简单的形式就是输入关键字raise ，后跟要引发的异常的名称 </p>
<p>异常 名称标识出具体的类，Python 异常处理是这些类的对象 。 raise 语句还可指定对异常对象进行初始化的参数  ，<strong>执行raise 语句时，Python 会创建指定的异常类的一个对象</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521201958.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521202026.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210521202332.png"  style="zoom:50%;" />

<p>处理学生成绩时，成绩不能为负数。利用前面创建的NumberError 异常类，处理出现负数成绩的异常 。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow-note</title>
    <url>/2021/04/26/tensorflow-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课程结构：</p>
<ol>
<li>神经网络计算：搭建第一个神经网络模型</li>
<li>神经网络优化：学习率、激活函数、损失函数、正则化、自写优化器</li>
<li>神经网络八股：搭建八股“六步法”</li>
<li>网络八股扩展：八股拓展：自制数据集、数据增强、断点续训、参数提取、可视化、给图识物</li>
<li>卷积神经网络：用CNN和一些工具实现图像识别</li>
<li>循环神经网络：用RNN和一些工具实现股票预测</li>
</ol>
<hr>
<p>每一章的思维框架借鉴了<a href="https://blog.csdn.net/weixin_42186072/article/details/106669979">大佬的博客</a>，学完一章可以看这里</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155209.png" alt="课程概览" style="zoom: 67%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155220.png" alt="引入"></p>
<h2 id="鸢尾花"><a href="#鸢尾花" class="headerlink" title="鸢尾花"></a>鸢尾花</h2><p>专家系统是理性的。（if case。）</p>
<p>但是有些花农直接可以看出种类，因为他们见了太多，而且经验越丰富，识别准确率越高</p>
<p>这是一种感性的直觉，是这门课介绍的神经网络方法</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/20210426223114.png" style="zoom:33%;" />

<hr>
<p>具体实现</p>
<p>MP模型，每个输入特征乘以线上的权重，再通过一个非线性函数输出，简化是去掉非线性函数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426224043.png" style="zoom:33%;" />

<p>每个输出节点都链接了所有的输入关系，称为全连接网络</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426224129.png" style="zoom:33%;" />

<h2 id="TF2"><a href="#TF2" class="headerlink" title="TF2"></a>TF2</h2><p>把numpy格式转换为tensor格式</p>
<p>创建形式和numpy非常类似！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155247.png" alt="创建"></p>
<hr>
<p>tensorflow中一切皆为张量，包括输出的常数结果也是一个shape = ()的tensor类型张量</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155255.png" alt="函数"></p>
<p>其中tf.argmax可以直接接受numpy数组类型的参数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426234353.png" style="zoom:33%;" />

<h2 id="鸢尾花2"><a href="#鸢尾花2" class="headerlink" title="鸢尾花2"></a>鸢尾花2</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426235530.png" style="zoom: 33%;" />



<p>class1 P45 <strong>非常重要</strong>，建议全文背诵hhh</p>
<h1 id="参数知识"><a href="#参数知识" class="headerlink" title="参数知识"></a>参数知识</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155310.png" alt="第二章" style="zoom:50%;" />

<p>先介绍一些函数：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095155.png" style="zoom:25%;" />

<p>记住这个是逐个比较</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095313.png" style="zoom:25%;" />



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095925.png" style="zoom: 25%;" />

<hr>
<p><strong>复杂度</strong></p>
<p>输入层不算层数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427132521.png" style="zoom:25%;" />

<p><strong>学习率</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427132837.png" style="zoom:25%;" />

<p>只是增加了一些代码</p>
<hr>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a><strong>激活函数</strong></h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191332.png" style="zoom:25%;" />





<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191556.png" style="zoom:25%;" />

<p>因为反向传播从输出层向输入层逐层求导，每一层的导数都落在0-0.25，多了以后趋于0，称为<strong>梯度消失</strong>，无法更新参数。所以sigmoid函数如今用的很少了</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191737.png" style="zoom:25%;" />

<p>通过调整初始化来避免“神经元死亡（一直是0）”，可以设置更小的学习率，减少参数分布的巨大变化，来👆</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427192342.png" style="zoom:25%;" />

<p>初学者的建议：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427192420.png" style="zoom:25%;" />

<p>对零均值化的解释：</p>
<p><a href="https://blog.csdn.net/wtrnash/article/details/87893725">https://blog.csdn.net/wtrnash/article/details/87893725</a></p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427194702.png" style="zoom:25%;" />

<p>loss_mse = tf.reduce.mean(tf.square(y_-y))</p>
<p>P19随机数使用很秀。</p>
<p>有时候也要根据实际情况自定义损失函数。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427200949.png" style="zoom:25%;" />

<p>交叉熵计算概率分布间的距离</p>
<p>tf.losses.categorical_crossentropy(y,y_)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427201314.png"></p>
<p>这个虽然可以配合softmax使用，但是还有集成的👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427201845.png" style="zoom:25%;" />

<p>如图，一换二不亏</p>
<h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>欠拟合是对现有数据集学习的不太彻底，拟合效果不好</p>
<p>过拟合是对现有数据拟合的太好，却对新数据难以处理</p>
<p>ps：</p>
<p>在机器学习的<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>中，超参数是在开始学习过程之前设置值的参数。 相反，其他参数的值通过训练得出。</p>
<p>超参数：</p>
<ul>
<li>定义关于模型的更高层次的概念，如复杂性或学习能力。</li>
<li>不能直接从标准模型培训过程中的数据中学习，需要预先定义。</li>
<li>可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427202855.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427203023.png"></p>
<p>P29有最优化代码</p>
<p>把区分0和1的分界线0.5标出颜色</p>
<h2 id="优化器（跳）"><a href="#优化器（跳）" class="headerlink" title="优化器（跳）"></a>优化器（跳）</h2><p>神经网络参数优化器</p>
<p><strong>不同的优化器，实质上只是定义了一阶动量和二阶动量的公式。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212011.png" style="zoom:25%;" />

<p>？？？？这个公式是什么鬼</p>
<p>gt是梯度，梯度下降优化器👇P32</p>
<p>我跑出来6.5s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212319.png" style="zoom:25%;" />

<p>我跑出来7.7s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212651.png" style="zoom:25%;" />

<p>这个公式,加了一个二阶动量，python实现如下👇P34</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212820.png" style="zoom:25%;" />

<hr>
<p>P36 7.3s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212903.png" style="zoom:25%;" />

<p>移动平均-&gt;指数滑动平均：</p>
<p>指数平滑法是在<a href="https://baike.baidu.com/item/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E6%B3%95/10785547">移动平均法</a>基础上发展起来的，它具有移动平均法的优点，又可以减少运算过程中的数据储存量，同时还考虑了不同时期的数据所起的不同作用。采用指数平滑法的关键是确定α值。一般情况下，α值的大小，既和反映近期数据的能力有关，也和数据波动状况有关。通常不直接利用一次指数平滑法来预测，而是利用二次指数平滑法，求出平滑系数，建立起预测模型，再进行预测</p>
<p>P38 8.3s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213327.png" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213358.png" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213417.png" style="zoom:25%;" />

<p>请注意：<strong>pycharm开的控制台越多越卡</strong>，所以之前的数据应该作废呜呜。。。还有以后跑之前记得把控制台全部关上。</p>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155317.png" alt="第三章" style="zoom: 67%;" />

<p>使用keras搭建</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213648.png" style="zoom:25%;" />

<p>MNIST是著名的手写数字识别</p>
<p>Fashion是著名的着装图片识别。</p>
<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p>六步：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155521.png" style="zoom: 50%;" />

<p><strong>导入</strong></p>
<p><strong>设定训练、测试集</strong></p>
<p><strong>逐层搭建神经网络、前向传播</strong></p>
<p><strong>配置训练方法（优化器、损失函数、评测指标）</strong></p>
<p><strong>执行训练过程</strong></p>
<p><strong>打印网络结构和参数统计</strong></p>
<p>Sequential可以认为是个容器，封装了神经网络的结构</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155749.png" style="zoom: 33%;" />

<p>卷积神经网络和循环神经网络，在第五讲和第六讲的时候再讲。</p>
<p>compile里的参数既可以填默认的字符串，亦可以写出具体函数然后细调参数</p>
<p>入门建议<strong>直接写名字</strong>，等掌握了再去官网查看函数的具体用法，调整超参数，细调函数参数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155802.png" style="zoom:33%;" />

<p>注意from_logits判断是否经过了概率分布，如果没有进过概率分布，该参数就是true</p>
<p>后面经常使用sparse_categorical_accuracy</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428160240.png" style="zoom: 33%;" />

<p>按照比例，还是按照输入特征分类。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428161322.png" style="zoom: 33%;" />

<p>param = (输入+1)*输出    1是因为bia</p>
<p>鸢尾花复现在class3里的p8</p>
<p>如果需要“跳连”，大概就是可以设置比较深层的神经网络p11</p>
<p>init函数设置各层，call函数调用各层进行前向传播</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428172612.png" style="zoom:25%;" />

<p>其中区别如下👇，</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428172607.png" style="zoom:33%;" />



<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428170337.png" style="zoom: 33%;" />

<p>在class 3 里 p13 14 15</p>
<h3 id="FASHION"><a href="#FASHION" class="headerlink" title="FASHION"></a>FASHION</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210906154804517.png" alt="image-20210906154804517"></p>
<h1 id="八股功能扩展"><a href="#八股功能扩展" class="headerlink" title="八股功能扩展"></a>八股功能扩展</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20200610164333221.png" alt="第四章" style="zoom: 67%;" />

]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python进行数据分析(暂废)</title>
    <url>/2021/05/01/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h3><p>Ctrl-D退出</p>
<p>tab自动补全神器</p>
<p>但是ipython默认隐藏了下划线开始的方法和属性，比如魔术方法，“私有”方法和属性，要先输入下划线才看得到</p>
<p>内省：变量名前后使用 ? 显示关于对象的概要信息（包括docstring）</p>
<p>??来显示函数的源代码</p>
<p>？的终极用途：搜索命名空间，比如np.*load*?</p>
<p>% file.py 运行文件中的代码，如果需要参数就加参数<strong>如果想让待运行的脚本使用ipython空间中有的变量，用%run -i filename.py</strong></p>
<p>%paste 和 %cpaste (–终止)黏贴代码</p>
<p>一些终端指令：ctrl-L清屏  C+U删除当前行  ….</p>
<h4 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h4><p>没有内建到python中去，调用示例:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token operator">%</span>timeit np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>大部分魔术指令可以用?看到额外的选项</p>
<p>魔术函数在不冲突时可以不加百分号调用，%automagic 可以启用、禁用</p>
<p>一些魔术函数像python函数一样，输出可以赋给一个变量</p>
<p>a = %pwd</p>
<pre class="line-numbers language-pytho" data-language="pytho"><code class="language-pytho">%quickref  快速参考卡
%magic 探索所有魔术命令
%debug从最后发生报错的底部进入交互式调试器  %pdb出现任意报错自动进入调试器
%hist
%paste   %cpaste
%reset 清空所有变量&#x2F;名称  %xdel variable 删除变量和相关引用
%page OBJECT  通过分页器更美观的打印一个对象
%run   %prun statement  使用CProfile执行语句，报告输出
%time 报告单个语句执行时间   %timeit 多次运行单语句，计算平均执行时间，用于估算代码最短执行时间
%who  %who_ls  %whos  依次更加详细的展示变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://developer.51cto.com/art/202007/620863.htm">这个厉害</a></p>
<h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>核心组件是 notebook 交互式的文档类型</p>
<p>python的jupyter内核使用ipython系统进行内部活动</p>
<p>集成matplotlib:</p>
<ul>
<li>在ipython命令行中 %matplotlib</li>
<li>在jupyter中 %matplotlib inline</li>
</ul>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>一切皆为对象，对象模型的一致性！！！</p>
<p>几乎所有的python对象都有内部函数，称为方法</p>
<p>python虽然没有显示声明类型，但却是<strong>强类型语言</strong>，比如’5’+5会报错，而不是像很多语言一样发生隐式转换</p>
<p>只有在特定，明显的情况下才会发生隐式转换比如float + int</p>
<p>tips: isinstance(a,(int,float))检查对象类型是否在右边的元组中</p>
<p>python。。。鸭子类型，不管具体类型，只要它拥有某个特殊的方法，就一定有某种属性</p>
<p>iter(x)检查可否迭代</p>
<p>if not isinstance(x,list) and isiterable(x):</p>
<p>​    x = list(x) 不是列表就转换为列表</p>
<p>None 是NoneType类型的唯一实例，如果函数没有显式返回值，那就返回None</p>
<p><strong>三元表达式</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">5</span>
<span class="token string">'a'</span> <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">5</span> <span class="token keyword">else</span> <span class="token string">'b'</span>
<span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span>date<span class="token punctuation">,</span>time
dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token string">'2021,5,1,21,8,30'</span><span class="token punctuation">)</span>
dt<span class="token punctuation">.</span>year<span class="token punctuation">,</span>month<span class="token punctuation">,</span>day<span class="token punctuation">,</span>hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>second
dt<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token punctuation">)</span>输出前三个
dt<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>输出后三个

dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%x%x%x'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">'202151'</span><span class="token punctuation">,</span><span class="token string">"%Y%m%d"</span><span class="token punctuation">)</span><span class="token comment">#转换为datetime对象</span>
datetime相减会产生datetime<span class="token punctuation">.</span>delta对象
delta <span class="token operator">=</span> datetime2 <span class="token operator">-</span> datetime1
delta <span class="token operator">==</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">7179</span><span class="token punctuation">)</span> <span class="token comment">#间隔99天,7179秒</span>
timedelta和datetime可以做加减得到新的datetime
<span class="token operator">%</span>y     两位数的年份表示（<span class="token number">00</span><span class="token operator">-</span><span class="token number">99</span>）
<span class="token operator">*</span><span class="token operator">%</span>Y     四位数的年份表示（<span class="token number">000</span><span class="token operator">-</span><span class="token number">9999</span>）
<span class="token operator">*</span><span class="token operator">%</span>m     月份（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>d     月内中的一天（<span class="token number">0</span><span class="token operator">-</span><span class="token number">31</span>）
<span class="token operator">*</span><span class="token operator">%</span>H     <span class="token number">24</span>小时制小时数（<span class="token number">0</span><span class="token operator">-</span><span class="token number">23</span>）
<span class="token operator">*</span><span class="token operator">%</span>I     <span class="token number">12</span>小时制小时数（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>M     分钟数（<span class="token number">00</span><span class="token operator">=</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>S     秒（<span class="token number">00</span><span class="token operator">-</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>a     本地简化星期名称
<span class="token operator">*</span><span class="token operator">%</span>A     本地完整星期名称
<span class="token operator">%</span>b     本地简化的月份名称
<span class="token operator">%</span>B     本地完整的月份名称
<span class="token operator">%</span>c     本地相应的日期表示和时间表示
<span class="token operator">%</span>j     年内的一天（<span class="token number">001</span><span class="token operator">-</span><span class="token number">366</span>）
<span class="token operator">%</span>p     本地A<span class="token punctuation">.</span>M<span class="token punctuation">.</span>或P<span class="token punctuation">.</span>M<span class="token punctuation">.</span>的等价符
<span class="token operator">%</span>U     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期天为星期的开始
<span class="token operator">%</span>w     星期（<span class="token number">0</span><span class="token operator">-</span><span class="token number">6</span>），星期天为星期的开始
<span class="token operator">%</span>W     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期一为星期的开始
<span class="token operator">%</span>x     本地相应的日期表示
<span class="token operator">%</span>X     本地相应的时间表示
<span class="token operator">%</span>Z     当前时区的名称
<span class="token operator">%</span><span class="token operator">%</span>     <span class="token operator">%</span>号本身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>tuple</strong></p>
<p>可以用tuple函数将任意序列或迭代器转换为元组，比如tuple(‘ab’)-&gt;(‘a’,’b’)</p>
<p>同样可以使用 + 来连接，可以使用 * 来组成大元组</p>
<p>嵌套元组拆包(为啥python不用临时变量的原因)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tup <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>
a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>collections有很多封装好的数据结构，比如collections.deque</strong></p>
<p>他们适合不同的场景，拥有特定的操作和某些特性下的加速，比如deque是双端数列，头尾插入快</p>
<p>list的remove很方便，但是内存占用比较高，还有insert代价比append更高</p>
<p>与字典，集合相比，对列表使用in时非常缓慢</p>
<p>list.extent(元素)比起创建新列表再使用+来连接节省很多内存</p>
<p>bisect模块可用于排序好的序列(实现了二分搜索，已排序列表的插值)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> bisect
c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
bisect<span class="token punctuation">.</span>bisect<span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#5要插在哪</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token number">6</span>
bisect<span class="token punctuation">.</span>insort<span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
c
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>序列函数enumerate,zip,sorted,reversed</p>
<p>zip取决于最短的那一项，enumerate,zip,reversed都返回生成器</p>
<p>字典的keys values items 返回的是迭代器！</p>
<p>a.update({xxxxxx})可以合并字典，如果冲突，则原来的被覆盖</p>
<p>由于字典本质是2-元组（含有两个元素的元组）的集合，字典可以接受一个2-元组为参数</p>
<p><code>dictionary = dict(zip(range(5),reversed(range(5))))</code></p>
<p>value = dict.get(key,default_value)，不加默认值就返回None，pop也可以，不过默认抛出异常</p>
<p>dict.setdefault(key, default=None)查找key，如果不存在就设置为default，可以用[]</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">by_letter <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
    letter <span class="token operator">=</span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    by_letter<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>letter<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
    <span class="token comment">#设置首字母序列</span>
<span class="token comment">#也可以直接from collections import defaultdict</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://www.jianshu.com/p/bbd258f99fd3">defaultdict</a></p>
<p>字典的键必须是不可变，它们将被哈希化，用hash(x)检查能否哈希化</p>
<p>为了将列表作为键，可以转换为元组，元组只要内部元素可以哈希化，它自身就可以哈希化</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
d<span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
d
<span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span> <span class="token comment">#...真的有必要把元组作为键吗</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#集合操作</span>
a<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#清空</span>
a<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#移除任意元素，空的则抛出keyerror</span>
a<span class="token operator">|</span>b
a<span class="token operator">&amp;</span>b
a<span class="token operator">-</span>b
a<span class="token operator">^</span>b
<span class="token comment">#这几个都可以 a x= b</span>
a<span class="token punctuation">.</span>issubset<span class="token punctuation">(</span>b<span class="token punctuation">)</span> a包含于b则返回ture
a<span class="token punctuation">.</span>issuperset<span class="token punctuation">(</span>b<span class="token punctuation">)</span> 如果a包含b返回true
a<span class="token punctuation">.</span>isdisjoint<span class="token punctuation">(</span>b<span class="token punctuation">)</span> ab没有交集返回true
a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>用于赋值，免得指向同一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>字典，集合都有推导式！推导式和map功能有些重复</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#字典示范</span>
dictionary <span class="token operator">=</span> <span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span>index <span class="token keyword">for</span> index<span class="token punctuation">,</span>val <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>嵌套列表推导式的for顺序排列,要区别于列表推导式中的列表推导式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">some_tuples <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
flattend <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> <span class="token builtin">tuple</span> <span class="token keyword">in</span> some_tuples <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">tuple</span><span class="token punctuation">]</span>
flattend <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">tuple</span><span class="token punctuation">]</span> <span class="token keyword">for</span> tup <span class="token keyword">in</span> some_tuples<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>global</p>
<p>返回多个值是以元组形式，甚至可以返回一个字典，啥都行</p>
<p>将函数作为参数传递，这种更函数化的编程有更强的复用性和通用性</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">complex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>ops<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> op <span class="token keyword">in</span> ops<span class="token punctuation">:</span>
        op<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
operation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">.</span>strip<span class="token punctuation">]</span>
<span class="token builtin">complex</span><span class="token punctuation">(</span><span class="token string">'wocao'</span><span class="token punctuation">,</span>operation<span class="token punctuation">)</span>
妙啊！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>lambda本身没有显式的__name__属性</p>
<p><strong>柯里化</strong></p>
<p>通过部分参数应用的方式从已有的函数里衍生出新的函数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> partial
add five <span class="token operator">=</span> partial<span class="token punctuation">(</span>add_numbers<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>生成器表达式可以作为函数参数用于替代列表推导式</p>
<p><code>sum(x ** 2 for x in range(100))</code></p>
<p><strong>itertools</strong></p>
<p>适用于大多数数据算法的生成器集合</p>
<p>可以查一下手册，需要的时候</p>
<p>except(xx,xx)来结合多个异常</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">read<span class="token punctuation">(</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
seek<span class="token punctuation">(</span>pos<span class="token punctuation">)</span>
tell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#随机三件套</span>
readlines<span class="token punctuation">(</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span>
writelines<span class="token punctuation">(</span>strings<span class="token punctuation">)</span>
close
flush <span class="token comment">#将内部I/O缓冲区内容刷新到硬盘</span>
closed

在文本模式下，f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#读取了10个字符所需要的字节并解码</span>
而在二进制模式下<span class="token punctuation">,</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#读取了10个字节，并未解码，显示b'xxxx'</span>
解码如果不完整，则会报错
文本模式配合<span class="token builtin">open</span>的encoding参数读取不同编码类型
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span><span class="token string">'xt'</span><span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>数组和向量化计算</p>
<ul>
<li>高校多维数组，提供数组算术操作和灵活的广播(不同尺寸数组)</li>
<li>线性代数，随机数，傅里叶变换</li>
<li>提供非常易用的C API，使得调用<strong>底层语言</strong>变得极其简单</li>
<li>诸多外部库都基于Numpy，这是数值计算最重要的python库</li>
</ul>
<p>Numpy的方法比python方法快10-100倍，并且使用的内存也更少</p>
<p><strong>核心特征ndarry 快速，灵活的大型数据集容器，允许使用类似标量的操作语法在整块数据上进行数学计算</strong></p>
<p><strong>生成</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">array<span class="token punctuation">(</span>列表，元组，数组<span class="token punctuation">)</span>
asarray<span class="token punctuation">(</span><span class="token punctuation">)</span>将输入转换为ndarray？？
arrange
ones<span class="token operator">/</span>zeros<span class="token operator">/</span>empty<span class="token operator">/</span>full<span class="token operator">+</span><span class="token operator">/</span>_like
eye<span class="token operator">/</span>identity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>dtype</strong></p>
<p>能和吉他系统数据灵活交互的原因</p>
<p>dtype和astype（new type）方法</p>
<p>转换时小数-&gt;整数截断，string转换为合适的，</p>
<p><strong>但在用numpy.string_作数据时，numpy会修正大小或删除输入而不发出警告</strong></p>
<p><strong>数组算术</strong></p>
<p>所谓向量化运算，逐元素操作。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>ndarray可以用”切片”赋值<code>b[1:4] = 5</code>把b的2-4号元素都赋值5</p>
<p><strong>ndarray的切片事原数组的视图，而不是复制！！！不然得多慢</strong>，要想复制得：arr[5:8].copy()</p>
<p>高维索引：可以arr2d[2][1]   也可以arr2d[2,1]</p>
<p>切片配合索引可以很好的进行切片，全选用单独 :</p>
<p><strong>布尔索引</strong></p>
<p>names是一个字符串ndarray</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">names <span class="token operator">==</span> <span class="token string">'Bob'</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token comment">#输出一个布尔值数组</span>
可以将布尔数组当作数组的索引，但是其长度必须和数组轴索引长度一致，不一致时不会报错，要小心
date <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
date<span class="token punctuation">[</span>date<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">#好厉害的功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>布尔索引也能配合切片使用</p>
<p>布尔索引总是生成数据的拷贝</p>
<p><code>~()表示对某个通用条件取反</code></p>
<p><strong>神奇索引</strong></p>
<p>真的很神奇。。使用整数数组进行数据索引（Numpy专用）</p>
<p>相当于是一维一维的选择数据，也可以把每个数组的对应位置组合起来看成索引</p>
<p>神奇索引的结果总是一维的，他也总是复制数据到新的数组中</p>
<p>假设arr是二维数组</p>
<p>arr[:,[2,1,0]] 相当于是把前三列倒过来再复制出来，很奇怪的用法</p>
<p>换轴：arr3d.transpose((1,0,2)) 换了轴的次序，有点抽象</p>
<p>arr.swapaxes(1,2)交换俩轴，返回视图而不是复制</p>
<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>快速的逐元素数组函数</p>
<p><strong>一元</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">abs</span><span class="token operator">/</span>fabs  
sqrt
square
exp
log log10 log2 log1p<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回ln(1+x)</span>
sign <span class="token comment">#返回符号值，正数1，0为0，负数-1</span>
ceil floor
rint <span class="token comment">#保留整数，保持dtype</span>
modf <span class="token comment">#分别返回小数部分和整数部分</span>
isnan <span class="token comment">#返回布尔数组</span>
isfinite <span class="token comment">#既非inf又非NaN </span>
isinf
cos<span class="token punctuation">,</span>cosh<span class="token punctuation">,</span>sin<span class="token punctuation">,</span>sinh<span class="token punctuation">,</span>tan<span class="token punctuation">,</span>tanh
arc<span class="token operator">*</span><span class="token number">6</span>
logical_not<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#按位取反</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>二元</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">add subtract multiply divide<span class="token operator">/</span>floor_divide
power<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token comment">#每项依次xi ** yi</span>
maximum<span class="token operator">/</span>minimum<span class="token operator">/</span>fmax<span class="token operator">/</span>fmin <span class="token comment">#后两个忽略NaN</span>
mod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#模</span>
copysign <span class="token comment">#将第一个数组的符号值改为第二个数组的符号值</span>
greater<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>不如直接用操作符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数学和统计"><a href="#数学和统计" class="headerlink" title="数学和统计"></a>数学和统计</h2><p>用数组表达式完成多种数据操作任务，代替显式循环，称为向量化，速度会快很多</p>
<p>np.where(布尔数组，标量/向量，标量/向量)是向量界的三元表达式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token punctuation">)</span>
mean
std<span class="token punctuation">,</span>var 标准差<span class="token operator">/</span>方差 ，可以选择自由度调整
<span class="token builtin">min</span> <span class="token builtin">max</span>
argmin argmax 最小值和最大值的位置<span class="token comment">#axis可以省略，直接写维度</span>
cumsum cumprod 累和 和 累积 有中间结果<span class="token comment">#</span>
sort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>布尔数组妙用</strong></p>
<p>arr = np.random.randn(100)</p>
<p>(arr&gt;0).sum()正值的个数</p>
<p>还有bools.any()检查是否至少一个true</p>
<p>bools.all()检查是否每个值都是True，里面可能放轴</p>
<p><strong>唯一值与其他集合逻辑</strong></p>
<p>有一些针对一维ndarray的基础集合操作</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">unique<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token comment">#对唯一值排序</span>
intersect1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>交集
union1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>并集
in1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>x项是否在y中，返回布尔数组
setdiff1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>返回x<span class="token operator">-</span>y
setxor1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>返回x<span class="token operator">^</span>y 不共有的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>文件</strong></p>
<p>numpy可以将数据以文本/二进制文件形式存入硬盘或载入，pandas或其他来载入文本/表格更被人们推崇</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#默认后缀是.npy</span>
arr <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'Iamfile'</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span>
np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'Iamfile.npy'</span><span class="token punctuation">)</span>
<span class="token comment">#多个就是</span>
np<span class="token punctuation">.</span>savez<span class="token punctuation">(</span><span class="token string">'Iammanyfile'</span><span class="token punctuation">,</span>a <span class="token operator">=</span> arr<span class="token punctuation">,</span> b <span class="token operator">=</span> arr<span class="token punctuation">)</span>
<span class="token comment">#load以后变成一个字典对象</span>
arch <span class="token operator">=</span> np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'Iammanyfile.npy'</span><span class="token punctuation">)</span>
arch<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">==</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#如果数据已经压缩好了，仍能存入压缩的文件</span>
np<span class="token punctuation">.</span>savez_compressed<span class="token punctuation">(</span><span class="token string">'small.npz'</span><span class="token punctuation">,</span>a <span class="token operator">=</span> arr<span class="token punctuation">,</span> b <span class="token operator">=</span> arr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>点乘</strong></p>
<p>a.dot(b)</p>
<p>np.dot(a,b)</p>
<p>a @ b</p>
<h3 id="linalg"><a href="#linalg" class="headerlink" title="linalg"></a>linalg</h3><p>顾名思义，numpy.linalg 拥有一个矩阵分解的标准函数集，以及其他常用函数比如求逆/行列式</p>
<p>这都是通过在MATLAB和R等其他语言使用的行业标准线性代数库实现的。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> numpy<span class="token punctuation">.</span>linalg <span class="token keyword">import</span> inv<span class="token punctuation">,</span>qr
diag<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回方针的对角元一维数组，一维数组就准换为对角矩阵</span>
dot
trace <span class="token comment">#考考你“迹”</span>
det 
eig <span class="token comment">#方阵特征值和特征向量</span>
inv 逆矩阵
pinv Moore<span class="token operator">-</span>Penrose伪逆
qr QR分解
svd 奇异值分解
solve 求解x的线性系统Ax <span class="token operator">=</span> b，其中A是方阵
lstsq 计算Ax <span class="token operator">=</span> b的最小二乘解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span>这个设置的是全局随机数种子
rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
arr <span class="token operator">=</span> rng<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">#这样生成的就是独立的</span>

seed
permutation<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment"># 返回一个序列的随机排列</span>
shuffle <span class="token comment"># 随机排列一个序列,直接更改原来的</span>
rand <span class="token comment">#从均匀分布[0,1)中抽取样本</span>
randint <span class="token comment">#根据给定的从低到高的范围抽取随机一个整数</span>
randn <span class="token comment">#从均值0方差1的正态分布</span>
normal<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#平均值，标准差，shape</span>

binomial <span class="token comment">#从二项分布中抽取样本</span>
beta <span class="token comment">#从beta分布中抽取样本</span>
chisquare <span class="token comment">#从卡方分布中抽取样本</span>
uniform<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#从均匀分布中抽取样本</span>
gamma <span class="token comment">#从伽马分布中抽取样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>随机漫步</strong></p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>numpy像序列化好的矩阵，序列，pandas相当于是字典(有名称的数据)</p>
<p>numpy适合处理同质型的数值类数组数据</p>
<p>pandas用来处理表格型或异质性数据</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>一维的数组型对象，包含一个值序列（类似numpy），和数据标签（索引 index）</p>
<p>默认索引0 - N-1 ，用values和index得到其值和索引</p>
<p>比numpy数组特殊的是可以用标签来索引：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>index
Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>values
Out<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int64<span class="token punctuation">)</span>
    
In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
d    <span class="token number">4</span>
s    <span class="token number">7</span>
dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>可以考虑它是一个长度固定且有序的字典，在可以使用字典的上下文中Series都能用</strong></p>
<p>使用numpy的函数或按numpy风格的操作，比如布尔数组索引，数学函数，都能用，且保存索引值链接</p>
<p>还能把字典变成Series  pd.Series(dict)</p>
<p><code>obj3 = pd.Series(list1,[index = list])</code>如果list里没有，则被舍弃，如果list里有没对上的，就NaN</p>
<p>Pandas用 isnull 和 notnull检查数据，也返回类似布尔值Series的东东</p>
<p><strong>自动对齐索引是非常有用的</strong></p>
<p>Series对象自身和其索引都有name属性</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'population'</span>
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>index<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'state'</span>
In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
state
d    <span class="token number">4</span>
s    <span class="token number">7</span>
c   <span class="token operator">-</span><span class="token number">5</span>
a    <span class="token number">3</span>
Name<span class="token punctuation">:</span> population<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>索引可以通过按位置赋值的方式进行改变 obj.index = [new list]</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>表示矩阵的数据表,它包含已排序的列集合，每一列可以是不同的值类型（数值，字符串，布尔值等），DataFrame既有行索引，又有列索引</p>
<p>在DataFrame中数据被存储为一个以上的二维块。</p>
<p>可以利用分层索引在DataFrame中展现更高层次的维度。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>利用包含等长度列表或numpy数组的字典</p>
<p>在jupyter notebook里面dataframe对象会展示一个更好康的HTML表格</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
frame <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
frame2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'first'</span><span class="token punctuation">,</span><span class="token string">'second'</span><span class="token punctuation">,</span><span class="token string">'third'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
colunmns指定列的顺序，索引指定索引。。如果columns里出现data没有的列，则填充缺失值NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>frame2[‘a’] == frame2.a  这是一个Series对象，frame2.a只在a是有效变量名时可用，前者则总可用</p>
<p>也可以用这个更改一列👆，用列表/数组赋值时请确保长度匹配，</p>
<p>将Series付给一列时，索引会尝试匹配，空缺补缺失值，如果a（被赋值的列）不存在，会产生新列（<strong>此时不能用frame2.a的语法！！</strong>），可以用del关键词来删除dataframe的列</p>
<p>返回的Series对象索引继承dataframe的，而且name属性被设置成字典的索引</p>
<p>从DateFrame中选的列同样是数据的视图，拷贝得用.copy()</p>
<p>另一种常用的数据形式是包含字典的嵌套字典:</p>
<p>pandas会将字典的键作为列，将内部字典的键作为行索引，自动补全NaN</p>
<p>可以用Numpy语法转置 frame3.T</p>
<p>内部字典的键会被联合，排序，但是如果显式指明索引，键不会被排列</p>
<p>frame3.index.name 和 frame3.columns.name 也是可以设置的</p>
<p>如果列是不同的dtypes，那么values的dtype会自动选择适合所有列的类型</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>reindex([]) 创建一个符合新索引的新对象</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>      blue
<span class="token number">2</span>    yellow
<span class="token number">4</span>     green
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3<span class="token punctuation">.</span>reindex<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">'ffill'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>      blue
<span class="token number">1</span>      blue
<span class="token number">2</span>    yellow
<span class="token number">3</span>    yellow
<span class="token number">4</span>     green
<span class="token number">5</span>     green
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>
<span class="token comment">#ffill会将值向前传递</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-python" data-language="python"><code class="language-python">reindex方法的参数
index <span class="token comment">#作为默认参数，可以省略</span>
columns <span class="token operator">=</span> xx <span class="token comment">#此关键字用于重建列的索引</span>
ps<span class="token punctuation">:</span>可以用frame<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">[</span>行索引<span class="token punctuation">]</span>，<span class="token punctuation">[</span>列索引<span class="token punctuation">]</span><span class="token punctuation">]</span>
method <span class="token comment">#ffill前向，bfiil后向填充</span>
fill_value <span class="token comment">#选择缺失时使用的替代值</span>
limit <span class="token comment">#前后填充时，填充的最大元素数量</span>
tolerance <span class="token comment">#前后填充时，填充的最大绝对数字距离</span>
copy <span class="token comment">#True时总是复制底层数据，False在索引相同时不复制数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>删除</strong></p>
<p>data.drop([xxx])删除索引，默认是轴9</p>
<p>data.drop([xxx],axis = 1) #也可以写axis = ‘columns’ 只删除一个的就不用列表</p>
<p>像drop这类函数会修改Series或DataFrame的尺寸或形状，直接操作原对象，不返回新对象</p>
<h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><p>不可变的，用obj.index拿出来，构造Series和DataFrame时，内部产生索引对象</p>
<p>可以用pd.Index([list])显式生成</p>
<p>它具备集合的特征，比如使用 in方法</p>
<p>但是它可以包含重复标签，根据重复标签筛选会选取所有匹配的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">append<span class="token punctuation">(</span><span class="token punctuation">)</span>
difference
intersection
union
isin
delete<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">#删除位置i的索引并产生新的索引</span>
drop<span class="token punctuation">(</span><span class="token string">'xx'</span><span class="token punctuation">)</span><span class="token comment">#删除xx索引并产生新的索引,可以传递列表来删除多个</span>
insert<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
is_monotonic <span class="token comment">#是否递增</span>
is_unique <span class="token comment">#是否唯一</span>
unique <span class="token comment">#得到索引的唯一值序列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Series</strong> 既可以使用obj[2:4]这样传统的顺序，也可以使用obj[[‘b’,’c’]]用索引里截取的列表来</p>
<p><strong>甚至可以obj[‘b’:’c’] 而且这个是包含尾部的</strong>，series只有一列，这些都是选择行</p>
<p><strong>对dataFrame可以直接用obj[‘two’]来索引某一列或用一个列表来选择！这是列选择语法</strong></p>
<p><strong>但是切片语法obj[2:4]时选择行的（这才是特殊的），传入单个/列表只能选择列！！！</strong></p>
<p><strong>loc和iloc选择(更准确，更无歧义)</strong></p>
<p>date.loc [[],[]] 前者选择行，后者选择列，必须是索引名</p>
<p>date.iloc [ xxx ]就只能用数字索引</p>
<p>当用列表时形式和原来相仿，当选了某一个行时，会发生转置</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data
Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
          one  two  three  four
OHIO        <span class="token number">0</span>    <span class="token number">1</span>      <span class="token number">2</span>     <span class="token number">3</span>
COLORADO    <span class="token number">4</span>    <span class="token number">5</span>      <span class="token number">6</span>     <span class="token number">7</span>
UTAH        <span class="token number">8</span>    <span class="token number">9</span>     <span class="token number">10</span>    <span class="token number">11</span>
NEWYORK    <span class="token number">12</span>   <span class="token number">13</span>     <span class="token number">14</span>    <span class="token number">15</span>

In <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">'OHIO'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
one      <span class="token number">0</span>
three    <span class="token number">2</span>
Name<span class="token punctuation">:</span> OHIO<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32
        
In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
three    <span class="token number">2</span>
two      <span class="token number">1</span>
Name<span class="token punctuation">:</span> OHIO<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两种方法是可以使用切片的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span>val<span class="token punctuation">]</span> 选择单列或列序列，特殊是数字切片选择行
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>val<span class="token punctuation">]</span> 选择行
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>val<span class="token punctuation">]</span> 选择列
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>val1<span class="token punctuation">,</span>val2<span class="token punctuation">]</span>选择某部分
df<span class="token punctuation">.</span>iloc同理
df<span class="token punctuation">.</span>ai<span class="token punctuation">[</span>label_i<span class="token punctuation">,</span>label_j<span class="token punctuation">]</span>根据索引选择单个标量
df<span class="token punctuation">.</span>iat<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span>根据位置选择单个标量
get_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>ps:当对标签使用切片时是包含尾部的，比如loc里面和series的标签切片，即使有时候标签就是数字</strong></p>
<h3 id="算数和数据对齐"><a href="#算数和数据对齐" class="headerlink" title="算数和数据对齐"></a>算数和数据对齐</h3><p>相加对象时，当索引对不同，返回结果的索引将时索引对的并集，没有交叠的部分全都变成NaN</p>
<p>灵活算术方法</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">add<span class="token punctuation">,</span>radd
sub<span class="token punctuation">,</span>rsub
div<span class="token punctuation">,</span>rdiv
floordiv<span class="token punctuation">,</span>rfloordiv
mul<span class="token punctuation">,</span>rmul
<span class="token builtin">pow</span><span class="token punctuation">,</span>rpow
参数fill_value设定了以后有必要会保留两边的，带r的都是参数翻转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>DataFrame和Series间的操作</strong></p>
<p>类似不同维度数组间的操作类似</p>
<p>当arr(np数组)减去一行时，减法依次在每一行进行了操作，这就是所谓的广播机制</p>
<p>二DataFrame和Series之间的操作是类似的，Series的索引和DataFrame的列进行匹配，然后广播到各行</p>
<p>如果索引值不在DataFrame的列中，也不在Series的索引中，对象会重建索引并进行联合。补NaN</p>
<p>如果想在行上匹配，列上广播，必须得用算术方法，然后指定参数axis = ‘index’或axis = 0</p>
<p>Numpy的通用函数们可以直接使用到pandas对象进行逐元素操作</p>
<p>DataFrame的apply方法可以将函数应用到一列或一行上，默认是对每一列调用一次，</p>
<p>用axis = ‘columns’ 或 1来对行调用，索引仍保留对应的，但大部分常用的功能都已经实现了</p>
<p>applymap就是对每个元素使用！</p>
<p>先到这吧</p>
<h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><p>有一大坨，我挑了几个</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">read_csv 从文件，url，文件型对象读取分隔好的数据，逗号是默认分隔符
read_table从文件，url，文件型对象读取分隔好的数据，制表符是默认分隔符
read_fwf 从特定宽度格式的文件中读取数据（无分隔符）
read_excel
read_html
read_json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于现实世界的数据非常混乱，随着时间推移，一些数据加载函数的可选参数变得非常复杂，pandas的在线文档中有大量实例展示，可以借鉴</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">一些参数
path
sep<span class="token operator">/</span>delimiter 分隔符，可以是正则表达式
header 用作列名的行号
index_col 用作行索引的列好<span class="token operator">/</span>列名
names 列名列表，必须header <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p>如果不是用了%matplot notebook/inline，就得用plt.</p>
<p>最终目标可能是构建网络交互式可视化</p>
<p>matplotlib用来制作静态或动态的可视化文件，生成出版级质量图表（一般二维）</p>
<p>matplotlib支持所有操作系统上的各种GUI后端，还可以导出为常见的矢量和光栅图形格式！</p>
<p>现在有了一些matplotlib数据可视化的附加工具包，（调用matplotlib进行底层绘图）比如seaborn</p>
<p><strong>尽管seaborn等库和pandas内建的绘图函数可以处理大部分绘图的普通细节，但是要更好的定制，必须得学习一些maplotlib的API</strong></p>
<p><strong>导入惯例</strong></p>
<p>import matplotlib.pyplot as plt</p>
<p>首先在jupyter notebook 来一句 %matplotlib notebook(Ipython则是%matplotlib)</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>这些图位于图片（Figure）对象中，可以使用plt.figure()生成一个新的图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114242.png" alt="image-20210503162615865"></p>
<p>Jupyter好像优化了，不仅可以提前显示，而且在后续单元格执行时不会重置图表</p>
<p>当再绘图时，会在最后一个子图上画画</p>
<p>fig.add_subplot返回的是Axes Subplot对象，可以调用这些对象绘图</p>
<p>可以去matplotlib官方文档找完整的图形类型</p>
<p>使用子图网格创建图片时非常常见的任务，所以有一个方法plt.subplots(size)，返回包含了已生成的子图对象的Numpy数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114253.png" alt="image-20210503171947679"></p>
<p>牛批啊，fig是一个尺寸对象Figure，axes则是返回的numpy数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114249.png" alt="image-20210503172248820"></p>
<p>有几个参数，sharex(True/all  False/None) sharey</p>
<p>subplot_kw：可选的，字典类型。包含传递给用于创建子图的调用add_subplot的关键字参数。</p>
<p>gridspec_kw：可选的，字典类型。包含传递给用于创建子图网格的GridSpec构造函数的关键字参数。</p>
<p>**fig_kw：所有传递给matplotlib.pyplot.figure调用的额外关键字参数。</p>
<p>比如plt.subplots(2,2,figsize = (8,6)最后一项传入figure对象</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><a href="https://blog.csdn.net/htuhxf/article/details/82863630">https://blog.csdn.net/htuhxf/article/details/82863630</a></p>
<p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html</a></p>
<p>可以用图对象的subplots_adjust方法，或者当作顶层函数用，调整间距</p>
<p>fig.subplots_adjust(left,bottom,right,top,wspace,hspace)</p>
<p>很多配置字符串可以合到一起，也可以分开来使得表达清晰</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'ko--'</span><span class="token punctuation">)</span>
等价于
ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>color <span class="token operator">=</span><span class="token string">'k'</span><span class="token punctuation">,</span>linestyle <span class="token operator">=</span> <span class="token string">'dashed'</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>大多数图表修饰工作有两种主要的方式：<strong>程序性的pyplot接口或更多面向对象的原生matplotlib API</strong></p>
<p>pyplot接口设计为交互式使用，包含xlim,xticks,xticklabels方法，他们在没有函数参数时返回当前参数值，在传入参数时设置参数值，<strong>他们默认在当前活动或最新创建的AxeSubplot上生效</strong>。他们分别对应于子图的两个方法，比如xlim对应于ax.get_lim和ax.set_lim，<strong>后者更为显式，单独操作子图</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#实例</span>
fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ticks <span class="token operator">=</span> ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">250</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">750</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置刻度</span>
labels <span class="token operator">=</span> ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token string">'five'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>rotation <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>fontsize <span class="token operator">=</span> <span class="token string">'small'</span><span class="token punctuation">)</span><span class="token comment">#设置标签</span>
ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'My first matplotlib plot'</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'Stages'</span><span class="token punctuation">)</span>

<span class="token comment">#也可以这样设置</span>
props<span class="token operator">=</span><span class="token punctuation">&#123;</span>
    <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token string">'My first matplotlib plot'</span><span class="token punctuation">,</span>
    <span class="token string">'xlabel'</span><span class="token punctuation">:</span><span class="token string">'Stages'</span>
<span class="token punctuation">&#125;</span>
ax<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token operator">**</span>props<span class="token punctuation">)</span><span class="token comment">#通用的一种方法</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>ticks<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114302.png" alt="image-20210503194818033"></p>
<p><strong>添加图例</strong></p>
<p>最简单的式在添加图表的时候ax.plot(加一个参数label = ‘xx’)</p>
<p>再执行ax.lengend(loc =’xx’)或者plt.legend就能自动生成图例，best会找到最合适的位置</p>
<p>好文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/110656183">一，折线图调整</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110902615">二，坐标轴</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110976210">三，挪动坐标轴</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111108841">四，设置label</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111331057">五，散点图</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/113657235">六，柱状图</a></p>
<p><strong>注释与子图加工</strong></p>
<p>text,arrow,annote方法可以添加注释和文本</p>
<p>比如：ax.text(x,y,’Hello world!’,family = ‘monospace’,fontsize = 10)</p>
<p>matplotlib含有表示多种常见图形的对象，这些对象的引用时patched。</p>
<p>全集位于matplotlib.patched中，少部分比如Rectangle和Circle可以在matplotlib.pyplot中找到</p>
<p>这个暂时用不到。。先略过吧</p>
<h3 id="保存到文件"><a href="#保存到文件" class="headerlink" title="保存到文件"></a>保存到文件</h3><p>使用plt.savefig将活动图片保存到文件，等价于图片对象的savefig实例方法</p>
<p>plt.savefig( ‘  xxx . svg’)文件类型会从文件拓展名自动推断</p>
<p>其他的参数/选项：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fname <span class="token comment">#默认参数，是一个路径+文件型对象名</span>
dpi <span class="token comment">#每英寸点数的分辨率，默认100</span>
facecolor<span class="token punctuation">,</span>edgecolor <span class="token comment">#图形背景的颜色，默认是'w'就是白色</span>
<span class="token builtin">format</span> <span class="token comment">#文件格式，比如'png','pdf',svg,ps,eps啥的，好像时可以覆盖</span>
bbox_inched <span class="token comment">#要保存的图片范围，如果是'tight'，将会去掉图片周围空白的部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>matplotlib配置</strong></p>
<p>几乎所有的默认行为都可以通过广泛的全局参数来定制，者通过plt.rc来实现</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#第一个参数时要自定义的组件,比如'figure',axes,xtick,ytick,grid,legend</span>
然后其他的就可以自定义了<span class="token punctuation">,</span>比如：
font_options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">'family'</span> <span class="token punctuation">:</span> <span class="token string">'monospace'</span><span class="token punctuation">,</span>
    <span class="token string">'weight'</span> <span class="token punctuation">:</span> <span class="token string">'bold'</span><span class="token punctuation">,</span>
    <span class="token string">'size'</span> <span class="token punctuation">:</span> <span class="token string">'5'</span>
<span class="token punctuation">&#125;</span>
plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'font'</span><span class="token punctuation">,</span> <span class="token operator">**</span>font_options<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="使用pandas和seaborn绘图"><a href="#使用pandas和seaborn绘图" class="headerlink" title="使用pandas和seaborn绘图"></a>使用pandas和seaborn绘图</h2><p>pandas有很多内建的方法简化dataframe和series对象生成可视化的过程，另一个库时seaborn</p>
<p>导入seaborn会修改默认的matplot配色方案和绘图央视</p>
<p>Series.plot的参数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">label 
ax 选用的子图对象，默认是当前活动的
style
alpha
kind 默认<span class="token string">'line'</span>
logy <span class="token comment">#在y上使用对数缩放</span>
use_index 使用对象索引刻度标签（默认x，水平图则是y）
rot
xticks
yticks
xlim
ylim
grid <span class="token comment">#展示轴网格，默认打开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>DataFrame的plot参数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">subplots <span class="token comment">#将每一列绘制在独立的子图中</span>
sharex<span class="token operator">/</span>sharey <span class="token comment">#当独立子图时可以设置的</span>
figsize 生成图片尺寸的元组
title 标题字符串
legend 添加子图图例，默认是<span class="token boolean">True</span>
sort_columns 按字母顺序绘制各列，默认为<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>折线图</strong></p>
<p>会把Series索引默认当作x轴</p>
<p>DataFrame默认划到一起去，可以设置</p>
<p>注意到DataFrame的列名称(column.name)成为了图例标题</p>
<p><strong>柱状图</strong></p>
<p>plot.bar() 竖直 plot.barh()水平柱状图,同样索引默认当作x轴、y轴</p>
<p>注意到DataFrame的列名称(column.name)成为了图例标题</p>
<p>stackedd = True 参数可以让DataFrame每一行的值叠在一起</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114307.png" alt="image-20210503205130179"></p>
<p><strong>直方图和密度图</strong></p>
<p>hist和density</p>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>复变函数和积分应用</title>
    <url>/2021/05/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言和资源"><a href="#前言和资源" class="headerlink" title="前言和资源"></a>前言和资源</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130415.png"  style="zoom: 67%;" />

<p>推荐一个宝藏up主  “乐乐老师的网络课堂”，是个狼灭</p>
<p>华中科技大学的慕课</p>
<h1 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h1><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130633.png"  style="zoom: 33%;" />

<p><strong>实数域是复数域的一个真子集，实数是有序数，复数不是，因此复数不可比较</strong></p>
<p>*四则运算</p>
<p>z*z共轭 = z模长的平方</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131813.png"  style="zoom:33%;" />

<h3 id="极坐标形式"><a href="#极坐标形式" class="headerlink" title="极坐标形式"></a>极坐标形式</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131923.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132008.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132027.png"  style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132647.png"  style="zoom:33%;" />

<p><strong>结合arctany/x的图会比较好理解，起到一个调整范围的作用。</strong></p>
<p>两个复数相等≠模和辐角分别相等，前不能推后，后可以推前，可能差了2npi，<strong>模和辐角主值相等则复数相等</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514143939.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144025.png"  style="zoom:33%;" />



<h3 id="乘幂与方根"><a href="#乘幂与方根" class="headerlink" title="乘幂与方根"></a>乘幂与方根</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144329.png"></p>
<p>由乘法直接看出</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144805.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144826.png"  style="zoom: 50%;" />

<p>方根</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145219.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145319.png"  style="zoom:33%;" />

<p><strong>单位根：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145634.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130456.png"  style="zoom: 25%;" />

<p>给一个例子：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145958.png"  style="zoom: 33%;" />



<h3 id="复数域扩充"><a href="#复数域扩充" class="headerlink" title="复数域扩充"></a>复数域扩充</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150150.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150310.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150548.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150705.png"  style="zoom:33%;" />

<p>复球面</p>
<p>由古老的测地投影法（绘制世界地图），衍生出复球面</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150941.png"  style="zoom: 33%;" />

<p>这样全体复数都可以被球面的点表示，N点表示无穷远点，这称为黎曼球面</p>
<h3 id="平面点集补充"><a href="#平面点集补充" class="headerlink" title="平面点集补充"></a>平面点集补充</h3><p>复变函数的基础，邻域，去心邻域</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151404.png"  style="zoom: 33%;" />

<p>内点，开集，闭集，边界点以及边界，孤立点（孤立一定是边界），有界集，无界集，连通集</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151735.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514152143.png"  style="zoom:50%;" />

]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>复变</tag>
      </tags>
  </entry>
  <entry>
    <title>hot key</title>
    <url>/2021/04/05/%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><p>Fn + 左右箭头快速抵达行头行尾</p>
<p>Fn + shift + 左右箭头快速选中整行</p>
<p>C + f 搜索</p>
<h2 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h2><p>单指：</p>
<p>轻点两下为拖拽，选择</p>
<p>双指：</p>
<p>轻击为右键，反方向为滑动</p>
<p>三指：</p>
<p>左右滑动选择窗口</p>
<p>向下，隐藏所有窗口</p>
<p>向上，依次打开，保留次序</p>
<p>四指：</p>
<p>向上：最近打开的文件</p>
<p>向下：复原</p>
<p>左右：切换桌面</p>
<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>C + g  快速到达某一行</p>
<p>C + A + 上下  为上下行的该位置添加光标，如果为空，则尽量左移</p>
<p>S + A + 拖动鼠标 选中规则同上</p>
<p>C + c  +  C + v 快速复制一行</p>
<p>或者 S + A + 上下</p>
<hr>
<p>C + /  单行注释</p>
<p>C + S + /   多行注释（改的，原来是S + A + a）</p>
<p>C + ~  打开终端</p>
<p>C + d 快速选中相同的</p>
<p>C + f 搜索</p>
<p>C + h 替换（可以全部替换）</p>
<p>C + +/-  放大/缩小布局</p>
<p>Tab 到达下一个光标</p>
<p>自定义快捷键</p>
<p>有些快捷键，我们使用不习惯，其实我们可以自定义快捷键的。</p>
<p>比如js 的多行注释是 shift + alt  + a  ，我们想修改为 ctrl + shfit +  /   </p>
<p>设置方法：   管理按钮  —   键盘快捷方式  —  输入  shift + alt  + a  找到这个快捷键  —– 点击编辑按钮  —- 直接按下  ctrl + shift  +  /     —- 最后按下回车 修改完毕。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/070e4f32b7326196062f020bbc3a91b30c7e470c.gif" alt="img"></p>
<h1 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h1><p>C + R是搜索。。</p>
<p>ipython里终端 C + r是回溯</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>C + S + j   开发者模式（谷歌），在火狐有些不同</p>
<p>C + h   历史记录</p>
<p>C + n  打开新窗口</p>
<p>C + S + n  新无痕窗口</p>
<p>C + 左键:打开新标签方式</p>
<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>C + b 加粗</p>
<p>C + i  斜体</p>
<p>C + k 设为超链接</p>
<h1 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h1><p>A 创建新单元格above当前单元格</p>
<p>B 创建新单元格below当前单元格</p>
<p>在markdown 和 code之间进行转换</p>
<p>markdown -&gt; code Y</p>
<p>code -&gt; markdown M </p>
<p>L 是显示行号d</p>
<p>双击D 可以删除单元格，Z撤销删除</p>
<p>S 保存！</p>
<p>最强的是C + S + P</p>
<p>打开万能的控制栏</p>
]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>hot key</tag>
      </tags>
  </entry>
  <entry>
    <title>《十年一梦》</title>
    <url>/2021/06/15/%E5%8D%81%E5%B9%B4%E4%B8%80%E6%A2%A6/</url>
    <content><![CDATA[<h1 id="十年一梦"><a href="#十年一梦" class="headerlink" title="十年一梦"></a>十年一梦</h1><p>第一篇<strong>读书笔记</strong>，我也不知道该咋写。。</p>
<h2 id="序1-唯有事实"><a href="#序1-唯有事实" class="headerlink" title="序1 唯有事实"></a>序1 唯有事实</h2><p>我们的认知需要建立在确切的<strong>事实</strong>上，不然就是无根之萍。事实应该包括两个方面，一个是我们自己，另一个是我们所面对的对象，在面对市场的时候，通常假定谁也改变不了市场，只能适应市场，因此我们更有理由重视“自己”</p>
<p>我们通常忽略自己，但是这是致命的错误，<strong>我们应该主动适应市场</strong>，成为行动的主体但是要认清自己实在是太难了，我们一言一行对周围的影响远超我们的外观。然而我们对这方面<strong>缺乏足够的参照物</strong>，在社会上，这些后果需要相当长的周期才能看得到，以至于我们可能忘记了前因后果，更何况大部分人总是缺乏反思和改正的想法。</p>
<p>对于学习市场操作，其实很不错，因为反馈是即刻的，这对于认知自己非常有效，但是我们要注意改进和纠正</p>
<p>另一方面，认清我们面对的对象也并非易事，每个人都有特定而局限的角度和立场，而这些不一定是最佳的，更不可能是全面的，甚至还随时间而改变。关于对象，我们获得的信息也总是滞后、有限的，观察方法和工具也受到时代的限制和自身能力的限制。</p>
<p>因此，获取事实是艰难的，但是这也是人生的主课，需要我们持续学习、领悟、突破。</p>
<p>这对初入社会的大学生是一个巨大的考验，光凭自己的人生经验和脑子，很难不吃苦头。</p>
<p>不要成为环境的奴隶，被各种情绪和刺激占据了所有的心思，做出过度的反应，而是要保持平静，认清这些事实，<strong>不应该预设某种态度</strong>，<strong>应保持思想的开放而不带着偏见</strong>（我感觉我最近偏见有点多了），但是这是十分占据时间精力的，我们要精挑细选有价值、有意义的刺激，而记住，<strong>刺激的重要程度并不和刺激的强度成正比</strong>。</p>
<p>做人做事从观察事实开始，进而采取行动；在行动过程中，还得持续观察行动的实际效果，反过来调整和修正行动。得到的事实越少，则虚妄的成本越多。</p>
<p>建议多读《大学》《中庸》《论语》《老子》，还有《周易》！具有极高的实践性，特别是针对个人行为的管理和塑造。尤其适合投资交易者，关键在自己能不能应用。还有就是研究实际案例。</p>
<p>第二本书《期货交易的策略与技巧》</p>
<h2 id="前言-艰难的路"><a href="#前言-艰难的路" class="headerlink" title="前言 艰难的路"></a>前言 艰难的路</h2><p><strong>期货交易是一条艰难的路</strong></p>
<p>不要小看期货交易的艰难性，两三年，甚至十年都是远远不够称得上是精通交易、战胜市场的，更别说孔子先生所说的“从心所欲不逾矩了”。</p>
<p>青泽先生认为的难点：</p>
<ol>
<li><p>理解、把握市场价格波动的特征难</p>
<p>最刻骨民心的莫过于市场价格的反复无常、神秘莫测，不确定性、随机性。</p>
<p>很多市场参与者都有一种认知误区：<strong>追求交易的确定性，把科学的思维简单应用到投机交易中，以为预测是市场交易的全部，希望找到一种科学的预测理论，但是这所谓的科学方法主张的严密和正确，其实很多时候不但无用武之地，还可能成为成功的障碍。</strong></p>
<p>当然，很多预测工具（比如波浪理论）确实很常用，有价值，但是不要把期货投机当作一门科学，事实上，什么理论都无法保证我们的交易和市场走势。</p>
<p><strong>投机领域充满了辩证法，模糊和缺陷是美，追求完美恰恰背道而驰</strong>。</p>
<p><u>市场价格运动表面看起来往往是一个偶然性接着另一个偶然性，但是在看似完全偶然的背后，市场也不是完全混乱无序，隐隐约约透露出一定的必然性或者说是趋势性。投机成功的核心就是要去追求，把握这种必然性。</u>，交易高手就是能够从表面上看来不确定、随机的市场波动中找到相对确定、比较有把握的机会，知道什么时候<strong>成功的概率高，比较有利，什么时候静观其变</strong></p>
<p>从抽象的层面、事后的角度我们可以看清规律，但是对于未来，需要投机者有客观、定量、科学的理性分析能力，也要有灵活、变通、前瞻的艺术、直觉</p>
</li>
<li><p>良好的风险管理难</p>
<p>市场不确定性、随机性的一面决定了投机永远有<strong>博弈的成分</strong>，不可能有科学系统的预测理论。</p>
<p>良好的风险管理是投资者的立身之本。</p>
<p><u>期货交易既是一门赢的艺术，更是一门控制风险的输的艺术</u></p>
<p>成功的投资者在交易中能做到严格控制损失，<strong>即使砍掉亏损部位</strong>，对盈利头寸则做到了尽可能地扩大战果</p>
<p>短期的走势偶然性、人为性，投机者的贪婪、恐惧等心理因素，是的投机者找到适合自己的风险管理策略并非易事，但是无论是怎样的交易方式，短或长，感性、程序化，都要坚持<strong>几个原则</strong>：</p>
<ul>
<li>任何一笔交易都不要出现大的损失</li>
<li>一如既往的采取试探——加码的交易策略</li>
<li>在行情走势和自己的判断不一致时迅速止损，一致时逐步加仓，扩大利润</li>
</ul>
<p>青泽把期货交易的盈利模式分为两类：仓位取胜（博弈型）、幅度取胜（趋势性），但核心一样。</p>
</li>
<li><p>了解自己、战胜自己难</p>
<p>在某种意义上说这是一个心理游戏，投机者应该做出正确的决策而不是舒服的决策，心理上舒服的决策结果往往很不好，遵守交易技术和资金管理策略，不要被情绪左右。</p>
<p>从交易之道到市场行为，隔了 知（了解），情（心理认同），意（执行的意志力），这三者的合力才能决定行为是否理性。</p>
<p>技术和基础知识其实一两年就够了，但是稳定、良好的心态和境界，这可能是一辈子的事</p>
</li>
</ol>
<p><u>关于期货最好的忠告：在开始之前就停止行动</u></p>
<p>有奇迹的故事，更有数不胜数的尸骨和黯然的退场</p>
<p>市场交易是残酷、险恶，梦醒之后，也不要忘记当年的热情和豪言壮志（我的热情还没开始呢！</p>
<p>青泽先生的前言是一篇难得的好文章。</p>
<h2 id="一、命运之门"><a href="#一、命运之门" class="headerlink" title="一、命运之门"></a>一、命运之门</h2><p>人的命运可以自己选择吗？可以，你可以走你愿意走的路。</p>
<p>但是，一旦你上了路，回头恐怕就没有那么容易了，人生的许多事情都无法重来一次。</p>
<p>人生就像一个怪圈。有些年轻时候认为无足轻重的问题，年龄大后可能觉得很重要，比如一个人的修养、个性、习惯等；有些年轻时认为很有意义的事，以后看来往往没有想象中那么有价值，比如年轻的时候某种特别的兴趣和爱好等。</p>
<p>索罗斯：“你不可能随心所欲，又在市场中有良好的表现”</p>
<p>一念之差，一面是个哲学领域的教授、学者。一面是专业投资家，睿智的赌徒。</p>
<p><strong>期货是浓缩的人生</strong>，交易世界和现实生活有着如梦如幻的巨大反差</p>
<p>当时头脑精明点就能赚到钱，大部分人都是先扎进去，然后才开始了解基本知识，现在的股市就凶险了许多，人们的整体素质高了不少，难度暴增。</p>
<p>大多数涉足股市的新手，只要在股票上赚过一次钱，就会被吸引住，从此欲罢不能，沉迷上瘾。心乱了</p>
<p>一次偶然的急于，让他成为公司的操盘手，即使当时毫无投资理念和策略，但这就是时代和命运。</p>
<p>这给了他坐着一个巨大的发展机会，也让他的人生充满跌宕起伏，承受了许多常人无法体会的坎坷磨难。曲折的经历，平淡的人生，都在羡慕着彼此。</p>
<h2 id="二、一个与众不同的赌徒"><a href="#二、一个与众不同的赌徒" class="headerlink" title="二、一个与众不同的赌徒"></a>二、一个与众不同的赌徒</h2><p>股票市场要赚大钱，不仅要靠知识，也要靠信念；不但要靠智慧，也要靠胆量。</p>
<p><strong>新手的运气往往很好</strong></p>
<p>有观点：新手想要在投机市场中赚钱，最佳策略时找机会大赌一次，而经验丰富，有胜算和有势的人反而应该注意控制资金，减少偶然性运气的影响。<strong>投机是一个大多数人必输的游戏。</strong></p>
<hr>
<p>理解股市：</p>
<p>西方发达国家证券市场诞生的意义来自经济发展的内在需要。有人需要筹集成本，有人希望投资，这是一个公平、高效的互惠互利、各取所需市场。</p>
<p>中国早期股市却打上了深深的中国特色烙印，为国有企业融资解困。因此判断国内市场我们既要看内在的市场规律，更要高度关注政治、决策的态度，这样才能提高投资的胜算。</p>
<ol>
<li><p>用政治眼光来审视股票市场，抓住市场可能出现的重大变化。</p>
<p>青泽认为在未来相当长的一段时间内仍是政策市，因此股票市场一点出现过于离谱的暴涨暴跌，就随时可能出现外在的力量左右市场走势，回到社会政治所能容忍的范围内。<strong>政治敏感度极其重要。</strong></p>
</li>
<li><p>抓住<strong>大行情</strong>可能来临的机会，长线交易，重仓交易，不贪小利，迷恋股市，整天炒来炒去。</p>
</li>
<li><p>绝不染指垃圾股，这些股票甚至在大牛市都没有出头之日。</p>
<p>分散投资是减少垃圾股上海的一个简单策略。</p>
</li>
</ol>
<p><u>重价不重势——典型的外行炒股手法。</u></p>
<p>作者有了一些新的认识：</p>
<p>如果股市波动时循环的，而长远看指数一直在稳步上涨，那么，投机者的操作只要稍稍聪明一点，不太干愚蠢的事，在一定意义上，股票交易其实一点风险都没有。作者希望投机者深入透彻地思考👇：</p>
<ol>
<li><p>操作手法问题。大利润一定来自于大的市场波动</p>
<p>要有足够的耐心等待永恒的牛熊循环，不要整天频繁的短线交易，在市场地无需波动中迷失自我</p>
</li>
<li><p>投机者的市场信念问题</p>
<p>巴菲特：“利润有时候往往来自对市场的愚忠”，对市场没有坚定信念的人，往往拿不住很有可能带来巨大回报的仓位，不能获得市场重大波动的利润。但是还是得远离垃圾股。</p>
</li>
<li><p>参与股票交易的投资者，对市场指数高低要有一些基本常识，不能犯太离谱的错误。</p>
<p>但是指数的高低总是相对的，判断起来不是简单的问题。</p>
</li>
</ol>
<hr>
<p>股票终究不是真正的赌场，背后有企业、业绩、国家政治的影响。</p>
<p>股市大跌后再买入，耐心等待下个牛市，这是一种常识，但遵循这个简单的真理却十分困难。</p>
<p>对市场短期走势过于在意，就不宜涉足股票市场。</p>
<p>通过抓住重大趋势波动来赢利的交易模式，只是一种策略，需要眼光、胆识、魄力和长线持仓的勇气。</p>
<p><u>对于操盘手来说，一两次交易中出现亏损是非常普通的事情，但是面对重大的历史机遇，在锐利的行情中只赚了小钱，这种错误是无法原谅的。</u></p>
<h2 id="三、误入“期”途"><a href="#三、误入“期”途" class="headerlink" title="三、误入“期”途"></a>三、误入“期”途</h2><p>【我刚玩投机就误入了hh】</p>
<p>我被自我一次次打倒，却不知道敌人在哪里。</p>
<p>在股票、期货这个弱肉强食的市场，大多数散户投机者的命运，就像天空中一只断了线的风筝，一会上升，一会儿下降。散户的资金、心理承受能力、市场经验决定他们注定是被动的牺牲品。在一个不规范的市场中，主力们只要略使小计，就能杀绝大部分跟风者</p>
<p><strong>如果股票是抽烟，那么期货就是毒品</strong></p>
<p>期货投机的魔力在于，对于单独某一次交易，即使是赌博，也有50%赢的可能。</p>
<p>尽管从账面上看，很多人的本金在一天天减少，但是偶尔的几次交易赢利，会使大多数投机者产生一种幻觉，迟早能重新赚回来，还有暴富的机会。但能赚回损失的人是少数。</p>
<p>短期交易没有什么道理可言，也无从分析，只是凭着感觉对市场波动做出反应。这样的人往往成了市场短期波动的俘虏，思维、情绪被支配，变得不由自主，控制不了自己的交易冲动，不愿失去一切交易机会，过度敏感。</p>
<p>赚的时候，幻想一直保持，亏的时候十分沮丧，但是一旦进入下一次交易，不佳的心情就被忘记。</p>
<h2 id="四、绝处逢生"><a href="#四、绝处逢生" class="headerlink" title="四、绝处逢生"></a>四、绝处逢生</h2><p>327之战。</p>
<p>这是作者的运气，但是也是作者的经验告诉他选择哪一边。</p>
<p>也许是年龄增长，市场中经历过的偶然性太多了，很多事情的评价标准有时反而变得模糊了。青泽先生现在也不能完全确定当初自己的举动（全仓多头）是疯狂、鲁莽还是大胆、勇敢。这取决于角度。</p>
<p>毫无疑问，这种重仓交易、以命相搏的交易手法是自取灭亡之道。</p>
<p>尽管有时候保守和谨慎可能是一种束缚人的枷锁，短期会拖投机者的后腿，但是长远来看，保守、谨慎、稳健无疑是期货交易者的立身之本。</p>
<p><strong>一旦一个人获得了如此辉煌的战绩，无论旁观者还是他自己，都会有意无意地把这种成功归功于投机者的主观因素，而对事情发生偶然性的一面选择性忽略。</strong></p>
<p><strong>对于一个职业投机客来说，交易是一条漫长地路，局部的输赢犹过眼云烟，实在是一件无足轻重地小时。过于拘泥某一笔交易地得失，对此痛心疾首或津津乐道，并非是一种聪明、理智的态度。只能说认识浅。</strong></p>
<h2 id="五、苦闷的求索"><a href="#五、苦闷的求索" class="headerlink" title="五、苦闷的求索"></a>五、苦闷的求索</h2><p>哲学家必须从感觉世界的”洞穴“上升到理智世界</p>
<p>但是一个人总不可能平白无故地进行行动，他需要某种行为方式和标准，至于这种权威是否可靠并不重要，不然这会让他面对波动不知所措。</p>
<p><strong>从预测制胜到重视资金、仓位的风险管理到心理、人生修养是一条漫长而痛苦的路。</strong></p>
<p>短期交易，迷惑人的心智，其实是赌博罢了。</p>
<hr>
<p><u>不可能有预测制胜，没有人能精确地预测市场的未来变化。</u></p>
<p><strong>市场交易是一个动态、系统的控制过程。理解价格变化、判断未来走势只是成功交易的一个不是最重要的环节</strong></p>
<p>在实际操作中：</p>
<ul>
<li>每一次交易投入的资金多少</li>
<li>情况不利时如何处理，有利时如何加码</li>
<li>价码后出现有利、不利情况如何应对</li>
<li>影里的交易怎样既不由赢转亏，又不丧失一旦市场大波动带来的暴利等</li>
</ul>
<p><em><strong>这些问题的应对技巧、策略、方法，远比希望准确预测走势重要得多，需要投机者有一套完整、系统的交易思路。</strong></em></p>
<hr>
<p>确实，在大行情下的急剧波动，不论多空其实都无安宁。</p>
<p>据好事者统计，当年在股票、国债期货市场上赚过大钱的人，90%的结局都不太妙，这反映了一些东西。</p>
<p><u>投机市场中，一个人偶尔可以赚大钱也许并不难，难的是一直稳稳当当地赚钱，而且守得住钱。</u></p>
<p><a href="https://baike.baidu.com/item/%E7%AE%A1%E9%87%91%E7%94%9F/10343491">管金生</a></p>
<p>他们藐视法律，操纵行情，玩弄市场。</p>
<p>中经开的营业部令人向往——神奇的部门</p>
<p>早期国内股票市场、期货市场，市场操纵横行，政府法规朝令夕改，普通投机者生存环境十分恶劣，在这样的情况下，已经不能完全的归结于投机者自身的内在原因，外界因素几乎对投资者的命运起到决定性的作用</p>
<h2 id="六、纸上富贵一场梦"><a href="#六、纸上富贵一场梦" class="headerlink" title="六、纸上富贵一场梦"></a>六、纸上富贵一场梦</h2><p>1995，国债期货叫停，游资转战上海、深圳股票市场。</p>
<p>一次典型的纸上富贵——两鸟在林不如一鸟在手，但是谁有真正看得清这一点呢。</p>
<p>鞍山信托的一枝独秀——庄家也可能犯错。</p>
<p>市场里，没有庄家，往往走势清淡乏味。投机者没有机会</p>
<p>但是庄家来了以后兴风作浪。谁都不可能独善其身，包括庄家自己。</p>
<h2 id="七、单纯与复杂"><a href="#七、单纯与复杂" class="headerlink" title="七、单纯与复杂"></a>七、单纯与复杂</h2><p>——交易有那么难么</p>
<p>在成千上万的交易后，总的结果取决于投机者综合实力和心理优势，而不是一两次的市场预测能力。</p>
<p>在实际交易中，投机者会面临巨大的心理、精神压力，这是一个股评家不能完全了解和体会的。</p>
<p>一旦建立头寸，趋势就不像原先一般客观、超然、自信，你的恐惧、焦虑、患得患失等主观因素很有可能扭曲你的思维，使你陷入混乱。你当初的判断完全准确，但是你没有从中赚到钱。</p>
<p>不要依靠盘面变化和市场感觉、本能杀进杀出，这是缺乏理性的，也缺乏外在的客观约束。</p>
<p>要从长远分析市场状态和下一步变化的可能。看大势，理性审视。</p>
<p>在期货交易中，如果投机者入市后三天都没有出现利润，立刻平仓出场。</p>
<p>作者的第一个月大获成功，他在日后也感慨那段时间的美妙和带给他的信心，他总结：</p>
<ol>
<li><p>精神、心理条件非常好。</p>
<p>保持谨慎的态度，反复思考，再三权衡。</p>
<p>不要奢望一夜之间赚大钱，不要被急躁、贪婪的欲望支配。</p>
<p>没有交易的损失，没有历史包袱，不会畏手畏脚，在需要大胆行动时犹豫不决</p>
</li>
<li><p>中线顺势操作</p>
<p>中线顺势交易是期货赚钱的最佳策略</p>
</li>
<li><p>严格的风险控制</p>
</li>
<li><p>加码策略</p>
<p>试探-加码策略。在第一次投资后，如果市场走势证明判断错误，立马离场。否则便一次次加码，即使资金量不大，这样总能赚大钱，亏小钱。</p>
</li>
<li><p>时代和运气</p>
</li>
</ol>
<h2 id="八、兵败苏州红小豆"><a href="#八、兵败苏州红小豆" class="headerlink" title="八、兵败苏州红小豆"></a>八、兵败苏州红小豆</h2><p>当你将身体交给一个陌生人任意处置，你一定会感到愤慨。那么，当你将自己的精神交给一个偶遇者任意处置时，你难道不感到羞愧吗？</p>
<p><u>许多投机大师都反对利用内幕消息交易，认为这是投机者自我毁灭的捷径</u></p>
<p>因为急于翻本，作者被负面情绪支配，越做越赔，越赔越做。</p>
<h2 id="九、与天为敌"><a href="#九、与天为敌" class="headerlink" title="九、与天为敌"></a>九、与天为敌</h2><p>重仓交易的危害</p>
<p><strong>以安全性为代价追求收益率最终往往是得不偿失的</strong>。——本杰明</p>
<p>在期货交易中，一个人的心理、精神状态远比他拥有的市场知识和预测技术重要得多</p>
<p>作者准确的把握了几次做大钱的趋势，但却被短线思维所害，无法贯彻中长线交易的策略和原则。这是一种从“中长线”开始衍生出的一系列思维模式吧</p>
<p>害怕自己到手的利润得而复失，不愿继续等待利润自然而然地增长，不断换市场。仿佛非常忙碌，但一无所获</p>
<p><strong>经验不是你经历过什么，而是你从经历中学到了什么，<em>包括别人的经历</em></strong></p>
<p>期货的成功建立在一个非常危险的观念之上，就像脆弱地基上的大楼，来的快，去的也快。</p>
<p>P114生动的讲述了作者在面对期货起落的精神状态</p>
<p>来自十年后的反思：</p>
<ol>
<li><p>对于大多数人来说，即使拿出五分之一的资产来从事期货投机，也是危险的</p>
<p>保守、胆小的行为其实是高瞻远瞩，胆大妄为的重仓交易，早晚会在市场中牺牲。</p>
</li>
<li><p>坏习惯“钱烧口袋漏，一有就不留”</p>
<p>交易的姬会不是每天都有，不能凭想象行事，否则就是不尊重市场，将会受到市场的惩罚</p>
</li>
<li><p>在期货市场可以赚大钱，但需要时间，量的积累带来质的飞跃</p>
<p>重仓交易者企图战胜时间的束缚，一夜暴富，辉煌的成功靠的是以命相搏，一次意外就可能彻底失败。</p>
<p>真正成功的人，要么是拥有极其强大的意志，在赌赢后果断离场，要么靠的是长期、稳定的赢利。</p>
</li>
</ol>
<p>索罗斯：</p>
<ul>
<li>相对于近期赢利，我更关心<strong>基金资本的安全</strong></li>
<li>我主要还是着眼于<strong>限制亏损</strong>，而不是牟取暴利</li>
</ul>
<h2 id="十、激战海南咖啡"><a href="#十、激战海南咖啡" class="headerlink" title="十、激战海南咖啡"></a>十、激战海南咖啡</h2><p>面对诱惑，人的记忆力总显得太弱</p>
<p>期货市场本应是用来规避风险的地方，然而，曾几何时，在国内的一些交易所，期货却成了制造风险，激化矛盾的东西。</p>
<p>海南咖啡交易的几大特点：</p>
<ol>
<li><p>咖啡纯粹只是个符号被炒作</p>
<p>它托利里基本面因素和供求关系的制约，谁也不知道内在价值是多少。</p>
<p>没有人想阵得买进咖啡，投机者的唯一目的是赚取市场差价，最终结果是金钱的重新分配而已。</p>
<p>这不就是数字货币的雏形吗</p>
</li>
<li><p>波动巨大，虽然比不过炒币</p>
</li>
<li><p>波动方式诡异，凶狠，残酷</p>
<p>常规的风险控制措施不管用，绝对不能出现方向性的措施，连续性的跌涨停板，没有逃命的姬会。</p>
</li>
<li><p>市场主力争斗你死我活、白热化</p>
<p>大量非市场因素参与其中</p>
</li>
</ol>
<p><strong>方向判断准确只是交易成功的第一步，并且可能不是最关键的一步。</strong></p>
<p><strong>赚大钱最主要的是投机者需要有大的耐心和忍耐力，面对短期波动的不确定性、反复无常，要坚定自己的市场信念。</strong></p>
<p><em><strong>能否抵御市场短期波动的威胁、欺骗，是顺势交易最令人头疼而不得不面对的现实问题。</strong></em></p>
<p>K线完全是形而上的思维方式，用静止，片面而孤立的观点看待市场，一叶障目，应该从整体，全局，的角度看待。</p>
<h2 id="十一、逆势操作的反思"><a href="#十一、逆势操作的反思" class="headerlink" title="十一、逆势操作的反思"></a>十一、逆势操作的反思</h2><p><strong>你不可能靠风向标致富</strong>——巴菲特</p>
<p>比起重仓的谨慎，逆势者像温水里的青蛙，慢慢丧命。</p>
<p>大多数情况下，市场的趋势运动是温和、缓慢演变的，趋势都不是很明显，具有偶然性和随机性</p>
<p>所以逆势操作有可能也能赚到钱，因此其巨大危险性不易察觉，直到大势到来，恶果就暴露无遗。</p>
<p>一般来说，操纵者并不怕市场对手，他们更怕法律和市场监管。期货市场不完善和监管缺失，使他们有机可乘，那么数字货币呢？</p>
<p>这些折戟的精英们，每一件失败的事都有大量的偶然因素，但是偶然背后也有必然的一面，他们有一些共同的特点：</p>
<ol>
<li><p>自负和贪婪</p>
<p>大多数人似乎总是高估自己的判断力，过于自负</p>
<p>如果一个投资者顺势交易，他往往觉得自己没有格调，不能证明自己，一旦被套住他会觉得自己愚蠢，一旦成功他会给予自己极高的评价。</p>
<p>当自负和贪婪集中在一个人身上，尤其是掌握巨额资金的大人物身上，悲剧就开始上演了。</p>
</li>
<li><p>侥幸</p>
<p>心理学预期认为：失败的时候我们是风险的爱好者，有盈利时我们是风险的厌恶者。</p>
<p><strong>大多数人都是这样，赚小钱、亏大钱，刚好与正确的交易原则相反。</strong></p>
<p>其实，任何巨大损失的造成，除了突发性消息引起的个别意外情况，一般有从到质变的过程。</p>
<p>没有人能避免错误，我们能做的只有——止损原则。</p>
</li>
<li><p>虚荣</p>
<p><u>处于自我保护和虚荣的本能下，不愿让别人知道自己犯的错误。</u></p>
<p>一大群投机者在牛市做空的原因：</p>
<ol>
<li>市场行情看似是高估的</li>
<li>市场行情的矫正时间到了</li>
<li>他们听到一个看跌的消息，认为价格将会下跌</li>
<li>消息</li>
</ol>
</li>
</ol>
<p>人们不愿反思、正视自己的弱点，不愿承认因为缺乏自我约束而犯下的愚蠢错误，故意遗忘掉那些令人不快的痛苦经历。</p>
<p>理由是：</p>
<ol>
<li><p>短线交易方式隐含的天然缺陷</p>
<p>过于注重细节的人，往往对大事情一无所知</p>
</li>
<li><p>总比市场慢一拍的思维</p>
<p><strong>总以为历史会简单的重复</strong></p>
</li>
<li><p>作者迷失在短期波动的大海里</p>
<p>投机者很容易沉溺短线思维而失去超然的思维，让投机者不知不觉中，稀里糊涂地变成了一个逆势交易者</p>
</li>
<li><p>市场趋势会反弹吗？——思维陷阱</p>
<p>任何一个市场趋势一旦明朗，市场价格往往已经涨跌了相当幅度。</p>
<p>在这种情况下，市场趋势随时反转的可能性并非不存在。一般人很难不折不扣地遵循顺势投资地原则，就是怕趋势反转。</p>
<p><strong>在市场交易中，投机者应该做出正确地决策，而不是做出让自己感觉舒服的决策。</strong>所以说投机是反人性</p>
</li>
</ol>
<p>教训：</p>
<ol>
<li>价格变化本身透露出的消息远比指标的意义重要。</li>
<li>对投机者来说，从众是大忌，风向标不会让人赚钱</li>
<li>再次强调止损</li>
</ol>
<p>现代决策心理学的研究表明：当一个人的内心充满矛盾时，最典型的行为特征是不采取任何行动。</p>
<h2 id="十二、冥河摆渡者"><a href="#十二、冥河摆渡者" class="headerlink" title="十二、冥河摆渡者"></a>十二、冥河摆渡者</h2><p>让新手盲目进入市场是非常不负责任的</p>
<p>市场交易离不开预测，但是预测只是一个合理的交易计划的一小部分。</p>
<p>投机者一定要时时刻刻保持冷静、理智，客观、谦逊的评价自己，不论低谷或高峰。</p>
<p>投机需要技巧、时机、经验和运气，蛮干、强求是无法成功的。</p>
<h2 id="十三、与恶魔进餐"><a href="#十三、与恶魔进餐" class="headerlink" title="十三、与恶魔进餐"></a>十三、与恶魔进餐</h2><p>市场主力的目的：让大多数投机者犯错，自己从中获利。</p>
<p>作者入瓮后试图破局：</p>
<ol>
<li>在市场真正突破有意义的技术点位后入市 失败</li>
<li>设置好小亏损，止盈设置高一点，在众多指标中，找到了一种恰好比较符合的遵守</li>
</ol>
<p>作者构建了一套理解市场的核心框架工具，严格遵守。</p>
<p>大势交易准则。</p>
<h2 id="十四、Jesse-Livermore"><a href="#十四、Jesse-Livermore" class="headerlink" title="十四、Jesse Livermore"></a>十四、Jesse Livermore</h2><p>进入市场前，要爬上巨人的肩膀。</p>
<p>作者发现安了里费默的这本书。</p>
<p>本杰明、投资：《价值投资》</p>
<p>里费默、投机：《股票作手回忆录》</p>
<p>ps:大致来讲，我们可以把股市回报分为两大类：<strong>基本面和投机面</strong>。基本面是指股票自身给予投资者的回报，主要包括公司分红和盈利增长。而投机面则主要反映了大众对于市场的悲观或者乐观情绪。从比较长的时间维度来看，基本面给予投资者的回报是可以预测并且比较稳定的，而投机面则变化无常，经常在天堂和地狱之间游走。</p>
<p>全书内容大致分三类：<u>市场认识、交易策略、心理精神</u></p>
<p><strong>市场认识</strong>：对股票、期货市场的重大原则问题的基本观点。包括市场趋势出现的原因，市场价格变化的必然性、偶然性，操作行为的影响等</p>
<p><strong>交易策略</strong>：应对市场价格变化的基本方法、技巧。包括入市时机，点位选择，投入资金，利好利空策略，何谓最佳离场时机。</p>
<p><strong>心理精神</strong>：如何看待盈亏，对待金钱的态度，长线交易中对待波动的准备，还有种种投机者盲目的心里根源。</p>
<p>不能无原则的止损！趋于大势。</p>
<p>主力的力量也必须服从供求关系，经济学理论并非毫无用处，市场价格大方向上必然符合经济大规律。</p>
<p>赚大钱不能靠看盘，而在于股价整个股市行情和走势。</p>
<p><strong>试探-加码策略</strong>，<strong>好有道理</strong></p>
<p>有学者认为投机者应该着重追市，在发生突破后再进入市场。</p>
<h2 id="十六、离市场远一点"><a href="#十六、离市场远一点" class="headerlink" title="十六、离市场远一点"></a>十六、离市场远一点</h2><p>在缓慢上涨的行情中，如果市场涨姿突然加速，这可能是市场要见顶。。</p>
<p>大行情要有一个发展过程，投机者必须给市场足够的时间，投机者是不是不该天天注意市场细节，而是离他远一点呢？</p>
<p>一个看图经验，在大幅下跌后的市场行情中，如果市场价格连续两周上涨，周K线都是中等长度阳线，后市往往极度看好。</p>
<p>既然自己把持不住短期波动的扰乱，那就躲远一点吧！</p>
<h2 id="十七、投机者"><a href="#十七、投机者" class="headerlink" title="十七、投机者"></a>十七、投机者</h2><p>面对相同的行情，投机者们有着完全不同的各种应对方式。</p>
<p>市场交易无非一买一卖，但背后却隐含着投机者不同的观念、意识、目的、动机，反映出投机者的价值观、交易理念、对待风险、金钱的态度等。</p>
<p>投机者在金融领域的最终命运，深层次的原因取决于一个投机者的综合素质——人生修养和境界。</p>
<p>这建立在两个方面上：</p>
<ul>
<li><u>对市场的理解</u>，对市场交易中一些重大的原则性问题的基本态度</li>
<li><u>对自我的认识</u>，既包括对人类本性的洞察，也包括对自身独特弱点、性格缺陷的反省</li>
</ul>
<p>心理游戏，与人斗，与自己斗。</p>
<p>很多人们都能随口说出的朴素、简单的经验，投机者都为之可能付出过惨痛的代价才能铭刻于心</p>
<p>投资的特性让人们容易忘记错误，沉迷于数字上涨的愉悦，忘记反省，便多出了无数的错误成本。</p>
<p>投机里的止损、冲动性交易等问题，其实都不是孤立的，投机者整体的交易理念、境界达不到一定的高度，就难以彻底</p>
<p><strong>冲动性交易是一种超级短线交易</strong></p>
<p>缺乏自我控制能力，沉迷于短时间赚大钱的欲望。</p>
<p>平静、淡然的欣赏市场的变化，也审视着自己的内心世界，这种境界。。</p>
<p><strong>止损需要莫大的勇气</strong></p>
<p>再交易不利时果断止损，推翻原来的市场判断是沉重的。这还涉及投机者的市场认识，投机策略，交易思路是否正确，更要求极高的精神境界。</p>
<p>每一次交易中，具体止损点位的设立，也是个复杂问题。不然就可能来回割肉，被市场愚弄</p>
<p>不能孤立、静止、机械地看待市场交易中的止损问题。如果一个人的盈利不能弥补止损的损失，那也毫无用处，止损对长线更有意义，因为利润远远大于损失。</p>
<ul>
<li>天下唯一确定的事情就是不确定性</li>
<li>任何决策都是均衡几率的结果</li>
<li>一旦做出决定就要立刻付出行动</li>
<li>决策者的品质远远比决策结果重要</li>
</ul>
<p>这是一个长期的培养、追求、领悟过程。</p>
<p>面对市场的不确定性，哲学的世界观、方法论、价值观和抽象思维模式也许能帮助投机者把握市场脉络。</p>
<p>高手之间的较量是投资哲学的较量，心态和境界的较量。</p>
<h2 id="十八、你能摆脱地星引力吗"><a href="#十八、你能摆脱地星引力吗" class="headerlink" title="十八、你能摆脱地星引力吗"></a>十八、你能摆脱地星引力吗</h2><p>理智的最后一步就是意识到有无数事物是它力所不及的。</p>
<p>不知命无以为君子。市场中人的因素重要，偶然性，同样重要。</p>
<p>环境、机遇和运气对一个的影响也是很大的，过于强调自我的意志、智慧和天赋，难免陷入幼稚和狂妄，付出惨痛的代价。</p>
<ol>
<li>社会政治、经济环境</li>
<li>政策因素，尤其在中国，一定要看得懂国家的态度，做出准确判断</li>
<li>市场本身，挑选市场，不同市场的规律不同，蕴含的机会也不同，波动大的市场蕴含更多的机会。</li>
<li>不公平竞争，几十年前市场的公平、公正原则荡然无存，内部勾结严重，尤其是交易所</li>
</ol>
<p>不要赌性太重，不要去做那些毫无把握的交易，珍惜已有的东西，善待自己，善待人生。</p>
<p>要根据环境的变化，审时度势，难免会被市场淘汰。</p>
<h2 id="十九、里费默之死"><a href="#十九、里费默之死" class="headerlink" title="十九、里费默之死"></a>十九、里费默之死</h2><p>生命本质的非理性之谜</p>
<p>人难胜天</p>
<p>一个富有想象力的人，在他的生活中，总是看到自己的生活具有传奇色彩，这就决定了他的生活方式——与其说他想创造美好的生活，不如说他想使他的生活成为一个美妙的故事。</p>
<p>没有人是绝对理性的，哪怕是传奇。</p>
<p>人性的困境如此悲哀。金融工程是不是就是为了解决这个问题？</p>
<p>忍不住好奇心，厌倦呆板的交易策略，迷失在探索市场奥妙的旅程，沉溺交易的快感，最后一无所有。</p>
<p>难道有什么比让自己心里愉悦更重要的吗？高明的交易原则在内心面前，也显得苍白无力</p>
<p>投机遵守的规矩是反人性的，领悟市场交易的局限性、危险性、悲剧性——性格决定命运</p>
<p>投机算的上是工作吗？——天空不留下鸟的痕迹，但我已飞过。</p>
<p>期货交易要赚钱，不但要有心，更要有运，多少年轻人都死在里面了。</p>
<p>市场交易中没有持续、安全、稳定的成功之路。</p>
<p>在西方国家，大众参与期货交易的方式往往是间接的，一般是通过基金让专业人士来操作，而我国期货市场80%都是散户，期货市场的残酷和凶险最后必然会淘汰大部分人，并使他们收到严重的伤害。</p>
<p>人啊，也许根本就无法战胜非理智地一面。</p>
<p>张爱玲《非走不可的弯路》</p>
<p>一个交易经验丰富、市场理解深刻的投机者，经历了长时间的摸索和尝试以后，往往能够建立起自己的交易模式、套路，具有明确的交易思路和交易风格。其思维和行为方式具有逻辑性和前后一致性。</p>
<p>成功操盘手的几个特征：</p>
<ol>
<li><p>拥有一套相对稳定的，有优势、有胜算的交易模式</p>
<p>这样才能明确自己在市场中关注什么，什么时候采取行动。</p>
</li>
<li><p>交易策略和风险控制的始终一贯性</p>
<p>坚持每一笔交易都不要出现重大损失；每一次都采取试探—加码策略。</p>
<p>限制亏损，发展利润</p>
</li>
<li><p>市场判断和操作的前后一致性</p>
<p>紧握头寸，把持住长期的确定性</p>
</li>
<li><p>哲学境界</p>
<p>武士道、茶道等东方哲学，在这个孤独的心里搏斗游戏中，如何贯彻一套哲学</p>
</li>
</ol>
]]></content>
      <categories>
        <category>finance</category>
      </categories>
      <tags>
        <tag>股市心理</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/03/08/python%E8%B6%85%E6%9D%82/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="廖雪峰"><a href="#廖雪峰" class="headerlink" title="廖雪峰"></a>廖雪峰</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li><p>在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。</p>
</li>
<li><p>可变对象和不可变对象：可变指存在某项操作可以改变本身如list</p>
</li>
<li><p>set里都是key，set可以做&amp;和|操作</p>
</li>
<li><p>tuple里的不变指“指向对象不变”，指向的对象自身可以变（如list）</p>
</li>
<li><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p>
</li>
<li><p>占位符pass什么都不做</p>
</li>
<li><p>函数可以同时返回多个值，但其实就是一个tuple，多个变量可以同时接收一个tuple，按位置赋给对应的值</p>
</li>
<li><p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！如果指向可变对象如一个list，默认参数则指向这个list，且内容会被记住，每次调用都有继承，通过妙用不变对象来规避</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_end</span><span class="token punctuation">(</span>L<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> L <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> L<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    因为Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
</li>
<li><p>参数前加*可以接受list和tuple并组装成tuple，加**则自动组装成dict，不过此时的key不用加引号</p>
<ol start="11">
<li><p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>
</li>
<li><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> args<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>函数参数规则：</p>
<ol>
<li><em><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></em></li>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</li>
<li><strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
</ol>
</li>
<li><p>```python<br> a, b = b, a + b #这个挺诡异的，记录了初始值</p>
<pre class="line-numbers language-none"><code class="language-none">
12. 切片可用于str，list，tuple

13. 判断一个对象是可迭代对象：通过collections模块的Iterable类型判断

    &#96;&#96;&#96;python
    &gt;&gt;&gt; from collections import Iterable
    &gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>列表解析：</p>
<ol>
<li>可以使用两层循环，可以生成全排列：</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>m <span class="token operator">+</span> n <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token string">'ABC'</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token string">'XYZ'</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'AX'</span><span class="token punctuation">,</span> <span class="token string">'AY'</span><span class="token punctuation">,</span> <span class="token string">'AZ'</span><span class="token punctuation">,</span> <span class="token string">'BX'</span><span class="token punctuation">,</span> <span class="token string">'BY'</span><span class="token punctuation">,</span> <span class="token string">'BZ'</span><span class="token punctuation">,</span> <span class="token string">'CX'</span><span class="token punctuation">,</span> <span class="token string">'CY'</span><span class="token punctuation">,</span> <span class="token string">'CZ'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>for后面的<code>if</code>是一个筛选条件，不能带<code>else</code></p>
</li>
<li><p>for前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果，必须加上else，如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
</li>
<li><p>生成器generator：</p>
<ol>
<li><p>第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code></p>
</li>
<li><p>二：如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator</p>
<p>​    变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
</li>
<li><p>generator函数的“调用”实际返回一个generator对象：</p>
</li>
<li><p>但是用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> g <span class="token operator">=</span> fib<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         x <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'g:'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Generator return value:'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p>
<p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p>
</li>
<li><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为不同地方都指向同一个对象，多处修改</p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" title="来自廖雪峰的装饰器详解">装饰器详解</a>functools.wraps(func)</p>
</li>
<li><p>偏函数：</p>
<p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。其实也可以传入其他值，会自动加到左侧</p>
<pre class="line-numbers language-none"><code class="language-none">max2 &#x3D; functools.partial(max, 10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">max2<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li><p>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>__name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
</li>
<li><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</p>
</li>
<li><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是 <em><strong>多态真正的威力</strong></em>：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
</li>
<li><p>动态语言的“鸭子类型”，它并不要求严格的继承体系,只要同样能进行操作，并不会检查它的类型，即使你要求的参数是animal类</p>
</li>
<li><p>千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
</li>
<li><p>可以给实例动态绑定属性（直接）</p>
<p>A是类，a=A()  </p>
<p> a.name=’darren’  del(a.name)可以直接操作</p>
<p>print(a.attribute)要是没有特殊的，就打印A的</p>
<p>还可以动态绑定方法：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">set_age</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#定义一个函数作为实例方法</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     self<span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> types <span class="token keyword">import</span> MethodType
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>set_age <span class="token operator">=</span> MethodType<span class="token punctuation">(</span>set_age<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment"># 给实例绑定一个方法</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>set_age<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token comment"># 调用实例方法</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>age <span class="token comment"># 测试结果</span>
<span class="token number">25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以直接给类动态绑定方法</p>
<p>A.set_age=set_age</p>
<p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字</p>
</li>
<li><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span> <span class="token comment"># 用tuple定义允许绑定的属性名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<p>（怪怪的）</p>
</li>
<li><p>@property   @method_name.setter将方法变成类</p>
</li>
<li><p><em><strong>定制类</strong></em>:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span><span class="token builtin">len</span>函数自动调用的计算长度工具
<span class="token operator">-</span><span class="token operator">-</span>name<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>获得当前函数的名族<span class="token punctuation">(</span>functions<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">str</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回用户信息
<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">repr</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回开发者信息
<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">iter</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>返回迭代对象，使一个类可以被<span class="token keyword">for</span> <span class="token keyword">in</span>使用
<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">next</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>迭代将调用<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">next</span><span class="token operator">-</span><span class="token operator">-</span>方法
<span class="token operator">-</span><span class="token operator">-</span>getitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>实现下标访问<span class="token punctuation">[</span><span class="token punctuation">]</span>（切片要分类。。。不懂）
<span class="token operator">-</span><span class="token operator">-</span>setitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>把对象视作<span class="token builtin">list</span><span class="token operator">/</span><span class="token builtin">dict</span>来赋值
<span class="token operator">-</span><span class="token operator">-</span>delitem<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>删除某元素
<span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">getattr</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>在没有找到属性<span class="token operator">/</span>方法时返回定义好的，可实现动态调用！
<span class="token operator">-</span><span class="token operator">-</span>call<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">:</span>直接对实例进行调用！可调用对象是Callable
Python的官方文档<span class="token punctuation">:</span>
  https<span class="token punctuation">:</span><span class="token operator">//</span>docs<span class="token punctuation">.</span>python<span class="token punctuation">.</span>org<span class="token operator">/</span><span class="token number">3</span><span class="token operator">/</span>reference<span class="token operator">/</span>datamodel<span class="token punctuation">.</span>html<span class="token comment">#special-method-names</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>枚举：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum，unique
Month <span class="token operator">=</span> Enum<span class="token punctuation">(</span><span class="token string">'Month'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Jan'</span><span class="token punctuation">,</span> <span class="token string">'Feb'</span><span class="token punctuation">,</span> <span class="token string">'Mar'</span><span class="token punctuation">,</span> <span class="token string">'Apr'</span><span class="token punctuation">,</span> <span class="token string">'May'</span><span class="token punctuation">,</span> <span class="token string">'Jun'</span><span class="token punctuation">,</span> <span class="token string">'Jul'</span><span class="token punctuation">,</span> <span class="token string">'Aug'</span><span class="token punctuation">,</span> <span class="token string">'Sep'</span><span class="token punctuation">,</span> <span class="token string">'Oct'</span><span class="token punctuation">,</span> <span class="token string">'Nov'</span><span class="token punctuation">,</span> <span class="token string">'Dec'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><em>value默认从1开始！！！！</em></p>
<p>用@unique精确控制Enum衍生</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@unique</span>
<span class="token keyword">class</span> <span class="token class-name">Weekday</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    Sun <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># Sun的value被设定为0</span>
    Mon <span class="token operator">=</span> <span class="token number">1</span>
    Tue <span class="token operator">=</span> <span class="token number">2</span>
    Wed <span class="token operator">=</span> <span class="token number">3</span>
    Thu <span class="token operator">=</span> <span class="token number">4</span>
    Fri <span class="token operator">=</span> <span class="token number">5</span>
    Sat <span class="token operator">=</span> <span class="token number">6</span>
    day1<span class="token operator">=</span>Weekday<span class="token punctuation">.</span>Mon
    day1<span class="token operator">==</span>Weekday<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    day1<span class="token punctuation">.</span>value<span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用.value获得对应的值</p>
</li>
<li><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数，所以类的类型是‘type’。</p>
</li>
<li><p>object是python的默认类，有很多的方法，python种默认的list,str,dict等等都是继承了object类的方法，继承了object的类属于新式类 ，没有继承属于经典类，在python3种默认都是新式类，也即是所有的自定义类，基类都会继承object类！</p>
</li>
<li><p>type也可创建新类</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合</li>
<li>class的方法名称与函数绑定，</li>
</ol>
</li>
<li><p>先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”，它可以改变类创建时的行为。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。。。</p>
<p>按照默认习惯，metaclass的类名总是以Metaclass结尾</p>
<p>（写法着实奇怪。。不放了。。希望这辈子碰不到！听说ORM要用。。）</p>
<p>url：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072#0">使用元类 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
</li>
</ol>
<h3 id="错误-amp-异常"><a href="#错误-amp-异常" class="headerlink" title="错误&amp;异常"></a>错误&amp;异常</h3><ol>
<li><p>错误衍生：</p>
<p>The class hierarchy for built-in exceptions is:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">BaseException
 <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemExit
 <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyboardInterrupt
 <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> GeneratorExit
 <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Exception
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopIteration
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> StopAsyncIteration
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ArithmeticError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FloatingPointError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OverflowError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ZeroDivisionError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AssertionError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> AttributeError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BufferError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> EOFError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ModuleNotFoundError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> LookupError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndexError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> KeyError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> MemoryError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NameError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnboundLocalError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> OSError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BlockingIOError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ChildProcessError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionError
      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BrokenPipeError
      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionAbortedError
      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionRefusedError
      <span class="token operator">|</span>    <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ConnectionResetError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileExistsError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FileNotFoundError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> InterruptedError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IsADirectoryError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotADirectoryError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PermissionError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ProcessLookupError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TimeoutError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ReferenceError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> NotImplementedError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RecursionError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> IndentationError
      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TabError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SystemError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> TypeError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ValueError
      <span class="token operator">|</span>    <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeError
      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeDecodeError
      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeEncodeError
      <span class="token operator">|</span>         <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeTranslateError
      <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> Warning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> DeprecationWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> PendingDeprecationWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> RuntimeWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> SyntaxWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UserWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> FutureWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ImportWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> UnicodeWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> BytesWarning
           <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span> ResourceWarning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>try .. except.. excepy…else…finally</p>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>bar()</code>，<code>bar()</code>调用<code>foo()</code>，结果<code>foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理</p>
</li>
<li><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出.</p>
<p>顺着错误信息一路向下就可以找到根源</p>
</li>
<li><p>logging可以记录错误信息，要配置。。。<a href="https://www.jianshu.com/p/feb86c06c4f4">python logging模块使用教程 -</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> logging
<span class="token keyword">try</span><span class="token punctuation">:</span><span class="token operator">//</span>
<span class="token keyword">except</span><span class="token punctuation">:</span> Excerption <span class="token keyword">as</span> e<span class="token punctuation">:</span>
    logging<span class="token punctuation">.</span>excerption<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样，在抛出错误信息后继续运行</p>
<p>当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理，raise不带参数则原样抛出</p>
</li>
<li><p>assert … , ‘decleration’可以在解释时<code>python -O file.py</code>来终止调用assert</p>
<p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看</p>
</li>
<li><p>logging.info()输出一段文本</p>
<p>在import logging后加<code>logging.basicConfig(level=logging.INFO)</code>指定记录信息的级别</p>
<p>error&gt;warning&gt;info&gt;debug，上面规定INFO后，logging.debug就失效了</p>
</li>
<li><p>PDB我不想学。。不如IDE自带</p>
</li>
<li><p>测试unittest参见《入门》</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">$ python <span class="token operator">-</span>m unittest mydict_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以直接启用测试，常用的assetRaises,Equal,NotEqual,True,False,In,NotIn</p>
<p>在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行</p>
</li>
<li><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> doctest
    doctest<span class="token punctuation">.</span>testmod<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ol>
<li><p>异步的理解</p>
<p>read(size)读取size</p>
<p>readline()读一行</p>
<p>readlines()一次读取并按行返回list</p>
<p>清理每行结尾自动加的\n</p>
</li>
<li><p>有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行</p>
<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲</p>
</li>
<li><p>open（url,encoding=’gbk’,errors=’igone’）默认编码UTF-8，在出现非法字符时，由errors决定解决方式，直接‘igone’。。。</p>
</li>
<li><p>StringIO在内存中读写str</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> io <span class="token keyword">import</span> StringIO
f<span class="token operator">=</span> StringIO<span class="token punctuation">(</span><span class="token string">'initial'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>getvalue()获得写入后的str</p>
<p>BytesIO操作的是二进制</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'中文'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">b'\xe4\xb8\xad\xe6\x96\x87'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>写入的是utf-8编码的bytes，也可以初始化，其他读取方式和文件一样</p>
</li>
<li><p>操作文件和目录</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os
os<span class="token punctuation">.</span>name  posix  nt
os<span class="token punctuation">.</span>uname<span class="token punctuation">(</span><span class="token punctuation">)</span>不适用于windows
os<span class="token punctuation">.</span>environ
os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span>
os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token comment">#查看绝对路径</span>
<span class="token string">'/Users/michael'</span>
<span class="token comment">#创建目录</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'/Users/michael'</span><span class="token punctuation">,</span> <span class="token string">'testdir'</span><span class="token punctuation">)</span>
<span class="token string">'/Users/michael/testdir'</span>
<span class="token comment"># 然后创建一个目录:</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">'/Users/michael/testdir'</span><span class="token punctuation">)</span>
<span class="token comment"># 删掉一个目录:</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span><span class="token string">'/Users/michael/testdir'</span><span class="token punctuation">)</span>
<span class="token comment">#合成路径不要拼接字符串，才能正确处理不同操作系统的路径分隔符</span>
os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名
os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span><span class="token punctuation">)</span>可以直接让你得到文件扩展名
os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token punctuation">)</span>重命名
os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span>删除
shutil模块提供了copyfile<span class="token punctuation">(</span><span class="token punctuation">)</span>的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充
Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os<span class="token punctuation">.</span>path模块中。
还有很多操作，需要用到时去找os库吧！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化指把变量从内存中变成可存储或传输的过程称之为序列化 pickling</p>
<p>比起pickle库，json库更好，更通用</p>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody></table>
<p>Python内置的<code>json</code>模块提</p>
<p>json.dump()   json.dumps(d,f)</p>
<p>json.load()   json.loads(f)</p>
<p>加了s是序列化和反序列化,没加则是操作文件同时序列化和反序列化。UTF-8</p>
<p>很多时候json不够智能，需要我们加上很多自定义参数来辅助，default是dumps用的，object_hook是loads用的，json好复杂啊</p>
<p><a href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p>
<p><a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ol>
<li><p>强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了</p>
</li>
<li><p>```python<br>import re<br>test = ‘用户输入的字符串’<br>if re.match(r’正则表达式’, test):</p>
<pre><code>print(&#39;ok&#39;)
</code></pre>
<p>else:</p>
<pre><code>print(&#39;failed&#39;)
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
3. 可用于切分字符串

   &#96;&#96;&#96;python
   &gt;&gt;&gt; re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)
   [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>提取字串！</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">m<span class="token operator">=</span>re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">r'正则表达式'</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span>
m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">=</span>string
m<span class="token punctuation">.</span>group<span class="token punctuation">(</span>n<span class="token punctuation">)</span>是第n个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token comment"># 编译:</span>
<span class="token operator">>></span><span class="token operator">></span> re_telephone <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span><span class="token punctuation">)</span>
<span class="token comment"># 使用：</span>
<span class="token operator">>></span><span class="token operator">></span> re_telephone<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'010-12345'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'010'</span><span class="token punctuation">,</span> <span class="token string">'12345'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> re_telephone<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'010-8086'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'010'</span><span class="token punctuation">,</span> <span class="token string">'8086'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li></li>
</ol>
<h2 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h2><ol>
<li><p><code>str.replace(&#39;a&#39;,&#39;A&#39;) 把字符串里的a替换成A</code></p>
</li>
<li><p>abs（）绝对值，max（）返回最大值</p>
</li>
<li><p>help(function_name)放到print里克查看帮助信息</p>
</li>
<li><p>int，float，str，bool 内置数据类型转换</p>
</li>
<li><p>hex（）函数把一个整数转换成十六进制表示的字符串</p>
</li>
<li><p>内置函数<code>isinstance()</code>用于数据类型检查，如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">isinstance</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
</li>
<li><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">reduce</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">[</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span> x4<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">(</span>f<span class="token punctuation">(</span>f<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> x3<span class="token punctuation">)</span><span class="token punctuation">,</span> x4<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><code>filter()</code>接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素，并返回的是一个<code>Iterator</code></p>
</li>
<li><p>sorted（列表，映射函数，reverse=True）</p>
<p>比较对每一项使用映射函数后的新列表！</p>
</li>
<li><p>基本类型都可以用<code>type()</code>判断，返回相应class</p>
<p>可以使用<code>types</code>模块中定义的常量：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> types
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>FunctionType
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>BuiltinFunctionType
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>LambdaType
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>types<span class="token punctuation">.</span>GeneratorType
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>dir()</code>函数，它返回一个包含字符串的list获得一个对象的所有属性和方法</p>
</li>
<li><p>```python<br>getattr()<code>、</code>setattr()<code>以及</code>hasattr()</p>
<pre class="line-numbers language-none"><code class="language-none">
可以分别验证，设置，得到某个instance的属性和方法

如果试图获取不存在的属性，会抛出AttributeError的错误：

&#96;&#96;&#96;python
&gt;&gt;&gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token comment"># 获取属性'z'，如果不存在，返回默认值404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>```python<br> raise ValueError(‘score must be an integer!’)</p>
<pre class="line-numbers language-none"><code class="language-none">
15. eval()解析字符串为指令

## 常用内建模块

还是看廖雪峰吧

1. datetime----datetime里有个datetime包！

   &#96;datetime.now()&#96;返回当前日期和时间，其类型是&#96;datetime&#96;。

   &#96;&#96;&#96;python
   from datetime import datetime
   &gt;&gt;&gt; dt &#x3D; datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
   &gt;&gt;&gt; print(dt)
   2015-04-19 12:20:00
   dt.timestamp() # 把datetime转换为timestamp
   1429417200.0
   datetime.(时区如utc)fromtimestamp(dt)
   &gt;&gt;&gt;2015-04-19 12:20:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>   <u>我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</u>对应的北京时间是：</p>
   <pre class="line-numbers language-python" data-language="python"><code class="language-python">timestamp <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1970</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>   str转换为datetime用datetime.strptime(‘time’,’格式参数’)具体参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python文档</a>此处得到的datetime无时区信息</p>
<p>   datetime转str用strftime</p>
<h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>   对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>
   <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">-</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">540997</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>参考PEP8    </p>
<ol>
<li><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
</li>
<li><p>运算符的空格要看出运算顺序，<code>x = 3*4 + 5</code>  <code>y = 3 + 5</code></p>
</li>
<li><p>每行代码应该不超过 <strong>80</strong> 个字符，虽然在某些使用情况下，<strong>99</strong> 个字符也可以</p>
</li>
</ol>
<h2 id="以后再学"><a href="#以后再学" class="headerlink" title="以后再学"></a>以后再学</h2><ol>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904" title="廖雪峰">定制类</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376">进程和线程</a></li>
</ol>
<h1 id="思科补充"><a href="#思科补充" class="headerlink" title="思科补充"></a>思科补充</h1><p>print(“..”,end=”分隔符”)分隔符用于指示结尾，默认为换行、</p>
<p>print(“a”,”b”,sep=”在句号间的分割标志”)</p>
<p><code>None</code>可以安全使用的情况只有两种：</p>
<ul>
<li>当您<strong>将其分配给变量</strong>（或将其作为<strong>函数的结果</strong>返回）时</li>
<li>当您<strong>将其与变量</strong>进行<strong>比较</strong>以诊断其内部状态时。</li>
</ul>
<p>它<strong>不能参与任何表达式</strong>。</p>
<p>列表和元组可以用*操作符“繁殖”</p>
<p>python3函数先定义再调用</p>
<h1 id="Udacity"><a href="#Udacity" class="headerlink" title="Udacity"></a>Udacity</h1><p>任何专业人士都无法记住所有方法，因此知道如何通过文档查询答案非常重要。掌握扎实的编程基础使你能够利用这些基础知识查询文档，并且构建的程序比死记硬背所有 python 可用函数的人士构建的程序强大得多。</p>
<p>区分函数和方法的概念</p>
<p>下图显示了任何字符串都可以使用的方法。</p>
<p><a href="https://www.w3school.com.cn/python/python_ref_string.asp">https://www.w3school.com.cn/python/python_ref_string.asp</a></p>
<p><strong><a href="https://docs.python.org/3/library/stdtypes.html#string-methods">文档是最宝贵的资料</a></strong></p>
<p>还有Udacity的<a href="https://anandology.com/python-practice-book/getting-started.html">文档教材</a></p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><hr>
<p>mutability 可变性</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409100005524.png"></p>
<p>包含可变对象和不可变对象的变量行为不同</p>
<p>把字符串赋给另一个变量就是复制一份，但如果是列表就类似引用</p>
<hr>
<p>orderd 有序性</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409100027234.png"></p>
<p>有序性的容器可以使用索引，在 python 中，所有有序容器（例如列表，字符串）的起始索引都是 0。</p>
<p>还可以使用切片</p>
<hr>
<h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a><strong>列表函数</strong></h3><p>max等函数在比较不能比的类型时，并不会自动转换！直接出错</p>
<p>支持 in</p>
<p>min  len   sorted（小心字符串没有列表的len方法，要用len(string)）</p>
<p>join字符串函数，注意python的字符串字面量间如果不加分隔符，会被视为连在一起</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">new_str <span class="token operator">=</span> <span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"fore"</span><span class="token punctuation">,</span> <span class="token string">"aft"</span><span class="token punctuation">,</span> <span class="token string">"starboard"</span><span class="token punctuation">,</span> <span class="token string">"port"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>new_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>输出:</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">fore
aft
starboard
port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>该函数同样在遇到非字符串类型时直接出错</p>
<p>小心一些方法或者函数没有返回值，比如append，这时默认返回None</p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>这下有定义了，元组是 <strong>不可变</strong> 的 <strong>有序</strong> 数据结构</p>
<p>所以不能更改，但可以使用索引和切片，元组适合确定后不变的数据们，可以用来表示始终不变的对应数据</p>
<p>元组还可以用来以紧凑的方式为多个变量赋值。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">dimensions <span class="token operator">=</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span>
length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height <span class="token operator">=</span> dimensions
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The dimensions are &#123;&#125; x &#123;&#125; x &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在定义元组时，小括号是<strong>可选</strong>的，如果小括号并没有对解释代码有影响，程序员经常会忽略小括号。</p>
<p>在第二行，我们根据元组 dimensions 的内容为三个变量赋了值。这叫做<strong>元组解包</strong>。你可以通过元组解包将元组中的信息赋值给多个变量，而不用逐个访问这些信息，并创建多个赋值语句。</p>
<p>如果我们不需要直接使用 <code>dimensions</code>，可以将这两行代码简写为一行，一次性为三个变量赋值！</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">100</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The dimensions are &#123;&#125; x &#123;&#125; x &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>{1,2,3}</p>
<p>无序，所以不存在最后一个元素这一说，pop方法如果无参数则会随机弹出</p>
<p>可变，支持in</p>
<p>但是不能使用append，要使用add方法</p>
<p><strong>不能往无序的里面使用某些带有有序意义的方法如append，</strong></p>
<p>对set可以进行数学上集合的操作，union()  intersection() difference(),并且与其他容器相比，速度快了很多。</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是无序的！</p>
<p>字典的键可以是任何<strong>不可变</strong>类型！一个字典的每个键也并非必须具有相同的类型</p>
<p>get()用来查找值！默认返回None，也可以自定义，如果可能出错，就使用get方法而不是方括号，免得崩溃</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> elements<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'kryptonite'</span><span class="token punctuation">,</span> <span class="token string">'There\'s no such element!'</span><span class="token punctuation">)</span>
<span class="token string">"There's no such element!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>恒等运算符is 和 is not  与 == 和 != 是有区别的</p>
<p>首先要知道Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。</p>
<p>== 比较的是值   is比较的是id      可以用id()查看id</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">只有数值型和字符串型的情况下，a <span class="token keyword">is</span> b才为<span class="token boolean">True</span>，当a和b是<span class="token builtin">tuple</span>，<span class="token builtin">list</span>，<span class="token builtin">dict</span>或<span class="token builtin">set</span>型时，a <span class="token keyword">is</span> b为<span class="token boolean">False</span>。

小整数导致的bug
<span class="token operator">**</span>大家自己试试看a<span class="token operator">=</span><span class="token number">257</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">257</span>时它们的<span class="token builtin">id</span>还是否会相等。事实上Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。而Python 对小整数的定义是 <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">257</span><span class="token punctuation">)</span>，只有数字在<span class="token operator">-</span><span class="token number">5</span>到<span class="token number">256</span>之间它们的<span class="token builtin">id</span>才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。<span class="token operator">**</span> 

<span class="token operator">**</span>总的来说，只有数值型和字符串型，并且在通用对象池中的情况下，a <span class="token keyword">is</span> b才为<span class="token boolean">True</span>，否则当a和b是<span class="token builtin">int</span>，<span class="token builtin">str</span>，<span class="token builtin">tuple</span>，<span class="token builtin">list</span>，<span class="token builtin">dict</span>或<span class="token builtin">set</span>型时，a <span class="token keyword">is</span> b均为<span class="token boolean">False</span>。<span class="token operator">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>推荐样式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> population <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Shanghai'</span><span class="token punctuation">:</span> <span class="token number">17.8</span><span class="token punctuation">,</span>
              <span class="token string">'Istanbul'</span><span class="token punctuation">:</span> <span class="token number">13.3</span><span class="token punctuation">,</span>
              <span class="token string">'Karachi'</span><span class="token punctuation">:</span> <span class="token number">13.0</span><span class="token punctuation">,</span>
              <span class="token string">'Mumbai'</span><span class="token punctuation">:</span> <span class="token number">12.5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>复合结构</strong></p>
<p>我们可以在其他容器中包含容器，以创建复合数据结构。例如，下面的字典将键映射到也是字典的值！</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">elements <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hydrogen"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
                         <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">1.00794</span><span class="token punctuation">,</span>
                         <span class="token string">"symbol"</span><span class="token punctuation">:</span> <span class="token string">"H"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
              <span class="token string">"helium"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
                         <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">4.002602</span><span class="token punctuation">,</span>
                         <span class="token string">"symbol"</span><span class="token punctuation">:</span> <span class="token string">"He"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们可以如下所示地访问这个嵌套字典中的元素。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">helium <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token string">"helium"</span><span class="token punctuation">]</span>  <span class="token comment"># get the helium dictionary</span>
hydrogen_weight <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token string">"hydrogen"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"weight"</span><span class="token punctuation">]</span>  <span class="token comment"># get hydrogen's weight</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="*逻辑"></a>*逻辑</h2><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><ul>
<li>逻辑运算符 <code>and</code>、<code>or</code> 和 <code>not</code> 具有特定的含义，与字面英文意思不太一样。确保布尔表达式的结果和你预期的一样。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Bad example</span>
<span class="token keyword">if</span> weather <span class="token operator">==</span> <span class="token string">"snow"</span> <span class="token keyword">or</span> <span class="token string">"rain"</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Wear boots!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这段代码在 Python 中是有效的，但不是布尔表达式，虽然读起来像。原因是 <code>or</code> 运算符右侧的表达式 <code>&quot;rain&quot;</code> 不是布尔表达式，它是一个字符串。稍后我们将讨论当你使用非布尔型对象替换布尔表达式时，会发生什么。</p>
<ul>
<li>请勿使用 <code>== True</code> 或 <code>== False</code> 比较布尔变量</li>
</ul>
<p><strong>以下是在 Python 中被视为 False 的大多数内置对象：</strong></p>
<ul>
<li>定义为 false 的常量：<code>None</code> 和 <code>False</code></li>
<li>任何数字类型的零：<code>0</code>、<code>0.0</code>、<code>0j</code>、<code>Decimal(0)</code>、<code>Fraction(0, 1)</code></li>
<li>空序列和空集合：<code>””</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>、<code>set()</code>、<code>range(0)</code></li>
</ul>
<p>在Python中and的优先级是大于or的，而且and和or都是会返回值的并且不转换为True和False。当not和and及or在一起运算时，优先级为是not&gt;and&gt;or</p>
<hr>
<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p><strong>短路求值</strong></p>
<p>如果<code>a = False</code>，对于<code>a and b</code>求值时，将直接得到结果为<code>False</code>，不会再对<code>b</code>的值做考核，不论它是<code>True</code>或<code>False</code>。</p>
<p>如果<code>a = True</code>，对于<code>a or b</code>求值时，将直接得到结果为<code>True</code>，不会再对<code>b</code>的值做考核，不论它是<code>True</code>或<code>False</code>。</p>
<p>python的if这些语句会提取表达式的真假，但并不是把表达式改了值！</p>
<hr>
<p><strong>短路输出</strong></p>
<p><strong>记住，所有被短路的表达式均不会被输出</strong></p>
<p><strong>短路规则如下</strong></p>
<ul>
<li><p>表达式从左至右运算，若 or 的左侧逻辑值为 True ，则短路 or 后所有的表达式（不管是 and 还是 or），直接输出 or 左侧表达式 。 // 若 or 的左侧逻辑值为 False ，则输出or右侧的表达式，不论其后表达式是真是假，整个表达式结果即为其后表达式的结果</p>
</li>
<li><p>表达式从左至右运算，若 and 的左侧逻辑值为 False ，则短路其后所有 and 表达式，直到有 or 出现，输出 and 左侧表达式到 or 的左侧，参与接下来的逻辑运算。  // 若 and 的左侧逻辑值为 True,则输出其后的表达式，不论其后表达式是真是假，整个表达式结果即为其后表达式的结果</p>
</li>
<li><p>若 or 的左侧为 False ，或者 and 的左侧为 True 则不能使用短路逻辑。</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/an9wer/p/5475551.html">有例子的大佬详解</a></p>
<p><strong>三元运算操作符</strong></p>
<p>　　在python2.5 之前，python 是没有三元操作符的，Guido Van Rossum 认为它并不能帮助 python 更加简洁，但是那些习惯了 c 、 c++ 和 java 编程的程序员却尝试着用 and 或者 or 来模拟出三元操作符，而这利用的就是python的短路逻辑。</p>
<p>　　三元运算操作符 bool ? a : b ，若 bool 为真则 a ，否则为 b 。</p>
<p>　　转化为 python 语言为：</p>
<blockquote>
<p>　　　　　　　　**bool and a or b **</p>
</blockquote>
<p>　　如何理解呢？ 首先 a ， b 都为真，这是默认的。如果 bool 为真， 则 bool and a 为真，输出 a ，短路 b 。如果 bool 为假，短路 a，直接 bool or b ，输出 b 。</p>
<p>　　换一种更简单的写法：</p>
<blockquote>
<p>　　　　　　　　<strong>return a if bool else b</strong></p>
</blockquote>
<h3 id="for和迭代"><a href="#for和迭代" class="headerlink" title="for和迭代"></a>for和迭代</h3><p><strong>iterable</strong> 也是一个很重要的属性！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409115901777.png"></p>
<p>字符串，列表，元组等序列结构，</p>
<p>字典，文件等非序列类型</p>
<p>iter()方法定义对象，使其为可迭代</p>
<p><strong>for用于可迭代对象</strong>！！！！！习惯用单复数分别作为迭代变量名，和迭代对象名</p>
<p>range(star,stop,step) 默认start -0 step-1  只能是整数,小心stop表示到xx停止，所以不会包含</p>
<p>漂亮用法👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409120515316.png"></p>
<p>只会返回一个可迭代的range对象。。得用list转化或for遍历</p>
<hr>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><code>For</code> 循环是一种“有限迭代”，意味着循环主体将运行预定义的次数。这与“无限迭代”循环不同，无限迭代循环是指循环重复未知次数，并在满足某个条件时结束，<code>while</code> 循环正是这种情况</p>
<p>break和continue</p>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">ps<span class="token punctuation">:</span> 格式化字符串函数<span class="token punctuation">.</span><span class="token builtin">format</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>    <span class="token comment"># 不设置指定位置，按默认顺序</span>
<span class="token string">'hello world'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"&#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment"># 设置指定位置</span>
<span class="token string">'hello world'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment"># 设置指定位置</span>
<span class="token string">'world hello world'</span>


也可以设置参数：
<span class="token comment"># 关键字参数</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> url<span class="token operator">=</span><span class="token string">"www.runoob.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 通过字典设置参数</span>
site <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"www.runoob.com"</span><span class="token punctuation">&#125;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token operator">**</span>site<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 通过列表索引设置参数</span>
my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>my_list<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># "0" 是必须的</span>
<span class="token comment"># 仅列表</span>
<span class="token keyword">for</span> point <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>labels<span class="token punctuation">,</span> x_coord<span class="token punctuation">,</span> y_coord<span class="token punctuation">,</span> z_coord<span class="token punctuation">)</span><span class="token punctuation">:</span>
    points<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&#123;&#125;: &#123;&#125;, &#123;&#125;, &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
此外我们可以使用大括号 <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> 来转义大括号
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"runoob"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
runoob 对应的位置是 <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span>

数字则在前面加上<span class="token punctuation">:</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<table>
<thead>
<tr>
<th align="left">数字</th>
<th align="left">格式</th>
<th align="left">输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3.1415926</td>
<td align="left">{:.2f}</td>
<td align="left">3.14</td>
<td align="left">保留小数点后两位</td>
</tr>
<tr>
<td align="left">3.1415926</td>
<td align="left">{:+.2f}</td>
<td align="left">+3.14</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">-1</td>
<td align="left">{:+.2f}</td>
<td align="left">-1.00</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">2.71828</td>
<td align="left">{:.0f}</td>
<td align="left">3</td>
<td align="left">不带小数</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:0&gt;2d}</td>
<td align="left">05</td>
<td align="left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:x&lt;4d}</td>
<td align="left">5xxx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">{:x&lt;4d}（顺着读：在x左边）</td>
<td align="left">10xx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">{:,}</td>
<td align="left">1,000,000</td>
<td align="left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td align="left">0.25</td>
<td align="left">{:.2%}</td>
<td align="left">25.00%</td>
<td align="left">百分比格式</td>
</tr>
<tr>
<td align="left">1000000000</td>
<td align="left">{:.2e}</td>
<td align="left">1.00e+09</td>
<td align="left">指数记法</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&gt;10d}（没写用啥补，就是空的）</td>
<td align="left">13</td>
<td align="left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&lt;10d}</td>
<td align="left">13</td>
<td align="left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:^10d}</td>
<td align="left">13</td>
<td align="left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td align="left"><code>1011 11 13 b 0xb 0XB</code></td>
<td align="left">进制</td>
</tr>
</tbody></table>
<hr>
<h3 id="Zip-amp-Enumerate"><a href="#Zip-amp-Enumerate" class="headerlink" title="Zip &amp;Enumerate"></a>Zip &amp;Enumerate</h3><p><code>zip</code> 返回一个将多个可迭代对象组合成一个元组序列的迭代器。每个元组都包含所有可迭代对象中该位置的元素。例如，</p>
<p><code>list(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]))</code> 将输出 <code>[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</code>.</p>
<p>正如 <code>range()</code> 一样，我们需要将其转换为列表或使用循环进行遍历以查看其中的元素。</p>
<p>你可以如下所示地用 <code>for</code> 循环拆分每个元组。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> letter<span class="token punctuation">,</span> num <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>letters<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>letter<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span>
这个是两个参数依次匹配，字典的items是用了这个原理<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>items原理（转化为一个元组列表）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194823598.png"></p>
<p>除了可以将两个列表组合到一起之外，还可以使用星号拆分列表。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">some_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
letters<span class="token punctuation">,</span> nums <span class="token operator">=</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>some_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这样可以创建正如之前看到的相同 <code>letters</code> 和 <code>nums</code> 列表，巧妙👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409190913313.png"></p>
<hr>
<p><code>enumerate</code> 是一个会返回元组迭代器的内置函数，这些元组包含列表的索引和值。当你需要在循环中获取可迭代对象的每个元素及其索引时，将经常用到该函数。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> letter <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>letters<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> letter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这段代码将输出：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">0 a
1 b
2 c
3 d
4 e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409191815484.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409191831742.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409192428071.png"></p>
<p>这个技巧很诡异，tuple可以将列表，区间，字符串，zip等（可迭代对象？）等转换为元组</p>
<p>但在转化字典时，只会保留键。这边就是把zip迭代对象转化为元组，</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409193651985.png"></p>
<p>这样就直接可以使用索引了！</p>
<h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3><p>终于知道SyntaxError原来是语法错误</p>
<p>你还可以向列表推导式添加条件语句。在可迭代对象之后，你可以使用关键字 <code>if</code> 检查每次迭代中的条件。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上述代码将 <code>squares</code> 设为等于列表 [0, 4, 16, 36, 64]，因为仅在 x 为偶数时才评估 x 的 2 次幂。如果你想添加 <code>else</code>，将遇到语法错误。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果你要添加 <code>else</code>，则需要将条件语句移到列表推导式的开头，直接放在表达式后面，如下所示。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> x <span class="token operator">+</span> <span class="token number">3</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>列表推导式并没有在其他语言中出现，但是在 python 中很常见。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194302935.png"></p>
<p>这个课程总有一些奇怪的知识藏在题解里面卧槽，split是个很重要的工具</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409194648954.png"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>仅在函数名称中使用普通字母、数字和下划线。不能有空格，需要以字母或下划线开头。</li>
<li><strong>不能使用在 Python 中具有重要作用的保留字或内置标识符</strong>，我们将在这门课程中学习这方面的知识。要了解 python 保留字列表，请参阅<a href="https://pentangle.net/python/handbook/node52.html">此处</a>。</li>
<li>尝试使用可以帮助读者了解函数作用的描述性名称</li>
</ol>
<h3 id="python变量"><a href="#python变量" class="headerlink" title="python变量"></a>python变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409234143765.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409234153818.png"></p>
<p><em><strong>你发现在函数内，我们可以成功地输出外部变量的值。因为我们只是访问该变量的值。当我们尝试将此变量的值更改或重新赋值为另一个值时，我们将遇到错误。Python 不允许函数修改不在函数作用域内的变量。</strong></em></p>
<p><em><strong>但是上面的原则仅适用于整数和字符串，列表、字典、集合、类中可以在子程序（子函数）中通过修改局部变量达到修改全局变量的目的。</strong></em></p>
<h3 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h3><p>通用写法是*arg  **kwargs</p>
<p>*args就是就是传递一个可变参数列表给函数实参，这个参数列表的数目未知，甚至长度可以为0。</p>
<p>打包后成为元组tuple</p>
<p>**kwargs则是将一个可变的关键字参数的字典传给函数实参，同样参数列表长度可以为0或为其他值</p>
<p>打包后是一个字典</p>
<p>args 必须放在 kwargs 前面</p>
<p>打包就是zip</p>
<p>解包可以是之前介绍的写法，一个变量对应一项，对应不上就报错</p>
<p>可以用*var 代替任意项<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410111047193.png"></p>
<p><strong>函数定义时</strong>，我们用的*和**其实也是压包解包过程</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">myfun</span><span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> myfun<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参数用<code>*num</code>表示，<code>num</code>变量就可以当成元组调用了。</p>
<p>其实这个过程相当于<code>*num, = 1,2,5,6</code></p>
<p>但是在<strong>传递参数</strong>时，是解包过程<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410111344033.png"></p>
<p>这个应用牛啊</p>
<p>可以看看<a href="https://zhuanlan.zhihu.com/p/33896402">原文</a></p>
<h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>docstrings，文档字符串是一种注释，用于解释函数的作用以及使用方式。</p>
<p>文档字符串用三个引号引起来，第一行简要解释了<strong>函数的作用</strong>。如果你觉得信息已经足够了，可以在文档字符串中只提供这么多的信息；</p>
<p>如果你觉得需要更长的句子来解释函数，可以在一行摘要后面添加更多信息</p>
<p>对函数的参数进行了解释，描述了每个参数的作用和类型。我们经常还会对函数输出进行说明</p>
<p><a href="https://www.python.org/dev/peps/pep-0257/">这里是惯例</a></p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>你可以使用 Lambda 表达式创建匿名函数，即没有名称的函数。lambda 表达式非常适合快速创建<strong>在代码中以后不会用到</strong>的函数。尤其<strong>对高阶函数或将其他函数作为参数的函数</strong>来说，非常实用。</p>
<p><strong>Lambda 函数的组成部分</strong></p>
<ol>
<li>关键字 <code>lambda</code> 表示这是一个 lambda 表达式。</li>
<li><code>lambda</code> 之后是该匿名函数的一个或多个参数（用英文逗号分隔），然后是一个英文冒号 <code>:</code>。和函数相似，lambda 表达式中的参数名称是随意的。</li>
<li>最后一部分是被评估并在该函数中返回的表达式，和你可能会在函数中看到的 return 语句很像。</li>
</ol>
<p>鉴于这种结构，lambda 表达式不太适合复杂的函数，但是非常适合简短的函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210409235417795.png"></p>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><p>Iterator   and   generator </p>
<p><strong>迭代器</strong>是每次可以返回一个对象元素的对象，例如返回一个列表。我们到目前为止使用的很多内置函数（例如 enumerate）都会返回一个迭代器。</p>
<p><strong>迭代器</strong>是一种表示数据流的对象。这与列表不同，列表是可迭代对象，但不是迭代器，因为它不是数据流。</p>
<p>第一种方法很简单，只要把一个列表解析式的<code>[]</code>改成<code>()</code></p>
<p><strong>生成器</strong>是使用函数创建迭代器的简单方式。也可以使用<strong>类</strong>定义迭代器，更多详情请参阅<a href="https://docs.python.org/3/tutorial/classes.html#iterators">此处</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">my_range</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> i
        i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，该函数使用了 yield 而不是关键字 return。这样使函数能够一次返回一个值，并且每次被调用时都从停下的位置继续。关键字 yield 是将生成器与普通函数区分开来的依据。调用该函数返回一个迭代器</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410003534992.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410003603746.png"></p>
<p>妙啊！用size指定间距，用切片进行范围切取</p>
<p><strong>python和c的思维方式是不一样的！</strong></p>
<p>C要利用有限的工具进行微操，而python要巧妙利用已有的强大工具进行组合！</p>
<p>这些工具组合起来太巧妙了</p>
<p>tuple,list,dict,zip,enumerate,压包解包,列表解析,lambda,range,iterator还有封装好的函数</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>Python 是一种“脚本语言”。脚本，对应的英文是：script。一般人看到script这个英文单词，或许想到的更多的是：电影的剧本，就是一段段的脚本，所组成的。电影剧本的脚本，决定了电影中的人和物，都做哪些事情，怎么做。而计算机中的脚本，决定了：计算机中的操作系统和各种软件工具，要做哪些事情，以及具体怎么做。</p>
<p>学完更全面的Anaconda和Jupyter Notebook  我们继续脚本</p>
<p>运行python文件得先输入python（理解为执行python命令，毕竟python没有c那么底层）</p>
<p>输入python进入环境，C + Z退出，或者exit()</p>
<p>input(‘xx’) 注意返回的是字符串</p>
<p>内置函数 <code>eval</code> 将用户输入解析为 Python 表达式，感觉非常危险！</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter an expression: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果用户输入 <code>2 * 3</code>，输出为 <code>6</code>。</p>
<p>ps:</p>
<p>split </p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"Line1-abcdef \nLine2-abc \nLine4-abcd"</span><span class="token punctuation">;</span> 
<span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment"># 以空格为分隔符，包含 \n </span>
<span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 以空格为分隔符，分隔成两个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>以上实例输出结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[&#39;Line1-abcdef&#39;, &#39;Line2-abc&#39;, &#39;Line4-abcd&#39;]
[&#39;Line1-abcdef&#39;, &#39;\nLine2-abc \nLine4-abcd&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>下面看一个神奇的例子</p>
<hr>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">names <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter names separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
assignments <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter assignment counts separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
grades <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Enter grades separated by commas: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>

message <span class="token operator">=</span> "Hi <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>\n\nThis <span class="token keyword">is</span> a reminder that you have <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> assignments left to \
submit before you can graduate<span class="token punctuation">.</span> You're current grade <span class="token keyword">is</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">and</span> can increase \
to <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">if</span> you submit <span class="token builtin">all</span> assignments before the due date<span class="token punctuation">.</span>\n\n"

<span class="token keyword">for</span> name<span class="token punctuation">,</span> assignment<span class="token punctuation">,</span> grade <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> assignments<span class="token punctuation">,</span> grades<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> assignment<span class="token punctuation">,</span> grade<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>assignment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h3><p>SyntaxError  语法异常</p>
<p>Exception就是语法正常但是出错</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410145517500.png"></p>
<p>Try 语句</p>
<p>我们可以使用 try 语句处理异常。你可以使用 4 个子句（除了视频中显示的子句之外还有一个子句）。</p>
<ul>
<li><p><code>try</code>：这是 <code>try</code> 语句中的唯一必需子句。该块中的代码是 Python 在 <code>try</code> 语句中首先运行的代码。</p>
</li>
<li><p><code>except</code>：如果 Python 在运行 <code>try</code> 块时遇到异常，它将跳到处理该异常的 <code>except</code> 块。</p>
<p>可以明确指明异常种类 except ValueError:   话说竟然C+C是KeyboardInterrupt异常</p>
<p>也可以用逗号分割来指定多种（实质是转化成一个元组，也可以直接写一个元组上去）</p>
<p>或者写多条except语句来分别不同情况</p>
</li>
<li><p><code>else</code>：如果 Python 在运行 <code>try</code> 块时没有遇到异常，它将在运行 <code>try</code> 块后运行该块中的代码。</p>
</li>
<li><p><code>finally</code>：在 Python 离开此 <code>try</code> 语句之前，在任何情形下它都将运行此 <code>finally</code> 块中的代码，即使要结束程序，例如：如果 Python 在运行 <code>except</code> 或 <code>else</code> 块中的代码时遇到错误，在停止程序之前，依然会执行此<code>finally</code> 块。</p>
</li>
</ul>
<p><a href="https://stackoverflow.com/questions/11551996/why-do-we-need-the-finally-clause-in-python">为何在 Python 中需要 <code>finally</code> 子句？</a></p>
<p>可用于清理代码比如关闭文件之类的👆</p>
<p>注意一下顺序</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410145940469.png"></p>
<p><strong>在这里，当执行了x = xx 时，抛出异常，直接到except里面，而不是执行break！</strong></p>
<p><strong>访问错误信息</strong></p>
<p>在处理异常时，依然可以如下所示地访问其错误消息：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># some code</span>
<span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
   <span class="token comment"># some code</span>
   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ZeroDivisionError occurred: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>应该会输出如下所示的结果：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ZeroDivisionError occurred: division by zero<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因此依然可以访问错误消息，即使已经处理异常以防止程序崩溃！</p>
<p>如果没有要处理的具体错误，依然可以如下所示地访问消息：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># some code</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
   <span class="token comment"># some code</span>
   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Exception occurred: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Exception</code> 是所有内置异常的基础类</strong>。你可以在<a href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions">此处</a>详细了解 Python 的异常。</p>
<hr>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件其实是一堆数字符号编码</p>
<p>其他的文件打开应用其实就是解读特定的编码并显示出来的GUI</p>
<p>在python中打开文件会出现一个公用程序接口</p>
<p>文件对象时python与文件交互的接口，智能按顺序一次查看一个字符</p>
<p>open打开，参数w，a，r之类的，write（返回输入的字符数）</p>
<p>read会从当前位置读取所有字符放进一个字符串，一定要close噢！小心耗尽文件句柄</p>
<p>如果向 <code>.read()</code> 传入整型参数，它将读取长度是这么多字符的内容，输出所有内容，并使 ‘window’ 保持在该位置以准备继续读取。</p>
<p>Python 提供了一个特殊的语法with，该语法会在你使用完文件后自动关闭该文件。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'my_path/my_file.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    file_data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>该 <code>with</code> 关键字使你能够打开文件，对文件执行操作，并在缩进代码（在此示例中是读取文件）执行之后自动关闭文件。现在，我们不需要调用 f.close() 了！你只能在此缩进块中访问文件对象 f。</p>
<p>实质是利用作用域</p>
<p>请参阅 <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files">Python 文档的相关部分</a></p>
<p>readline() 会读取一行</p>
<p><code>f.tell()</code> returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode.</p>
<p>鬼知道这个不透明数字是个啥玩意</p>
<p>To change the file object’s position, use <code>f.seek(offset, whence)</code>. The position is computed from adding <em>offset</em> to a reference point; the reference point is selected by the <em>whence</em> argument. A <em>whence</em> value of 0 measures from the beginning of the file, <strong>1 uses the current file position, and 2 uses the end of the file as the reference point</strong>. <em>whence</em> can be omitted and <strong>defaults to 0</strong>, using the beginning of the file as the reference point.</p>
<p>在文本文件中（那些<code>b</code>在模式字符串中不带a开头的文件），<strong>仅允许相对于文件开头的查找</strong>（查找到以结尾的文件末尾为例外），并且唯一有效的<em>偏移</em>值是从零返回的<em>偏移</em>量值。。任何其他<em>偏移</em>值都会<strong>产生不确定</strong>的行为。<code>seek(0, 2)``f.tell()</code>  这个和c语言一样</p>
<p>很方便的是，Python 将使用语法 <code>for line in file</code> 循环访问文件中的各行内容。 我可以使用该语法创建列表中的行列表。因为<strong>每行依然包含换行符</strong>，因此我使用 <code>.strip()</code> 删掉换行符。也可以rstrip()</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">camelot_lines <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"camelot.txt"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        camelot_lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>camelot_lines<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[&quot;We&#39;re the knights of the round table&quot;, &quot;We dance whenever we&#39;re able&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>比如提取每行的信息，前提是你知道怎么分离的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_cast_list</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
    cast_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># use with to open the file filename</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token comment"># use the for loop syntax to process each line        </span>
    <span class="token comment"># and add the actor name to cast_list</span>
        <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
            line_data <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
            cast_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> cast_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>只能在导入语句之后使用相应python代码，所以习惯放在顶部</p>
<p><strong>模块是具有python定义和语句的文件</strong></p>
<p>import  xxx as xx</p>
<p>还有python里面的<strong>main函数</strong> if __name__ ==  “__main__“</p>
<p>这样的结构不错：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># useful_functions.py</span>

<span class="token keyword">def</span> <span class="token function">mean</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">add_five</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">5</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> num_list<span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Testing mean function"</span><span class="token punctuation">)</span>
    n_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">]</span>
    correct_mean <span class="token operator">=</span> <span class="token number">30.5</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>mean<span class="token punctuation">(</span>n_list<span class="token punctuation">)</span> <span class="token operator">==</span> correct_mean<span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Testing add_five function"</span><span class="token punctuation">)</span>
    correct_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>add_five<span class="token punctuation">(</span>n_list<span class="token punctuation">)</span> <span class="token operator">==</span> correct_list<span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"All tests passed!"</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<a href="https://pymotw.com/3/">python标准库里查看并引用需要的module</a></p>
<p>datetime 用来处理日期和时间</p>
<p>os可以用来处理操作系统相关的，还有当前目录</p>
<p><strong>直接导入</strong></p>
<p>from module_name import object_name   </p>
<p>from module_name import object_name,object_name2</p>
<p>只获取所需要的对象，所以说函数其实也是一个对象</p>
<p>廖雪峰教材里确实有提到：函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p>
<p>总结：</p>
<ol>
<li><p>要从模块中导入单个函数或类：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> object_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>要从模块中导入多个单个对象：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> first_object<span class="token punctuation">,</span> second_object<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>要重命名模块：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> module_name <span class="token keyword">as</span> new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>要从模块中导入对象并重命名：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> object_name <span class="token keyword">as</span> new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>要从模块中单个地导入所有对象（请勿这么做）：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> <span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>如果你真的想使用模块中的所有对象，请使用标准导入 module_name 语句并使用点记法访问每个对象。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> module_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<hr>
<p>为了更好地管理代码，Standard 标准库中的模块被拆分成了子模块并包含在软件包中。<strong>软件包</strong>是一个包含子模块的模块。子模块使用普通的点记法指定。</p>
<p>子模块的指定方式是软件包名称、点，然后是子模块名称。你可以如下所示地导入子模块。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> package_name<span class="token punctuation">.</span>submodule_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<p>python的标准库非常庞大，但即使这样，仍有成千上万的第三方库</p>
<p>pip和conda下载这些库的的软件包，这样你可以使用与导入标准库相同的语法来导入第三方软件包</p>
<p><strong>conda据说专门针对数据科学！</strong>pip是内置，也是一般情况</p>
<p>按照规范，最好把第三方库放在导入标准库的语句后面</p>
<p><strong>使用 <code>requirements.txt</code> 文件</strong></p>
<p>大型 Python 程序可能依赖于十几个第三方软件包。为了更轻松地分享这些程序，程序员经常会在叫做 requirements.txt 的文件中列出项目的依赖项。下面是一个 requirements.txt 文件示例。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">beautifulsoup4&#x3D;&#x3D;4.5.1
bs4&#x3D;&#x3D;0.0.1
pytz&#x3D;&#x3D;2016.7
requests&#x3D;&#x3D;2.11.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>该文件的每行包含软件包名称和版本号。版本号是可选项，但是通常都会包含。不同版本的库之间可能变化不大，可能截然不同，因此有必要使用程序作者在写程序时用到的库版本。</p>
<p>你可以使用 pip 一次性安装项目的所有依赖项，方法是在命令行中输入 <code>pip install -r requirements.txt</code>。</p>
<h3 id="实用的第三方软件包"><a href="#实用的第三方软件包" class="headerlink" title="实用的第三方软件包"></a>实用的第三方软件包</h3><p>能够安装并导入第三方库很有用，但是要成为优秀的程序员，还需要知道有哪些库可以使用。大家通常通过在线推荐或同事介绍了解实用的新库。如果你是一名 Python 编程新手，可能没有很多同事，因此为了帮助你了解入门信息，下面是优达学城工程师很喜欢使用的软件包列表。（可能部分网站在国内网络中无法打开）</p>
<ul>
<li><a href="https://ipython.org/">IPython</a> - 更好的交互式 Python 解释器</li>
<li><a href="http://docs.python-requests.org/">requests</a> - 提供易于使用的方法来发出网络请求。适用于访问网络 API。</li>
<li><a href="http://flask.pocoo.org/">Flask</a> - 一个小型框架，用于构建网络应用和 API。</li>
<li><a href="https://www.djangoproject.com/">Django</a> - 一个功能更丰富的网络应用构建框架。Django 尤其适合设计复杂、内容丰富的网络应用。</li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> - 用于解析 HTML 并从中提取信息。适合网页数据抽取。</li>
<li><a href="http://doc.pytest.org/">pytest</a> - 扩展了 Python 的内置断言，并且是最具单元性的模块。</li>
<li><a href="http://pyyaml.org/wiki/PyYAML">PyYAML</a> - 用于读写 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件。</li>
<li><a href="http://www.numpy.org/">NumPy</a> - 用于使用 Python 进行科学计算的最基本软件包。它包含一个强大的 N 维数组对象和实用的线性代数功能等。</li>
<li><a href="http://pandas.pydata.org/">pandas</a> - 包含高性能、数据结构和数据分析工具的库。尤其是，pandas 提供 dataframe！</li>
<li><a href="http://matplotlib.org/">matplotlib</a> - 二维绘制库，会生成达到发布标准的高品质图片，并且采用各种硬拷贝格式和交互式环境。</li>
<li><a href="http://ggplot.yhathq.com/">ggplot</a> - 另一种二维绘制库，基于 R’s ggplot2 库。</li>
<li><a href="https://python-pillow.org/">Pillow</a> - Python 图片库可以向你的 Python 解释器添加图片处理功能。</li>
<li><a href="http://www.pyglet.org/">pyglet</a> - 专门面向游戏开发的跨平台应用框架。</li>
<li><a href="http://www.pygame.org/">Pygame</a> - 用于编写游戏的一系列 Python 模块。</li>
<li><a href="http://pytz.sourceforge.net/">pytz</a> - Python 的世界时区定义。</li>
</ul>
<h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>通过在终端里输入 <code>python</code> 启动 python 交互式解释器。你可以接着输入内容，直接与 Python 交互。这是每次实验和尝试一段 Python 代码的很棒工具。只需输入 Python 代码，输出将出现在下一行。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; type(5.23)
&lt;class &#39;float&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在解释器中，提示符窗口中最后一行的值将自动输出。如果有多行代码需要输出值，依然需要使用 print。</p>
<p>如果你开始定义函数，你将在提示符窗口中看到变化，表示这是可以继续的行。在定义函数时，你需要自己添加缩进。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def cylinder_volume(height, radius):
...         pi &#x3D; 3.14159
...         return height * pi * radius ** 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>解释器的不足之处是修改代码比较麻烦。如果你在输入该函数时出现了拼写错误，或者忘记缩进函数的主体部分，无法使用鼠标将光标点到要点击的位置。需要使用箭头键在代码行中来回移动。有必要了解一些实用的快捷方式，例如移到一行的开头或结尾。</p>
<p>注意，我可以引用我在解释器中之前定义的任何对象！</p>
<p>实际上有一个代替默认 python 交互式解释器的强大解释器 IPython，它具有很多其他功能。</p>
<p>在命令行输入ipython就可以打开</p>
<ul>
<li>Tab 键补充完整</li>
<li><code>?</code>：关于对象的详细信息</li>
<li><code>!</code>：执行系统 shell 命令</li>
<li>语法突出显示</li>
</ul>
<p>你可以在<a href="https://ipython.org/ipython-doc/3/interactive/tutorial.html">此处</a>查看更多其他功能！</p>
<h3 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询"></a>快速查询</h3><p>要想成为熟练的程序员，需要掌握大量知识。需要了解库、记住语法以及其他细节。此外，让这一切更具挑战的是，技术在不断革新，因为新的技巧和工具会不断出现。</p>
<p>对于编程新手来说，学习所有这些细节并及时获悉新的发展动态似乎是一项不可能完成的任务。的确是这样！具有多年经验的编程专业人士实际上并不是在脑中记下百科全书一样的知识，而是掌握了快速查找信息的技巧。</p>
<p>下面是高效网络搜索的一些技巧：</p>
<ul>
<li>在查询时，尝试使用 Python 或要使用的库的名称作为第一个字词。这样会告诉搜索引擎优先显示与你要使用的工具明确相关的结果。</li>
<li>创建良好的搜索查询需要多次尝试。如果第一次尝试时没有找到有用的结果，再试一遍。</li>
<li>尝试使用在一开始搜索时发现的网页上发现的关键字，使搜索引擎在后续搜索中转到更好的资源。</li>
<li>复制粘贴错误消息作为搜索字词。这样会出现错误解释性信息和潜在原因。错误消息可能包括你所写的特定行号引用。只在搜索中包含这些信息之前的错误消息部分。</li>
<li>如果找不到问题答案，自己提出问题！StackOverflow 等社区有一些行为规则，如果你要加入该社区，必须了解这些规则，但是别因为这些规则而不愿意使用这些资源。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410161009668.png"></p>
<p>虽然有很多关于编程的在线资源，但是并非所有资源都是同等水平的。下面的资源列表按照大致的可靠性顺序排序。</p>
<ol>
<li><strong><a href="https://docs.python.org/3/tutorial/">Python 教程</a></strong> - 这部分官方文档给出了 Python 的语法和标准库。它会举例讲解，并且采用的语言比主要文档的要浅显易懂。确保阅读该文档的 Python 3 版本！</li>
<li><strong><a href="https://docs.python.org/3/index.html">Python 语言和库参考资料</a></strong> - 语言参考资料和库参考资料比教程更具技术性，但肯定是可靠的信息来源。当你越来越熟悉 Python 时，应该更频繁地使用这些资源。</li>
<li><strong>第三方库文档</strong> - 第三方库会在自己的网站上发布文档，通常发布于 <a href="https://readthedocs.org/">https://readthedocs.org/</a> 。你可以根据文档质量判断第三方库的质量。如果开发者没有时间编写好的文档，很可能也没时间完善库。</li>
<li><strong>非常专业的网站和博客</strong> - 前面的资源都是主要资源，他们是编写相应代码的同一作者编写的文档。主要资源是最可靠的资源。次要资源也是非常宝贵的资源。次要资源比较麻烦的是需要判断资源的可信度。<a href="https://doughellmann.com/blog/">Doug Hellmann</a> 等作者和 <a href="http://eli.thegreenplace.net/">Eli Bendersky</a> 等开发者的网站很棒。不出名作者的博客可能很棒，也可能很糟糕。</li>
<li><strong><a href="http://stackoverflow.com/">StackOverflow</a></strong> - 这个问答网站有很多用户访问，因此很有可能有人之前提过相关的问题，并且有人回答了！但是，答案是大家自愿提供的，质量参差不齐。在将解决方案应用到你的程序中之前，始终先理解解决方案。如果答案只有一行，没有解释，则值得怀疑。你可以在此网站上查找关于你的问题的更多信息，或发现替代性搜索字词。</li>
<li><strong>Bug 跟踪器</strong> - 有时候，你可能会遇到非常罕见的问题或者非常新的问题，没有人在 StackOverflow 上提过。例如，你可能会在 GitHub 上的 bug 报告中找到关于你的错误的信息。这些 bug 报告很有用，但是你可能需要自己开展一些工程方面的研究，才能解决问题。</li>
<li><strong>随机网络论坛</strong> - 有时候，搜索结果可能会生成一些自 2004 年左右就不再活跃的论坛。如果这些资源是唯一解决你的问题的资源，那么你应该重新思考下寻找解决方案的方式。</li>
</ol>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>再看看这里的Anaconda和Jupyterbook</p>
<ol>
<li>Anaconda发行版中的可用软件包<code>conda</code>专注于数据科学，而这些软件包<code>pip</code>通常用于一般用途。Conda安装预编译的软件包。例如，Anaconda发行版随附使用<a href="https://docs.continuum.io/mkl-optimizations/">MKL库</a>编译的Numpy，Scipy和Scikit-learn ，从而加快了各种数学运算的速度。<strong>但是，有时候，您可能需要除Anaconda发行版中列出的软件包以外的软件包。</strong></li>
<li>Pip可以安装Python软件包和非Python软件包。Pip可以安装<a href="https://pypi.org/">Python软件包索引</a>（PyPI）上列出的任何软件包。</li>
</ol>
<p>conda list 列出安装的所有包</p>
<p>conda env list 检查环境列表</p>
<p>为了避免以后出现错误，最好在默认环境中更新所有软件包。打开终端/ Anaconda Prompt应用程序。在提示符下，运行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">conda upgrade conda
conda upgrade --all #千万不要！！！！！！！不然会带来一堆兼容性错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>并在询问是否要安装软件包时回答是。最初安装时附带的软件包往往已过时，因此立即更新它们可以防止将来的软件过时错误。</p>
<p>新环境里最好安装个pip</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Check if pip is already installed, by running this command on Terminal/Anaconda Prompt</span>
pip --version

<span class="token comment"># Once you have conda installed, run the command below on Terminal/Anaconda Prompt</span>
conda <span class="token function">install</span> pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h2><p>您可以同时安装多个软件包。例如，下面的命令将同时安装所有三个软件包。</p>
<pre class="line-numbers language-none"><code class="language-none">conda install numpy scipy pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以通过添加版本号（例如）来指定所需的软件包版本<code>conda install numpy=1.10</code>。</p>
<p>Conda还会自动为您安装依赖项。例如<code>scipy</code>使用和要求<code>numpy</code>。如果仅安装<code>scipy</code>（<code>conda install scipy</code>），<code>numpy</code>则尚未安装的Conda也将安装。</p>
<pre class="line-numbers language-none"><code class="language-none">conda remove PACKAGE_NAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">conda update package_name
conda update --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果您不知道要查找的软件包的确切名称，可以尝试使用进行搜索<code>conda search *SEARCH_TERM*</code>。例如，我知道我想安装<a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>，但是我不确定确切的软件包名称。因此，我尝试<code>conda search *beautifulsoup*</code>。请注意，<code>*</code>在运行conda命令之前，您的shell可能会扩展通配符。要解决此问题，请将搜索字符串用单引号或双引号引起来，例如<code>conda search &#39;*beautifulsoup*&#39;</code>。</p>
<p>请参阅《<a href="https://conda.io/projects/conda/en/latest/commands.html">Conda命令参考指南》</a>以了解有关conda命令的更多信息</p>
<h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><pre class="line-numbers language-none"><code class="language-none">conda create -n env_name [python&#x3D;X.X] [LIST_OF_PACKAGES]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此处<code>-n env_name</code>设置环境<code>-n</code>名称（用于名称），并且<code>LIST_OF_PACKAGES</code>是要在环境中安装的软件包的列表。如果要安装要安装的特定版本的Python，例如3.7，请使用<code>python=3.7</code>。例如，要创建一个以<code>my_env</code>Python 3.7命名的环境，并在其中安装NumPy和Keras，请使用以下命令。</p>
<pre class="line-numbers language-none"><code class="language-none">conda create -n my_env python&#x3D;3.7 numpy Keras<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>激活</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">activate my_env
deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>保存和加载环境</strong></p>
<p>一个真正有用的功能是共享环境，以便其他人可以使用正确的版本安装代码中使用的所有软件包。让我们使用以下命令查看所有软件包名称，包括当前环境中存在的Python版本：</p>
<pre class="line-numbers language-none"><code class="language-none">conda env export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/conda-env-export.png" alt="img"></p>
<p>导出环境打印到终端</p>
<p>在上图中，您可以看到环境的名称，并且列出了所有依赖项（<em>以及版本</em>）。您可以将上述所有信息保存到<a href="http://www.yaml.org/">YAML</a>文件中<code>environment.yaml</code>，然后再通过GitHub或其他方式与其他用户共享此文件。该文件将在当前目录中创建（或覆盖）。</p>
<pre class="line-numbers language-none"><code class="language-none">conda env export &gt; environment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的export命令的第二部分，<code>&gt; environment.yaml</code>将导出的文本写入<code>environment.yaml</code>。现在可以使用Github存储库（或任何其他方式）共享此文件，其他人将能够创建与项目所用的环境相同的环境。</p>
<hr>
<p>对于不使用conda的用户，您可能希望共享当前环境中安装的软件包列表。您可以使用以下<code>pip</code>命令生成此类列表作为<code>requirements.txt</code>文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip freeze <span class="token operator">></span> requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>稍后，您可以<code>requirements.txt</code>通过Github与其他用户共享此文件。用户（或您自己）切换到另一个环境后，可以使用以下命令安装<code>requirements.txt</code>文件中提到的所有软件包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>您可以<a href="https://pip.pypa.io/en/stable/reference/pip_freeze/">在此处了解更多</a>有关使用<code>pip</code>而不是的信息<code>conda</code>。这将使人们更容易为您的代码安装所有依赖项</p>
<p><strong>创建环境</strong></p>
<p>要从环境文件创建环境，请使用以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">conda env create -f environment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令将创建一个新环境，其名称与中列出的相同<code>environment.yaml</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">conda env list &#x2F;&#x2F;检查现有的环境<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果有不再使用的环境，请使用下面的命令删除指定的环境（此处名为<code>env_name</code>）。</p>
<pre class="line-numbers language-none"><code class="language-none">conda env remove -n env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<ul>
<li>要了解有关conda及其在Python生态系统中的适用性的更多信息，请查看Jake Vanderplas的这篇文章：<a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/">Conda的神话和误解</a>。</li>
<li>这是<a href="https://docs.conda.io/projects/conda/en/latest/glossary.html">conda词汇表文档，</a>供您参考。</li>
</ul>
<h1 id="Jupyter"><a href="#Jupyter" class="headerlink" title="Jupyter"></a>Jupyter</h1><p>一直想学来着，这个课程也太好了吧！</p>
<p>jupyter notebook是一个Web应用程序，可让您将说明性文本，数学方程式，代码和可视化结合在一个易于共享的文档中。</p>
<p>非常适合数据处理，可以执行部分代码，并查看上下文信息等</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Notebooks are a form of <a href="http://www.literateprogramming.com/">literate programming</a> proposed by Donald Knuth in 1984. With literate programming, the documentation is written as a narrative alongside the code instead of sitting off by its own. In Donald Knuth’s words,</p>
<blockquote>
<p>Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.</p>
</blockquote>
<p>After all, code is written for humans, not for computers. Notebooks provide exactly this capability. You are able to write documentation as narrative text, along with code. This is not only useful for the people reading your notebooks, but for your future self coming back to the analysis.</p>
<p>Just a small aside: recently, this idea of literate programming has been extended to a whole programming language, <a href="http://www.witheve.com/">Eve</a>.</p>
<p>Jupyter笔记本源自Fernando Perez发起的<a href="https://ipython.org/">IPython项目</a>。IPython是一个交互式shell，类似于普通的Python shell，但具有诸如语法突出显示和代码之类补全的强大功能。最初，笔记本通过将消息从Web应用程序（您在浏览器中看到的笔记本）发送到IPython内核（在后台运行的IPython应用程序）来工作。内核执行了代码，然后将其发送回笔记本。当前的架构与此类似，如下所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/notebook-components.png" alt="img"></p>
<p>中心点是笔记本服务器。您通过浏览器连接到服务器，并且笔记本呈现为Web应用程序。您在Web应用程序中编写的代码通过服务器发送到内核。内核运行代码并将其发送回服务器，然后所有输出将在浏览器中呈现。保存笔记本时，它将作为带有<code>.ipynb</code>文件扩展名的JSON文件写入服务器。</p>
<p>该体系结构的很大一部分是内核不需要运行Python。由于笔记本和内核是分开的，因此可以在它们之间发送任何语言的代码。例如，两个较早的非Python内核分别用于<a href="https://www.r-project.org/">R</a>和<a href="http://julialang.org/">Julia</a>语言。对于R内核，用R编写的代码将被发送到R内核并在其中执行，这与在Python内核上运行的Python代码完全相同。IPython笔记本被重命名，因为笔记本变得与语言无关。新名称<strong>Ju pyt er</strong>来自<strong>Ju</strong> lia，<strong>Pyt</strong> hon和<strong>R的组合</strong>。如果您有兴趣，这里<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">是可用内核</a>的<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">列表</a>。</p>
<p>另一个好处是服务器可以在任何地方运行并可以通过Internet访问。通常，您将在存储所有数据和笔记本文件的自己的计算机上运行服务器。但是，您也可以在远程计算机或云实例（例如Amazon的EC2）上<a href="http://jupyter-notebook.readthedocs.io/en/latest/public_server.html">设置服务器</a>。然后，您可以从世界任何地方在浏览器中访问笔记本。</p>
<p>可以同时启动多个笔记本服务器，这会在8888默认端口后继续创建</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>您应该考虑安装Notebook Conda软件包以帮助管理您的环境。运行以下终端命令：</p>
<pre class="line-numbers language-none"><code class="language-none">conda install nb_conda

conda install -c conda-forge jupyter_contrib_nbextensions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>成功安装<code>nb_conda</code>软件包后，如果您在conda环境中运行笔记本服务器，则还可以访问下面显示的“ Conda”选项卡。在这里，您可以从Jupyter内部管理您的环境。您可以创建新环境，安装软件包，更新软件包，导出环境等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410125054498.png"></p>
<p>此外，<code>nb_conda</code>安装后，选择内核时，您将可以访问任何conda环境。例如，下图显示了在具有几种不同conda环境的计算机上创建新笔记本的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410125313617.png"></p>
<p><strong>关闭前记得保存</strong></p>
<p>您可以通过标记服务器主页上笔记本旁边的复选框并单击“关闭”来关闭各个笔记本。不过，在执行此操作之前，请确保已保存您的工作！自上次保存以来所做的任何更改都将丢失。您还需要在下次运行笔记本时重新运行代码。</p>
<p>您可以通过在终端中按两次Control + C来关闭整个服务器。同样，这将立即关闭所有正在运行的笔记本，因此请确保您的工作已保存！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/server-shutdown.png" alt="img"></p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>先新建（选择一个内核）来创建一个notebook</p>
<p>上面的命令将在名为的新浏览器选项卡中创建一个新笔记本<code>Untitled.ipynb</code></p>
<p><strong>工具栏</strong></p>
<p>简单明了，真不戳</p>
<p>小键盘是命令面板。这将显示一个带有搜索栏的面板，您可以在其中搜索各种命令。这对于加速工作流程非常有帮助，因为您无需使用鼠标在菜单中四处搜索。只需打开命令面板，然后输入您要执行的操作即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410130030588.png"></p>
<p>选项栏</p>
<p>右边是内核类型（在我的情况下为Python 3），旁边是一个小圆圈。当内核运行单元时，它将填充。对于大多数快速运行的操作，它不会填充。这是一个小指示器，可以让您知道更长运行的代码实际上正在运行。</p>
<p>连同工具栏中的“保存”按钮一起，笔记本会定期自动保存。标题右侧会显示最近保存的内容。您可以保存按钮，或者按与手动保存<code>escape</code>，然后按<code>s</code>。<code>escape</code>更改为命令模式，然后<code>s</code>是“保存”的快捷方式。稍后将介绍命令模式和键盘快捷键。</p>
<p><strong>存储</strong></p>
<p>在“文件”菜单中，您可以下载多种格式的笔记本。您通常会希望将其下载为HTML文件，以便与不使用Jupyter的其他人共享。另外，您可以将笔记本作为普通的Python文件下载，所有代码都将正常运行。 The <a href="https://daringfireball.net/projects/markdown/">Markdown</a> and <a href="http://docutils.sourceforge.net/rst.html">reST</a> formats are great for using notebooks in blogs or documentation.</p>
<p><strong>导入本地</strong></p>
<p>File -&gt; open 选择合适的<code>.ipynb</code>文件</p>
<p>或者直接upload，然后在文件导航里面查找你需要的文件</p>
<p>这里有一个markdown的<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">备忘单</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>又得学新的快捷键卧槽</p>
<p>首先，在编辑模式和命令模式之间切换。 编辑模式允许您键入单元格，而命令模式将使用按键来执行命令，例如创建新单元格和打开命令面板。 当您选择一个单元格时，您可以通过该单元格周围的框的颜色来判断当前正在使用哪种模式。 在编辑模式下，方框和左粗框显示为绿色。 在命令模式下，它们显示为蓝色。 同样在编辑模式下，您应该在单元格本身中看到一个光标。</p>
<p>默认情况下，当您创建一个新的单元格或移动到下一个单元格时，您将处于命令模式。 要进入编辑模式，请按<strong>Enter</strong> / Return。 要从编辑模式返回到命令模式，请按<strong>Escape键</strong>。</p>
<p>练习：单击此单元格，然后按<strong>Enter + Shift进入下一个单元格</strong>。 在编辑和命令模式之间切换几次。</p>
<p>在命令模式按下H可以打开帮助菜单<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410131817701.png"></p>
<hr>
<p><strong>常用的快捷键</strong></p>
<p>A 创建新单元格above当前单元格</p>
<p>B 创建新单元格below当前单元格</p>
<p>在markdown 和 code之间进行转换</p>
<p>markdown -&gt; code  <strong>Y</strong></p>
<p>code -&gt; markdown  <strong>M</strong></p>
<p>L 是显示行号d</p>
<p>双击D 可以删除单元格，Z撤销删除</p>
<p>S 保存！</p>
<p>最强的是P</p>
<p>打开万能的控制栏</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210410132647354.png"></p>
<h2 id="魔术关键字"><a href="#魔术关键字" class="headerlink" title="*魔术关键字"></a>*魔术关键字</h2><p>Magic Keywords</p>
<p>魔术关键字是特殊命令，您可以在单元格中运行这些命令，以使您可以控制笔记本电脑本身或执行系统调用（例如更改目录）。例如，您可以使用设置matplotlib以在笔记本中进行交互工作<code>%matplotlib</code>。</p>
<p>魔术命令前面分别带有针对行魔术和单元魔术的一个或两个百分号（<code>%</code>或<code>%%</code>）。线魔术仅适用于在其上写入了魔术命令的行，而单元格魔术适用于整个单元。</p>
<p><strong>注意：</strong>这些魔术关键字特定于普通的Python内核。如果您使用的是其他内核，那么这些内核很可能无法正常工作。</p>
<p>如果您想计时整个单元需要多长时间，可以这样使用<code>%%timeit</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/magic-timeit2.png" alt="img"></p>
<p>以后学学。。。</p>
<p>在笔记本中嵌入可视化</p>
<p>如前所述，笔记本使您可以将图像以及文本和代码嵌入其中。当您使用<code>matplotlib</code>或其他绘图程序包创建可视化效果时，此功能最为有用。您可以使用<code>%matplotlib</code>设置<code>matplotlib</code>为在笔记本中进行交互使用。默认情况下，图形将在其自己的窗口中呈现。但是，您可以将参数传递给命令以选择特定的<a href="http://matplotlib.org/faq/usage_faq.html#what-is-a-backend">“后端”</a>，即渲染图像的软件。要直接在笔记本中绘制图形，您应该在命令中使用嵌入式后端<code>%matplotlib inline</code>。</p>
<blockquote>
<p><strong>提示：</strong>在高分辨率屏幕（例如Retina显示屏）上，笔记本计算机中的默认图像可能看起来模糊。使用<code>%config InlineBackend.figure_format = &#39;retina&#39;</code>after<code>%matplotlib inline</code>渲染更高分辨率的图像。</p>
</blockquote>
<p><img src="https://video.udacity-data.com/topher/2016/November/5833867f_magic-matplotlib/magic-matplotlib.png" alt="img"></p>
<p>在笔记本中调试</p>
<p>使用Python内核，您可以使用magic命令打开交互式调试器<code>%pdb</code>。导致错误时，您将能够检查当前名称空间中的变量。</p>
<p><img src="https://video.udacity-data.com/topher/2016/November/58337eac_magic-pdb/magic-pdb.png" alt="img"></p>
<p>在笔记本中调试</p>
<p>在上面可以看到我试图总结一个给出错误的字符串。调试器会引发错误，并提示您检查代码。</p>
<p><code>pdb</code>在<a href="https://docs.python.org/3/library/pdb.html">文档中</a>了解更多信息。要退出调试器，只需<code>q</code>在提示中输入即可。</p>
<p>更多阅读</p>
<p>还有很多其他魔术命令，我只涉及了一些您最常使用的命令。要了解有关它们的更多信息，<a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">这</a>是所有可用的魔术命令<a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">的列表</a>。</p>
<h2 id="转换笔记本"><a href="#转换笔记本" class="headerlink" title="转换笔记本"></a>转换笔记本</h2><p>Notebooks are just big <a href="http://www.json.org/">JSON</a> files with the extension <code>.ipynb</code>.</p>
<p>由于笔记本是JSON，因此很容易将它们转换为其他格式。Jupyter附带有一个实用程序，<code>nbconvert</code>用于将其转换为HTML，Markdown，幻灯片等。将给定<code>mynotebook.ipynb</code>文件转换为另一个FORMAT的一般语法为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert --to FORMAT mynotebook.ipynb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当前支持的输出<code>FORMAT</code>可以是以下任意一种（忽略大小写）：</p>
<ol>
<li>HTML,</li>
<li>LaTeX,</li>
<li>PDF,</li>
<li>WebPDF,</li>
<li>Reveal.js HTML slideshow,</li>
<li>Markdown,</li>
<li>Ascii,</li>
<li>reStructuredText,</li>
<li>executable script,</li>
<li>notebook.</li>
</ol>
<p>For example, to convert a notebook to an HTML file, in your terminal use</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Install the package below, if not already</span>
pip <span class="token function">install</span> nbconvert
jupyter nbconvert --to html mynotebook.ipynb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>注</strong>-如果您希望在conda中安装Anaconda发行版中<strong>没有的</strong>任何软件包（例如Airbase软件包），请使用<code>pip install airbase</code>，而不是<code>conda install airbase</code>。</p>
</blockquote>
<p><strong>转换为HTML可以与不使用笔记本的其他人共享您的笔记本。Markdown非常适合在博客和其他接受Markdown格式的文本编辑器中添加笔记本。</strong></p>
<p>与往常一样，从<a href="https://nbconvert.readthedocs.io/en/latest/usage.html">文档中</a>了解更多<code>nbconvert</code>信息。</p>
<h2 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h2><p>幻灯片是像普通笔记本一样在笔记本中创建的，但是您需要指定哪些单元格是幻灯片以及该单元格将是幻灯片的类型。在菜单栏中，单击“视图”&gt;“单元格工具栏”&gt;“幻灯片放映”以在每个单元格上弹出幻灯片单元格菜单。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/slides-cell-toolbar-menu.png" alt="img"></p>
<p>打开单元格的幻灯片工具栏</p>
<p>这将在每个单元格上显示一个菜单下拉菜单，使您可以选择该单元格在幻灯片中的显示方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/slides-choose-slide-type.png" alt="img"></p>
<p><strong>Slides</strong> are full slides that you move through left to right. <strong>Sub-slides</strong> show up in the slideshow by pressing up or down. <strong>Fragments</strong> are hidden at first, then appear with a button press. You can skip cells in the slideshow with <strong>Skip</strong> and <strong>Notes</strong> leaves the cell as speaker notes.</p>
<p>运行幻灯片</p>
<p>要从笔记本文件创建幻灯片，您需要使用<code>nbconvert</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert notebook.ipynb --to slides<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这只是将笔记本转换为幻灯片所需的文件，但是您需要将其与HTTP服务器一起使用才能实际查看演示文稿。</p>
<p>要转换并立即看到它，请使用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jupyter nbconvert notebook.ipynb --to slides --post serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这将在您的浏览器中打开幻灯片放映，以便您进行演示。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python（</tag>
      </tags>
  </entry>
  <entry>
    <title>introduction-to-Network（已完结）</title>
    <url>/2021/03/14/introduction-to-Networks/</url>
    <content><![CDATA[<p>[toc]</p>
<p>因为我发现学这个课老是断断续续的，每次捡起来超级麻烦，所以趁这次来个大复习，把一些该有的知识点直接记下来好了</p>
<h1 id="当今网络"><a href="#当今网络" class="headerlink" title="当今网络"></a>当今网络</h1><h2 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h2><p>术语“主机”特指网络上为通信目的而分配了一个数字的设备。这个数字用来标识特定网络中的主机。这个数字称为互联网协议 (IP) 地址。IP 地址标识主机和主机所连接的网络。</p>
<p>服务器是装有特殊软件，可以为网络上其他终端设备提供信息（例如电子邮件或网页）的计算机。每项服务都需要单独的服务器软件。例如，服务器必须安装 Web 服务器软件才能为网络提供 Web 服务。安装有服务器软件的计算机可以同时向多个不同客户端提供服务。</p>
<p>客户端和服务器软件通常运行在单独的服务器上，但一台计算机也可以同时兼任两个角色。在小企业和家庭中，许多计算机在网络中既是服务器又是客户端。这种网络称为对等网络。</p>
<ol>
<li>终端设备是指通过网络传输的消息的<strong>来源或目的地</strong>。</li>
<li>中间设备可以将单个终端连接到网络中。它们可以将多个独立的网络连接起来，形成互联网络。这些中间设备提供连接并确保数据在网络中传输。</li>
<li>现代网络主要使用三种介质来连接设备：</li>
</ol>
<ul>
<li><strong>金属线电缆</strong> - 数据被编码为电脉冲</li>
<li><strong>玻璃或塑料光纤（光缆）</strong> - 数据被编码为光脉冲</li>
<li><strong>无线传输</strong> - 数据是通过调制特定频率的电磁波进行编码的。</li>
</ul>
<p>常见表示方法：</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314161643916.png"></p>
<p>除了这些表示之外，还使用专门的术语来描述这些设备和介质是如何相互连接的:</p>
<ul>
<li><strong>网络接口卡 (NIC)</strong> - 将设备从物理上连接到网络。</li>
<li><strong>物理端口</strong>（physical port） - 网络设备上的接口或插口，介质通过它连接到终端设备或其他网络设备。</li>
<li><strong>接口</strong>（interface） - <strong>网络设备上连接到独立网络的专用端口</strong>。由于路由器连接了不同的网络，路由器上的端口称为网络接口。</li>
</ul>
<p>但是port和interface经常混用</p>
<p>几个类型：</p>
<p>内部网，外联网，Intranets and Extranets</p>
<p>LAN WAN通常提供 LAN 之间的较慢链路。</p>
<p>互联网不属于任何个人或团体。要确保通过这种多元化基础设施有效通信，需要采用统一的公认技术和标准，也需要众多网络管理机构相互协作。为了维护互联网协议和进程的结构和标准化，人们建立了许多组织。</p>
<h2 id="常用连接技术"><a href="#常用连接技术" class="headerlink" title="常用连接技术"></a>常用连接技术</h2><p>家庭和小型办公室</p>
<ul>
<li><strong>有线电视</strong> （<strong>Cable</strong>）- 通常由有线电视服务提供商提供，互联网数据信号在输送有线电视信号的同一电缆上进行传输。它提供了高带宽、高可用性和始终在线的互联网连接。</li>
<li><strong>DSL</strong> - 数字用户线也可提供高带宽、高可用性和始终在线的互联网连接。DSL 通过电话线路运行。通常小型办公室和家庭办公室用户会选择使用非对称 DSL (ADSL)，这种方式的特点是下载速度高于上传速度。</li>
<li><strong>蜂窝网</strong>（<strong>Cellular</strong>） - 蜂窝网互联网接入使用手机网络进行连接。只要您能收到蜂窝网信号，就能获得蜂窝网互联网接入。性能会受手机功能和手机基站的限制。</li>
<li><strong>卫星</strong>（<strong>Satellite</strong>） - 对于根本没有互联网连接的地方来说，获得卫星互联网访问非常有用。卫星天线要求有到卫星的清晰视线。</li>
<li><strong>拨号电话</strong>（<strong>Dial-up Telephone</strong>） - 使用电话线和调制解调器，费用相对较低。拨号调制解调器连接提供的低带宽不足以用于大型数据传输，但对旅行过程中的移动访问非常有用。</li>
</ul>
<p>企业</p>
<ul>
<li><strong>专用租用线路</strong>（<strong>Dedicated Leased Line</strong> ） - 租用线路是服务提供商网络内连接地理位置分散的办公室的保留电路，提供个人语音和/或数据网络。电路按月或按年租用。</li>
<li><strong>城域以太网</strong>（<strong>Metro Ethernet</strong>） -有时被称为以太网 WAN. 在本模块中，我们把它称为城域以太网。城域以太网将 LAN 访问技术扩展到 WAN 中。以太网是一种 LAN 技术，您将在后面的模块中学习。</li>
<li><strong>DSL</strong>（<strong>Business DSL</strong>） - 企业 DSL 提供各种格式。一种常见的选择是对称数字用户线路 (SDSL)，它类似于 DSL 的普通用户版本，但是提供相同的上传和下载速度。</li>
<li><strong>卫星</strong> – 当有线解决方案不可用时，卫星服务可以提供连接。</li>
</ul>
<p>今天，独立的数据、电话和视频网络融合在了一起。与专用网络不同，融合网络能够通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频。此网络基础设施采用一组相同的规则、协议和实施标准。融合数据网络在一个网络中传送多种服务。</p>
<h2 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h2><p>容错能力-提供冗余的多条路径</p>
<p>可拓展性-设计人员可以遵循广为接受的标准和协议</p>
<p>服务质量 (QoS)-通过各种协议和优先级</p>
<p>网络安全-设备安全，网络安全：</p>
<ul>
<li><p><strong>机密性</strong> - 数据机密性意味着只有预定和授权收件人可以访问并读取数据。</p>
</li>
<li><p><strong>完整性</strong> - 数据完整性表示保证信息在从源到目的地的传输过程中不会被更改。</p>
</li>
<li><p><strong>可用性</strong> - 数据可用性表示保证授权用户及时可靠地访问数据服务。</p>
</li>
<li><p><strong>病毒、蠕虫和特洛伊木马</strong> <strong>Viruses, worms, and Trojan horses</strong>- 这些包括在用户设备上运行的恶意软件或代码。</p>
</li>
<li><p><strong>间谍软件和广告软件</strong> <strong>Spyware and adware</strong>-这些是安装在用户设备上的软件类型。这些软件会秘密收集有关用户的信息。</p>
</li>
<li><p><strong>零日攻击（也称零小时攻击）****Zero-day attacks</strong> - 在出现漏洞的第一天发起的攻击。</p>
</li>
<li><p><strong>威胁发起者攻击</strong> <strong>Threat actor attacks</strong>-恶意人员攻击用户设备或网络资源。</p>
</li>
<li><p><strong>拒绝服务攻击</strong> <strong>Denial of service attacks</strong>- 使网络设备上的应用和进程减缓或崩溃的攻击。</p>
</li>
<li><p><strong>数据拦截和盗窃****Data interception and theft</strong> - 通过公司网络捕获私人信息的攻击。</p>
</li>
<li><p><strong>身份盗窃****Identity theft</strong> - 窃取用户的登录凭证来访问私人数据的攻击。</p>
</li>
</ul>
<h2 id="一些趋势"><a href="#一些趋势" class="headerlink" title="一些趋势"></a>一些趋势</h2><p>BYOD 意味着设备由任何使用者在任意地点使用。</p>
<p>云计算</p>
<p>智能家庭技术（物联网）</p>
<p>电力网：</p>
<p>使用标准电源适配器，只要有电源插座，设备就可以连接到 LAN。无需安装数据线，也几乎不需要额外的电力。通过使用供电的同一线路，电力线网络通过按一定频率发送数据来发送信息。</p>
<p>当无线接入点无法到达家里的所有设备时，电力线网络特别有用。电力线网络不会取代数据网络中的专用布线。但是，当有线数据网络或无线通信不可行时，电力线网络可以备用。</p>
<p>无线互联网服务提供商 (WISP) 是使用类似家庭无线局域网 (WLAN) 的无线技术</p>
<h1 id="配置交换机-终端"><a href="#配置交换机-终端" class="headerlink" title="配置交换机/终端"></a>配置交换机/终端</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163007230.png"></p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>默认情况下，交换机将转发流量，无需配置即可工作。连接到同一新交换机的两个已配置了的主机能够进行通信。</p>
<p>无论新交换机的默认特性如何，都应配置并保护所有交换机。</p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>控制台 (Console)</strong></td>
<td align="left">这是一种物理管理端口，可通过该端口对思科设备进行带外访问。带外访问是指通过仅用于设备维护的专用管理通道进行访问。使用控制台端口的优势在于，<strong>即使没有配置任何网络服务，也可以访问设备</strong>，例如执行初始配置时。控制台连接需要运行终端仿真软件的计算机和用于连接设备的特殊控制台电缆。</td>
</tr>
<tr>
<td align="left"><strong>安全外壳(SSH)</strong></td>
<td align="left">SSH 是一种带内且被推荐的方法，它使用虚拟接口<strong>通过网络远程建立安全的 CLI连接</strong>。不同于控制台连接，SSH 连接需要设备上具有有效的网络服务，<strong>包括配置了地址的有效接口</strong>。大部分思科 IOS 版本配备了 SSH 服务器和 SSH 客户端，可用于与其他设备建立 SSH 会话。</td>
</tr>
<tr>
<td align="left"><strong>Telnet</strong></td>
<td align="left">Telnet 使用虚拟接口通过网络远程建立 CLI 会话，这种带内方法并不安全。与 SSH 不同，Telnet 不提供安全的加密连接，只能在实验室环境中使用。用户身份验证、密码和命令通过网络以明文形式发送。最好的做法是使用 SSH 而不是 Telnet。思科 IOS 包括 Telnet 服务器和 Telnet 客户端。</td>
</tr>
</tbody></table>
<p><strong>注意:</strong> 某些设备，比如路由器，还可以支持传统辅助端口，这种辅助端口可使用调制解调器通过电话连接远程建立 CLI 会话。类似于控制台连接，AUX 端口也是带外连接，且不需要配置或提供网络服务。</p>
<h2 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h2><p>作为一项安全功能，思科 IOS 软件将管理访问分为以下两种命令模式：</p>
<ul>
<li><strong>用户 EXEC 模式</strong>（user） - 该模式功能有限，但可用于有效执行基本操作。它只允许有限数量的基本监控命令，不允许执行任何可能改变设备配置的命令。用户 EXEC 模式由采用 &gt; 符号结尾的 CLI 提示符标识。</li>
<li><strong>特权 EXEC 模式</strong>（privileged） - 要执行配置命令，网络管理员必须访问特权 EXEC 模式。较<strong>高级别的配置模式，比如全局配置模式，只能通过特权 EXEC 模式访问</strong>。特权 EXEC 模式由采用# 符号结尾的提示符标识。</li>
</ul>
<p>要配置设备，用户必须进入全局配置模式。</p>
<p>在全局配置模式下， CLI 配置所做的更改将影响整个设备的运行。全局配置模式由在设备名称之后加(config)#结尾的提示符标识，比如Switch(config)#。</p>
<p>访问全局配置模式之后才能访问其他具体的配置模式。在全局配置模式下，用户可以进入不同的子配置模式。其中的每种模式可以用于配置 IOS 设备的特定部分或特定功能。两个常见的子配置模式包括：</p>
<ul>
<li><strong>线路配置模式</strong> - 用于配置<strong>控制台</strong>、SSH、Telnet 或 AUX 访问。</li>
<li><strong>接口配置模式</strong> - 用于配置交换机端口或路由器网络接口。</li>
</ul>
<p>当使用 CLI 时，每种模式由该模式独有的命令提示符来标识。默认情况下，每个提示符都以设备名称开头。命令提示符中设备名称后的部分用于表明模式。</p>
<p>例如，线路配置模式的默认提示符是 <strong>Switch(config-line)#</strong> </p>
<p>默认的接口配置模式提示符是 **Switch(config-if)#**。interface</p>
<ul>
<li><strong>startup-config(启动配置文件)</strong> -存储在 NVRAM 中的配置文件。它包含在启动时或重启时用到的所有命令。当设备断电后，其中的内容不会消失。</li>
<li><strong>running-config(运行配置文件)</strong> -存储在随机存取存储器（RAM）中。它反映了当前的配置。修改运行配置会立即影响思科设备的运行。RAM 是易失性存储器。如果设备断电或重新启动，则它会丢失所有内容。</li>
</ul>
<h1 id="学习命令"><a href="#学习命令" class="headerlink" title="学习命令"></a>学习命令</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314163957083.png"></p>
<table>
<thead>
<tr>
<th align="left"><strong>约定</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>粗体</strong></td>
<td align="left">粗体文本表示您需要原样输入的命令和关键字， 如显示的那样。</td>
</tr>
<tr>
<td align="left"><em>斜体</em></td>
<td align="left">斜体文本指示由您提供值的参数。</td>
</tr>
<tr>
<td align="left"><strong>[<strong>x</strong>]</strong></td>
<td align="left">方括号表示可选元素（关键字或参数）。</td>
</tr>
<tr>
<td align="left"><strong>{<strong>x</strong>}</strong></td>
<td align="left">大括号表示必需元素（关键字或参数）。</td>
</tr>
<tr>
<td align="left">**[**x **{**y <strong>|</strong> z <strong>}]</strong></td>
<td align="left">方括号中的大括号和垂直线表示 可选元素中的必填选项。空格用于清楚地描述 命令的各个部分。</td>
</tr>
</tbody></table>
<p>enable / disable</p>
<p>configure terminal / exit  (子配置—&gt;上一级)</p>
<p>end / Ctrl+Z (任何子配置-&gt;特权)</p>
<p>子配置模式间可以随意转换：</p>
<p><strong>line console 0</strong></p>
<p><strong>interface FastEthernet 0/1</strong></p>
<p><strong>line vty 0 15</strong> 两个数字说明是0-15一起设置</p>
<p>（注意全是小写，草）</p>
<p><em><strong>用户模式只能查看配置，且只能查看部分配置，不能配置交换机；特权模式只能查看配置，且只能查看部分配置，不能配置交换机；全局模式可以修改配置，且对全局生效，但是默认不能查看；而端口模式所做的配置都是针对接口所设定的。</strong></em></p>
<h3 id="用户特权"><a href="#用户特权" class="headerlink" title="用户特权"></a>用户特权</h3><p>show running-config/startup-config</p>
<p><strong>copy running-config startup-config</strong>。</p>
<p>reload 清除未保存的running-config  但在一段很短的时间内设备将会离线，导致网络中断。</p>
<p>erase start 删除启动设置，之后需重新加载设备来恢复出厂</p>
<p>show + 子模式 仅查看子模式的信息</p>
<p>show arp 交换机等设备显示MAC地址信息</p>
<p>show mac address-table 查看mac地址表</p>
<p>clear mac address-table dynamic 清除mac地址表</p>
<p><strong>show ip arp</strong> 查看arp表</p>
<p>show ipv6 neighbors 检查路由器是否发现了邻居</p>
<p>clear ipv6 neighbors</p>
<p>show flash 查看闪存</p>
<p>show ip(ipv6) interface brief 检查接口的正确数量和标识</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">show ip                                              interface brief<br />show ipv6 interface brief</td>
<td align="left">所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</td>
</tr>
<tr>
<td align="left">show ip route<br />show ipv6 route</td>
<td align="left">显示存储在 RAM 中的 IP 路由表的内容。也可以检验连接性</td>
</tr>
<tr>
<td align="left">show interfaces</td>
<td align="left">显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</td>
</tr>
<tr>
<td align="left">show ip interface(后面可以加特定的线路)</td>
<td align="left">显示路由器上所有接口的 IPv4 统计信息。</td>
</tr>
<tr>
<td align="left">show ipv6 interface</td>
<td align="left">显示路由器上所有接口的 IPv6 统计信息。</td>
</tr>
</tbody></table>
<h3 id="全局指令"><a href="#全局指令" class="headerlink" title="全局指令"></a>全局指令</h3><p>hostname name 主机名字仅使用字母、数字和破折号</p>
<p>no hostname 清空主机名字</p>
<p>enable secret (password)  保护特权访问</p>
<p><strong>service password-encryption</strong>（全局配置指令+加密所有）</p>
<p>security passwords min-length 8 指定密码的最小长度为8</p>
<p>login block-for 120 attempts 3 within 60  在 60 秒内有 3 次登录尝试失败时阻止vty登录尝试 120 秒。</p>
<p>**banner motd #<strong>当日消息</strong>#**（其实#可以换别的，向访问设备的人展示）</p>
<p>ip default-gateway 设置默认网关</p>
<p>ip route （远程网址+子网掩码）（下一跳路由器的IP地址）配置静态路由表</p>
<p> no ip directed-broadcasts 关闭定向广播</p>
<p> <strong>ipv6 unicast-routing</strong>  启用ipv6路由</p>
<h3 id="子模式"><a href="#子模式" class="headerlink" title="子模式"></a>子模式</h3><p>password ….  特定线路设置密码，如控制台</p>
<p>login 启用登录，不启用就根本进不去</p>
<p>mdix auto 启用Auto-MDIX，可以忽视另一端的设备类型使用铜缆（接口配置指令）</p>
<p>transport input {ssh | telnet}或者俩都加上  保护远程Telnet | SSH访问</p>
<p>ip address a b 192.168.1.20 255.255.255.0设置ipv4地址和子网掩码</p>
<p>(GUA)ipv6 address 地址/前缀长度，e.g.  ipv6 address 2001:db8:acad:10::1/64</p>
<p>(LLA)ipv6 address 链路本地地址 link-local</p>
<p>no shutdown 启用虚拟接口</p>
<p>description xxx 设置说明，比如第三方连接和联系信息（&lt;=240字符）</p>
<p>no ip domain-lookup 禁用DNS解析(特权模式)</p>
<p>description description-text 设置接口说明</p>
<p><strong>ip default-gateway</strong> ip-address为交换机配置默认网关</p>
<p>ipv6 unicast-routing 启用 IPv6 路由</p>
<p>exec-timeout 分 秒    在x分x秒后自动断开非活动用户</p>
<h3 id="主机端"><a href="#主机端" class="headerlink" title="主机端"></a>主机端</h3><p>ipconfig （/all）</p>
<p>arp -a 显示所有arp表</p>
<p>arp -d 清除 ARP 表</p>
<p>ping … 测试链接，一般要两遍，第一遍是自动配置arp所以一般失败</p>
<p><strong>route print</strong>或命<strong>netstat -r</strong>令可以显示主机路由表（windows主机），会列出</p>
<ul>
<li><strong>接口列表</strong> - 列出主机上的介质访问控制 (MAC) 地址和每个网络接口的已分配接口编号，包括以太网、 Wi-Fi 和蓝牙适配器。</li>
<li><strong>IPv4 路由表</strong> - 列出所有已知的 IPv4 路由，包括直接连接、本地网络和本地默认路由。</li>
<li><strong>IPv6 路由表</strong> - 列出所有已知的 IPv6 路由，包括直接连接、本地网络和本地默认路由。</li>
</ul>
<p><strong>netstat</strong>可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。</p>
<p>默认情况下，<strong>netstat</strong>命令会试图将 IP 地址解析为域名，将端口号解析为公认应用程序。使用**-n**选项能够以数字形式显示 IP 地址和端口号</p>
<p><strong>nslookup</strong> 程序手动查询域名服务器，来解析给定的主机名。</p>
<p>该实用程序也可以用于检修域名解析故障，以及验证域名服务器的当前状态。</p>
<h2 id="好多缩写"><a href="#好多缩写" class="headerlink" title="好多缩写"></a>好多缩写</h2><p>interface  = int</p>
<p>FastEthernet = f</p>
<p>running-config = run</p>
<p>startup-config = start</p>
<p>address == add</p>
<h2 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h2><p>？：</p>
<p>直接输入则显示当前模式可用</p>
<p>指令输入一般会显示补全可能</p>
<p>缺参数可以显示参数</p>
<p>主要Ctrl+A/E</p>
<p>c+s+6</p>
<p>c+r返回被打扰的命令行</p>
<table>
<thead>
<tr>
<th align="left"><strong>键盘输入</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Tab</strong></td>
<td align="left">补全部分输入的命令项。</td>
</tr>
<tr>
<td align="left"><strong>Backspace</strong></td>
<td align="left">删除光标左边的字符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-D</strong></td>
<td align="left">删除光标所在的字符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-K</strong></td>
<td align="left">删除从光标到命令行尾的所有字符。</td>
</tr>
<tr>
<td align="left"><strong>Esc D</strong></td>
<td align="left">删除从光标到词尾的所有字符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl+U</strong> 或 <strong>Ctrl+X</strong></td>
<td align="left">删除从光标到命令行首的 所有字符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-W</strong></td>
<td align="left">删除光标左边的单词。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-A</strong></td>
<td align="left">将光标移至行首。</td>
</tr>
<tr>
<td align="left"><strong>向左箭头</strong> 或 <strong>Ctrl+B</strong></td>
<td align="left">将光标左移一个字符。</td>
</tr>
<tr>
<td align="left"><strong>Esc B</strong></td>
<td align="left">将光标向后左移一个单词。</td>
</tr>
<tr>
<td align="left"><strong>Esc F</strong></td>
<td align="left">将光标向前右移一个单词。</td>
</tr>
<tr>
<td align="left"><strong>向右箭头</strong> 或 <strong>Ctrl+F</strong></td>
<td align="left">将光标右移一个字符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-E</strong></td>
<td align="left">将光标移至命令行尾。</td>
</tr>
<tr>
<td align="left"><strong>向上箭头</strong> 或 <strong>Ctrl+P</strong></td>
<td align="left">调出历史记录缓冲区中的命令， 从最近输入的命令开始。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl+R</strong> 或 <strong>Ctrl+I</strong> 或 <strong>Ctrl+L</strong></td>
<td align="left">收到控制台消息后重新显示系统提示符和 命令行。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>: 虽然 <strong>Delete</strong> 键通常用于删除提示符右侧的字符，但 IOS 命令结构无法识别 Delete 键。</p>
<p>当命令输出产生的文本超过终端窗口中可以显示的文本时，IOS 将显示一个 <strong>“–More–”</strong> 提示。下表描述了显示此提示时可以使用的键盘输入。</p>
<table>
<thead>
<tr>
<th align="left"><strong>键盘输入</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>回车</strong> 键</td>
<td align="left">显示下一行。</td>
</tr>
<tr>
<td align="left"><strong>空格</strong>键</td>
<td align="left">显示下一屏。</td>
</tr>
<tr>
<td align="left">任何其他按键</td>
<td align="left">结束显示字符串，返回特权模式。</td>
</tr>
</tbody></table>
<p>此表列出了用于退出操作的命令。</p>
<table>
<thead>
<tr>
<th align="left"><strong>键盘输入</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Ctrl-C</strong></td>
<td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。处于设置模式下时，用于中止并返回命令 提示符。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-Z</strong></td>
<td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。</td>
</tr>
<tr>
<td align="left"><strong>Ctrl-Shift-6</strong></td>
<td align="left">通用中断序列用于中止 DNS lookup、traceroutes、 pings等</td>
</tr>
</tbody></table>
<h1 id="协议和模型"><a href="#协议和模型" class="headerlink" title="协议和模型"></a>协议和模型</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>常用的计算机协议包含以下要求：</p>
<ul>
<li><p>消息编码-将信息转换成可传输和解码的</p>
<p>编码是将信息转换为另一种广为接受的形式的过程</p>
</li>
<li><p>消息格式和封装（encapsulation）-</p>
<p>当消息从源发送到目的地时，必须使用特定的格式或结构。取决于消息类型和传递信道</p>
</li>
<li><p>消息大小</p>
</li>
<li><p>消息时序（timing）</p>
<ul>
<li><strong>流量控制（flow control）-</strong> 这是管理数据传输速率的过程。流量控制定义了可以发送多少信息以及传递信息的速率。例如，如果一个人讲话太快，对方就难以听清和理解。</li>
<li><strong>响应超时</strong>(responce timeout) -如果一个人提问之后在合理的时间内没有得到回答，就会认为没有获得回答并作出相应的反应。此人可能会重复这个问题，也可能继续谈话。网络上的主机会使用网络协议来指定等待响应的时长，以及在响应超时的情况下执行什么操作。</li>
<li><strong>访问方法</strong> -这决定人们可以发送消息的时间。如果两个人同时讲话，就会发生信息冲突，两个人必须作出让步，重新开始的动画演示。同样，当设备想要在无线局域网上传输时，有必要使用 WLAN 网络接口卡 (NIC) 来确定无线介质是否可用。</li>
</ul>
</li>
<li><p>消息传输方式</p>
</li>
</ul>
<p>网络协议定义了用于设备之间交换消息的通用格式和规则集。协议由软件、硬件或两者中的终端设备和中间设备实现。每个网络协议都有自己的功能、格式和通信规则。</p>
<p>该表列出了在一个或多个网络上通信所需的各种协议类型。</p>
<table>
<thead>
<tr>
<th align="left"><strong>协议类型</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>网络通信协议</strong></td>
<td align="left">这类协议使两个或多个设备能够在一个或多个 网络上通信。以太网技术家族涉及多种协议， 例如IP，传输控制协议（TCP）， 超文本传输协议（HTTP）等。</td>
</tr>
<tr>
<td align="left"><strong>网络安全协议</strong></td>
<td align="left">这类协议保护数据以提供身份验证、数据完整性和 数据加密。安全协议的示例包括安全外壳协议 (SSH)、安全套接字层协议 (SSL) 和传输层安全协议 (TLS)。</td>
</tr>
<tr>
<td align="left"><strong>路由（routing）协议</strong></td>
<td align="left">这类协议使路由器能够交换路由信息，比较路径 信息，然后选择到达目标网络的 最佳路径。路由协议的示例包括开放最短路径优先协议 (OSPF)和边界网关协议 (BGP)。</td>
</tr>
<tr>
<td align="left"><strong>服务发现协议。</strong></td>
<td align="left">这类协议用于设备或服务的自动检测。 服务发现协议的示例包括发现用于IP地址分配 服务的动态主机配置协议（DHCP）， 和用于执行域名到IP地址转换的 域名系统（DNS）。</td>
</tr>
</tbody></table>
<p>协议的功能包括：<strong>编制、可靠性、流量控制、排序、差错检验、应用接口。</strong></p>
<p>在许多情况下，协议必须能够与其他协议配合使用，以便让在线体验为您提供网络通信所需的一切。协议簇旨在相互无缝协作。</p>
<p>执行某种通信功能所需的一组内在相关协议称为协议簇。</p>
<p>要形象地表现协议簇中的协议如何互动，最佳方法之一就是将这种互动看成一个堆栈。协议栈展示了协议簇中的单个协议是如何实施的。<strong>协议显示为分层结构，每种上层服务都依赖于其余下层协议所定义的功能。协议栈的下层负责通过网络传输数据和向上层提供服务，而上层则负责处理发送的消息内容。</strong></p>
<p>当年多种协议簇，只剩下TCP/IP（互联网协议簇）和一点点OSI（开放系统互连协议）</p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="*TCP/IP"></a>*TCP/IP</h2><p>免费 且 标准，图中只是较为常用的一些协议。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314171619114.png"></p>
<p>在一项工作中，每一层都有某个或多个协议参与。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314173907739.png"></p>
<table>
<thead>
<tr>
<th><strong>4 - 应用层</strong></th>
<th>向用户提供数据，以及编码和对话控制。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>3 - 传输层</strong></td>
<td>支持各种设备之间通过不同网络通信。</td>
</tr>
<tr>
<td><strong>2 - 互联网层</strong></td>
<td>确定通过网络的最佳路径。</td>
</tr>
<tr>
<td><strong>1 - 网络接入层</strong></td>
<td>控制组成网络的硬件设备和介质。</td>
</tr>
</tbody></table>
<p>OSI 5/6/7层供应用程序开发者参考</p>
<p>而底层通常使用OSI的1/2层</p>
<p>#应用层#(Applicaton Layer)</p>
<pre class="line-numbers language-none"><code class="language-none">域名系统
DNS - 域名系统(Domain Name System)。将域名（例如 cisco.com）转换为 IP 地址。

主机配置
DHCPv4 - IPv4动态主机配置协议(Dynamic Host Configuration Protocol for IPv4)。DHCPv4 服务器在启动时动态地将 IPv4 编址信息分配给 DHCPv4 客户端，并允许在不再需要时重新使用这些地址。
DHCPv6 - IPv6动态主机配置协议。DHCPv6类似于DHCPv4。
SLAAC -无状态地址自动配置(Stateless Address Autoconfiguration)。一种允许设备在不使用DHCPv6服务器的情况下获得其IPv6编址信息的方法。

邮件
SMTP -简单邮件传输协议(Simple Mail Transfer Protocol)。使客户端能够将邮件发送到邮件服务器，并使服务器能够将邮件发送到其他服务器。
POP3 -邮局协议第 3 版(Post Office Protocol version 3)。使客户端能够从邮件服务器检索电子邮件并将电子邮件下载到客户端本地邮件应用程序。
IMAP -互联网消息访问协议(Internet Message Access Protocol)。使客户端能够访问存储在邮件服务器上的电子邮件，并在服务器上维护电子邮件。
文件传输

FTP - 文件传输协议(File Transfer Protocol)。它设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件。FTP是一种可靠、面向连接且进行确认的文件传输协议。
SFTP - SSH文件传输协议(SSH...)。作为安全外壳 (SSH)协议的扩展，SFTP可用于建立安全的文件传输会话，在该会话中对文件传输进行加密。SSH 是一种安全远程登录的方法，通常用于访问设备的命令行。
TFTP -简单文件传输协议(Trivial...)。这是一个简单的，无连接的文件传输协议，使用尽最大努力、无需确认的文件传输方式。它使用的开销比FTP少。
Web和Web服务

HTTP(Hybertext Transfer Protocol) -超文本传输协议。这是有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集。
HTTPS -安全 HTTP(HTTP Secure)。这是一种安全的HTTP形式，它对在万维网上交换的数据进行加密。
REST -具象状态传输协议(Representational State Transfer)。它使用应用程序编程接口 (API) 和 HTTP 请求创建 Web 应用程序的 Web 服务。前后端交接！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>#传输层#(Transport layer)</p>
<pre class="line-numbers language-none"><code class="language-none">面向连接
TCP -传输控制协议(Transmission Control Protocol)。它使运行在不同主机上的进程之间能够进行可靠的通信，并提供可靠的、需要确认的传输，以确保传输成功。

无连接
UDP -用户数据报协议(User Datagram Protocol)。它允许一台主机上运行的进程向另一台主机上运行的进程发送数据包。但是，UDP不会确认数据报传输是否成功。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>#互联网层#(Internet Layer)</p>
<pre class="line-numbers language-none"><code class="language-none">Internet 协议
IPv4 -互联网协议第 4 版(Internet Protocol version 4)。它接收来自传输层的消息段，将消息打包成数据包，并为通过网络进行端到端传递的数据包进行地址分配。IPv4 使用 32 位地址。
IPv6 - 互联网协议第 6 版。与 IPv4 类似，但使用 128 位地址。
NAT -网络地址转换(Network Address Translation)。将私有网络 IPv4 地址转换为全球唯一的公有 IPv4 地址。

消息传送
ICMPv4 - IPv4 互联网控制消息协议(Internet Control Message Protocol for IPv4)。目的主机针对数据包传输中出现的错误，向源主机提供反馈。
ICMPv6 -用于 IPv6 的ICMP。与 ICMPv4 类似的功能，但用于 IPv6 数据包。
ICMPv6 ND -IPv6 邻居发现(IPv6 Neighbor Discovery)。包括用于地址解析和重复地址检测的四个协议消息。

路由协议
OSPF -开放最短路径优先协议(Open Shortest Path First)。它使用基于区域的分层设计的链路状态路由协议。OSPF是一种开放式标准内部路由协议。
EIGRP — 增强型内部网关路由协议(Enhanced Interior Gateway Routing Protocol)这是一种思科开发的开放标准路由协议，使用基于带宽、延迟、负载和可靠性的复合度量。
BGP -边界网关协议(Border Gateway Protocol)。这是一种开放标准的外部网关路由协议，用于互联网服务提供商(ISP)之间。BGP 还通常用于 ISP 与其大型私有客户端之间来交换路由信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>#网络接入层#(Network Access Layer)</p>
<pre class="line-numbers language-none"><code class="language-none">地址解析
ARP -地址解析协议(Address Resolution Protocol)。提供 IPv4 地址与硬件地址之间的动态地址映射。
注意：您可能会看到其他文档声明 ARP 在互联网层（OSI 第 3 层）运行。但是，在本课程中，我们声明 ARP 在网络接入层（OSI 第 2 层）运行，因为它的主要目的是发现目标的 MAC 地址。MAC 地址是第 2 层地址。

数据链路协议
Ethernet -为网络接入层的布线和信令标准定义规则。
WLAN -无线局域网(Wirelee Local Area Network)。定义 2.4 GHz 和 5 GHz 无线电频率的无线信号规则。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<table>
<thead>
<tr>
<th align="left"><strong>OSI 模型层</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>7 - 应用层</strong></td>
<td align="left">应用层包含用于进程间通信 的协议。</td>
</tr>
<tr>
<td align="left"><strong>6 - 表示层</strong></td>
<td align="left">表示层用常用方式表示数据 在应用层服务之间的传输。</td>
</tr>
<tr>
<td align="left"><strong>5 - 会话层</strong></td>
<td align="left">会话层向表示层提供服务，组织对话并 管理数据交换。</td>
</tr>
<tr>
<td align="left"><strong>4 - 传输层</strong></td>
<td align="left">传输层定义服务以对数据进行分段，传输和 重组，以进行终端设备之间的单独 通信。</td>
</tr>
<tr>
<td align="left"><strong>3 - 网络层</strong></td>
<td align="left">网络层为所标识的终端设备之间通过网络 交换独立的数据的片段提供服务。</td>
</tr>
<tr>
<td align="left"><strong>2 - 数据链路层</strong></td>
<td align="left">数据链路层协议描述了设备之间通过 公共介质交换数据帧的方法。</td>
</tr>
<tr>
<td align="left"><strong>1 - 物理层</strong></td>
<td align="left">物理层协议描述了机械的、电气的、功能的 和程序化的方法，以激活，维护和解除物理连接， 实现与网络设备之间的位 设备。</td>
</tr>
</tbody></table>
<h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>理论上来说，可以将一次通信的内容（如音乐视频或有很多很大的附件的电子邮件）作为一大块连续的高容量比特流，通过网络从源发送到目的地。但是，这会给其他需要使用相同通信通道或链路的设备带来问题。这种大型数据流会导致严重的延迟。而且，一旦互联网络基础架构中的任何链路在传输期间出现故障，那么整个消息都会丢失，必须全部重传。</p>
<p>所以，更好的办法是先将数据划分为更小、更易于管理的片段，然后再通过网络发送。分段是将数据流划分成更小的单元，以便在通过网络传输的过程。</p>
<p>好处：</p>
<ul>
<li><strong>提高速度</strong> - 由于将大数据流分段成为数据包，因此可以在不独占通信链路的情况下，通过网络发送大量数据。这允许许多不同的会话在称为多路复用的网络上交错。</li>
<li><strong>提高效率</strong> - 如果单个数据段由于网络故障或网络拥塞而无法到达其目的地，则只需要重新传输该段，而不需要重新发送整个数据流。</li>
</ul>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314174259989.png"></p>
<p>PDU协议数据单元</p>
<p>Data 数据 </p>
<p>Segment 段  Datagram 报</p>
<p>Packet 包</p>
<p>Frame 帧</p>
<p>Bits 位</p>
<p>这个图一开始忽略掉了，各层关注的地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801171105.png"></p>
<p>IP 地址包含两部分：</p>
<ul>
<li>网络部分(IPv4)或前缀(IPv6) – 地址最左边的部分，表示 IP 地址是哪个网络的成员。同一网络中所有设备的地址都有相同的网络部分。</li>
<li>主机部分(IPv4)或接口ID(IPv6) - 地址的其余部分，用于识别网络上的特定设备。这部分对于网络中的每个设备或接口都是唯一的。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801171401.png"></p>
<p>具体mac和ip的方式等后面吧。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>网络接口卡 (NIC) 将设备连接到网络。以太网网卡用于有线连接、，而无线局域网（WLAN）网卡用于无线连接。最终用户设备可能包括一种或两种类型的网卡。</p>
<p>在连接网络时，所有物理连接的<strong>性能水平并不是相等</strong>的。</p>
<p>OSI 物理层通过网络介质传输构成数据链路层帧的比特（位）。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。帧由经过编码的比特（位）构成，这些位可以被终端设备或中间设备接收。</p>
<h2 id="物理层特征"><a href="#物理层特征" class="headerlink" title="物理层特征"></a>物理层特征</h2><p>由以下组织定义和管理：</p>
<ul>
<li>国际标准化组织 (ISO)</li>
<li>电信工业协会/电子工业协会 (TIA/EIA)</li>
<li>国际电信联盟 (ITU)</li>
<li>美国国家标准学会 (ANSI)</li>
<li>电气电子工程师协会 (IEEE)</li>
<li>国家级电信管理局包括美国联邦通信委员会 (FCC) 和欧洲电信标准协会 (ETSI)。</li>
</ul>
<p>除了这些组织之外，通常还有地方性布线标准组织，例如 CSA（加拿大标准协会）、CENELEC（欧洲电工标准化委员会）和 JSA/JIS（日本标准协会），开发本地规范。（放在这里谨表敬意，绝对不记！！）</p>
<p>物理层标准管理三个功能区：</p>
<ul>
<li>物理组件 - 电子硬件设备、介质和其他连接器，组件均按照物理层的相关标准进行规定路由器上的各种端口和接口也属于物理组件，根据标准使用特定连接器和引脚。</li>
<li>编码 - 将数据位流转换为预先定义“代码”的方法，这些代码就是位的编组，用于提供一种可预测模式，以便发送者和接收者均能识别。换句话说，编码是用于表示数字信息的方法或模式。（比如曼切斯特）</li>
<li>信令 - 表示位的方法称为信令方法，在介质上生成代表“1”和“0”的电信号、光信号或无线信号，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。长脉冲可能代表 1，而短脉冲可能代表 0。</li>
</ul>
<p>信令是方式，是编码的基础，编码是抽象的逻辑，借由信令这个媒介加以实现（我猜的）</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>不同的物理介质所支持的位传输速率不同。数据传输的讨论通常都会提及带宽。带宽是介质承载数据的能力。数字带宽可以测量在给定时间内从一个位置流向另一个位置的数据量。</p>
<p><strong>延迟</strong></p>
<p>延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。</p>
<p>在拥有多个网段的网际网络或网络中，吞吐量不能超过从源到目的地之间路径的最低链路。纵使这些网段全部或多数具备高速带宽，它也只使用那段低速率路径的吞吐量，这就会造成整个网络的吞吐量瓶颈。</p>
<p><strong>吞吐量</strong></p>
<p>吞吐量是给定时段内通过介质传输的位的量度。</p>
<p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符。吞吐量通常低于带宽。影响吞吐量的因素</p>
<ul>
<li>流量大小</li>
<li>流量类型</li>
<li>从源通往目的地的过程中遇到的网络设备数量所造成的延时。</li>
</ul>
<p><strong>实际吞吐量</strong></p>
<p>用于评估可用数据传输的第三个测量标准称为实际吞吐量。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。实际吞吐量就是吞吐量<strong>减去建立会话、确认、封装和重传所产生的流量开销</strong>。实际吞吐量总是低于吞吐量，而吞吐量通常低于带宽。</p>
<h2 id="介质"><a href="#介质" class="headerlink" title="介质"></a>介质</h2><h3 id="铜缆"><a href="#铜缆" class="headerlink" title="铜缆"></a>铜缆</h3><p>有三种不同类型的铜缆布线，每一种都用于特定的情况。</p>
<p>价格低廉、易于安装、对电流的电阻低。但是，铜介质受到距离和信号干扰的限制。</p>
<p>信号传输的距离越远，信号下降就越多。这称为信号衰减。</p>
<ul>
<li><em><strong>电磁干扰 (EMI) 或射频干扰 (RFI)</strong></em> - EMI 和 RFI 干扰信号会扭曲和损坏通过铜介质承载的数据信号。EMI 和 RFI 的潜在来源包括无线电波和电磁设备（如荧光灯或电动机）。</li>
<li><em><strong>串扰</strong></em> - 串扰是一根电线中信号的电场或磁场对邻近电线中的信号造成的干扰。在电话线上，串扰会由相邻电路中另一语音会话的接听部分引起。具体而言，当电流流经电线时，会在电线周围产生一个较小的环形磁场，而相邻电线可能接收到该磁场。</li>
</ul>
<p>为了应对 EMI 和 RFI 的负面影响，某些类型的铜缆会用金属屏蔽套包裹，并要求适当的接地连接。</p>
<p>为了应对串扰的负面影响，某些类型的铜缆将相反电路线对绞合在一起以有效消除串扰。（物理学hh）</p>
<p>使用以下建议也可以限制电子噪音对铜缆的影响：</p>
<ul>
<li>选择的电缆类型或类别要适合特定的网络环境。</li>
<li>设计电缆基础设施时应规避建筑结构中已知和潜在的干扰源。</li>
<li>使用包括正确处理和端接电缆的布线技术。</li>
</ul>
<p><strong>UTP非屏蔽双绞线 Unshielded twisted-pair</strong> </p>
<p>最常用的网络介质。通过 RJ-45 连接器端接的 UTP 布线用于<strong>网络主机与中间网络设备的互连</strong>，例如交换机和路由器。四对用颜色标记的电线组成</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801172405.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801172405.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<p><strong>STP屏蔽双绞线 Shielded twisted-pair</strong></p>
<p>比 UTP 布线提供更好的噪声防护。但是，与 UTP 电缆相比，STP 电缆更加昂贵而且不易安装。和 UTP 相同，STP 也使用 RJ-45 连接器。为了充分利用屏蔽的优势，STP 电缆使用特殊屏蔽 STP 数据连接器进行端接。如果电缆接地不正确，屏蔽就相当于一个天线，会接听多余信号。</p>
<p>多了金属编制和金属箔</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801172356.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801172356.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<p><strong>Coaxial cable</strong></p>
<p>同轴电缆，或简称同轴，由于它的两根导线共享同一个中轴而得名</p>
<p>同轴电缆使用许多不同类型的连接器</p>
<p>&lt;img src=”<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314182735686.png&quot;">https://gitee.com/darren-greenhand//picture/raw/master/image-20210314182735686.png&quot;</a> “ style=”zoom:67%;” /&gt;</p>
<p>虽然 UTP 电缆在现代以太网安装中最终取代了同轴电缆，但在以下情形中仍采用同轴电缆设计：</p>
<ul>
<li><strong>无线安装</strong> - 用同轴电缆将<strong>天线连接到无线设备</strong>。同轴电缆可传送天线和无线电设备之间的射频 (RF) 能量。</li>
<li><strong>有线电视互联网安装</strong> - 有线电视服务提供商为其客户提供互联网连接，他们会使用光缆替换同轴电缆和支撑放大元件部分。但是，<strong>客户所在地的布线</strong> 仍采用同轴电缆。</li>
</ul>
<h3 id="UTP布线"><a href="#UTP布线" class="headerlink" title="UTP布线"></a>UTP布线</h3><p>UTP 布线遵循由 TIA/EIA 共同制定的标准。具体而言，TIA/EIA-568 规定了 LAN 安装的商业布线标准，它是 LAN 布线环境中最常用的标准。定义的一些要素如下：</p>
<ul>
<li>电缆类型</li>
<li>电缆长度</li>
<li>连接器</li>
<li>电缆端接</li>
<li>测试电缆的方法</li>
</ul>
<p>IEEE 按照它的性能对 UTP 布线划分等级。电缆分类的依据是它们承载更高速率带宽的能力。例如，5类电缆通常用于 100BASE-TX 快速以太网安装。其他类别包括增强型 5类电缆、6类电缆 和 6a 类电缆。</p>
<p>为了支持更高的数据传输速率，人们设计和构造了更高类别的电缆。随着新的千兆位以太网技术的开发和运用，如今已经很少采用 5e 类电缆，新建筑安装推荐使用 6 类电缆。</p>
<p>-3 类电缆最初用于语音线路的语音通信，但后来用于数据传输。 -5 类和5e 类电缆用于数据传输。5类电缆支持 100Mbps，5e 类电缆支持 1000 Mbps -6类电缆在每对线之间增加了一个分隔器以支持更高的速度。 6类电缆支持高达 10 Gbps。 -7类电缆也支持 10 Gbps。 -8类电缆支持 40 Gbps。</p>
<p>UTP 电缆的端头通常为 RJ-45 连接器。TIA/EIA-568 标准描述为以太网电缆进行引脚分配（引出线）的电线颜色标记。</p>
<p>&lt;img src=”<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200028243.png&quot;">https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200028243.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<hr>
<p>&lt;img src=”<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200013783.png&quot;">https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200013783.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<p>直通和交通</p>
<ul>
<li><strong>以太网直通电缆</strong> -最常见的网络电缆类型。它通常用于主机到交换机和交换机到路由器的互连。</li>
<li><strong>以太网交叉电缆</strong> -用于互连相似设备的电缆。例如，交换机到交换机、主机到主机或路由器到路由器的连接。但是，由于网卡使用介质相关接口交叉（auto-MDIX）来自动检测电缆类型并进行内部连接，因此现在已将交叉电缆视为传统电缆。</li>
<li>但是<strong>主机链接路由器竟然也是用交叉线！</strong></li>
</ul>
<p><strong>注意</strong>: 另一种类型的电缆是思科专有的全反电缆。它用于连接路由器或交换机的<strong>控制台端口</strong>。</p>
<p>在设备间错误使用交叉电缆或直通电缆不会损坏设备，但也无法连通设备并进行通信</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314200350348.png"></p>
<table>
<thead>
<tr>
<th align="left">电缆类型</th>
<th align="left">标准</th>
<th align="left">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">以太网直通线</td>
<td align="left">两端均为 T568A 或两端均为 T568B</td>
<td align="left">将网络主机连接到交换机或集线器之类的网络设备</td>
</tr>
<tr>
<td align="left">以太网交叉线</td>
<td align="left">一端为 T568A，另一端为 T568B</td>
<td align="left">连接两个网络主机或连接两台网络中间设备 （交换机到交换机或路由器到路由器）</td>
</tr>
<tr>
<td align="left">全反电缆</td>
<td align="left">思科专有</td>
<td align="left">使用适配器连接工作站串行端口与路由器 控制台端口。</td>
</tr>
</tbody></table>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><ul>
<li>单模光纤 (SMF) Single-mode fiber</li>
<li>多模光纤 (MMF) Mulitimode fiber</li>
</ul>
<p>单模光纤包含一个极小的芯，使用昂贵的激光技术来发送单束光，如图所示。单模光纤在跨越数百公里的长距离传输情况下很受欢迎，例如应用于长途电话和有线电视中的光纤。</p>
<p>多模光纤包含一个稍大的芯，使用 LED 发射器发送光脉冲。具体而言，LED 发出的光从不同角度进入多模光纤，t有多条光路，普遍用于 LAN 中，因为它们可以由低成本的 LED 提供支持。它可以通过长达 550 米的链路提供高达 10 Gb/s 的带宽。</p>
<p>多模和单模光纤之间的<strong>主要区别之一就是色散的数量</strong>。色散是指光脉冲在时间上的分布。色散增加意味着信号强度损失增加。多模光纤具有比单模光纤更大的色散。这就是为什么多模光纤在信号丢失之前只能传播 500 米。</p>
<ul>
<li><strong>企业网络</strong> - 用于主干布线和基础设施设备互连。</li>
<li><strong>光纤到户 (FTTH)</strong> - 用于为家庭和小型企业提供不间断宽带服务。</li>
<li><strong>长距离传输网络</strong> - 由服务提供商用于连接国家/地区与城市。</li>
<li><strong>水下有线网络</strong> - 用于提供可靠高速、高容量的网络解决方案，使其在深度与横跨海洋的距离相当的严酷海下环境中仍能生存。在互联网上搜索“海底电缆电信地理地图”，以在线查看各种地图。</li>
</ul>
<p>连接器：</p>
<p>直通式ST Straight-tip</p>
<p>用户连接器SC Subscriber Connector</p>
<p>朗讯连接器LC单工 Lucent Connector Simplex Connectors</p>
<p>双工多模LC连接器 Duplex Multimode</p>
<p>直到最近，光还只能在光纤上沿一个方向传播。因此，<strong>需要两根光纤来支持全双工操作</strong>。因此，光纤跳线是将两根光纤线缆捆绑在一起，并通过一对标准的单光纤接头端接。有些光纤连接器可以在单个连接器上同时传送和接收光纤，称为双工连接器，其实就是连接了俩线</p>
<p>需要使用光纤接插线（即光纤跳线）互连基础设施设备。人们使用不同颜色来区分单模和多模接插线。黄色表皮的是单模光缆，橙色（或浅绿色）的是多模光缆。</p>
<p>有SC-SC多模  LC-LC 单模 ST-LC多模 SC-ST单模 。。。</p>
<h3 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h3><p>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。</p>
<p>以下是无线网络的一些局限性:</p>
<ul>
<li><strong>覆盖面积</strong> - 无线数据通信技术非常适合开放环境。但是，在楼宇和建筑物中使用的某些建筑材料以及当地地形将会限制它的有效覆盖。</li>
<li><strong>干扰</strong> - 无线电易受干扰，可能会受到家庭无绳电话、某些类型的荧光灯、微波炉和其他无线通信装置等常见设备的干扰。</li>
<li><strong>安全性</strong> - 无线通信覆盖无需进行介质的物理接线。因此，未获得网络访问授权的设备和用户可以访问传输。所以网络安全是无线网络管理的重要组成部分。</li>
<li><strong>共享介质</strong> - WLAN 以半双工模式运行，意味着一台设备一次只能发送或接收。无线介质由所有无线用户共享。许多用户同时访问WLAN会导致每个用户的带宽减少。</li>
</ul>
<p>标准规定了：</p>
<ul>
<li>数据到无线电信号编码</li>
</ul>
<ul>
<li>传输频率和功率</li>
<li>信号接收和解码要求</li>
<li>天线的设计和施工</li>
</ul>
<p>这些是无线标准：</p>
<ul>
<li><strong>Wi-Fi (IEEE 802.11)</strong> - 无线 LAN (WLAN) 技术，通常称为 Wi-Fi。WLAN 使用一种称为“载波侦听多路访问/冲突避免 (CSMA/CA)”的争用协议。无线 NIC 在传输数据之前必须先侦听，以确定无线信道是否空闲。如果其他无线设备正在传输，则 NIC 必须等待信道空闲。Wi-Fi 是 Wi-Fi 联盟的标记。Wi-Fi 与基于 IEEE 802.11 标准的认证 WLAN 设备结合使用。</li>
<li><strong>蓝牙 (IEEE 802.15)</strong> - 这是一个无线个人局域网 (WPAN) 标准，通常称为 “蓝牙”。它采用设备配对过程进行通信，距离为 1 到 100 米。</li>
<li><strong>WiMAX (IEEE 802:16)</strong> - 通常称为微波接入全球互通 (WiMAX)，这个无线标准采用点到多点拓扑结构，提供无线带宽接入。</li>
<li><strong>Zigbee (IEEE 802.15.4)</strong> - Zigbee是一种用于低数据速率、低功耗通信的规范。它适用于需要短距离、低数据速率和长电池寿命的应用。Zigbee 通常用于工业和物联网 (IoT) 环境，如无线照明开关和医疗设备数据采集。</li>
</ul>
<p>WLAN 要求具备下列网络设备：</p>
<ul>
<li><strong>无线接入点 (AP) Wireless Access Point</strong> - 集中用户的无线信号，并连接到现有基于铜介质的网络基础设施，如以太网。如图所示，家庭和小型企业无线路由器将路由器、交换机和接入点的功能整合到了一起。</li>
<li><strong>无线网卡适配器Wireless NIC adapters</strong> - 能够为每台网络主机提供无线通信</li>
</ul>
<p>以太网网卡用于有线连接，而 WLAN（无线局域网）网卡用于无线连接。</p>
<h1 id="地址plus"><a href="#地址plus" class="headerlink" title="地址plus"></a>地址plus</h1><p>IPV4每一个地址包含一串 32 位字符串，并分为四个部分，每个部分称为二进制八位组。每一个二进制八位组包含 8 位（或 1 个字节），用句点分隔。</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173248.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173248.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<p>IPv4 地址通常表达为点分十进制记法</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173306.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173306.png&quot;</a> “ style=”zoom:50%;” /&gt;</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173439.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801173439.png&quot;</a> “ style=”zoom:80%;” /&gt;</p>
<p>十六进制数制系统在网络中用于表示以太网 MAC 地址和 IP V6 地址。</p>
<p>IPv6地址长度为128位，每 4 位以一个十六进制数字表示，共 8个十六进制数（或者说32 个十六进制值）。IPv6 地址不区分大小写，可用大写或小写书写。首选格式为<code> x:x:x:x:x:x:x:x</code>，</p>
<p>每个“x”称为一个十六进制数，包括四个十六进制值</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>与 TCP/IP 的上层协议不同，数据链路层协议通常不是由征求意见 (RFC) 文档定义的。互联网工程任务组 (IETF) 虽然维护着 TCP/IP 协议簇上层的工作协议和服务，但它没有定义TCP/IP模型的网络接入层的功能和操作。</p>
<p>OSI模型的数据链路层(第2层)为物理网络<strong>准备网络数据</strong>。数据链路层<strong>负责网络接口卡 (NIC) 到网络接口卡的通信</strong>。数据链路层执行以下操作：</p>
<ul>
<li>允许上层访问介质。上层协议完全不知道用于转发数据的介质类型。</li>
<li>接受数据，通常是第 3 层数据包（即 IPv4 或 IPv6），并将它们封装到第 2 层帧中。</li>
<li>控制数据在介质上的放置和接收方式，</li>
<li>通过网络介质在终端之间交换帧。</li>
<li>接收封装的数据，通常是第 3 层数据包，并将它们定向到适当的上层协议。</li>
<li>执行错误检测并拒绝任何损坏的帧。</li>
</ul>
<p>如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。此外，每当开发出一种新的网络技术或介质时，IP 必须做出相应调整。而这些交给数据链路层来考虑，IP只需考虑更加抽象的架构</p>
<h2 id="IEEE-802-LAN-MAN"><a href="#IEEE-802-LAN-MAN" class="headerlink" title="IEEE 802 LAN/MAN"></a>IEEE 802 LAN/MAN</h2><p>IEEE 802 LAN/MAN 标准专用于以太网局域网、无线局域网 (WLAN)、无线个人区域网 (WPAN) 和其他类型的局域网和城域网。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：</p>
<ul>
<li><strong>逻辑链路控制 (LLC)</strong> - 这个 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。<strong>它放入帧中的信息用于确定帧所使用的网络层协议</strong>。此信息<strong>允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</strong>不必让每个协议自己研究这些</li>
<li><strong>介质访问控制 (MAC)</strong> - 在硬件上实现这个子层（IEEE 802.3、802.11 或 802.15）。它负责数据<strong>封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</strong></li>
</ul>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314205917487.png"></p>
<p>LLC 子层获取网络协议数据（通常是 IPv4 或 IPv6数据包）并加入第2层控制信息，帮助将数据包传送到目的节点。 </p>
<p>MAC子层控制<strong>网卡</strong>和负责在有线或无线LAN/MAN介质上发送和接收数据的<strong>其他硬件</strong>。</p>
<p>MAC 子层提供数据封装：</p>
<ul>
<li><strong>帧定界</strong> - 在成帧过程中提供重要的定界符，用来标识帧中的字段。这些定界符位可以在发送节点与接收节点之间提供同步。</li>
<li><strong>编址</strong> - 提供源和目的编址，用于在同一共享介质上的设备之间传输第 2 层帧。</li>
<li><strong>错误检测</strong> - 包含一个帧尾，用于检测传输错误。</li>
</ul>
<p>MAC 子层还提供介质访问控制，允许多个设备通过共享（半双工）介质进行通信。全双工通信不需要访问控制。</p>
<h2 id="介质访问"><a href="#介质访问" class="headerlink" title="介质访问"></a>介质访问</h2><p>在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。例如，以太网 LAN 通常由许多争用网络介质访问的主机组成。MAC 子层解决了这个问题。对于串行链路，访问方法可能只包括两个设备之间的直接连接，通常是两个路由器。因此，它们不需要 IEEE 802 MAC 子层所使用的技术。</p>
<p>路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p>
<p>在路径上的每一跳，路由器都执行以下第 2 层功能：</p>
<ol>
<li>从介质接受帧</li>
<li>解封帧</li>
<li>将数据包重新封装到新帧中</li>
<li>从适合该物理网络网段的介质转发新帧</li>
</ol>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><ul>
<li><strong>物理拓扑</strong> - 标识物理连接，以及终端设备和中间设备（即，路由器、交换机和无线接入点）如何互连。这个拓扑还可能包括特定的设备位置，如房间号和设备机架上的位置。物理拓扑通常是点对点拓扑或星型拓扑。</li>
<li><strong>逻辑拓扑</strong> - 是指网络将帧从一个节点传输到另一节点的方法。此拓扑使用<strong>设备接口和<em>第 3 层</em> IP 寻址方案识别虚拟连接。</strong></li>
</ul>
<p>在控制对介质的数据访问时，数据链路层“看见”的是网络的逻辑拓扑。正是逻辑拓扑在影响网络成帧和介质访问控制的类型。</p>
<p><strong>WAN拓扑</strong></p>
<p><strong>点对点</strong>：在这种布局中，两个节点无需与其他主机共享介质。此外，当使用串行通信协议，如点对点协议(PPP)时，节点无需判定收到的帧是指向它还是指向另一节点。因此，逻辑数据链路协议将非常简单，因为介质中的所有帧都只去往或来自这两个节点。节点将帧放置到一端的介质上，然后点对点线路另一端的节点从介质取走帧。<br><strong>在网络中使用物理设备并不会影响逻辑拓扑</strong></p>
<p><strong>中心辐射</strong>：这是星型拓扑的 WAN 版本，在该拓扑中一个中心站点使用点对点链路互连分支机构站点。如果不经过中心站点，分支站点就不能与其他分支站点交换数据。</p>
<p><strong>网状</strong>：该拓扑可用性高，但要求每个终端系统都与其他各个系统互连。因此管理成本和物理成本都会非常高。每条链路实质上是另一节点的点对点链路。</p>
<p>混合拓扑（任意拓扑的变体和组合）</p>
<p><strong>LAN拓扑</strong></p>
<p>在多路访问局域网中，终端设备（即节点）使用星型或扩展星型拓扑相互连接，如图所示。在这种类型的拓扑中，终端设备连接到一个中央中间设备，在本例中是一个以太网交换机。扩展星型（<strong>扩展星型</strong>）通过连接多个以太网交换机来扩展此拓扑。星型和扩展星型拓扑安装简单、扩展性好（易于添加和删除终端设备），而且故障排除容易。早期的星型拓扑使用以太网集线器互连终端设备。</p>
<p><strong>传统LAN拓扑</strong></p>
<p>早期的以太网和传统令牌环局域网技术包括另外两种拓扑结构:</p>
<ul>
<li><strong>总线</strong> - 所有终端系统都相互连接，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。传统的以太网络中会使用采用同轴电缆的总线拓扑，因为它价格低廉而且安装简易。</li>
<li><strong>环</strong> - 终端系统与其各自的邻居相连，形成一个环状。与总线拓扑不同，环拓扑不需要端接。传统的光纤分布式数据接口 (FDDI) 和令牌环网络使用环拓扑。</li>
</ul>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314211820357.png"></p>
<p><strong>半双工</strong></p>
<p>两台设备都可以通过该介质发送和接收，但无法同时执行这两个操作。WLAN和带有以太网集线器的传统总线拓扑使用半双工模式。</p>
<p><strong>全双工</strong></p>
<p>两台设备都可以在共享介质上同时发送和接收，现代Ethernet</p>
<p>双工不匹配会导致效率严重下降！重要错误</p>
<h3 id="访问控制方法"><a href="#访问控制方法" class="headerlink" title="访问控制方法"></a>访问控制方法</h3><p><em><strong>如今，以太网网络以全双工方式运行，不需要访问方法。</strong></em></p>
<p>多路访问网络是指可能有两个或多个终端设备同时试图访问网络的网络。</p>
<p>以太网 LAN 和 WLAN 都是多路访问网络的示例</p>
<p>对于共享介质，有两种基本的访问控制方法：</p>
<ul>
<li>基于竞争的访问</li>
<li>受控访问</li>
</ul>
<p><strong>受控访问</strong></p>
<p>在基于控制的多路访问网络中，每个节点都有自己的时间来使用介质。这种确定性的传统网络类型<strong>效率很低</strong>，因为设备必须等到轮到自己才能访问介质。使用受控访问的多路访问网络的示例包括：</p>
<ul>
<li>传统令牌环</li>
<li>传统ARCNET</li>
</ul>
<p><strong>基于竞争的访问</strong></p>
<p>在基于竞争的多路访问网络中，所有节点都工作在半双工方式，争夺介质的使用。然而，一次只有一台设备能够发送。因此，当多台设备同时传输时，会使用一个处理过程。基于竞争的访问方法示例如下：</p>
<ul>
<li>在<strong>传统总线拓扑/使用集线器的以太网局域网</strong>上使用载波侦听多路访问/冲突<strong>检测</strong>(CSMA/CD)</li>
<li>在<strong>无线局域网</strong>上使用载波侦听多路访问/冲突<strong>避免</strong>(CSMA/CA)</li>
</ul>
<p><em>基于竞争的系统在介质使用率高的情况下都无法很好地扩展。</em></p>
<p><strong>CSMA/CD</strong></p>
<p>如果两台设备同时传输，则会发生冲突。对于传统以太网局域网，两台设备将会检测到网络上的冲突。这就是 CSMA/CD 的冲突检测 (CD) 部分。网卡通过比较传输的数据与接收的数据，或通过识别介质中的信号振幅是否高于正常状况来实现。两台设备发送的数据会损坏且需重新发送。</p>
<p>集线器例子：</p>
<p>在某主机给集线器发了个帧后，所有主机都会接受这个帧，此时抑制这些主机发送，都接受到后只有拥有 PC3 的目的数据链路地址的设备才会复制该帧</p>
<p>它还提供了一种回退重传算法。</p>
<p><strong>CSMA/CA</strong></p>
<p>在无线环境中，设备可能无法检测到冲突。CMSA/CA 不检测冲突，但会通过在传输之前等待来尝试避免冲突。每台设备发送时都会包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有久不可用。</p>
<h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><p>附加到帧的信息由正在使用的协议决定。</p>
<p>数据链路协议负责同一网络中的网卡间通信。虽然有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有三个基本组成部分：</p>
<ul>
<li>帧头</li>
<li>数据</li>
<li>帧尾</li>
</ul>
<p>没有一种帧结构能满足通过所有类型介质的全部数据传输需求。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。例如，WLAN帧必须包含避免冲突的过程，因此与以太网帧相比需要额外的控制信息。在脆弱的环境下，需要更多控制才能确保送达。<strong>由于所需控制信息较多，因此帧头和帧尾字段都较大。（一个特征）</strong></p>
<p>&lt;img src=”<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213324158.png&quot;">https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213324158.png&quot;</a> “ style=”zoom:67%;” /&gt;</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314213352540.png"></p>
<p><em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p>
<p>在 TCP/IP 网络中，所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用。但是，所用的第 2 层协议取决于逻辑拓扑和物理介质。</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801220318.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801220318.png&quot;</a> “ style=”zoom:67%;” /&gt;</p>
<p>每个协议执行指定第 2 层逻辑拓扑的介质访问控制。这意味着在执行这些协议时，有很多种不同的网络设备都可以充当运行在数据链路层上的节点。这些设备包括计算机上的网卡以及路由器和第 2 层交换机上的接口。</p>
<p>用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。所使用的技术取决于网络规模（根据主机数量和地理范围判断）以及通过网络提供的服务。</p>
<p>带宽差异常会导致 LAN 和 WAN 使用不同的协议。</p>
<p>数据链路层协议包括：</p>
<ul>
<li>以太网</li>
<li>802.11 无线</li>
<li>点对点协议 (PPP)</li>
<li>高级数据链路控制 (HDLC) High-Level Data Link Control</li>
<li>帧中继 Frame Relay</li>
</ul>
<p>分别适合不同的设备和介质之间传递</p>
<h1 id="以太网交换"><a href="#以太网交换" class="headerlink" title="以太网交换"></a>以太网交换</h1><p>以太网和无线局域网是当前使用最广泛的两种LAN技术。以太网支持高达 100 Gbps 的带宽，这就是其受欢迎的原因。另一种是无线局域网（WLAN），它使用有线通信，包括双绞线、光纤链路和同轴电缆。</p>
<p>以太网在数据链路层和物理层运行，是 IEEE 802.2 和 802.3 标准中定义的一系列网络技术。（无线是802.11）</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214332628.png"></p>
<p>以太网也使用802 LAN/MAN协议的俩子层</p>
<ul>
<li><strong>LLC 子层</strong> - 此 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。<strong>它放入帧中的信息</strong>用于确定帧所使用的<strong>网络层协议</strong>。此信息允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</li>
<li><strong>MAC 子层</strong> - 此子层（例如 IEEE 802.3、802.11 或 802.15）在硬件中实现，负责数据封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</li>
</ul>
<h2 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h2><p>MAC 子层负责数据封装和访问介质。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214654631.png"></p>
<p><strong>数据封装</strong></p>
<p>IEEE 802.3 数据封装包括以下内容：</p>
<ul>
<li><strong>以太网帧</strong> - 这是以太网帧的内部结构。</li>
<li><strong>以太网寻址</strong> - 以太网帧中包含源和目的MAC 地址，用于将该以太网帧从以太网网卡传送到<strong>同一LAN</strong>上的以太网网卡。</li>
<li><strong>以太网错误检测</strong> - 以太网帧中包含用于错误检测的帧校验序列 (FCS) 帧尾。</li>
</ul>
<p>它也负责使用CSMA/CD and CSMA/CA技术</p>
<h3 id="以太网帧字段"><a href="#以太网帧字段" class="headerlink" title="以太网帧字段"></a>以太网帧字段</h3><p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。<strong>在描述帧的大小时，不包含“前导码”字段</strong>。</p>
<p>任何长度小于 <strong>64</strong> 个字节的帧都被接收站点视为“冲突碎片”或“残帧”而自动丢弃。超过 <strong>1500</strong> 个字节的数据帧被视为“巨帧”或“小型巨型帧”。</p>
<p>如果发送的帧小于最小值或者大于最大值，接收设备将会丢弃该帧。帧之所以被丢弃，可能是因为冲突或其他多余信号。它们被视为无效。大多数快速以太网和千兆以太网交换机和网卡通常都支持巨帧。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314214944369.png"></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前导码和帧首定界符字段                            .</td>
<td align="left">前导码（Preamble）（7 字节）和帧首定界符(Start Frame Delimiter)（SFD），也称为 帧首（1 字节），该字段用于发送设备 与接收设备之间的同步。帧开头的八个字节 用于引起接收节点的注意。基本上，前几个字节的 作用是告诉接收方准备接收新帧。</td>
</tr>
<tr>
<td align="left">目的 MAC 地址字段</td>
<td align="left">该 6 字节字段是预期接收方的标识符。读者应该还记得， 此地址被第2层用来协助设备 确定帧是否发送到目的地。帧中的地址将会与设备中的 MAC 地址进行比对。如果匹配， 设备就接受该帧。可以是单播、组播或广播 地址。</td>
</tr>
<tr>
<td align="left">源 MAC 地址字段</td>
<td align="left">该 6 字节字段标识发出帧的网卡 或接口。</td>
</tr>
<tr>
<td align="left">类型/长度</td>
<td align="left">该字段包含两个字节，<strong>标识封装于以太网帧中的 上层协议</strong>。常见值为十六进制，0x800 用于 IPv4， 0x86DD 用于 IPv6，0x806 用于 ARP。 <strong>注意</strong>：您也可能会看到此字段称为 EtherType、类型或长度。</td>
</tr>
<tr>
<td align="left">数据字段</td>
<td align="left">该字段（46-1500 字节）包含来自 较高层的封装数据，一般是第3层PDU。最常见是IPv4 数据包。所有帧至少必须有 64 个字节。<strong>如果封装的是小数据包， 则使用填充位将帧增大到最小值</strong>。</td>
</tr>
<tr>
<td align="left">帧校验序列字段</td>
<td align="left">“帧校验序列 (Frame Check Sequence)(FCS)”字段（4 个字节）用于检测帧中 的错误。它使用循环冗余校验 (CRC)。发送设备 在帧的 FCS 字段中包含 CRC 的结果。接收设备 接收帧并生成 CRC 以查找 错误。如果计算匹配，就不会发生错误。计算 不匹配则表明数据已经改变。因此， 帧会被丢弃。数据的变化可能是 由于代表比特位的电信号受到干扰所致。</td>
</tr>
</tbody></table>
<h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>在<strong>以太网</strong>中，每台网络设备都连接到同一个共享介质。MAC 地址用于标识本地网段上的物理源和目的设备。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。</p>
<p>以太网 MAC 地址是使用 <strong>12个十六进制数字</strong>表示的 48 位地址，因为一个字节等于 8 位，我们也可以说 一个MAC 地址长度为 6 个字节。</p>
<p>所有 MAC 地址对于以太网设备或以太网接口必须是<strong>唯一</strong>的。<br>为了确保这一点，所有销售以太网设备的供应商必须向 IEEE 注册才能获得唯一的 6个十六进制（即 24 位或 3 字节）代码，称为组织唯一标识符 (OUI)。（Organization unique identifier）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210801221759.png"></p>
<p>当供应商为设备或以太网接口分配 MAC 地址时，供应商必须执行以下操作：</p>
<ul>
<li>使用其分配的 OUI 作为前 6 个十六进制数字。</li>
<li>为后 6 个十六进制数字分配唯一值。</li>
</ul>
<p>OUI查询网址：<a href="http://standards-oui.ieee.org/oui/oui.txt">http://standards-oui.ieee.org/oui/oui.txt</a></p>
<p>供应商有责任确保其设备不被分配相同的 MAC 地址。但是，由于制造过程中出现的错误、某些虚拟机部署方式中的错误或使用多种软件工具之一进行的修改，可能存在重复的 MAC 地址。若出现以上任一情况，必须在新网卡或软件中修改 MAC 地址。</p>
<p>MAC 地址通常称为烧录地址(Built-in Address) (BIA)，因为传统上该地址被烧录到网卡的只读存储器（ROM）中。这意味着该地址会永久编码到 ROM 芯片中。</p>
<p><strong>注意</strong>: 在现代 PC 操作系统和网卡中，可以在软件中更改MAC 地址。当试图访问基于 BIA 进行过滤的网络时，这一点非常有用。因此，根据 MAC 地址来过滤或控制流量就不再安全了。</p>
<p>当计算机启动时，网卡将 MAC 地址从 ROM 复制到 RAM 中</p>
<p>收到以太网帧时，网卡会查看帧中的目的 MAC 地址是否与设备 RAM 中存储的物理 MAC 地址匹配。如果不匹配，设备就会丢弃帧。如果与帧中的目的 MAC 匹配，则网卡会将帧向上传送到 OSI 层进行解封处理。</p>
<p><em><strong>单播，广播，组播MAC地址</strong></em></p>
<p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p>
<p>以太网<strong>单播</strong> MAC 地址是帧从一台发送设备去往一台目的设备时使用的唯一地址</p>
<p>源主机用来确定目的IPv4地址所对应的目的 MAC 地址的流程称为**地址解析协议 (ARP)<strong>。源主机用来确定目的IPv6地址所对应的目的 MAC 地址的流程称为</strong>邻居发现 (ND)**。（参看TCP/IP）</p>
<p>以太网<strong>广播</strong>帧由以太网LAN上的每个设备接收和处理。以太网广播的功能如下：</p>
<ul>
<li>它有一个十六进制（在二进制中是 48 个 1）FF-FF-FF-FF-FF-FF的<strong>目的 MAC</strong> 地址。</li>
<li>它向除输入端口以外的所有以太网交换机端口泛洪。</li>
<li><strong>路由器不会转发该帧</strong>。</li>
</ul>
<p>IPv4 的 DHCP 是使用以太网和 IPv4 广播地址的一个协议示例。</p>
<p>以太网组播帧由属于同一组多播组的以太网LAN上的一组设备接收和处理。以太网组播的功能如下：</p>
<ul>
<li>当封装数据为IPv4组播包时，目的MAC地址为<strong>01-00-5E</strong>;<br>当封装数据为IPv6组播包时，目的MAC地址为<strong>33-33</strong>。</li>
<li>当封装的数据不是IP时，还有其他预留的组播目的MAC地址，<br>如生成树协议Spanning Tree Protocol(STP)和链路层发现协议Link Layer Discovery Protocol(LLDP)。</li>
<li>除非交换机被配置为用于组播窥探multicast snooping，否则它将向除传入端口之外的所有以太网交换机端口泛洪flooded out。</li>
<li>它不会由路由器转发，除非路由器配置为路由组播数据包。</li>
</ul>
<p>如果封装的数据是一个IP组播包，则属于组播组的设备都分配有该组播组IP地址。IPv4 组播地址（目的IP）的范围为 224.0.0.0 到 239.255.255.255。IPv6 组播地址的范围以 ff00::/8 开头。由于组播地址代表一组地址（有时称为主机组），因此只能用作数据包的目的地址。源地址始终应为单播地址。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>现在就该讨论交换机如何使用这些地址将帧转发(或丢弃)到网络上的其他设备。如果交换机只是转发出它接收到的每一帧到所有端口，您的网络将会非常拥挤，以至于它可能会完全停止工作。</p>
<p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，交换机<strong>仅根据第 2 层以太网 MAC 地址做出转发决策</strong>。这才实现了真正的分工和可复用</p>
<p>一个以太网交换机检查它的<strong>MAC地址表</strong>，为<strong>每个帧</strong>做出一个<strong>转发决策</strong>，不像传统的以太网集线器，向除了传入端口以外的所有端口重复发出比特位。</p>
<p><strong>注意</strong>: MAC 地址表有时也称为内容可寻址内存Content-addressable-memory (<strong>CAM</strong>) 表。虽然 CAM 表这一术语相当常见，但在本课程中，我们将称其为 MAC 地址表。</p>
<p><strong>交换机学习</strong></p>
<p>进入交换机的每个帧被检查，以确定其中是否有可被学习的新信息。它是通过<u>检查帧的源 MAC 地址和帧进入交换机的端口号来完成这一步的</u>。如果源 MAC 地址在该网络不存在（就是来自另一局域网），会将其和传入端口号一并添加到表中。如果源 MAC 地址已存在表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</p>
<p><strong>注意</strong>: 如果源 MAC 地址已经保存在表中，但是对应的是不同的端口，那么交换机会将其视为一个新的条目。使用相同的 MAC 地址和最新的端口号来<strong>替换</strong>该条目。</p>
<p><strong>转发Forward</strong></p>
<p>如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。如果表中存在该目的MAC地址，交换机会从指定端口转发帧。如果表中不存在该目的MAC地址，交换机会从除传入端口外的所有端口转发帧。这称为<strong>未知单播</strong>。</p>
<p><strong>注意</strong>: 如果目的 MAC 地址为广播或组播，该帧<strong>也将被泛洪</strong>到除传入端口外的所有端口。</p>
<p>如果一台设备的 IP 地址在远程网络上，则不能将以太网帧直接发送到目的设备。而是将以太网帧发送到默认网关（路由器）的 MAC 地址。</p>
<h3 id="交换机速率-转发方法"><a href="#交换机速率-转发方法" class="headerlink" title="交换机速率/转发方法"></a>交换机速率/转发方法</h3><p>对于思科交换机，实际上有两种帧转发的方法，根据具体情况，有充分的理由使用其中一种来代替另一种。</p>
<p>在过去，交换机使用下面的两种转发方法之一来进行网络端口间的数据交换：</p>
<ul>
<li><strong>存储转发交换</strong> - 这个帧转发的方法接收整个帧并计算CRC。CRC 根据帧中的比特位为 1 的位数量，使用数学公式来确定收到的帧是否有错。如果 CRC 有效，则交换机查找目的地址，目的地址决定了转发接口。帧然后从正确的端口转发出去。</li>
</ul>
<p>ps：<em>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 cyclic redundancy check (CRC) 值。此值将放入帧校验序列 (FCS) 字段 frame check sequence中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</em></p>
<ul>
<li><strong>直通交换</strong> - 这种帧转发的方法在收到整个帧之前即转发帧。在可以转发帧之前，至少必须读取帧的目的地址。</li>
</ul>
<p><strong>存储转发交换</strong>的一大优点是，它可以在传播帧之前确定帧是否有错误。当在帧中检测到错误时，交换机丢弃该帧。丢弃有错的帧可减少损坏的数据所耗用的带宽量。存储转发交换对于融合网络中的服务质量 (QoS) 分析是必需的，在融合网络中，<strong>必须对帧进行分类以划分流量优先级</strong>。如 IP 语音数据流的优先级需要高于 Web 浏览流量。</p>
<p><strong>直通交换</strong>中，交换机在收到数据时立即处理数据，即使传输尚未完成。交换机只缓冲帧的一部分，缓冲的量仅足以读取目的 MAC 地址，以便确定转发数据时应使用的端口。目的 MAC 地址位于帧中前导码后面的前 6 个字节。交换机在其交换表中查找目的 MAC 地址，确定转发端口，然后通过指定的交换机端口将帧转发到其目的地。交换机对该帧<strong>不执行任何错误检查。</strong></p>
<ul>
<li><strong>快速转发交换 -</strong> 快速转发交换提供最低程度的延时。快速转发交换在读取目的地址之后立即转发数据包。由于快速转发交换在收到整个数据包之前就开始转发，因此有时候中继数据包时会出错。这种情况并不经常发生，而且 <strong>目的网络适配器在收到含错数据包时会将其丢弃</strong>。在快速转发模式下，延时是指从收到第一个位到传出第一个位之间的时间差。快速转发交换是典型的直通交换方法。<strong>Fast-forward switching</strong></li>
<li><strong>免分片交换 -</strong> 在免分片交换中，交换机在转发之前存储帧的前 64 个字节，原因是，大部分网络错误和冲突都发生在前 64 个字节。免分片交换在转发帧之前对帧的前 64 个字节执行小错误检查以确保没有发生过冲突，并且尝试通过这种方法来增强快速转发交换功能。免分片交换是存储转发交换的高延时和高完整性与快速转发交换的<strong>低延时和弱完整性之间的折衷</strong>。<strong>Fragment-free switching</strong></li>
</ul>
<p>某些交换机可配置为按端口执行直通交换，当达到用户定义的错误阈值时，这些端口自动切换为存储转发。当错误率低于该阈值时，端口自动恢复到直通切换。（智能化）</p>
<h3 id="缓冲办法"><a href="#缓冲办法" class="headerlink" title="缓冲办法"></a>缓冲办法</h3><p>以太网交换机在转发帧之前，可以使用<strong>缓冲技术</strong>存储帧。当目的端口由于拥塞而繁忙时，也可以使用缓冲。交换机将帧存储起来，直到可以传输。</p>
<p>有两种内存缓冲方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基于端口的内存</strong></td>
<td align="left">帧存储在链接到特定传入端口和传出 端口的队列中。<br />只有当队列前面的所有帧都成功传输后， 才会将帧传输到传出端口。<br />由于目地端口繁忙， 单个帧可能会造成内存中所有帧的传输延迟。<br />即使其他帧可以传送到开放的目的端口， 这种延迟仍然会发生。</td>
</tr>
<tr>
<td align="left"><strong>共享内存</strong></td>
<td align="left">将所有帧存储到由所有交换端口共享的公共内存缓冲区中， 并且动态分配一个端口所需的 缓冲区内存量。<br />缓冲区中的帧动态地链接到目的端口， 允许在一个端口上接收数据包，然后 在另一个端口上发送，而无需移动到另一个队列。</td>
</tr>
</tbody></table>
<p>而且<strong>共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少</strong>。这对于<strong>非对称交换</strong>非常重要，因为它允许在不同端口上使用<strong>不同的数据速率</strong>，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p>
<p>交换机上<u>最基本的两个设置</u>是带宽(有时称为“速率”)和每个交换机端口的双工设置。交换机端口和连接的设备（例如计算机或另一台交换机）的双工设置和带宽设置必须匹配。</p>
<p><strong>自动协商</strong>是大多数以太网交换机和网卡的一项可选功能。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。</p>
<p><strong>注意</strong>: 大多数思科交换机和以太网网卡默认采用自动协商功能，以提高速率和实现双工。千兆以太网端口仅以全双工模式运行。</p>
<p>当链路上的一个或两个端口被重置时，会发生双工不匹配，自动协调过程并不会使链路上的两个端口的配置相同。<u>当用户重新配置链路的一端而忘记重新配置另一端时，也会出现这样的情况</u>。链路的两端均应都使用或都不使用自动协商。最佳实践是将两个以太网交换端口都配置为全双工。</p>
<h3 id="Auto-MDIX"><a href="#Auto-MDIX" class="headerlink" title="Auto-MDIX"></a>Auto-MDIX</h3><p><strong>注意</strong>: 路由器和主机之间的直连需要使用交叉线。</p>
<p>现在，大多数交换机设备都支持自动介质相关接口交叉 (auto-MDIX) 功能。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。因此，如果要连接到交换机上的铜缆 10/100/1000 端口，您既可以使用交叉线，也可以使用直通线，而无需考虑连接另一端的设备类型。</p>
<p>在运行思科 IOS Release 12.2(18)SE 或更高版本的交换机上，默认启用 auto-MDIX 功能。当然，该功能可以被禁用。因此，您应始终使用正确的线缆类型，而不是依赖auto-MDIX 功能。Auto-MDIX 可以使用接口配置命令 <strong>mdix auto</strong> 重新启用。</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>要向<strong>不在本地网络</strong>上的任何人发送电子邮件（视频或文件等），您必须能够访问路由器。要访问路由器，您必须使用网络层协议。</p>
<h2 id="网络层特征"><a href="#网络层特征" class="headerlink" title="网络层特征"></a>网络层特征</h2><p>网络层即 OSI 第 3 层，提供能够<em><strong>让终端设备跨整个网络交换数据的服务</strong></em></p>
<p>IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括路由协议，如开放式最短路径优先协议(OSPF)，和消息传递协议，如Internet控制消息协议(ICMP)。</p>
<p>为了实现跨网络边界的端到端通信，网络层协议执行四个基本操作:</p>
<ul>
<li><strong>终端设备编址</strong> - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li>
<li><strong>封装</strong> - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</li>
<li><strong>路由</strong> - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是<strong>为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由</strong>。数据包可能需要经过很多路由器才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</li>
<li><strong>解封</strong> - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</li>
</ul>
<p>传输层（OSI 第 4 层）负责管理 <strong>每台主机上的运行进程之间的数据传输</strong> (  原来如此！)，而网络层通信协议（即，IPv4和IPv6）则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。网络层工作时<strong>无需考虑每个数据包中所携带的数据</strong>，这使其能够为多台主机之间的多种类型的通信传送数据包</p>
<p><strong>逐层封装数据的流程使我们可以开发和扩展位于不同层的服务而不影响其他层</strong>。这意味着传输层数据段可以随时通过 IPv4 或 IPv6 进行封装，或使用未来可能开发出的任何新协议进行封装。</p>
<p>从数据包离开源主机到达目的主机之前，IP编址信息保持不变，除非是由为IPv4执行网络地址转换(NAT)的设备进行转换。</p>
<h3 id="IP的基本特征"><a href="#IP的基本特征" class="headerlink" title="IP的基本特征"></a><em><strong>IP的基本特征</strong></em></h3><p>IP 被设计为一种<strong>低开销</strong>协议。它只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。并不负责跟踪和管理数据包的流动。这些功能（如果需要）将由其他层的其他协议（主要是第 4 层的 TCP）执行。</p>
<p>IP的基本特征：</p>
<ul>
<li><strong>无连接</strong> - 发送数据包前不与目的地建立连接。IP 在转发数据包前，并不需要初步交换控制信息来创建端到端连接。</li>
<li><strong>尽力而为</strong> - IP本质上是<strong>不可靠</strong>的，因为不保证数据包交付。IP 也不需要报头中包含其他字段来维持建立的连接。此过程显著降低了 IP 的开销。但是，由于没有预先建立端到端连接，发送数据包时，发送方不知道目的地是否存在和正常运行，同时发送数据包时，也不会知道目的地是否接收数据包，或者，目的设备是否可以访问并读取数据包。确认由其他协议负责</li>
<li><strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。如果数据包顺序错乱或丢失，则使用数据或上层服务的应用程序必须解决这些问题。这让 IP 可以非常有效地发挥作用。在 TCP/IP 协议簇中，可靠性是TCP协议在传输层的功能。IP 数据包既可以作为电信号通过铜缆传送，也可以作为光信号通过光纤传送或作为无线电信号无线传送。</li>
</ul>
<p>但是，网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (MTU)。数据链路层和网络层之间的部分控制通信就是确定数据包的最大尺寸<strong>。数据链路层将 MTU 值向上传送到网络层</strong>。网络层会由此确定可以传送的数据包的大小。</p>
<p>有时，中间设备（通常是路由器），在将IPv4数据包从一个介质转发到具有更小 MTU 的介质时，必须分割数据包。此过程称为数据包分片或分片。<strong>分片会导致延迟。IPv6 数据包不能被路由器分片。</strong></p>
<p>OSI传输层发送被封装在IPv4或IPv6包中的数据段</p>
<p>OSI数据链路层负责接收数据包并准备数据包以在通信介质上传输</p>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><h3 id="IPv4数据包"><a href="#IPv4数据包" class="headerlink" title="IPv4数据包"></a>IPv4数据包</h3><p>IPv4 是主要网络层通信协议之一。IPv4 数据包报头用于确保此数据包在到达目的地终端设备的路上被传递到其下一站。</p>
<p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233828847.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314233849824.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314234312571.png"></p>
<p>互联网报头长度 (IHL)、总长度和报头校验和字段用于识别和验证数据包。</p>
<p>其他字段用于重新排列分段的数据包。具体而言，IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段。路由器从一种介质向具有较小 MTU 的另一种介质转发IPv4数据包时必须将它分片。</p>
<p>注意：选项和填充字段很少使用，因此不在本模块的介绍范围之内。</p>
<p><em><strong>8.2.3的视频描述wireshark中检测IPv4报头非常好！</strong></em></p>
<h3 id="IPv6数据包"><a href="#IPv6数据包" class="headerlink" title="*IPv6数据包"></a>*IPv6数据包</h3><p>IPv6它最终将取代 IPv4</p>
<p>多年来，为应对新的挑战，已经制定了附加议定书和规程。但是，尽管经历了多次变更，IPv4 仍然有三个重要问题：</p>
<ul>
<li><strong>IPv4地址耗尽 -</strong> IPv4 的可用唯一公有地址数量有限。尽管有大约 40 亿的 IPv4 地址，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li>
<li><strong>缺乏端到端连接 -</strong> 网络地址转换 (NAT) 是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li>
<li><strong>增加的网络复杂性</strong> - 虽然NAT延长了IPv4的寿命，但它只是作为一种过渡到IPv6的机制。NAT在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。</li>
</ul>
<p>IPv6 的功能提升包括以下：</p>
<ul>
<li><strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li>
<li><strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</li>
<li><strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</li>
</ul>
<p>32 位的 IPv4 地址空间提供大约 4,294,967,296 个地址。IPv6 地址空间提供 340,282,366,920,938,463,463,374,607,431,768,211,456 个或 340 涧（10 的 36 次方）个地址。这大致相当于地球上的每一粒沙子。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210314235834424.png"></p>
<p>IPv6 较 IPv4 的一个重大改进是简化的 IPv6 报头。</p>
<p>例如，IPv4 报头包含 20 个二进制八位组的可变长度报头（如果使用“选项”字段，则高达 60 字节）和 12 个基本报头字段（不包括“选项”字段和“填充”字段）。</p>
<p>对于 IPv6，某些字段保持不变，某些字段的名称和位置发生了变化，而某些 IPv4 字段不再需要，正如图中突出显示。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000426978.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000511899.png"><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315000554634.png"></p>
<p>共40个八位组，8个报头字段</p>
<h2 id="主机路由方式"><a href="#主机路由方式" class="headerlink" title="主机路由方式"></a>主机路由方式</h2><p>对于IPv4和IPv6，数据包总是在源主机上创建。源主机必须能够将数据包定向到目的主机。为此，<strong>主机终端设备将创建自己的路由表</strong>。本主题讨论终端设备如何使用路由表。</p>
<p>网络层的另一个作用是在主机之间转发数据包。主机可以将数据包发送至如下：</p>
<ul>
<li><strong>主机自己</strong> - 主机可以通过向特定的地址发送数据包来向自己发起ping测试，这个特定的地址是：IPv4地址127.0.0.1，或者IPv6地址 ::1，它被称为<strong>环回接口</strong>。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</li>
<li><strong>本地主机</strong> - 目的主机与发送主机位于同一本地网络。源和目的主机共享同一个网络地址。</li>
<li><strong>远程主机</strong> - 这是位于远程网络上的目的主机。源和目的主机不共享同一个网络地址。</li>
</ul>
<p>数据包是要发送到本地主机还是远程主机是由源端设备决定的。源端设备确定目的 IP 地址是否与源设备本身所在的网络相同。确定方法因 IP 版本不同而异：</p>
<ul>
<li><strong>在 IPv4 中</strong> -源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址来进行此判断。</li>
<li><strong>在 IPv6 中</strong> -本地路由器将<strong>本地网络地址</strong>（前缀）通告给网络上的所有设备</li>
</ul>
<p>在家庭或企业网络中，您可能有若干通过中间设备（LAN 交换机和/或无线接入点 (WAP) 等）互联的有线和无线设备。这种中间设备在本地网络上的本地主机之间提供互联服务。本地主机可以互相访问和共享信息，无需任何附加设备。如果主机要将数据包发送到与本主机在同一 IP 网络中的设备，<strong>则数据包仅是被转发出主机接口，然后经过中间设备即可直接到达目的设备（不必经手路由器）。</strong></p>
<p>当然，在大多数情况下我们希望我们的设备不仅仅能够连接本地网段，还能连接其他家庭、企业和互联网。位于本地网段外的设备称为远程主机。如果源设备发送数据包到远程目的设备，则需要借助路由器和路由。路由是确定到达目的地之最佳路径的过程。<strong>连接到本地网段的路由器称为默认网关Defalut Gateway。</strong></p>
<p><strong>默认网关</strong></p>
<p>Default Gateway是可以将流量路由到其他网络的网络设备(即，路由器或第3层交换机)。如果把一个网络比作一个房间，那么默认网关就好比是门口。如果要去另一个房间或网络，您就需要找到门口。</p>
<p>在网络上，默认网关通常是具有以下功能的路由器：</p>
<ul>
<li>它拥有与本地网络其他主机位于相同地址范围的本地 IP 地址。</li>
<li>它可以接受数据到本地网络，并将数据转发出本地网络。</li>
<li>它向其他网络路由流量。</li>
</ul>
<p>需要使用默认网关来发送本地网络之外的流量。如果没有默认网关、未配置默认网关地址或默认网关关闭，则无法将流量转发到本地网络之外。</p>
<p>主机的路由表通常包括默认网关。在IPv4中，主机通过动态主机配置协议 (DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以在主机上手动配置。</p>
<p><strong>配置默认网关会在 PC 的路由表中创建一个默认路由</strong>。默认路由是计算机尝试联系远程网络时所用的路由或路径。</p>
<h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><p>当数据包到达路由器接口时会发生什么?</p>
<p>路由器会检查数据包的目的 IP 地址并搜索其路由表以确定将数据包转发到何处。路由表包含所有<strong>已知网络地址（前缀）以及数据包转发位置</strong>的列表。这些条目称为路由条目或路由。路由器将使用最佳（最长）匹配的路由条目转发数据包。</p>
<p>路由表存储三种类型的路由条目：</p>
<ul>
<li><strong>直连网络-</strong> 这些网络路由条目是活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。每个路由器接口均连接到一个不同的网段。在图中，R1 IPv4路由表中的直连网络为192.168.10.0/24和209.165.200.224/30。</li>
<li><strong>远程网络</strong> - 这些网络路由条目连接到其他路由器。路由器通过由管理员明确配置或使用动态路由协议交换路由信息来学习远程网络。在图中，R1 IPv4路由表中的远程网络为10.1.1 /24。</li>
<li><strong>默认路由</strong> -像主机一样，大多数路由器还包含默认路由条目，即默认网关。<strong>当IP路由表中没有更好(更长)的匹配时，将使用默认路由</strong>。在图中，R1 IPv4路由表很可能包含一个将所有数据包转发到路由器R2的默认路由。</li>
</ul>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315124026095.png"></p>
<p>路由器可通过两种方式获知远程网络：</p>
<ul>
<li><strong>手动</strong> - 使用静态路由将远程网络手动输入到路由表中。</li>
<li><strong>动态</strong> - 使用动态路由协议自动学习远程路由。</li>
</ul>
<p><em><strong>静态路由</strong></em></p>
<p>手动配置的路由条目</p>
<p>静态路由包括远程网络地址和下一跳路由器的IP地址。</p>
<p>ip route 远程网络地址 下一跳路由器的IP地址</p>
<p>静态路由具有以下特征：</p>
<ul>
<li>必须手动配置静态路由。</li>
<li>如果拓扑发生变化，且静态路由不再可用，则管理员需要重新配置静态路由。</li>
<li>静态路由适用于小型网络且当冗余链路很少或没有冗余链路的情况。</li>
<li>静态路由通常与动态路由协议一起用于配置默认路由。</li>
</ul>
<p><em><strong>动态路由</strong></em></p>
<p>动态路由协议可让路由器从其他路由器那里自动学习远程网络，包括默认路由。如果使用动态路由协议，则路由器无需网络管理员的参与，即可自动与其它路由器共享路由信息并对拓扑结构的变化作出反应。如果网络拓扑发生变化，路由器将使用动态路由协议共享此信息，并自动更新路由表。</p>
<p>动态路由协议包括OSPF（开放最短路径优先协议）和增强型内部网关路由协议 (EIGRP)，e.g.</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802143704.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802143704.png&quot;</a> “ style=”zoom: 80%;” /&gt;</p>
<p>基本配置只需要网络管理员在动态路由协议中启用直连网络。动态路由协议将自动执行如下操作：</p>
<ul>
<li>发现远程网络</li>
<li>维护最新路由信息</li>
<li>选择通往目的网络的最佳路径</li>
<li>当前路径无法再使用时尝试找出新的最佳路径</li>
</ul>
<p>当使用静态路由手动配置路由器或使用动态路由协议动态学习远程网络时，远程网络地址和下一跳地址将被输入到IP路由表中。如图所示，如果网络拓扑发生变化，路由器将自动调整并尝试找到新的最佳路径。（R1,2,3正在使用动态路由协议OSPF）</p>
<p>&lt;img src=”<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315124816720.png&quot;">https://gitee.com/darren-greenhand//picture/raw/master/image-20210315124816720.png&quot;</a> “ style=”zoom:80%;” /&gt;</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210315125544736.png"></p>
<p><em><strong>8.5.5大致介绍挺好的</strong></em></p>
<p>每个路由表条目的开头都有一个代码，用于标识路由的类型或路由的学习方式。常见路由源（代码）包括以下内容：</p>
<ul>
<li><strong>L</strong> - 该网络所直连的它的本地接口的 IP 地址</li>
<li><strong>C</strong> - 直连网络</li>
<li><strong>S</strong> - 静态路由由管理员手动配置</li>
<li><strong>O</strong> - OSPF</li>
<li><strong>D</strong> - EIGRP</li>
</ul>
<p>默认路由具有全都是零的网络地址。例如，IPv4 网络地址为 0.0.0.0。路由表中的静态路由条目以 S\ * 的代码开头</p>
<h1 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h1><p>主机和路由器都创建路由表，以确保它们可以跨网络发送和接收数据。那么这些信息是如何在路由表中被创建的呢? 作为网络管理员，您可以手动输入这些 MAC 和 IP 地址。但这将花费大量时间，而且犯一些错误的可能性很大。您是否认为一定有某种方式，由主机和路由器可以自动完成? 当然，您是对的！即使它是自动的，您仍然必须要了解它是如何工作的，因为您可能会需要排除一些故障，或更糟的是，您的网络可能会受到威胁发起者的攻击。</p>
<p>（复习）以太网 LAN 上的设备都配有两个主要地址：</p>
<ul>
<li><strong>物理地址（MAC 地址）</strong> – 用于同一网络上的以太网网卡之间的通信。</li>
<li><strong>逻辑地址（IP地址）</strong> – 用于将数据包从源设备发送到目的设备。目的IP地址可能与源地址在同一个IP网络上，也可能在远程网络上。</li>
</ul>
<p>第二层物理地址(即以太网MAC地址)用于将数据链路层帧从同一网络中一个网卡发送到另一个网卡， IP 数据包就封装在帧中。<br>如果目的IP地址在同一网络上，则目的MAC地址将是目的设备的MAC地址。<br>当目的 IP 地址(IPv4或IPv6)处于远程网络中时，则目的 MAC 地址为主机的默认网关的地址(即路由器接口)</p>
<p>数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过地址解析协议 (ARP) 过程来完成。对于IPv6数据包，这个过程是ICMPv6邻居发现(ND)。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>IPv4当将帧发送到另一个远程网络时，只知道IP地址，要获得MAC地址得使用ARP帮助</p>
<p>设备使用地址解析协议(ARP)来确定一个已知 IPv4 地址的本地设备的目的MAC地址。</p>
<p>ARP 提供两个基本功能：</p>
<ul>
<li>将 IPv4 地址<strong>解析</strong>为 MAC 地址</li>
<li><strong>维护IPv4到MAC地址映射表</strong></li>
</ul>
<p>当数据包发送到要封装入以太网帧的数据链路层时，设备将参照其<strong>内存中的表来</strong>查找映射至 IPv4 地址的 MAC 地址。此表临时存储在<strong>RAM</strong>内存中，称为 ARP 表或 ARP 缓存。</p>
<p><strong>发送设备</strong>首先会在自己的 ARP 表中搜索目的 IPv4 地址和相应的 MAC 地址。</p>
<ul>
<li>如果数据包的目的 IPv4 地址与源 IPv4 地址处于同一个网络，则设备会在 ARP 表中搜索目的 IPv4 地址。</li>
<li>如果目的 IPv4 地址与源 IPv4 地址不在同一个网络中，则设备会在 ARP 表中搜索默认网关的 IPv4 地址。</li>
</ul>
<p>这两种情况都是搜索设备的 IPv4 地址和与其相对应的 MAC 地址。</p>
<p>ARP 表中的每一条（或每行）将一个 IPv4 地址与一个 MAC 地址绑定。我们把两个值之间的关系称为<strong>映射</strong>。这意味着您可以在表中查找 IPv4 地址并发现相应的 MAC 地址。ARP 表暂时保存（缓存）LAN 上设备的映射。</p>
<p><em><strong>ARP 请求。</strong></em></p>
<p>当设备需要确定与 IPv4 地址关联的 MAC 地址，而它的 ARP 表中没有该 IPv4 地址条目时，会发送一个 ARP 请求。</p>
<p><strong>ARP 消息直接封装到以太网帧中。没有 IPv4 报头</strong>。ARP 请求使用以下帧头信息封装在以太网帧中：</p>
<ul>
<li><strong>目的 MAC 地址</strong> – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的<strong>广播地址FF-FF-FF-FF-FF-FF</strong>。</li>
<li><strong>源 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li>
<li><strong>类型</strong> - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</li>
</ul>
<p>因为 ARP 请求属于广播，交换机会将其泛洪到除接收端口外的其他所有端口。局域网上的所有以太网网卡都会处理广播，并且必须将ARP请求发送到其操作系统进行处理。每台设备必须处理 ARP 请求，以检查目的 IPv4 地址是否与其自己的地址相匹配。<strong>路由器不会将广播转发到其他接口。</strong></p>
<p><em><strong>ARP应答</strong></em></p>
<p>LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应答。</p>
<p>只有具有与ARP请求相应的目的IPv4地址的设备才会以ARP应答做出响应。ARP 应答使用以下帧头信息封装在以太网帧中：</p>
<ul>
<li><p><strong>目的 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</p>
</li>
<li><p><strong>源 MAC 地址</strong> – 这是ARP应答发送方的MAC地址。</p>
</li>
<li><p><strong>类型</strong> – ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</p>
<p> 只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。该 IPv4 地址的数据包现在便可使用其相应的 MAC 地址封装在帧中。</p>
<p> 如果没有设备响应 ARP 请求，就无法创建帧，<u>那么这个数据包会被丢弃</u>。</p>
</li>
</ul>
<p>对于每台设备，ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目。时间根据设备的操作系统不同而不同。例如，较新的 Windows 操作系统将 ARP 表条目<strong>存储 15 秒到 45 秒</strong>之间</p>
<p>也可以使用命令来手动删除 ARP 表中的部分或全部条目。当条目被删除之后，要想在 ARP 表中输入映射，必须重复一次发送 ARP 请求和接收 ARP 回复的过程。</p>
<p>作为<strong>广播帧（IPv6是组播）</strong>，本地网络上的每台设备都会收到并处理 ARP 请求。在一般的商业网络中，这些广播对网络性能的影响可能微不足道。但是，如果大量设备都已启动，并且同时开始使用网络服务，网络性能可能会有短时间的下降。在设备发出初始 ARP 广播并获取必要的 MAC 地址之后，网络受到的影响将会降至最小。</p>
<p>有时，使用 ARP 可能会造成潜在的安全风险。威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。如图所示，威胁发起者使用这种技术来应答属于另一台设备（例如默认网关）的 IPv4 地址的 ARP 请求。威胁发起者会发送一个带有自己 MAC 地址的 ARP 应答。ARP 应答的接收方会将错误的 MAC 地址添加到其 ARP 表中，并将这些数据包发送给威胁发起者。 企业级的交换机包含称为动态 ARP 检查 (DAI) 的缓解技术。DAI 不在本课程的讨论范围之内。</p>
<h2 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h2><p>IPv6 邻居发现协议有时被称为 ND 或 NDP。在本课程中，我们称它为 ND。ND使用ICMPv6为IPv6提供<strong>地址解析、路由器发现和重定向服务</strong>。ICMPv6 ND 使用五种 ICMPv6 消息来执行这些服务：</p>
<ul>
<li>邻居请求消息</li>
<li>邻居通告消息</li>
<li>路由器请求消息</li>
<li>路由器通告消息</li>
<li>重定向消息</li>
</ul>
<p><strong>邻居请求和邻居通告消息</strong>用于<strong>设备到设备</strong>的消息传递，例如地址解析（类似于 IPv4 的 ARP）。设备包括主机计算机和路由器。如果在neighrbor表中没找到目标IPv6条目：</p>
<p>&lt;img src=”<a href="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802152908.png&quot;">https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802152908.png&quot;</a> “ style=”zoom: 33%;” /&gt;</p>
<p>它会从on hold的IPv6信息中得到目标IPv6地址，映射为特定的IPv6组播，再映射为特定的MAC组播，在这个过程中比起ARP广播缩小了范围，而且如果没有匹配的，会直接丢弃，不把他传给上层进程，这也是优于IPv4的。</p>
<p><strong>路由器请求和路由器通告消息</strong>用于设备和路由器之间的消息传递。通常，路由器发现用于<em><strong>动态地址分配和无状态地址自动配置 (SLAAC)。</strong></em></p>
<p><strong>注意</strong>: 第五个 ICMPv6 ND 消息是一个重定向消息，用于更好的下一跳选择。这不在本课程的讨论范围之内。</p>
<p>IPv6 ND 是在 IETF RFC 4861 中定义的。</p>
<p>ICMPv6 邻居请求和邻居通告消息用于MAC地址解析。这类似于ARP用于IPv4的ARP请求和ARP应答</p>
<p><strong>ICMPv6邻居请求消息使用特定的以太网和IPv6 组播 而不是广播地址发送。这允许接收设备的以太网卡确定邻居请求消息是否属于它自己，而不必将它发送到操作系统进行处理。</strong></p>
<h1 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在路由器上配置初始设置时，应完成以下任务。</p>
<ol>
<li>配置设备名称。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config)# hostname hostname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>保护特权模式。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config)# enable secret password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>保护用户模式</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config)# line console 0
Router(config-line)# password password
Router(config-line)# login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>保护远程 Telnet / SSH 访问</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config-line)# line vty 0 4
Router(config-line)# password password
Router(config-line)# login
Router(config-line)# transport input &#123;ssh | telnet&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="5">
<li>保护配置文件中的所有密码。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config-line)# exit
Router(config)# service password-encryption<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li>提供法律通知。</li>
</ol>
<p>法律通知警告用户只能由允许用户访问该设备。法律通知配置如下。</p>
<pre class="line-numbers language-none"><code class="language-none">R1(config)# banner motd #
Enter TEXT message. End with a new line and the #
*********************************************** 
WARNING: Unauthorized access is prohibited!
***********************************************
#
R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="7">
<li>保存配置。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Router(config)# end
Router# copy running-config startup-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="配置接口"><a href="#配置接口" class="headerlink" title="配置接口"></a>配置接口</h2><p>下一步将配置它们的接口。这是因为在配置接口之前，终端设备无法访问路由器。</p>
<p>配置路由器接口的任务与交换机上管理 SVI 非常相似。具体来说，它包括发出以下命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router(config)# interface type-and-number
Router(config-if)# description description-text
Router(config-if)# ip address ipv4-address subnet-mask
Router(config-if)# ipv6 address ipv6-address&#x2F;prefix-length
Router(config-if)# no shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此表总结了用于验证接口配置的更常用 <strong>show</strong> 命令。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>**show ip interface brief****show ipv6 interface brief**</code></td>
<td align="left">所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</td>
</tr>
<tr>
<td align="left"><code>**show ip route****show ipv6 route**</code></td>
<td align="left">显示存储在 RAM 中的 IP 路由表的内容。</td>
</tr>
<tr>
<td align="left"><code>**show interfaces**</code></td>
<td align="left">显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</td>
</tr>
<tr>
<td align="left"><code>**show ip interface**</code></td>
<td align="left">显示路由器上所有接口的 IPv4 统计信息。</td>
</tr>
<tr>
<td align="left"><code>**show ipv6 interface**</code></td>
<td align="left">显示路由器上所有接口的 IPv6 统计信息。</td>
</tr>
</tbody></table>
<h2 id="配置默认网关"><a href="#配置默认网关" class="headerlink" title="配置默认网关"></a>配置默认网关</h2><p>如果您的本地网络只有一个路由器，它就将是网关路由器，并且必须使用此信息配置网络上的所有主机和交换机。如果您的本地网络有多个路由器，则必须选择其中一个作为默认网关路由器</p>
<p>连接客户端计算机的交换机通常是第 2 层设备。因此，第 2 层交换机不需要使用 IP 地址就能正常工作。但是，可以在交换机上配置 IP 配置，以便管理员能够远程访问交换机。</p>
<p>要通过本地 IP 网络连接和管理交换机，必须配置交换机虚拟接口 (SVI)。SVI 配置了本地局域网上的 IPv4 地址和子网掩码。要从远端网络管理交换机，必须给交换机配置一个默认网关。</p>
<p><strong>在会通过本地网络之外的方式通信的所有设备上，一般都会配置默认网关地址。</strong></p>
<p>要为交换机配置默认网关，请使用<strong>ip default-gateway</strong> ip-address 全局配置命令。配置的 IP 地址是连接到交换机的本地路由器接口的 IP 地址。</p>
<p>也可以使用 SVI 上的 IPv6 地址配置工作组交换机。但是，<strong>交换机不需要手动配置默认网关的 IPv6 地址。</strong>交换机将自动接收来自路由器的 ICMPv6 路由器公告消息的默认网关。</p>
<h2 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h2><p>您将使用的故障排除方法包含以下步骤：</p>
<p>a. 验证网络文档，并使用测试来查明问题。 </p>
<p>b. 为查明的问题确定一个适当的解决方案。 </p>
<p>c. 实施解决方案。 </p>
<p>d. 进行测试以验证问题是否已解决。</p>
<p> e. 记录解决方案。</p>
<p>在整个 CCNA 学习过程中，您会遇到不同的 故障排除方法，以及测试 并记录问题和解决方案的不同方法。这是有意设计的。故障排除没有固定的 标准或模板。每个组织都制定了独特的 流程和文档标准（有时候，一个组织的流程就是“我们没有 固定流程”）。但是，所有有效的故障排除方法通常都包括 上述步骤。</p>
<p>注意：通常不止一个解决方案。但是，排除故障的最佳做法是每次实施和验证一个解决方案。在更复杂的 情形中，实施多个解决方案会导致其他问题。</p>
<h1 id="IPv4编制"><a href="#IPv4编制" class="headerlink" title="IPv4编制"></a>IPv4编制</h1><p>目前，仍有大量使用IPv4编址的网络，即这些组织正在向IPv6过渡。因此，对于网络管理员来说，了解有关IPv4编址的所有信息仍然非常重要。本模块详细介绍了IPv4编址的基本方面。它包括了如何将网络划分为子网，以及如何创建一个变长子网掩码 (VLSM) 作为整体IPv4编址方案的一部分。子网划分就像把一个饼切成越来越小的块。</p>
<h2 id="地址编制"><a href="#地址编制" class="headerlink" title="地址编制"></a>地址编制</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802160937.png"></p>
<p>对于同一网络中的所有设备，地址的网络部分中的位必须完全相同。地址的主机部分中的位必须唯一，这方便识别网络中的特定主机。如果两台主机在 32 位数据流中的指定网络部分有相同的位模式，则这两台主机位于同一网络。但是，主机如何知道 32 位数据流中的哪一部分用于标识网络，哪一部分用于标识主机呢？这就是子网掩码的作用。</p>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码是一个1位连续序列，后面跟有一个0位连续序列组成的序列。</p>
<p>为了确定 IPv4 地址的网络部分和主机部分，要将子网掩码与 IPv4 地址进行从左到右逐位比较（如图所示）。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802161118.png"  style="zoom:67%;" />

<p>子网掩码实际上不包含 IPv4 地址的网络部分或主机部分，它仅通知计算机在哪里查找IPv4地址的网络部分和主机部分。</p>
<p>用于确定网络部分和主机部分的实际流程叫做 AND 运算。</p>
<h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>使用点分十进制子网掩码地址表示网络地址和主机地址会变得很麻烦。幸运的是，还有另一种识别子网掩码的方法，称为前缀长度。前缀长度是子网掩码中设置为 1 的位数。使用“斜线记法”写入，即“/”紧跟设置为 1 的位数。借此计算子网掩码中的位数，并在前面加斜线表示。</p>
<p>长度的多少取决于网络的规模</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802161306.png"  style="zoom:67%;" />

<p>当使用前缀长度表示 IPv4 地址时，IPv4 地址后面写入不带空格的前缀长度。例如192.168.10.10 255.255.255.0可以写成192.168.10.10/24。后面将讨论各种类型前缀长度的使用。目前重点是 /24（例如 255.255.255.0）前缀。</p>
<p>网络地址是表示特定网络的地址。如果设备满足以下三个条件，则属于此网络：</p>
<ul>
<li>它具有与网络地址相同的子网掩码。</li>
<li>它具有与网络地址相同的网络位，如子网掩码所示。</li>
<li>它与具有相同网络地址的其他主机位于同一广播域中。</li>
</ul>
<p>主机通过在其 <u>IPv4 地址与其子网掩码之间执行一个AND运算来确定其网络地址。</u></p>
<p>如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813113919883.png" alt="image-20210813113919883"></p>
<h3 id="单播、组播、广播"><a href="#单播、组播、广播" class="headerlink" title="单播、组播、广播"></a>单播、组播、广播</h3><p>IPv4 单播主机地址的地址范围是 1.1.1.1到 223.255.255.255。不过，此范围中的很多地址被留作特殊用途。这些特殊用途的地址将在本模块后续部分讨论。</p>
<p>广播数据包以主机部分全部为 1 的地址<strong>或32个1位</strong>作为目的 IP地址。</p>
<p><strong>注意:</strong> IPv4使用广播数据包但是，IPv6没有广播数据包。</p>
<p>广播数据包必须由同一广播域中的所有设备处理。广播域标识同一网段上的所有主机。可以对广播进行定向或限制。定向广播是将数据包发送给特定网络中的所有主机。例如，位于 172.16.4.0/24 网络的主机向 172.16.4.255 发送数据包。受限广播将被发送至 255.255.255.255。<strong>默认情况下，路由器不转发广播。</strong></p>
<p>广播数据包使用网络上的资源，使网络上的所有接收主机都处理该数据包。因此，广播通信应加以限制，以免对网络或设备的性能造成负面影响。因为路由器可分隔广播域，所以细分网络可以通过消除过多的广播通信来提高网络性能。</p>
<p><strong>IP直接广播</strong></p>
<p>除了 255.255.255.255 的广播地址外，每个网络还有一个广播 IPv4 地址。这个地址称为<strong>定向广播</strong>，它使用网络范围内的最大地址，即所有主机位全部为 1 的地址。例如，网络192.168.1.0/24的定向广播地址是192.168.1.255。此地址允许与该网络中的所有主机进行通信。要向网络中的所有主机发送数据，主机只需以该网络广播地址为目标地址发送一个数据包即可。</p>
<p><strong>未直接连接到目标网络的设备</strong>转发 IP 定向广播，其方式与转发去往网络上主机的单播 IP 数据包相同。<u>当定向广播数据包到达直接连接到目标网络的路由器时，该数据包在目标网络上进行广播</u>。</p>
<p>主机通过组播传输可以向所属组播组中的选定主机组发送一个数据包，从而减少了流量。</p>
<p>组播数据包是一个目的IP地址为组播地址的数据包。IPv4 将 224.0.0.0 到 239.255.255.255 的地址保留为组播范围。</p>
<p>接收特定组播数据包的主机称为组播客户端。组播客户端使用客户端程序请求的服务来加入组播组。每个组播组由一个 IPv4 组播目的地址代表。当 IPv4 主机加入组播组后，<strong>该主机既要处理目的地址为此组播地址的数据包，也要处理发往其唯一单播地址的数据包。</strong></p>
<p>路由协议（如 OSPF）使用组播传输。例如，启用 OSPF 的路由器使用保留的 OSPF 组播地址 224.0.0.5 相互通信。只有启用 OSPF 的设备才会以 224.0.0.5 作为目的 IPv4 地址处理这些数据包。所有其他设备将忽略这些数据包。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802163316.png"  style="zoom:50%;" />

<h2 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h2><p>一些 IPv4 地址不能用于外联到互联网，而其他地址则专门用于路由到互联网。一些用于验证连接，另一些则是自分配的。</p>
<p>公有 IPv4 地址是能在 ISP（互联网运营商）路由器之间全局路由的地址。但是，并非所有可用的 IPv4 地址都可用于互联网。<strong>大多数组织</strong>使用称为私有地址的地址块向内部主机分配 IPv4 地址。</p>
<p>20 世纪 90 年代中期，随着万维网(WWW)的引入，由于 IPv4 地址空间耗尽，引入了私有 IPv4 地址。私有 IPv4 地址并不是唯一的，可以在任何网络内部使用它。</p>
<p><strong>注意</strong>: 私有地址在 RFC 1918 中定义，有时也称为 RFC 1918 地址空间。</p>
<h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><p>私有地址块</p>
<table>
<thead>
<tr>
<th align="left"><strong>网络地址和前缀</strong></th>
<th align="left"><strong>RFC 1918 私有地址范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">10.0.0.0/8</td>
<td align="left">10.0.0.0 - 10.255.255.255</td>
</tr>
<tr>
<td align="left">172.16.0.0/12</td>
<td align="left">172.16.0.0 - 172.31.255.255</td>
</tr>
<tr>
<td align="left">192.168.0.0/16</td>
<td align="left">192.168.0.0 - 192.168.255.255</td>
</tr>
</tbody></table>
<p><strong>注意</strong>: 私有地址在 RFC 1918 中定义，有时也称为 RFC 1918 地址空间。</p>
<p>在 ISP 可以转发此数据包之前，它必须使用网络地址转换 (NAT) 将源 IPv4 地址（即私有地址）转换为公有 IPv4 地址。<strong>NAT用于转换私有和公有 IPv4 地址</strong>。这通常是在将内部网络连接到 ISP 网络的<strong>路由器上完成</strong>。在路由到互联网之前，组织内部网中的私有 IPv4 地址将被转换为公有 IPv4 地址。</p>
<p><strong>注意</strong>: 虽然具有私有 IPv4 地址的设备无法通过互联网从另一个设备直接访问，<u>但 IETF 并不认为私有 IPv4 地址或 NAT 是有效的安全措施。</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802181758.png"  style="zoom:67%;" />

<p>拥有可用于互联网的资源的组织（如 Web 服务器）也将拥有具有公有 IPv4 地址的设备。如图所示，该网络的这一部分被称为DMZ（非军事区）(demilitarized zone)。图中的路由器不仅执行路由，还执行 NAT 并充当安全防火墙。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802181935.png"  style="zoom:67%;" />



<h3 id="专用地址"><a href="#专用地址" class="headerlink" title="专用地址"></a>专用地址</h3><p><strong>环回地址</strong></p>
<p>环回地址（127.0.0.0 /8 或 127.0.0.1 到 127.255.255.254）通常仅被标识为127.0.0.1，主机使用这些特殊地址将流量指向其自身。例如，如图所示，主机可以使用这个特殊地址测试 TCP/IP 配置是否运行正常。注意 127.0.0.1 环回地址对 <strong>ping</strong> 命令的应答。</p>
<p><strong>本地链路地址</strong></p>
<p>本地链路地址（169.254.0.0 /16 或 169.254.0.1 至 169.254.255.254）通常称为自动私有 IP 编址 (APIPA) 地址或自分配地址。 当没有可用的DHCP服务器时，Windows DHCP客户端使用它们进行自我配置。本地链路地址可以用于点对点连接，但通常不用于此目的。</p>
<h3 id="传统有类编制"><a href="#传统有类编制" class="headerlink" title="传统有类编制"></a>传统有类编制</h3><p>二十世纪90年代中期，随着万维网 (WWW) 的引入，<strong>有类编址被弃用</strong>，以便更有效地分配有限的 IPv4 地址空间。有类地址分配被替换为今天使用的无类编址。无类编址会忽略A、B、C类的规则。公有 IPv4 网络地址（网络地址和子网掩码）是根据合理的地址数量分配的。</p>
<p>1981 年，使用在RFC 790 中(<a href="https://tools.ietf.org/html/rfc790">https://tools.ietf.org/html/rfc790</a>) Assigned Numbers 部分定义的有类编址对 IPv4 地址进行了分配。根据三个类别（A 类、B 类或 C 类）之一为客户分配网络地址。RFC 将单播范围分为具体的类别：</p>
<ul>
<li><strong>A 类 (0.0.0.0/8 - 127.0.0.0/8)</strong> - 用于支持拥有 1600 万以上主机地址的<strong>规模非常大的网络</strong>。A类的第一个八位组使用固定的 /8 前缀表示网络地址，其他的三个八位组表示主机地址(每个网络支持1600 万以上主机地址)。</li>
<li><strong>B 类 (128.0.0.0 /16 – 191.255.0.0 /16)</strong> - 用于支持拥有大约 65,000 个主机地址的<strong>大中型网络</strong>。B类的两个高位八位组使用固定的 /16 前缀表示网络地址，其他的两个八位组表示主机地址(每个网络支持65,000个以上主机地址)。</li>
<li><strong>C 类 (192.0.0.0 /24 – 223.255.255.0 /24)</strong> - 用于支持最多拥有 254 台主机的<strong>小型网络</strong>。C类的前三个八位组使用固定的 /24 前缀表示网络地址，其余的八位组表示主机地址（每个网络中只有254个主机地址）。</li>
</ul>
<p><strong>注意</strong>: 还有包含 224.0.0.0 到 239.0.0.0 的 D 类组播块以及包含 240.0.0.0 – 255.0.0.0 的 E 类实验地址块。</p>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>公有 IPv4 地址是能通过互联网全局路由的地址。公有 IPv4 地址必须是唯一的。</p>
<p>IPv4 和 IPv6 地址是通过<strong>互联网编号指派机构</strong> (IANA) 管理的。IANA 管理并向地区性互联网注册机构 (RIR) 分配 IP 地址块。图中显示了五个RIR。</p>
<p>RIR 的职责是向 ISP 分配 IP 地址，而 ISP 将向组织和更小的 ISP 提供 IPv4 地址块。根据 RIR 的政策规定，组织也可直接从 RIR 获取地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802183559.png"></p>
<h2 id="网络分段"><a href="#网络分段" class="headerlink" title="网络分段"></a>网络分段</h2><p>交换机会将广播传播到所有接口，接收它的接口除外。</p>
<p>路由器在收到广播时，它不会将其转发到其他接口。</p>
<p>因此，每个路由器接口都连接了一个广播域，而广播只能在特定广播域内传播。</p>
<p>大型广播域是连接很多主机的网络。大型广播域的一个问题是这些主机会生成太多广播，这会对网络造成不良影响。在图中，局域网1 连接了 400 个用户，可能会产生过量的广播流量。这会导致网络操作速度缓慢，因为它会导致大量的流量，而设备操作变慢是因为设备必须接受和处理每个广播数据包。</p>
<p>解决方案是使用称为“子网划分”的过程缩减网络的规模以<strong>创建更小的广播域。较小的网络空间通常称为“子网”</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210802213121.png" style="zoom:67%;" />

<p>注意，从一个单一的/16网络到两个/24网络前缀长度是如何变化的。这是基本的子网划分：使用主机位可以创建其他子网。</p>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>子网划分可以降低整体网络流量并改善网络性能。它也能让管理员实施安全策略，例如哪些子网允许或不允许进行通信。另一个原因是，它减少了由于错误配置、硬件/软件问题或恶意意图而受到异常广播流量影响的设备数量。</p>
<p>网络管理员可以使用<strong>对网络有意义的任何其他划分来创建子网</strong>。在每个图中，<strong>子网使用较长的前缀</strong>来标识网络。</p>
<p>比如可以 按照 <strong>位置、组或功能、设备类型</strong>划分</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210803094439.png"  style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210803094550.png" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210803094615.png"  style="zoom:67%;" />



<h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><h3 id="在二进制八位组边界上、内划分"><a href="#在二进制八位组边界上、内划分" class="headerlink" title="在二进制八位组边界上、内划分"></a>在二进制八位组边界上、内划分</h3><p>创建 IPv4 子网时会将一个或多个主机位作为网络位。具体做法是延长子网掩码，从地址的主机部分借用若干位来增加网络位。借用的主机位越多，可以定义的子网也就越多。为了增加子网数量而借用的位越多，每个子网的主机数量就越少。</p>
<p>网络在二进制八位数边界 /8、/16 和 /24 处最容易进行子网划分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817195419305.png" alt="image-20210817195419305"></p>
<p>​    请考虑以下示例。假设企业选择了私有地址 10.0.0.0/8 作为其内部网络地址。该网络地址可以在一个广播域中连接 16,777,214 个主机。显然，在一个子网上拥有超过 1600 万台主机并不理想。</p>
<p>企业可以进一步在二进制八位组边界 /16 处对 10.0.0.0/8 地址进行子网划分，如表所示。这能让企业定义多达 256 个子网（例如，10.0.0.0/16 – 10.255.0.0/16），每个子网可以连接 65,534 个主机。</p>
<p>另外，企业也可以选择在 /24 二进制八位组边界处对 10.0.0.0/8 网络进行子网划分，如表所示。这将让企业能定义 65,536 个子网，每个子网能连接 254 个主机。/24 边界在子网划分中使用非常广泛，因为它在这个二进制八位数边界处可以容纳足够多的主机，并且子网划分也很方便。</p>
<hr>
<p>到目前为止所展示的示例都是从常见的 /8、/16 和 /24 网络前缀借用了主机位。然而，子网可以从任何主机位借用位来创建其他掩码。</p>
<p>例如，/24 网络地址通常通过从第 4 个二进制八位数借用位来使用更长的前缀进行子网划分。这可以让管理员在将网络地址分配到更少数量的终端设备时具有很好的灵活性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817195732265.png" alt="image-20210817195732265"></p>
<p>可以用幻数（magic number 其实就是最后一位数字，按八位组分的）从0开始加上2的对应幂来列出所有的子网</p>
<h3 id="对私有、共有地址划分"><a href="#对私有、共有地址划分" class="headerlink" title="对私有、共有地址划分"></a>对私有、共有地址划分</h3><p>虽然可以快速地将网络划分为子网，但是您的组织的网络可能同时使用公有和私有IPv4地址。这会影响您的网络划分子网的方式。</p>
<ul>
<li><strong>内部网</strong> - 这是公司网络的内部部分，只能在组织内部访问。内部网中的设备使用私有 IPv4 地址。</li>
<li><strong>DMZ</strong> - 这是公司网络的一部分，其中包含可供互联网使用的资源，如 Web 服务器。DMZ 中的设备使用公有 IPv4 地址。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817221021546.png" alt="image-20210817221021546" style="zoom: 67%;" />

<p>私有的刚才讲了</p>
<p>对DMZ来说，这些设备需要从互联网公开访问，所以DMZ中的设备需要公有IPv4地址。从20世纪90年代中期开始，公有IPv4地址空间的耗尽成为了一个问题。自 2011 年以来，IANA 和五个 RIR 中的四个用尽了 IPv4 地址空间。虽然组织正在向IPv6过渡，但是剩余的IPv4地址空间仍然非常有限。</p>
<p>这意味着组织必须最大限度地提高其自身有限数量的公有 IPv4 地址。这要求网络管理员将其公有地址空间划分到具有不同子网掩码的子网中，以便最大限度地<strong>减少每个子网的未使用主机地址数量</strong>。这称为<strong>可变长子网掩码</strong> (VLSM)。</p>
<p>要尽量减少未使用的主机 IPv4 地址数量并最大化可用子网数量，在规划子网时需要考虑两个因素：每个网络所需的主机地址数量和所需的单个子网数量。</p>
<p><s>其实很好算。。。为啥他花了这么多篇幅讲这个，是外国人的算数确实比较low吗:joy:</s></p>
<p>需要注意的是，如果一个拓扑中的站点需要与互联网链接，每个站点得多加一个子网</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817222058792.png" alt="image-20210817222058792"></p>
<h3 id="VLSM"><a href="#VLSM" class="headerlink" title="VLSM"></a>VLSM</h3><p>公有地址和私有地址会影响您将网络划分子网的方式。还有其他一些问题影响着子网划分方案。一个标准的/16子网划分方案创建的每个子网都拥有相同数量的主机。并不是您创建的每个子网都需要这么多主机，这会导致许多IPv4地址未被使用。也许您需要一个包含更多主机的子网。这就是开发可变长子网掩码 (VLSM) 的原因。</p>
<p>就是子网在不干扰别的子网的情况下可以继续细分，形式是自己分好就行了，无需额外操作</p>
<p>更大的IPv6地址允许比IPv4更容易的地址规划和分配。保留IPv6地址不是问题。这是向IPv6 过渡的驱动力之一。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817230552228.png" alt="image-20210817230552228" style="zoom: 67%;" />

<p>但是，路由器之间的连接每个子网仅需要两个主机地址（每个路由器接口一个主机地址）。目前，所有子网中的每个子网都有 30 个可用的主机地址。为了避免每个子网浪费28个地址，可以使用 VLSM 为 路由器之间的连接创建较小子网。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210817230924701.png" alt="image-20210817230924701"></p>
<h3 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h3><p>在开始子网划分之前，您应该为整个网络开发一个 IPv4 编址方案。您要了解您需要多少子网、特定子网需要多少主机、哪些设备是子网的一部分、网络的哪些部分使用私有地址、哪些使用公有地址以及许多其他决定因素。一个良好的编址方案<strong>允许增长</strong>。一个良好的编址方案也是一个良好的网络管理员的标志。</p>
<p>IPv4网络子网的规划要求同时分析组织的网络使用需求和子网的构建方法。进行<strong>网络需求调研</strong>是子网规划的起点。这意味着查看整个网络，包括内部网和DMZ，并确定如何划分每个区域。地址计划包括确定哪里需要地址保留(通常在DMZ中)，哪里有更大的灵活性(通常在内部网中)。</p>
<p>如果需要<strong>地址保留</strong>，计划应确定需要多少个子网以及每个子网有多少个主机。如前所述，这通常是DMZ中的公有IPv4地址空间所需要的。这很可能包括使用 VLSM。</p>
<p>在企业内部网中，地址保留通常不是问题，这主要是由于使用私有IPv4编址，包括10.0.0.0/8，有超过1600万个主机IPv4地址。</p>
<p>对于大多数组织，私有 IPv4 地址允许提供足够多的内部（内部网）地址。对于许多较大的组织和ISP来说，即使是私有的IPv4地址空间<strong>也不足以满足</strong>它们的内部需求。这也是组织向 IPv6 过渡的另一个原因。</p>
<p>对于使用私有 IPv4 地址的内部网和使用公有 IPv4 地址的 DMZ，地址规划和分配非常重要。</p>
<p>在需要时，地址计划包括根据大小确定每个子网的需要。每个子网将有多少台主机地址计划还需要包括如何分配主机地址，哪些主机要求静态 IPv4 地址和哪些主机可以使用 DHCP 获取其编址信息的需求。这也将有助于防止地址重复，同时允许出于性能和安全原因对地址进行监测和管理。</p>
<p>了解您的IPv4地址需求将确定您实施的主机地址的范围，并帮助确保有足够的地</p>
<hr>
<p>在一个网络中，有不同类型的设备需要分配地址：</p>
<ul>
<li><strong>终端用户客户端</strong> – 大部分网络使用动态主机配置协议 (DHCP)动态地将IPv4地址分配给客户端设备。这能减少网络支持人员的负担，并显著减少输入错误。使用 DHCP 时，地址仅租用一段时间，并且可以在租约到期时重新使用。这是支持临时用户和无线设备的网络的一个重要特性。更改子网划分方案意味着 DHCP 服务器需要进行重新配置，并且客户端必须续订其 IPv4 地址。IPv6 客户端可以使用 DHCPv6 或 SLAAC 获取地址信息。</li>
<li><strong>服务器和外部设备</strong> - 这些应具有可预测的静态 IP 地址。对这些设备使用统一的编号系统。</li>
<li><strong>可从互联网访问的服务器</strong> - 需要在互联网上公开可用的服务器必须具有公有 IPv4 地址，通常使用 NAT 访问。在一些组织中，必须使远程用户可以使用内部服务器(不可公开使用)。在大多数情况下，这些服务器在内部分配了私有地址，用户需要创建一个虚拟专用网络 (VPN) 连接来访问服务器。这与用户从内部网中的主机访问服务器具有相同的效果。</li>
<li><strong>中间设备</strong> – 这些设备出于网络管理、监视和安全目的分配了地址。因为我们必须知道如何与中间设备通信，所以它们应当具有可以预测的静态地址。</li>
<li><strong>网关</strong> - 路由器和防火墙设备给每个接口分配一个 IP 地址，用作该网络中主机的网关。路由器接口一般使用网络中的最小地址或最大地址。</li>
</ul>
<p>在制定 IP 编址方案时，通常建议您使用一种固定模式为各类设备分配地址。这样有益于管理员添加和删除设备、根据 IP 过滤流量和简化文档。</p>
<h1 id="IPv6编制"><a href="#IPv6编制" class="headerlink" title="IPv6编制"></a>IPv6编制</h1><p>在辛苦学习了对IPv4网络进行子网划分之后，您可能会发现对IPv6网络进行子网划分要容易得多。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>您已经知道IPv4的地址用完了。这就是为什么您需要了解 IPv6 的原因。</p>
<p>IPv6 旨在接替 IPv4。IPv6 拥有更大的 128 位地址空间，提供 340 涧（即，340后面有36个0）个不确定地址。不过，IPv6 不只是具有更大的地址空间。</p>
<p>当 IEFT 开始开发 IPv4 的接替版本时，还借此机会修复了 IPv4 的限制，并开发了增强功能。一个示例是 Internet 控制消息协议第 6 版 (ICMPv6)，它包括 IPv4 的 ICMP (ICMPv4) 中没有的地址解析和地址自动配置功能。</p>
<p>私有地址与网络地址转换 (NAT) 对于放缓 IPv4 地址空间的耗尽起了不可或缺的作用。然而，NAT对于许多应用程序来说是有问题的，它会造成延迟，并且有严重阻碍对等体对对等体通信的限制。</p>
<p>随着移动设备数量的不断增加，移动供应商一直在引领着向IPv6的过渡。美国最大的两家移动运营商报告称，他们超过90%的流量都在IPv6之上。</p>
<p>大多数顶级ISP和内容提供商，如YouTube、Facebook和NetFlix，也已经完成了过渡。许多公司，如微软、Facebook和LinkedIn，都在向内部只允许使用ipv6过渡。2018年，宽带ISP Comcast报告部署超过65%，英国天空广播报告超过86%。</p>
<p><strong>互联网正在不断向物联网 (IoT) 发展。能够访问互联网的设备将不仅仅只有计算机、平板电脑和智能手机。</strong></p>
<p><strong>共存与迁移</strong></p>
<p>过渡到 IPv6 不是一朝一夕可以完成的。在不久的将来，IPv4和IPv6都将共存，并且过渡将需要几年的时间。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可分为三类：</p>
<ul>
<li><p>双堆栈允许 IPv4 和 IPv6 在同一网段上共存。双堆栈设备同时运行 IPv4 和 IPv6 协议栈。称为原生 IPv6，这意味着客户网络与他们的ISP建立了IPv6连接，并能够通过IPv6访问互联网上的内容。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210818103516893.png" alt="image-20210818103516893" style="zoom: 50%;" /></li>
<li><p>隧道是一种通过 IPv4 网络传输 IPv6 数据包的方法。IPv6 数据包与其他类型数据类似，也封装在 IPv4 数据包中。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210818103636652.png" alt="image-20210818103636652" style="zoom:50%;" /></li>
<li><p>网络地址转换 64 (NAT64) 允许支持 IPv6 的设备与支持 IPv4 的设备使用类似于 IPv4 中 NAT 的转换技术进行通信。IPv6 数据包被转换为 IPv4 数据包，IPv4 数据包被转换为 IPv6 数据包。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210818103701274.png" alt="image-20210818103701274" style="zoom: 50%;" /></li>
</ul>
<p><strong>注意:</strong> <u>隧道和转换用于过渡到原生IPv6，仅应在需要时使用。目标是从源到目的地进行本地 IPv6 通信。</u></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>书写 IPv6 地址的首选格式为 <code>x:x:x:x:x:x:x:x</code>，每个“x”均包括四个十六进制值。在 IPv6 中，十六位位组是指代 16 位二进制或四位十六进制数的非官方术语。每个“x”是一个16 位二进制数或四位十六进制数字组成的十六进制数。</p>
<pre class="line-numbers language-none"><code class="language-none">e.g.
2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000: 0200 
2001 : 0db8 : 0000 : 00a3 : abcd : 0000 : 0000: 1234 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>首选格式表示使用所有 32 个十六进制数字书写 IPv6 地址。这并不意味着它是表示 IPv6 地址的理想方法。在本模块中，您将了解到有两条规则可帮助减少表示一个 IPv6 地址所需数字的数目。</p>
<ul>
<li><p>第一条有助于缩短 IPv6 地址记法的规则是省略十六进制数中的所有前导 0（零）此规则仅适用于前导 0，不适用于后缀 0</p>
</li>
<li><p>第二条有助于缩短 IPv6 地址记法的规则是使用双冒号 (::) 替换任何由一个或多个全由 0 组成的16 位十六进制数组成的连续字符串。例如，2001:db8:cafe:1:0:0:0:1（前导0省略）可以表示为2001:db8:cafe:1::1。</p>
<p>双冒号 (::) 仅可在每个地址中<strong>使用一次</strong>，否则可能会得出一个以上的地址。当与忽略前导 0 的方法一起使用时，IPv6 地址记法可以大幅缩短。这通常称为压缩格式。</p>
</li>
</ul>
<p>单播、组播、任播</p>
<p><strong>任播</strong> - IPv6 任播地址是可分配到多个设备的 IPv6 任播地址。发送至任播地址的数据包会被路由到最近的拥有该地址的设备。任播地址不在本课程的讨论范围之内。</p>
<p>与 IPv4 不同，IPv6 没有广播地址。但是，IPv6 具有 IPv6 <strong>全节点组播地址</strong>，这在本质上与广播地址的效果相同。</p>
<p>在 IPv4 中，/24 称为前缀。在 IPv6 中，它被称为前缀长度</p>
<p>IPv6 不使用点分十进制子网掩码记法，前缀长度以<strong>斜线记法</strong>表示，用于表示 IPv6 地址的网络部分。</p>
<p><strong>强烈建议对大多数网络使用 64 位接口 ID（主机部分）</strong>。这是因为**无状态地址自动配置(SLAAC)**使用64位作为接口ID。它还使子网划分更易于创建和管理。</p>
<p>与IPv4设备只有一个地址不同，IPv6地址通常有两个单播地址:</p>
<ul>
<li><strong>全局单播地址(GUA)</strong> - 这类似于公有 IPv4 地址。这些地址具有全局唯一性，是互联网可路由的地址。GUA可静态配置或动态分配</li>
<li><strong>链路本地地址 (LLA)</strong> - 这对于每个支持ipv6的设备都是必需的。LLA用于与同一链路中的其他设备通信。在 IPv6 中，术语链路是指子网。LLA仅限于单个链路。它们的唯一性仅在该链路上得到保证，因为它们在该链路之外不具有可路由性。换句话说，路由器不会转发具有本地链路源地址或目的地址的数据包。</li>
</ul>
<p>唯一本地地址（范围 fc00:: /7 到 fdff:: /7）尚未普遍实现</p>
<p>IPv6 唯一本地地址与 IPv4 的 RFC 1918 私有地址具有相似之处，但是也有着重大差异。</p>
<ul>
<li>唯一本地地址用于一个站点内或数量有限的站点之间的本地编址。</li>
<li>唯一本地地址可用于从来不需要访问其他网络的设备。</li>
<li>唯一本地地址不会全局路由或转换为全局 IPv6 地址。</li>
</ul>
<p>许多站点也使用 RFC 1918 地址的私有性质来尝试去保护或隐藏其网络，使其免遭潜在的安全风险。但是，<u>这绝不是这些技术的既定用途，IETF 始终推荐各站点在面向互联网的路由器上采取妥善的安全预防措施。</u></p>
<h2 id="GUA-amp-LLA"><a href="#GUA-amp-LLA" class="headerlink" title="GUA&amp;LLA"></a>GUA&amp;LLA</h2><p><strong>GUA</strong></p>
<p>IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6互联网上路由。这些地址相当于公有 IPv4 地址。互联网名称与数字地址分配机构 (ICANN)，即 IANA 的运营商，将 IPv6 地址块分配给五家 RIR。目前分配的仅是前三位为 001 的全局单播地址（GUA），如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210818110108525.png" alt="image-20210818110108525" style="zoom:67%;" />

<p>因此当前可用的GUAs的第一个十六进制数字（16位）以2或3开头。这只是可用 IPv6 地址空间的 1/8</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210818105923359.png" alt="image-20210818105923359" style="zoom:67%;" />

<p><strong>全局路由前缀</strong>是提供商（如 ISP）分配给客户或站点的地址的前缀或网络部分。例如，ISP 通常会为其客户分配 /48 全局路由前缀。全局路由前缀通常会因 ISP 的策略而异。</p>
<p><strong>子网ID字段</strong>是全局路由前缀和接口ID之间的区域。与IPv4不同，在IPv4中您必须从主机部分借用位来创建子网，IPv6在设计时考虑到了子网。<u>组织使用子网 ID 确定其站点的子网</u>。子网 ID 越大，可用子网越多。</p>
<p><strong>注意</strong>: 许多组织正在接收 /32 全局路由前缀。使用推荐的 /64 前缀来创建 64 位接口 ID，会留下一个 32 位子网 ID。这意味着具有 /32 全局路由前缀和 32 位子网 ID 的组织将拥有 43 亿个子网，每个子网都有 1800亿亿（18后面跟18个0）个子网。这是与公有 IPv4 地址数量一样多的子网！</p>
<p><strong>IPv6 接口 ID</strong> 相当于 IPv4 地址的主机部分。使用术语“接口 ID”是因为单个主机可能有多个接口，而每个接口又有一个或多个 IPv6 地址。该图显示了 IPv6 GUA 的结构示例。强烈建议在大多数情况下使用 /64 子网，这会创建64位接口ID。64 位接口 ID 允许每个子网有1800亿亿个设备或主机。</p>
<p>建议允许启用 SLAAC 的设备创建自己的 64 位接口 ID。它还使得 IPv6 编址计划的开发变得简单而有效。</p>
<p><strong>注意</strong>: 与 IPv4 不同，在 IPv6 中，全 0 和全 1 主机地址可以分配给设备。可以使用全1地址，因为广播地址不在IPv6中使用。全 0 地址也可使用，但它留作子网路由器任播地址，应仅分配给路由器。</p>
<hr>
<p><strong>LLA</strong></p>
<p>IPv6 链路本地地址 (LLA) 允许设备与同一链路上支持 IPv6 的其他设备通信，并且只能在该链路（子网）上通信。具有源或目的LLA的数据包不能在数据包的源链路之外进行路由。</p>
<p><strong>GUA 不是一项要求。但是，每个启用 IPv6 的网络接口都必须有 LLA。</strong></p>
<p>如果没有手动为接口配置 LLA，设备会在不与 DHCP 服务器通信的情况下自动创建自己的地址。支持 IPv6 的主机会创建 IPv6 LLA，即使没有为该设备分配 IPv6 全局单播地址。这允许支持 IPv6 的设备与同一子网中的其他支持 IPv6 的设备通信。这包括与默认网关（路由器）的通信。</p>
<p>IPv6 LLAs在fe80::/10范围内。/10 表示前 10 位是 1111 1110 10xx xxxx。第一个十六进制数的范围是 1111 1110 10<strong>00 0000</strong> (fe80) 到 1111 1110 10<strong>11 1111</strong> (febf)。</p>
<p>通常情况下，用作链路上其他设备的默认网关的是路由器的 LLA 而不是 GUA。</p>
<p>设备可以通过两种方式获取 LLA：</p>
<ul>
<li><strong>静态</strong> - 这意味着设备已手动配置。</li>
<li><strong>动态</strong> - 这意味着设备通过使用随机生成的值或使用扩展唯一标识符 (EUI) 方法创建自己的接口 ID，该方法使用客户端 MAC 地址和其他位。</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如您在上一主题中了解到的，IPv6 GUA与公有 IPv4 地址数量相同。它们具有全局唯一性，可在 IPv6 互联网上路由。IPv6 LLA 允许两个启用 IPV6 的设备在同一链路（子网）上相互通信。在路由器上静态配置 IPv6 GUA 和 LLA 很容易，可以帮助您创建 IPv6 网络。本主题教您如何做到这一点！</p>
<p>思科里，大多数 IPv6 的配置和验证命令与 IPv4 的相似。在多数情况下，唯一区别是命令中使用 <strong>ipv6</strong> 取代 <strong>ip</strong> 。</p>
<p>与使用 IPv4 一样，在客户端配置静态地址并不能扩展至更大的环境。因此，多数 IPv6 网络的管理员会启用 IPv6 地址的动态分配</p>
<p>设备可以通过两种方法自动获取 IPv6 GUA：</p>
<ul>
<li>无状态地址自动配置 (SLAAC)</li>
<li>有状态 DHCPv6</li>
</ul>
<p><strong>注意</strong>: 使用 DHCPv6 或 SLAAC 时，路由器的LLA将自动指定为默认网关地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210819170944632.png" alt="image-20210819170944632"></p>
<h3 id="GUA动态编址"><a href="#GUA动态编址" class="headerlink" title="GUA动态编址"></a>GUA动态编址</h3><p>如果您不想静态地配置IPv6 GUAs，也不必担心。大多数设备会动态获取其 IPv6 GUA。本主题说明如何使用路由器通告（RA）和路由器请求（RS）消息来完成此过程。本主题比较技术性，但是当您理解了路由器通告可以使用的三种方法之间的区别，以及创建接口ID的EUI-64进程与随机生成的进程的区别，您将在您的IPv6专业知识上有一个巨大的飞跃!</p>
<p>对于 GUA，设备通过 Internet 控制消息协议版本 6 (ICMPv6) 消息动态获取地址。</p>
<p>IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。</p>
<p>在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，该RS消息是对RA消息的请求。</p>
<p>RA消息位于IPv6路由器以太网接口上。必须为路由器启用 IPv6 路由，这在默认情况下是不启用的。若要将路由器启用为 IPv6 路由器，必须使用 <strong>ipv6 unicast-routing</strong> 全局配置命令。</p>
<p>ICMPv6 RA 消息提示设备获取 IPv6 GUA的方式。最终决定取决于设备的操作系统。ICMPv6 RA 消息包括以下：</p>
<ul>
<li><strong>网络前缀和前缀长度</strong> – 这会告知设备其所属的网络。</li>
<li><strong>默认网关</strong> – IPv6 LLA，RA 消息的<strong>源 IPv6 地址</strong>。</li>
<li><strong>DNS 地址和域名</strong> – 这些是DNS 服务器的地址和域名。</li>
</ul>
<p>RA 消息有三种方法：</p>
<ul>
<li><strong>方法 1: SLAAC</strong> - “我拥有您需要的一切，包括前缀、前缀长度和默认网关地址。”</li>
<li><strong>方法 2: SLAAC 和 无状态DHCPv6服务器</strong> - “这是我的信息，但您需要从 无状态DHCPv6 服务器获得其他信息，例如 DNS 地址。”</li>
<li><strong>方法 3: 有状态的 DHCPv6（无SLAAC）</strong> - “我可以给您默认网关的地址。您需要向有状态的 DHCPv6 服务器询问您的所有其他信息。”</li>
</ul>
<ol>
<li><p>SLAAC</p>
<p>SLAAC是一种允许设备在没有DHCPv6服务的情况下创建自己的GUA的方法。</p>
<p>SLAAC 是无状态的，也就是说没有中央服务器（例如有状态DHCPv6 服务器）来分配GUA和维持设备及其地址的清单。借助 SLAAC，<u>客户端设备使用 RA 消息中的信息创建其自己的GUA</u>。如图中所示，地址的两部分生成如下：</p>
<ul>
<li><strong>前缀</strong> - 这是在 RA 消息中通告的。</li>
<li><strong>接口 ID</strong> - 使用 EUI-64 流程或通过生成一个随机 64 位数字产生，取决于设备的操作系统。</li>
</ul>
</li>
<li><p>SLAAC 和无状态 DHCPv6</p>
<p>使用此方法，RA 消息建议设备使用以下内容：</p>
<ul>
<li>SLAAC创建自己的IPv6 GUA</li>
<li>路由器LLA，是RA源IPv6地址，作为默认网关地址</li>
<li>使用无状态 DHCPv6 服务器获取其他信息，例如 DNS 服务器地址和域名。</li>
</ul>
<p><strong>注意</strong>: 使用无状态 DHCPv6 服务器分配 DNS 服务器地址和域名。它不分配 GUA。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820002740998.png" alt="image-20210820002740998"></p>
</li>
<li><p>有状态的DHCPv6</p>
<p>有状态 DHCPv6 与 IPv4 的 DHCP 相似。设备可以从有状态 DHCPv6 服务器自动接收编址信息，包括GUA、前缀长度和 DNS 服务器地址。</p>
<p>RA 消息建议设备使用以下内容：</p>
<ul>
<li>路由器LLA，是RA源IPv6地址，作为默认网关地址。</li>
<li>使用有状态 DHCPv6 服务器获取GUA、DNS 服务器地址、域名和其他必要信息。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820002915745.png" alt="image-20210820002915745"></p>
</li>
</ol>
<p><strong>生成接口ID</strong></p>
<p>客户端从 RA 消息中获知地址的前缀部分，但必须创建自己的接口 ID。接口 ID 可使用 <strong>EUI-64 流程或随机生成</strong>的 64 位数字创建。</p>
<p> IEEE 定义了扩展唯一标识符 (EUI) 或修改的 EUI-64 流程。该流程使用客户端的 48 位以太网 MAC 地址，并在该 48 位 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820100531493.png" alt="image-20210820100531493"></p>
<p>识别地址可能是使用 EUI-64 创建的一个简单方法是位于接口 ID 中间的 <strong>fffe</strong>。</p>
<p>EUI-64 优势在于可以使用以太网 MAC 地址确定接口 ID。这也允许网络管理员使用唯一 MAC 地址轻松跟踪终端设备的 IPv6 地址。然而，这引起了许多<strong>用户的隐私担忧</strong>，他们担心自己的数据包可能会被追踪到实际的物理计算机。出于这些顾虑，可以转而使用随机生成的接口 ID。</p>
<p><strong>随机生成</strong></p>
<p>根据操作系统，设备可以使用随机生成的接口 ID，而不使用 MAC 地址和 EUI-64 流程。从 Windows Vista 开始，Windows 使用随机生成的接口 ID，而不是 EUI-64 创建的接口 ID。Windows XP 和之前的 Windows 操作系统均使用 EUI-64。</p>
<p><strong>注意</strong>: 为确保任何 IPv6 单播地址的唯一性，客户端可以使用重复地址检测 (DAD) 流程。这与 ARP 请求其地址的流程相似。如该请求没有响应，则地址是唯一的。</p>
<h3 id="LLA动态编址"><a href="#LLA动态编址" class="headerlink" title="LLA动态编址"></a>LLA动态编址</h3><p>操作系统，如Windows，通常会对SLAAC创建的GUA和动态分配的LLA使用相同的方法。<strong>即ID部分相同</strong></p>
<p><strong>当为接口分配GUA时，思科路由器会自动创建 IPv6 LLA</strong>。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有LLA生成接口 ID。对于串行接口，路由器会使用以太网接口的 MAC 地址。</p>
<p>使用动态分配的LLA的缺点在于其接口 ID 较长，因此很难识别并记住分配的地址。</p>
<p>为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 LLA。</p>
<h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>组播地址仅可用作目的地址，不能用作源地址。</p>
<p>IPv6 组播地址的前缀为ff00::/8。</p>
<p>IPv6 组播地址分为两种类型：</p>
<ul>
<li>知名组播地址</li>
<li>请求节点组播地址</li>
</ul>
<p>分配的组播地址是为预先定义的设备组保留的组播地址。分配的组播地址是用于到达运行通用协议或服务的设备组的单个地址。分配的组播地址用在特定的协议环境，例如 DHCPv6。</p>
<ul>
<li><strong>ff02:全节点组播组</strong> - 这是一个包含所有支持 IPv6 的设备的组播组。发送到该组的数据包由该链路或网络上的所有 IPv6 接口接收和处理。这与 IPv4 中的广播地址具有相同的效果。图中显示使用全节点组播地址进行通信的示例。IPv6 路由器将 ICMPv6 RA 消息发送给全节点组播组。</li>
<li><strong>ff02:全路由器组播组</strong> - 这是所有IPv6路由器加入的组播组。当在 IPv6 路由器全局模式下启用 ipv6 unicast-routing 命令后，该路由器即成为该组的成员。发送到该组的数据包由该链路或网络上的所有 IPv6 路由器接收和处理。</li>
</ul>
<p>请求节点组播地址类似于全节点组播地址。请求节点组播地址的优势在于它被映射到特殊的以太网组播地址。这使得以太网网卡可以通过检查目的 MAC 地址过滤该帧，而不是将它发送给 IPv6 流程来判断该设备是否是 IPv6 数据包的既定目标。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820110425088.png" alt="image-20210820110425088" style="zoom: 67%;" />



<h3 id="子网-1"><a href="#子网-1" class="headerlink" title="子网"></a>子网</h3><p>128 位地址的好处在是，它可以为每个网络支持足够多的子网并为每个子网支持足够多的主机。地址保留不是问题。例如，如果全局路由前缀是a /48，并且使用一个典型的64位接口ID，这将创建一个16位子网ID</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820111159718.png" alt="image-20210820111159718" style="zoom:67%;" />

<p>由于有 65,536 个子网可供选择，网络管理员的任务就变为设计一个逻辑方案来分配网络地址。</p>
<p>IPv6的串行链路子网将具有与局域网相同的前缀长度。虽然这可能会“浪费”地址，但是使用 IPv6 时地址保留并不是问题。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>在本主题中，您会了解不同类型的 Internet 控制消息协议 (ICMP) ，以及用于发送它们的工具。</p>
<p>虽然 IP 只是“尽最大努力”的协议，但在与另一个IP设备通信时，TCP/IP套件确实提供了错误消息和参考消息。这些消息使用 ICMP 服务发送。其用途是就特定情况下处理 IP 数据包的相关问题提供反馈，而并非是使 IP 可靠。ICMP 消息并非必需的，而且在网络内通常出于安全原因而被禁止。</p>
<p>ICMP 可同时用于 IPv4 和 IPv6。ICMPv4 是 IPv4 的消息协议。ICMPv6 为 IPv6 提供相同的服务，此外，还包括其他功能。</p>
<p>ICMP 消息的类型及其发送原因非常多。ICMPv4 和 ICMPv6 通用的 ICMP 消息包括：</p>
<ul>
<li>主机联通性</li>
<li>目的地或服务不可达</li>
<li>超时</li>
</ul>
<p><strong>主机可连通性</strong></p>
<p>ICMP Echo消息可用于测试 IP 网络上主机的可达性。本地主机向一台主机发送 ICMP Echo请求。如果主机可用，目的主机会回应以Echo应答。在图中，请单击“播放”按钮观看 ICMP Echo请求/Echo应答动画。如此使用 ICMP Echo消息是 <strong>ping</strong> 实用程序的基础。</p>
<p>当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机，目的地或服务无法到达。消息包括指示数据包为何无法传送的代码。</p>
<p>ICMPv4 的目的地不可达代码示例有：</p>
<ul>
<li>0 - 网络不可达。</li>
<li>1 - 主机不可达。</li>
<li>2 - 协议不可达。</li>
<li>3 - 端口不可达。</li>
</ul>
<p>ICMPv6 的目的地不可达代码示例有：</p>
<ul>
<li>0-没有通往目标的路由。</li>
<li>1-管理上禁止与目的地通信（例如防火墙）</li>
<li>2-超出源地址的范围</li>
<li>3-地址无法访问</li>
<li>4-端口不可达。</li>
</ul>
<p><strong>超时</strong></p>
<p>路由器使用 ICMPv4 超时消息表明，因为数据包的生存时间 (TTL) 字段递减到 0 而不能转发该数据包。如果路由器接收数据包并且将 IPv4 数据包的 TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息。</p>
<p>如果路由器因数据包过期而无法转发 IPv6 数据包，ICMPv6 也会发送超时消息。ICMPv6使用IPv6跳数限制字段来确定数据包是否已过期，而不是IPv4 TTL字段。</p>
<p>ICMPv6 拥有 ICMPv4 中所没有的新特性和功能提升。ICMPv6 消息封装在 IPv6 中。</p>
<p>ICMPv6 在邻居发现协议（ND 或 NDP）中包括四个新协议。</p>
<p>IPv6 路由器和 IPv6 设备之间的消息传递，包括动态地址分配如下所示：</p>
<ul>
<li>路由器请求 (RS) 消息</li>
<li>路由器通告 (RA) 消息</li>
</ul>
<p>IPv6 设备之间的消息传递，包括重复的地址检测和地址解析如下所示：</p>
<ul>
<li>邻居请求 (NS) 消息</li>
<li>邻居通告 (NA) 消息</li>
</ul>
<p><strong>注意</strong>: ICMPv6 ND 还包括重定向消息，与 ICMPv4 中使用的重定向消息功能相似。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>​    传输层是将数据从一个主机传输到另一个主机的地方。这是您的网络真正开始动起来的地方! 传输层使用两个协议: TCP和UDP。可以把TCP看作是在邮件中收到一封挂号信。您必须先签收,然后邮递员才会给您。这会稍微减慢这个过程,但是发送者可以确定地知道您收到了这封信,以及您收到这封信的时间。UDP更像是一个普通的,盖了邮戳的信。它到达了您的邮箱（如果它到了的话）,它可能是给您的,但它实际上也可能是给其他不住在那里的人的。而且,它还可能根本就没有到达您的邮箱。发件人无法确定您已收到了信。尽管如此,有时还是需要像盖了邮戳的信件一样的UDP协议。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>应用层程序生成必须在源主机和目的主机之间交换的数据。<strong>传输层负责在不同主机上运行的应用程序之间进行的逻辑通信</strong>。这可能包括在两个主机之间建立临时会话以及应用程序信息的可靠传输等服务。</p>
<p>传输层并不了解目标主机类型、数据必须经过的介质类型、数据使用的路径，链路拥塞情况或网络大小。</p>
<p><strong>职责</strong></p>
<p><strong>跟踪各个会话</strong></p>
<p>在传输层中，源应用和目的应用之间传输的每个数据集称为会话并分别进行跟踪。传输层负责维护并跟踪这些会话。</p>
<p>每台主机上都可以有多个应用同时在网络上通信。</p>
<p>大多数网络对单个数据包能承载的数据量都有限制。因此，必须将数据分成可管理的部分。</p>
<p><strong>数据分段和数据段重组</strong></p>
<p>传输层负责将应用程序数据划分为适当大小的块。根据所使用的传输层协议，传输层块称为数据段或数据报。该图说明了使用不同块进行每个会话的传输层。</p>
<p><strong>添加报头信息</strong></p>
<p>传输层协议还将包含二进制数据的报头信息添加到每个数据块中，这些数据被组织成几个字段。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</p>
<p>例如，接收主机使用报头信息将数据块重新组装为接收应用程序层程序的完整数据流。</p>
<p><u>传输层可以确保在设备上运行多个应用时，所有应用都能接收正确的数据。</u></p>
<p><strong>标识应用</strong></p>
<p>传输层必须能够划分和管理具有不同传输要求的多个通信。为了将数据流传递到适当的应用程序，传输层使用称为端口号的标识符来标识目标应用。如图所示，在每台主机中，每个需要访问网络的软件进程都将被分配一个唯一的端口号。</p>
<p><strong>会话多路复用</strong></p>
<p>将某些类型的数据（即视频流）作为完整的通信流在网络中发送，会使用所有可用带宽。这将阻止其他通信会话同时发生。而且也难以对损坏的数据开展错误恢复和重新传输的工作。</p>
<p>传输层使用数据段和多路复用，使不同的通信会话在同一网络上交错。</p>
<p>可对数据段中的数据执行错误检查，以确定数据段在传输过程中是否发生了更改。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>IP 只涉及数据包的结构、地址分配和路由。IP 不指定数据包的传送或传输方式。</p>
<p>传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。传输层包括 TCP 和 UDP 协议。</p>
<p>不同的应用有不同的传输可靠性要求。因此，TCP/IP 提供了两个传输层协议</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP将数据分为若干个数据段。（segment）</p>
<p>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备。TCP包含确保应用数据传递的字段。这些字段需要发送和接收的主机进行额外处理。</p>
<p>TCP 使用以下基本操作提供可靠性和流量控制：</p>
<ul>
<li>编号并跟踪从特定应用程序发送到特定主机的数据段。</li>
<li>确认收到数据</li>
<li>在一定时间段后重新传输未确认的数据</li>
<li>有顺序的数据可能以错误的顺序到达 以接收方可以接受的有效速率* 发送数据</li>
</ul>
<p>除了支持数据分段和重组的基本功能之外，TCP 还提供以下服务：</p>
<ul>
<li><strong>建立会话</strong> - TCP是一种面向连接的协议，在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</li>
<li><strong>确保可靠的传递</strong> - 由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。TCP确保从源设备发送的每个数据段都能够到达目的地。</li>
<li><strong>提供相同顺序的传递</strong> - 由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，TCP 确保按正确的顺序重组这些数据段。</li>
<li><strong>支持流量控制</strong> - 网络主机的资源有限（即，内存或处理能力）。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</li>
</ul>
<p>有关 TCP 的更多信息，请在互联网上搜索 RFC 793。</p>
<p>在封装应用层数据时，TCP 数据段会增加 20 个字节（即 160 位）的开销。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820114849519.png" alt="image-20210820114849519" style="zoom:67%;" />

<table>
<thead>
<tr>
<th align="left"><strong>TCP 报头字段</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>源端口</strong></td>
<td align="left">一个16位字段, 用于通过端口号标识源应用程序。</td>
</tr>
<tr>
<td align="left"><strong>目的端口</strong></td>
<td align="left">一个16位字段, 用于通过端口号标识目的应用 程序。</td>
</tr>
<tr>
<td align="left"><strong>序列号</strong></td>
<td align="left">一个32位字段, 用于数据重组。</td>
</tr>
<tr>
<td align="left"><strong>确认号</strong></td>
<td align="left">一个32位的字段, 用于指示已接收到数据, 并且期望从源 接收下一个字节。</td>
</tr>
<tr>
<td align="left"><strong>报头长度</strong></td>
<td align="left">一个4位字段, 称为“数据偏移”, 表示 TCP数据段报头的长度。</td>
</tr>
<tr>
<td align="left"><strong>保留</strong></td>
<td align="left">一个6位字段, 保留供将来使用。</td>
</tr>
<tr>
<td align="left"><strong>控制位</strong></td>
<td align="left">一个6位字段, 包括位代码或标志, 指示 TCP段的目的和功能。</td>
</tr>
<tr>
<td align="left"><strong>窗口大小</strong></td>
<td align="left">一个16位字段, 用于指示一次可以接受的 字节数。</td>
</tr>
<tr>
<td align="left"><strong>校验和</strong></td>
<td align="left">一个16位字段, 用于数据段报头和数据的错误检查。</td>
</tr>
<tr>
<td align="left"><strong>紧急</strong></td>
<td align="left">一个 16 位字段, 用于指示包含的数据是否紧急。</td>
</tr>
</tbody></table>
<p>TCP 很好地说明了 TCP/IP 协议簇的不同层如何拥有特定角色。TCP 处理与将数据流划分为数据段、提供可靠性、控制数据流量和数据段重新排序相关的所有任务。TCP 使应用程序不用再管理这些任务。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>diagram</p>
<p>UDP是一种无连接协议。由于 UDP 不提供可靠性或流量控制，因此不需要建立连接。由于 UDP 不跟踪客户端和服务器之间发送或接收的信息，因此UDP 也称为无状态协议。</p>
<p>UDP 也称为最大努力交付协议，因为在目的地接收到数据后没有确认消息。UDP 中没有通知发送方是否成功传输的传输层流程。</p>
<p>UDP是一种比TCP更简单的传输层协议。它不提供可靠性和流量控制，这意味着它需要更少的报头字段。由于发送方和接收方UDP进程不需要管理可靠性和流量控制，这意味着 UDP 数据报的处理速度比 TCP 数据段快。UDP 仅提供在相应应用之间传输数据报的基本功能，需要很少的开销和数据检查。</p>
<p>UDP 协议非常简单，它通常被描述为与 TCP 比较所不提供的功能。</p>
<p>UDP的特点包括以下几种：</p>
<ul>
<li>数据按照接收顺序重构。</li>
<li>丢失的任何数据段都不会重新发送。</li>
<li>不会建立会话。</li>
<li>不会告知发送者资源可用性。</li>
</ul>
<p>如果使用 UDP 作为传输协议时要求可靠性，必须<strong>由应用来处理可靠性</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820115337986.png" alt="image-20210820115337986"></p>
<p>最适合采用 UDP 协议的三种应用程序包括：</p>
<ul>
<li><strong>实时视频和多媒体应用程序</strong> - 这些应用可以容忍部分数据丢失但要求延迟极小或没有延迟的应用程序。示例包括 VoIP 和实时流传输视频。</li>
<li><strong>简单请求和应答应用程序</strong> - 处理简单事务的应用程序，其中主机发送请求，但不一定收到应答。示例包括 DNS 和 DHCP。</li>
<li><strong>处理可靠性的应用程序</strong> - 不要求进行流量控制、错误检测、确认和错误恢复，或这些功能由应用程序来执行的单向通信。示例包括 SNMP 和 TFTP。</li>
</ul>
<p>虽然 DNS 和 SNMP 默认使用 UDP，但它们都可以使用 TCP。如果 DNS 请求或 DNS 响应大于 512 字节，DNS 会使用 TCP，例如 DNS 响应包含许多域名解析时。同样，在某些情况下，网络管理员可以配置 SNMP 使用 TCP。</p>
<p><strong>选择</strong></p>
<p>一些应用可以容忍在网络传输过程中丢失部分数据，但是不接受传输中出现延迟。由于需要的网络开销较少，对于这些应用，UDP 是更好的选择。UDP 是 IP 语音 (VoIP) 之类应用的首选。确认和重新发送会拖慢传输速度，并使语音会话不可接受。</p>
<p>UDP 也被“请求-回复”应用程序使用，其中数据最少，并且可以快速完成重新传输。例如，域名服务 (DNS) 为此类事务使用 UDP。客户端从DNS服务器请求已知域名的IPv4和IPv6地址。<strong>如果客户端在预定的时间内没有收到响应，它将再次发送请求。</strong></p>
<p>例如，如果视频数据流中的一段或者两段数据未到达目的地，就会造成数据流的短暂中断。这可能表现为图像失真或声音失真，用户也许不会察觉。如果目的设备必须负责处理丢失的数据，则流可能在等待重新发送的过程中被推迟，从而导致图像或声音的质量大大降低。在这种情况下，最好利用接收到的分段呈现最佳媒体，并放弃可靠性。</p>
<p>对于其他应用程序，重要的是所有数据都应到达并且可以按适当的顺序对其进行处理。对于这些类型的应用程序，使用TCP 作为传输协议。例如，数据库、Web 浏览器和邮件客户端等应用，要求发送的所有数据都必须以原始形式到达目的地。任何数据的丢失都可能导致通信失败，要么不能完成通信，要么通信的信息不可读。例如，通过网页访问银行信息时，确保所有信息都正确发送和接收是非常重要的。</p>
<p>应用开发人员必须根据应用的需求，选择适合的传输层协议类型。视频可以通过 TCP 或 UDP 发送。存储音频和视频流的应用使用 TCP。应用程序使用 TCP 执行缓冲、带宽探测和拥塞控制，以便更好地控制用户体验。</p>
<p>实时视频和语音通常使用UDP，但也可能使用TCP，或同时使用UDP和TCP。视频会议应用程序默认情况下可能使用UDP，但由于许多防火墙阻止UDP，应用程序也可以通过TCP发送。</p>
<p>存储音频和视频流的应用使用 TCP。例如，如果您的网络突然不能支持观看一个点播电影所需的带宽，则应用使播放暂停。在暂停期间，您可能会看到一个“缓冲……”消息，这时，TCP 正在重建流。当所有的片段都井然有序且恢复最低限度的带宽时，您的 TCP 会话重新开始，电影恢复播放。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>无论传输何种类型的数据，TCP和UDP都使用端口号。</p>
<p>TCP 和 UDP 传输层协议使用端口号来管理多个同时的对话</p>
<p>在请求中，目的端口号是标识目的Web服务器正在被请求的服务类型的端口号。例如，当客户端在目的端口中指定端口 80 时，接收该消息的服务器就知道请求的是 Web 服务。</p>
<p>服务器可同时提供多个服务，例如在端口 80 上提供 Web 服务，并同时在端口 21 上提供建立文件传输协议 (FTP) 连接的服务。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820115913366.png" alt="image-20210820115913366" style="zoom: 50%;" />

<p>套接字用于标识客户端所请求的服务器和服务。客户端套接字可能如下所示，其中 1099 代表源端口号：192.168.1.5:1099</p>
<p>Web 服务器上的套接字则可能是192.168.1.7:80</p>
<p>这两个套接字组合在一起形成一个套接字对：192.168.1.5:1099，192.168.1.7:8</p>
<p>有了套接字，一台客户端上运行的多个进程便可彼此区分，它们与同一服务器进程建立的多个连接也可以彼此区分。</p>
<p>互联网编号指派机构 (IANA) 是负责分配各种编址标准（包括端口号）的标准组织。用于标识源端口号和目的端口号的16位二进制提供了从0到65535的端口范围。</p>
<p>IANA 已将号码范围划分为以下三个端口组。</p>
<table>
<thead>
<tr>
<th align="left"><strong>端口组</strong></th>
<th align="left"><strong>号码范围</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>公认端口</strong></td>
<td align="left"><strong>0到1023</strong></td>
<td align="left">这些端口号保留用于常见或流行的服务和应用程序, 例如 Web浏览器, 电子邮件客户端和远程访问 客户端。为常用的服务器应用程序定义的公认端口使 客户端能够轻松识别所需的关联服务。</td>
</tr>
<tr>
<td align="left"><strong>注册端口</strong></td>
<td align="left"><strong>1024到49151</strong></td>
<td align="left">IANA将这些端口号分配给请求实体, 以用于特定的进程或应用程序。这些进程主要是用户选择安装的单个 应用程序, 而不是使用公认端口号的 常见应用程序。例如, 思科已为其RADIUS服务器身份验证进程 注册了端口1812。</td>
</tr>
<tr>
<td align="left"><strong>私有</strong> 和(或) <strong>动态端口</strong></td>
<td align="left"><strong>49152 到 65535</strong></td>
<td align="left">这些端口也称为 <em>临时端口</em>。客户端的操作系统通常在 发起与服务的连接时动态分配端口号。之后即可在通信过程中使用动态端口识别客户端 应用程序。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>: 一些客户端操作系统在分配源端口时可能使用注册端口号而不是动态端口号。</p>
<table>
<thead>
<tr>
<th align="left"><strong>端口号</strong></th>
<th align="left"><strong>协议</strong></th>
<th align="left"><strong>应用层</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>20</strong></td>
<td align="left">TCP</td>
<td align="left">文件传输协议 (FTP) - 数据</td>
</tr>
<tr>
<td align="left"><strong>21</strong></td>
<td align="left">TCP</td>
<td align="left">文件传输协议 (FTP) - 控制</td>
</tr>
<tr>
<td align="left"><strong>22</strong></td>
<td align="left">TCP</td>
<td align="left">安全 Shell (SSH)</td>
</tr>
<tr>
<td align="left"><strong>23</strong></td>
<td align="left">TCP</td>
<td align="left">Telnet</td>
</tr>
<tr>
<td align="left"><strong>25</strong></td>
<td align="left">TCP</td>
<td align="left">简单邮件传输协议 (SMTP)</td>
</tr>
<tr>
<td align="left"><strong>53</strong></td>
<td align="left">UDP、TCP</td>
<td align="left">域名服务 (DNS)</td>
</tr>
<tr>
<td align="left"><strong>67</strong></td>
<td align="left">UDP</td>
<td align="left">动态主机配置协议 (DHCP)- 服务器</td>
</tr>
<tr>
<td align="left"><strong>68</strong></td>
<td align="left">UDP</td>
<td align="left">动态主机配置协议-客户端</td>
</tr>
<tr>
<td align="left"><strong>69</strong></td>
<td align="left">UDP</td>
<td align="left">简单文件传输协议 (TFTP)</td>
</tr>
<tr>
<td align="left"><strong>80</strong></td>
<td align="left">TCP</td>
<td align="left">超文本传输协议 (HTTP)</td>
</tr>
<tr>
<td align="left"><strong>110</strong></td>
<td align="left">TCP</td>
<td align="left">邮局协议第 3 版 (POP3)</td>
</tr>
<tr>
<td align="left"><strong>143</strong></td>
<td align="left">TCP</td>
<td align="left">互联网消息访问协议 (IMAP)</td>
</tr>
<tr>
<td align="left"><strong>161</strong></td>
<td align="left">UDP</td>
<td align="left">简单网络管理协议 (SNMP)</td>
</tr>
<tr>
<td align="left"><strong>443</strong></td>
<td align="left">TCP</td>
<td align="left">安全超文本传输协议 (HTTPS)</td>
</tr>
</tbody></table>
<p>一些应用程序可能既使用 TCP，又使用 UDP。例如，当客户端向 DNS 服务器发送请求时，DNS 使用 UDP。但是，两台 DNS 服务器之间的通信始终使用 TCP。</p>
<p>不明的 TCP 连接可能造成重大的安全威胁。因为此类连接表示某程序或某人正连接到本地主机。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。Netstat 是一种重要的网络实用程序，可用来检验此类连接。</p>
<p>输入命令 <strong>netstat</strong>可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。</p>
<p>默认情况下，<strong>netstat</strong>命令会试图将 IP 地址解析为域名，将端口号解析为公认应用程序。使用**-n**选项能够以数字形式显示 IP 地址和端口号。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><h3 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h3><p>分配有特定端口的活动服务器应用程序被认为是开放的，也就是说，传输层将接受并处理分配到该端口的数据段。所有发送到正确套接字地址的传入客户端请求都将被接受，数据将被传送到服务器应用。在同一服务器上可以同时开启很多端口，每个端口对应一个动态服务器应用。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820121900322.png" alt="image-20210820121900322" style="zoom:67%;" />

<p>在一些文化中，两个人见面时常常通过握手来问好。双方都把握手的行为理解为友好问候的信号。网络中的连接是类似的。在 TCP 连接中，主机客户端使用<strong>三次握手过程</strong>与服务器建立连接。</p>
<p>SYN -&gt; ACK和SYN -&gt; ACK</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820122108492.png" alt="image-20210820122108492" style="zoom: 50%;" />

<p>三次握手验证目标主机是否可用来通信。在示例中，主机 A验证了主机 B可用。</p>
<p>若要关闭连接，分段报头必须设置完成 (FIN) 控制标志。为终止每个单向 TCP 会话，需采用包含 FIN 分段和确认 (ACK) 分段的二次握手。因此，若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820122520033.png" alt="image-20210820122520033" style="zoom:50%;" />

<p>当所有数据段得到确认后，会话关闭。</p>
<p>主机维护状态，跟踪会话过程中的每个分段，并使用 TCP 报头信息交换已接收数据的相关信息。TCP 是全双工协议，每个连接都代表两个单向通信会话。若要建立连接，主机应执行三次握手。TCP 报头中的控制位指出了连接的进度和状态。通信完成后，将关闭会话并终止连接。连接和会话机制保障了 TCP 的可靠性功能。</p>
<p>三次握手的功能：</p>
<ul>
<li>确认目的设备存在于网络上。</li>
<li>确认目的设备有活动的服务，并且正在源客户端要使用的目的端口号上接受请求。</li>
<li>通知目的设备源客户端想要在该端口号上建立通信会话。</li>
</ul>
<p>六个控制位标志如下：</p>
<ul>
<li><strong>URG</strong> - 紧急指针字段（重要）</li>
<li><strong>ACK</strong> - 用于建立连接和会话终止的确认标志</li>
<li><strong>PSH</strong> - 推送功能</li>
<li><strong>RST</strong> - 在出现错误或超时时重置连接</li>
<li><strong>SYN</strong> - 同步建立连接中使用的序列号</li>
<li><strong>FIN</strong> - 没有更多来自发送方的数据，并用于会话终止</li>
</ul>
<p>SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</p>
<hr>
<h3 id="可靠性和流控制"><a href="#可靠性和流控制" class="headerlink" title="可靠性和流控制"></a>可靠性和流控制</h3><p>有时可能TCP数据段没有到达目的地。有时，TCP段可能会无序到达。因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号，便于进行数据重组。序列号代表 TCP 分段的第一个数据字节在完整数据中的位置。</p>
<p><strong>序列号和确认</strong></p>
<p>在会话建立过程中，将设置初始序列号 (ISN)。此 ISN 表示传输到接收应用的字节起始值。在会话过程中，每传送一定字节的数据，序列号就随之增加。</p>
<p>ISN 并不是从 1 开始，而是随机的数字。这样做的目的是防止某些类型的恶意攻击。为简单起见，本章的示例中我们将使用 1 作为 ISN。在wireshark中会将第一个转换为0，称为相对序列号。</p>
<p>接收方的 TCP 进程将数据段中的数据存入缓存区，然后数据段按照正确的序列顺序进行排列，重组后发送到应用层。对于序列号混乱的分段，将被保留以备后期处理。等缺失的分段到达后，再来按顺序处理这些分段。</p>
<p><strong>丢失和重传</strong></p>
<p>TCP 提供了管理数据段丢失的方法。其中一个方法就是重新传输未确认的数据。</p>
<p>序列 (SEQ) 号和确认 (ACK) 号一起使用，以确认接收传输段中包含的数据字节。SEQ 编号标识正在传输的数据段中的第一个字节。TCP 使用发送回源代码的 ACK 编号来指示接收方希望接收的下一个字节。这称为期望确认。</p>
<p>当源主机的计时器结束后若未收到ACK，则会重传</p>
<p>在进行后续增强之前，TCP只能确认预期的下一个字节。例如，在图中，为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B将应答并确认指定下一个预期的数据段是段3。主机A不知道其他数据段是否到达。因此，主机A将重新发送段3到段10。如果所有重新发送的数据段都成功到达，则段 5 到 段10 将是重复的。这会导致延迟、拥塞和效率低下。</p>
<p>今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段。因此，发送主机只需要重新传输丢失的数据。例如，在下图中，还是为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B可以确认它已经接收了段1和段2 (ACK 3)，并有选择地确认段5到10 (SACK 5-10)。主机A只需要重新发送段3和段4。</p>
<p>显示了 PCA 向 PCB 发送 10 段，但第 3 段和第 4 段未能到达。这一次，PCB发送了一个ACK 3和一个SACK 5-10，让PCA知道重新发送缺失的段3和段4，并继续发送段11</p>
<p><strong>流量控制</strong></p>
<p>流量控制可以调整给定会话中源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性。为此，TCP 报头包括一个称为“窗口大小”的 16 位字段。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820211158091.png" alt="image-20210820211158091" style="zoom:50%;" />

<p>窗口大小是 TCP 会话的目的设备一次可以接受和处理的字节数。在本例中，PC B 用于 TCP 会话的初始窗口大小为 10000 字节。从第 1 个字节开始，字节数为 1，PC A 在不收到确认的前提下可以发送的最后一个字节为 10,000。这被称为PC A的发送窗口。每个 TCP 分段均包含窗口大小，那样目的设备可以根据缓冲区的可用性随时修改窗口大小。</p>
<p>初始窗口大小在三次握手期间建立 TCP 会话时确定。源设备必须根据目的设备的窗口大小限制发送到目的设备的字节数。只有源设备收到字节数已接收的确认之后，才能继续发送更多会话数据。通常情况下，目的设备不会等待其窗口大小的所有字节接收后才以确认应答。<strong>接收和处理字节时，目的设备就会发送确认，以告知源设备它可以继续发送更多字节。</strong></p>
<p>目的设备在处理接收的字节时发送确认并不断调整源设备的发送窗口大小被称为<strong>滑动窗口</strong>。在上一个示例中，PC A 的发送窗口会增加或滑动了 2921 个字节，从 10000 增到 12920。</p>
<p>如果目的设备缓冲区空间的可用性减小，它可以缩减窗口大小，通知源设备减少发送的字节数，而不需要接收确认。滑动窗口的优势在于，只要接收方确认之前的数据段，就可以让发送方持续传输数据段。滑动窗口的详细信息不在本课程的讨论范围之内。</p>
<p>MSS 是 TCP 报头中选项字段的一部分，用于指定设备可以在单个 TCP数据段中接收的最大数据量（以字节为单位）。MSS 大小不包括 TCP 报头。</p>
<p>使用 IPv4 时，常见的 MSS 为 1460 字节。主机会从以太网最大传输单位 (MTU) 中减去 IP 和 TCP 报头，从而确定其 MSS 字段的值。</p>
<p>在以太网接口上，默认 MTU 为 1500 个字节。减去 20 个字节的 IPv4 报头和 20 个字节的 TCP 报头，默认 MSS 大小为 1460 个字节，如图所示。</p>
<p><strong>避免拥塞</strong></p>
<p>网络中出现拥塞会使过载的路由器丢弃数据包。当包含 TCP 数据段的数据包未到达其目的地时，它们就成为未确认的数据包。通过确定 TCP 数据段<strong>发送但未确认的速率</strong>，源设备可以假设一定程度的网络拥塞。</p>
<p>出现网络拥塞时，从源设备丢失的 TCP 数据段就会重传。如果不适当控制重传，TCP 数据段的额外重传会使拥塞的情况更糟。网络中不仅有 TCP 数据段的新数据包，而且还有重传丢失的 TCP 数据段的反馈效果，这都增加了拥塞。为避免和控制拥塞，TCP 使用了多个<strong>拥塞处理机制、计时器和算法</strong>。</p>
<p>如果源设备确定 TCP 数据段没有被确认或没有被及时确认，它会在收到确认之前减少发送的字节数。</p>
<h3 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h3><p>与 TCP分段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。UDP 不会按传输顺序重新排列数据报。</p>
<p>因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。</p>
<p>与基于 TCP 的应用程序相同的是，基于 UDP 的服务器应用程序也被分配了公认端口号或注册端口号。当上述应用或进程在服务器上运行时，它们就会接受与所分配端口号相匹配的数据。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p><strong>应用层</strong></p>
<p>如您所知，传输层实际上是数据从一个主机移动到另一个主机的地方。但在此之前，必须确定很多细节，以便正确地进行数据传输。这就是为什么在OSI 和 TCP/IP 模型中都有一个应用层。</p>
<p>在OSI和TCP/IP 模型中的应用层最接近最终用户。<strong>该层为用于通信的应用程序和用于消息传输的底层网络提供接口。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820214053169.png" alt="image-20210820214053169" style="zoom:50%;" />

<p>目前已有很多种应用层协议，而且人们还在不断开发新的协议。某些最广为人知的应用层协议包括超文本传输协议(HTTP)、文件传输协议 (FTP)，简单文件传输协议 (TFTP)，互联网邮件访问协议 (IMAP) 和域名系统 (DNS) 协议。</p>
<p><strong>会话层</strong></p>
<p>表示层具有三个主要功能：</p>
<ul>
<li>将来自源设备的数据格式化或表示成<strong>兼容</strong>形式，以便目的设备接收。</li>
<li>采用可被目的设备解压缩的方式对数据进行<strong>压缩</strong>。</li>
<li><strong>加密</strong>要传输的数据并在收到数据时解密数据。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820214317110.png" alt="image-20210820214317110" style="zoom:67%;" />

<p><strong>会话层</strong></p>
<p>顾名思义，会话层的功能就是创建并维护源应用程序和目的应用程序之间的对话。会话层用于处理信息交换，发起对话并使其处于活动状态，并在对话中断或长时间处于空闲状态时重启会话。</p>
<p>TCP/IP 应用层协议指定了许多常见互联网通信功能必需的格式和控制信息。在通信会话过程中，源设备和目的设备均使用应用层协议。为确保通信畅通，<strong>源主机和目的主机上所实现的应用层协议必须一致。</strong></p>
<h2 id="对等"><a href="#对等" class="headerlink" title="对等"></a>对等</h2><p>在客户端-服务器模型中，请求信息的设备称为客户端，而响应请求的设备称为服务器。 客户端是一个硬件/软件的组合，人们使用它来直接访问存储在服务器上的资源。</p>
<p>客户端进程和服务器进程都处于应用层。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。应用层协议规定了客户端和服务器之间请求和响应的格式。除了实际数据传输外，数据交换过程还要求用户身份验证以及要传输的数据文件的标识。</p>
<p><strong>对等网络</strong></p>
<p>在对等 (P2P（Peer-to-Peer）) 网络模式中，可以从对等设备访问数据，而无需使用专用服务器。</p>
<p>P2P 网络模型包含两个部分：P2P 网络和 P2P 应用程序。这两个部分具有相似的特征，但实际工作过程却大不相同。</p>
<p>在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源(如打印机和文件)时可以不借助专用服务器。每台接入的终端设备（称为“对等体”）<strong>既可以作为服务器，也可以作为客户端</strong>。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。于是，计算机的角色根据请求的不同在客户端和服务器之间切换。</p>
<p>除共享文件外，这样一个网络还允许用户启用网络游戏，或者共享互联网连接。</p>
<p>在对等交换中，两台设备在通信过程中处于平等地位。对等体1拥有与对等体2共享的文件，甚至可以访问直接连接到对等体2的共享打印机来打印文件。</p>
<p>某些 P2P 应用程序中采用混合系统，即共享的资源是分散的，但<strong>指向资源位置的索引存储在集中目录</strong>中。在混合系统中，每台对等设备通过访问索引服务器获取存储在另一台对等设备中的资源位置。</p>
<p><strong>注意:</strong> 用户间可以分享任何类型的文件。这些文件中的许多是有版权的，这意味着只有创建者有使用和分发它们的权利。未得到版权持有者许可下载或分发有版权的文件是违法的。侵害版权会导致刑事起诉或民事诉讼。</p>
<h2 id="具体协议"><a href="#具体协议" class="headerlink" title="具体协议"></a>具体协议</h2><p><strong>DNS - 域名系统（或服务）</strong></p>
<ul>
<li>TCP,UDP客户端 53</li>
<li>将域名（例如 cisco.com）转换为 IP 地址。</li>
</ul>
<p><strong>DHCP-动态主机配置协议</strong></p>
<ul>
<li>UDP 客户端 68，服务器 67</li>
<li>动态分配IP地址可以重复使用不再需要的地址</li>
</ul>
<p><strong>SMTP - 简单邮件传输协议</strong></p>
<ul>
<li>TCP 25</li>
<li>允许客户端向邮件服务器发送电子邮件</li>
<li>允许服务器向其他服务器发送电子邮件</li>
</ul>
<p><strong>POP3 - 邮局协议</strong></p>
<ul>
<li>TCP 110</li>
<li>允许客户端从邮件服务器检索电子邮件 将电子邮件* 下载到客户端的本地邮件应用程序</li>
</ul>
<p><strong>IMAP - 互联网消息访问协议</strong></p>
<ul>
<li>TCP 143</li>
<li>允许客户端访问存储在邮件服务器中的电子邮件</li>
<li>在服务器上维护电子邮件</li>
</ul>
<p><strong>FTP - 文件传输协议</strong></p>
<ul>
<li>TCP 20至21</li>
<li>设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件</li>
<li>FTP是一种可靠、面向连接且进行确认的文件传输协议。</li>
</ul>
<p><strong>TFTP - 简单文件传输协议</strong></p>
<ul>
<li>UDP 客户端 69</li>
<li>一个简单的，无连接的文件传输协议，使用尽最大努力、不被答复的文件交付</li>
<li>它使用的开销比FTP少</li>
</ul>
<p><strong>HTTP-超文本传输协议</strong></p>
<ul>
<li>TCP 80,8080</li>
<li>有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集</li>
</ul>
<p><strong>HTTPS - 安全 HTTP</strong></p>
<ul>
<li>TCP，UDP 443</li>
<li>浏览器使用加密技术保护 HTTP 通信</li>
<li>验证您的浏览器连接的网站</li>
</ul>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>电子邮件托管是 ISP 提供的主要服务之一。如果要在计算机或其他终端设备上运行电子邮件，仍然需要多种应用程序和服务，如图所示。邮件是通过网络发送、存储和检索电子消息的存储转发方法。邮件消息存储在邮件服务器的数据库中。</p>
<p>邮件客户端通过与邮件服务器通信来收发邮件。邮件服务器之间也会互相通信，以便将邮件从一个域发到另一个域中。也就是说，发送邮件时，邮件客户端并不会直接与另外一个邮件客户端通信。而是双方客户端均依靠邮件服务器来传输邮件。</p>
<p><strong>SMTP</strong></p>
<p>SMTP 邮件格式要求邮件具有报头和正文。虽然邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人邮件地址和发件人地址。</p>
<p>当客户端发送邮件时，客户端 SMTP 进程会连接公认端口 25 上的服务器 SMTP 进程。连接建立后，客户端将尝试通过此连接发送邮件到服务器。服务器收到邮件后，<strong>如果收件人在本地</strong>，它会将邮件保存在本地账户中，或者将邮件转发给另一台邮件服务器以便传输。</p>
<p>发出邮件时，目的邮件服务器可能并不在线，或者正忙。因此，SMTP 将邮件转到后台处理，稍后再发送。服务器会定期检查邮件队列，然后尝试再次发送。经过预定义的过期时间后，如果仍然无法发送邮件，则会将其作为无法投递的邮件退回给发件人。</p>
<p><strong>POP</strong></p>
<p>应用程序使用 POP 从邮件服务器中检索邮件。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。这是 POP 的默认操作。</p>
<p>服务器通过在 TCP 端口 110 上被动侦听客户端连接请求来启动 POP 服务。当客户端要使用此服务时，它会发送一个请求来建立与服务器的 TCP 连接，如图所示。一旦建立连接，POP 服务器即会发送问候语。然后客户端和 POP 服务器会交换命令和响应，直到连接关闭或中止。</p>
<p>根据 POP，由于电子邮件会下载到客户端并从服务器删除，因此电子邮件不会集中保存在某一特定的位置。因为 POP 不存储邮件，因此不建议用于需要集中备份解决方案的小型企业。</p>
<p>POP3 是最常用的版本。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210820225748133.png" alt="image-20210820225748133" style="zoom:67%;" />

<p><strong>IMAP</strong></p>
<p>IMAP 是另外一种用于检索电子邮件消息的协议。与 POP 不同的是，当用户连接使用 IMAP 的服务器时，邮件的副本会下载到客户端应用程序，如图所示。同时原始邮件会一直保留在服务器上，直到用户将它们手动删除。用户在自己的邮件客户端软件中查看邮件副本。</p>
<h3 id="IP编制服务"><a href="#IP编制服务" class="headerlink" title="IP编制服务"></a>IP编制服务</h3><p>本主题将详细介绍 IP 编址服务、DNS 和 DHCP。</p>
<p>DNS 协议定义了一套自动化服务，该服务将资源名称与所需的数字网络地址匹配。协议涵盖了查询格式、响应格式及数据格式。DNS 协议通信采用单一格式，即消息格式。该格式用于所有类型的客户端查询和服务器响应、报错消息、以及服务器间的资源记录信息的传输。</p>
<p>在使用域名时请求首先发到DNS服务器，服务器将请求与IP地址匹配后返回IP，客户端再使用IP请求服务器</p>
<p>DNS 服务器中<strong>存储不同类型的资源记录，用来解析域名</strong>。这些记录中包含域名、地址以及记录的类型。这些记录有以下类型：</p>
<ul>
<li><strong>A</strong> - 终端设备 IPv4 地址</li>
<li><strong>NS</strong> - 授权域名服务器</li>
<li><strong>AAAA</strong> - 终端设备 IPv6 地址（读作“四 A”）</li>
<li><strong>MX</strong> - 邮件交换记录</li>
</ul>
<p>在客户端进行查询时，服务器 DNS 进程首先会查看自己的记录以解析名称。如果服务器不能通过自身存储的记录解析域名，<strong>它将联系其他服务器对该域名进行解析</strong>。在检索到匹配信息并将其返回到原始请求服务器后，服务器临时存储数字地址，以供再次请求同一域名时使用。</p>
<table>
<thead>
<tr>
<th align="left"><strong>DNS 消息部分</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">问题</td>
<td align="left">向域名服务器提出的问题</td>
</tr>
<tr>
<td align="left">回答</td>
<td align="left">回答该问题的资源记录</td>
</tr>
<tr>
<td align="left">权限 (Authority)</td>
<td align="left">指向权限的资源记录</td>
</tr>
<tr>
<td align="left">更多</td>
<td align="left">包含其他信息的资源记录</td>
</tr>
</tbody></table>
<p><strong>层级</strong></p>
<p>DNS 协议采用分层系统创建数据库以提供名称解析</p>
<p>域名结构被划分为多个更小的受管域。每台 DNS 服务器维护着特定的数据库文件，而且只负责管理 DNS 结构中那一小部分的“域名-IP”映射。</p>
<p>当 DNS 服务器收到的域名转换请求不属于其所负责的 DNS 区域时，该 DNS 服务器可将请求转发到与该请求对应的区域中的 DNS 服务器进行转换。</p>
<p>DNS 具有可扩展性，这是因为主机名解析分散于多台服务器上完成。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821120533246.png" alt="image-20210821120533246" style="zoom:67%;" />

<p>ISP往往会为 DNS 服务器提供地址。</p>
<p>用户还可以使用操作系统中名为 Nslookup 的实用程序手动查询域名服务器，来解析给定的主机名。</p>
<p>该实用程序也可以用于检修域名解析故障，以及验证域名服务器的当前状态。</p>
<p><strong>动态主机配置协议</strong></p>
<p>IPv4 服务的动态主机配置协议 (DHCP) 会自动分配 IPv4 地址、子网掩码、网关以及其他 IPv4 网络参数。这称为动态编址。动态编址的替代选项是静态编址。在使用静态编址时，网络管理员在主机上手动输入 IP 地址信息。</p>
<p>主机连入网络时，将联系 DHCP 服务器并请求地址。DHCP 服务器从已配置地址范围（也称为“地址池”）中选择一条地址，并将其分配（租赁）给主机。</p>
<p>在较大型的网络中，或者用户经常变更的网络中，地址分配优先选用 DHCP。新用户可能在到达时需要连接；其他用户可能有新计算机必须要连接。<strong>与为每个连接使用静态编址的做法相比，采用 DHCP 自动分配 IPv4 地址的方法更有效。</strong></p>
<p>DHCP可以在一段可配置的时间内分配IP地址，这段时间称为<strong>租期</strong>，当租期过期或 DHCP 服务器收到 DHCPRELLAME 消息时，地址将返回到 DHCP 池以便重复使用。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821121252200.png" alt="image-20210821121252200" style="zoom:67%;" />

<p>很多网络都同时采用 DHCP 和静态编址。DHCP 用于一般用途主机，例如用户终端设备。静态编址用于网络设备，例如网关路由器、交换机、服务器和打印机。</p>
<p>IPv6 的 DHCP（DHCPv6）为 IPv6 客户端提供类似服务。一个重要的不同是，DHCPv6 不会提供默认网关地址。这只能从路由器的 Router Advertisement（路由器通告）消息中动态获得。</p>
<p><strong>工作原理</strong></p>
<p>配置了 DHCP 的 IPv4 设备在启动或连接到网络时，客户端将广播一条 DHCP 发现 (DHCPDISCOVER) 消息以确定网络上是否有可用 DHCP 服务器。DHCP 服务器回复 DHCP 服务 (DHCPOFFER) 消息，为客户端提供租赁服务。该服务消息包含为其分配的 IPv4 地址和子网掩码、DNS 服务器的 IPv4 地址和默认网关的 IPv4 地址。租赁服务还包括租用期限。</p>
<p>如果本地网络中有超过一台 DHCP 服务器，客户端可能会收到多条 DHCPOFFER 消息。此时，客户端必须在这些服务器中进行选择，并且将包含服务器标识信息及客户端所接受的租赁服务的 DHCP 请求 (DHCPREQUEST) 消息发送出去。<strong>客户端还可选择向服务器请求分配以前分配过的地址。</strong></p>
<p>如果客户端请求的 IPv4 地址（或者服务器提供的 IPv4 地址）仍然可用，服务器将返回 DHCP 确认 (DHCPACK) 消息，向客户端确认地址租赁。如果请求的地址不再有效，则所选服务器将回复一条 DHCP 否定确认 (DHCPNAK) 消息。一旦返回 DHCP NAK 消息，应<strong>重新启动选择进程</strong>，并重新发送新的 DHCP 发现消息。客户端租赁到地址后，应在租期结束前发送 DHCPREQUEST 消息进行<strong>续期</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821121446056.png" alt="image-20210821121446056" style="zoom:50%;" />

<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>FTP 用于客户端和服务器之间的数据传输。FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821123329521.png" alt="image-20210821123329521" style="zoom:50%;" />

<p>客户端使用 TCP 端口 21 与服务器建立第一个连接用于控制流量。流量由客户端命令和服务器应答组成。</p>
<p>客户端使用 TCP 端口 20 与服务器建立第二个连接用于实际数据传输。每当有数据需要传输时都会建立此连接。</p>
<p><strong>数据传输可以在任何一个方向进行</strong>。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。</p>
<p>服务器消息块 (SMB) 是一种客户端/服务器文件<strong>共享协议</strong>，用于规范共享网络资源（如目录、文件、打印机以及串行端口）结构。</p>
<p>以下是 SMB 消息的三个功能：</p>
<ul>
<li>启动、身份验证以及终止会话</li>
<li>控制文件和打印机的访问</li>
<li>允许应用程序向任何设备收发消息</li>
</ul>
<p>Microsoft 网络配置中主要采用 SMB 形式实现文件共享和打印服务。</p>
<p>从 Windows 2000 开始，之后的所有 Microsoft 产品都使用 DNS 命名，使 TCP/IP 协议能够直接支持 SMB 资源共享，如图所示。</p>
<p>与 FTP 协议支持的文件共享不同，SMB 协议中的客户端要与服务器建立长期连接。一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p>
<h1 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h1><p>本模块将概述网络攻击的类型，以及如何减少威胁发起者成功的机会。</p>
<h2 id="威胁和漏洞"><a href="#威胁和漏洞" class="headerlink" title="威胁和漏洞"></a>威胁和漏洞</h2><h3 id="威胁类型"><a href="#威胁类型" class="headerlink" title="威胁类型"></a><strong>威胁类型</strong></h3><p><strong>信息盗窃</strong> 指侵入计算机以获取机密信息。信息可以用于各种目的或出售。例子: 盗窃组织的专有信息，例如研究和开发数据。</p>
<p><strong>数据丢失和操纵</strong> 是指闯入计算机破坏或更改数据记录。数据丢失的示例是：一个威胁发起者发送可重新格式化计算机硬盘的病毒。数据操纵示例是：闯入记录系统来更改信息（例如物品价格）。</p>
<p><strong>身份盗窃</strong> 是一种信息盗窃形式，以冒用他人的身份为目的窃取个人信息。利用此类信息，威胁发起者便可以非法获取文件、申请信用贷款或者进行未经授权的在线购物。身份盗窃案件日渐增多，每年造成的损失达数十亿之多。</p>
<p><strong>服务中断</strong> 阻止合法用户访问他们有权访问的服务。例如: 对服务器、网络设备或网络通信链路发起的拒绝服务 (DoS) 攻击。</p>
<h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a><strong>漏洞类型</strong></h3><p>漏洞是指网络或设备的薄弱程度。路由器、交换机、桌面、服务器、甚至安全设备都存在一定程度的漏洞。一般而言，受到攻击的网络设备都是端点设备，例如服务器和台式计算机。</p>
<p>有三种主要的漏洞或弱点：技术、配置和安全策略。所有这三种漏洞源都会让网络或设备<strong>对各种攻击保持开放状态</strong>，包括恶意代码攻击和网络攻击。</p>
<p><strong>技术漏洞</strong></p>
<table>
<thead>
<tr>
<th align="left">漏洞</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TCP/IP 协议缺陷</td>
<td align="left">超文本传输协议 (HTTP)，文件传输协议(FTP)， 和互联网控制消息协议 (ICMP)本质上是 不安全的。简单网络管理协议 (SNMP)和简单邮件传输 协议 (SMTP) 与TCP设计时所基于的固有的 不安全结构有关。</td>
</tr>
<tr>
<td align="left">操作系统缺陷</td>
<td align="left">每个操作系统都有必须解决的安全问题。UNIX、Linux、Mac OS、Mac OS X、Windows Server 2012、Windows 7、 Windows 8它们记录在计算机应急响应小组 (CERT) 档案中， 网址为 <a href="http://www.cert.org./">http://www.cert.org。</a></td>
</tr>
<tr>
<td align="left">网络设备缺陷</td>
<td align="left">各种类型的网络设备，例如路由器，防火墙和 交换机都具有安全弱点，必须识别并加以 保护。他们的弱点包括密码保护，缺乏 身份验证、路由协议和防火墙漏洞。</td>
</tr>
</tbody></table>
<p><strong>配置漏洞</strong></p>
<table>
<thead>
<tr>
<th align="left">漏洞</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">不安全的用户帐户</td>
<td align="left">用户帐户信息可能不安全地通过网络传输， 将用户名和密码暴露给威胁发起者。</td>
</tr>
<tr>
<td align="left">系统帐户的密码容易被猜到</td>
<td align="left">用户密码创建不当造成了这种常见问题。</td>
</tr>
<tr>
<td align="left">互联网服务配置错误</td>
<td align="left">在Web浏览器中打开JavaScript可以在访问不受信任的站点时 通过由威胁发起者控制的JavaScript进行攻击。 其他潜在的弱点来源包括配置错误的终端 服务、FTP 或 Web 服务器（例如微软互联网信息 服务 IIS) 和 Apache HTTP 服务器。</td>
</tr>
<tr>
<td align="left">产品的默认设置不安全</td>
<td align="left">许多产品的默认设置容易带来 安全漏洞。</td>
</tr>
<tr>
<td align="left">网络设备配置错误</td>
<td align="left">设备本身配置错误会带来严重的安全 问题。例如，错误配置的访问列表、路由协议或 SNMP 社区字符串可以造成或开启安全漏洞。</td>
</tr>
</tbody></table>
<p><strong>策略漏洞</strong></p>
<table>
<thead>
<tr>
<th align="left">漏洞</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缺乏书面的安全策略</td>
<td align="left">未以书面形式记录的安全策略无法得到长久有效的 应用和执行。</td>
</tr>
<tr>
<td align="left">政治</td>
<td align="left">政治斗争和争权夺利可能导致难以长期执行 相同的安全策略。</td>
</tr>
<tr>
<td align="left">缺乏身份验证持续性</td>
<td align="left">如果密码选择不当、易于破解或甚至是默认密码，会导致 对网络的未经授权的访问。</td>
</tr>
<tr>
<td align="left">没有实行逻辑访问控制</td>
<td align="left">监控和审计力度不够，导致攻击和未授权使用不断发生， 浪费公司资源。这可能会导致法律诉讼 或针对IT技术人员、IT管理人员、 甚至允许这些不安全条件持续存在的公司领导层的解雇。</td>
</tr>
<tr>
<td align="left">软件和硬件的安装与更改没有遵循策略执行</td>
<td align="left">未经授权更改网络拓扑或安装 未经批准的应用程序会造成或开启安全漏洞。</td>
</tr>
<tr>
<td align="left">没有设计灾难恢复计划</td>
<td align="left">缺乏灾难恢复计划可能在发生自然灾害或 企业在遭到威胁发起者攻击时造成恐慌和 混乱。</td>
</tr>
</tbody></table>
<h3 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h3><p>如果网络资源可以被物理性破坏，攻击发起者便可借此拒绝对网络资源的使用。</p>
<p>物理威胁分为四类：</p>
<p>硬件威胁 － 这包括对服务器、路由器、交换机、布线间和工作站的物理破坏<br>环境威胁 －这包括极端温度（过热或过冷）或极端湿度（过湿或过干）<br>电气威胁 － 这包括电压过高、电源电压不足（电气管制）、不合格电源（噪音），以及断电<br>维护威胁 － 这包括关键电气组件处理不佳（静电放电），缺少关键备用组件、布线混乱和标识不明</p>
<h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h3><p>恶意软件是“有恶意的软件”的简称。是专门用来损坏、破坏、窃取数据、主机或网络或对数据、主机或网络进行“坏的”或者非法操作的代码或软件。恶意软件的类型包括病毒、蠕虫和特洛伊木马</p>
<p><strong>病毒</strong></p>
<p>计算机病毒是一种通过将自身副本插入另一个程序并成为其一部分来传播的恶意软件类型。</p>
<p>几乎所有的病毒都是附加到一个可执行文件中，这意味着病毒可能在系统上存在，但在用户运行或打开恶意主机文件或程序前不会处于活跃状态也不会传播。执行主机代码后，也就执行了病毒代码。</p>
<p>当病毒附加的软件或文档通过网络、磁盘、文件共享或被感染的电子邮件附件从一台计算机传输到另一台计算机时，也传播了病毒。</p>
<p><strong>蠕虫</strong></p>
<p>计算机蠕虫与病毒相似，它们均可复制自身的功能副本，并造成相同类型的损坏。与病毒相比，病毒需要通过感染的主机文件来传播，而蠕虫属于独立软件，无需借助主机程序或人工帮助便可利用系统功能在网络中传输。</p>
<p><strong>特洛伊木马</strong></p>
<p>它是看起来合法的有害软件。用户通常是被骗加载特洛伊木马并在他们的系统上执行。特洛伊木马激活后，可以在主机上进行任意数量的攻击，从激怒用户（过多的弹窗或改变桌面）到破坏主机（删除文件、窃取数据或激活和传播病毒等其他恶意软件）。众所周知，<u>特洛伊木马为恶意用户访问系统创建后门</u>。</p>
<p>特洛伊木马必须通过用户交互传播，如打开电子邮件附件或从互联网下载并运行文件。</p>
<h3 id="网络攻击-1"><a href="#网络攻击-1" class="headerlink" title="网络攻击"></a>网络攻击</h3><ul>
<li><strong>侦察攻击</strong> – 搜索和映射系统、服务或漏洞</li>
<li><strong>访问攻击</strong> – 数据、系统或用户访问权限的未授权控制</li>
<li><strong>拒绝服务</strong> – 网络、系统或服务的禁用或损坏</li>
</ul>
<p>对于侦察攻击，外部威胁发起者可以使用互联网工具（如 nslookup 和 whois 实用程序）轻松地确定分配给公司或实体的 IP 地址空间。确定 IP 地址空间后，威胁发起者可以 ping 这些公有 IP 地址以确定哪些地址正在使用。为帮助自动执行此步骤，威胁发起者可能会使用 ping 扫描工具，例如 fping 或 gping。它系统地向给定范围或子网中的所有网络地址执行 ping 操作。</p>
<p><strong>侦察攻击</strong></p>
<p>互联网查询：查找与目标相关的初始信息，可以使用多种工具，包括Google搜索、组织机构网站、whois等。</p>
<p>ping扫描：发起 ping 扫描，以确定哪些 IP 地址处于活动状态。</p>
<p>端口扫描：威胁发起者对发现的活动 IP 地址执行端口扫描。</p>
<p><strong>访问攻击</strong></p>
<p>访问攻击利用身份验证服务、FTP 服务和 Web 服务的已知漏洞，获取对 Web 帐户、机密数据库和其他敏感信息的访问。访问攻击使个人能够对他们无权查阅的信息进行未经授权访问。</p>
<p>密码攻击：暴力攻击、特洛伊木马、数据包嗅探</p>
<p>信任利用：威胁发起者会使用未经授权的特权来访问系统，可能还会进一步攻陷目标。</p>
<p>端口重定向：威胁发起者会把攻陷的系统作为攻击其他目标的大本营。</p>
<p>中间人：威胁发起者会置身于两个合法实体之间，以便读取或修改双方之间传输的数据。</p>
<p><strong>拒绝服务攻击</strong></p>
<p>拒绝服务 (DoS) 攻击是知名度最高的攻击，并且是最难防范的攻击。然而，由于其实施简单、破坏力强大，安全管理员需要特别关注 DoS 攻击。</p>
<p>DoS 攻击的方式多种多样。不过其目的都是通过<strong>消耗系统资源使授权用户无法正常使用服务</strong>。为了帮助防止 DoS 攻击，必须使操作系统和应用程序与最新的安全更新保持同步。</p>
<p>DoS 攻击属于重大风险，因为它们可以中断通信，并在时间和财务上造成大量损失。这些攻击执行起来相对简单，即使是缺乏技能的威胁发起者也可以执行。</p>
<p>分布式 DoS 攻击 (DDoS) 与 DoS 攻击类似，但是它从多个协同攻击源发起攻击。举例来说，威胁发起者建立了一个受感染主机的网络，受感染的主机称为僵尸主机。受感染主机（僵尸）的网络称为僵尸网络。威胁发起者使用命令和控制(CnC)程序来指示僵尸网络进行DDoS攻击。</p>
<h2 id="网络攻击缓解"><a href="#网络攻击缓解" class="headerlink" title="网络攻击缓解"></a>网络攻击缓解</h2><p>要缓解网络攻击，必须首先保护设备，包括路由器、交换机、服务器和主机。大多数组织机构使用纵深防御法（也称为分层方法）来确保安全性。这需要网络设备和服务相互配套以协同工作。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821151358183.png" alt="image-20210821151358183" style="zoom: 67%;" />

<p><strong>保留备份</strong></p>
<p>备份设备配置和数据是防止数据丢失的最有效方式之一。</p>
<p>应根据安全策略中的规定定期执行备份。数据备份通常存储在非现场位置，在主要设施发生任何问题时能保护备份介质。Windows 主机提供了备份和还原实用程序。对用户来说，将数据备份到其他驱动器或基于<strong>云</strong>的存储提供商非常重要。</p>
<table>
<thead>
<tr>
<th align="left"><strong>考虑事项</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">频率</td>
<td align="left">根据安全策略中的标识定期执行 备份。完全备份可能非常耗时，因此需要每月或 或每周执行一次备份，并经常对更改的文件进行部分备份。</td>
</tr>
<tr>
<td align="left">存储容量</td>
<td align="left">务必对备份进行验证，以确保数据的完整性并验证文件恢复程序。 验证文件恢复程序。</td>
</tr>
<tr>
<td align="left">安全</td>
<td align="left">应按照安全策略的要求，每天， 每周或每月轮流将备份转移到批准的异地 存储位置。</td>
</tr>
<tr>
<td align="left">验证</td>
<td align="left">应使用强密码保护备份。恢复数据 需要提供密码。</td>
</tr>
</tbody></table>
<p>保持与最新进展同步会使对网络攻击的防御更加有效。随着新的恶意软件不断涌现，企业必须保持当前的防病毒软件为最新版本。</p>
<p><strong>认证、授权和记账</strong></p>
<p>所有网络设备都应该进行安全配置，只允许经过授权的个人访问。认证、授权和记账（AAA 或“三 A”）网络安全服务提供了设置网络设备访问控制的主要框架。</p>
<p>AAA 方法用于控制可以访问网络的用户（认证）、用户访问网络时可以执行的操作（授权），以及把他们在那里时所做的事记录下来（记账）。</p>
<p><strong>防火墙</strong></p>
<p>防火墙是保护用户远离外部威胁的最为有效的安全工具之一。防火墙可通过防止不必要的流量进入内部网络来保护计算机和网络。防火墙驻留在两个或多个网络之间，控制其间的流量并帮助阻止未授权的访问。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821152853399.png" alt="image-20210821152853399" style="zoom:50%;" />

<p>防火墙可以允许外部用户控制对特定服务的访问。例如，外部用户可访问的服务器通常位于称为隔离区 (DMZ) 的特殊网络中，如图所示。DMZ 使网络管理员能够为连接到该网络的主机应用特定策略。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210821152909802.png" alt="image-20210821152909802" style="zoom:50%;" />



<p><strong>防火墙类型</strong></p>
<p>防火墙产品可以打包成各种形式。这些产品使用不同技术来区分应禁止和应允许的网络访问。其包括以下内容：</p>
<p>数据包过滤 - 根据 IP 或 MAC 地址阻止或允许访问<br>应用程序过滤 - 根据端口号阻止或允许访问特定类型的应用程序<br>URL 过滤 - 根据特定的 URL 或关键字阻止或允许访问网站<br>状态包侦测 (SPI) - 传入数据包必须是对内部主机所发出请求的合法响应。除非得到特别允许，否则未经请求的数据包会被拦截。状态包侦测还可具有识别和过滤特定类型攻击，例如拒绝服务 (DoS) 的能力。</p>
<h2 id="设备安全"><a href="#设备安全" class="headerlink" title="设备安全"></a>设备安全</h2><p>在网路中有很多区域需要格外提供安全防护，设备本身就是其中之一。</p>
<p>当在设备上安装新的操作系统时，安全设置保留为默认值。在大多数情况下，这种安全级别并不够。对于思科路由器，思科AutoSecure 功能可用于协助保护系统，如示例所示。</p>
<p>通常，制造商提供的设备已经在仓库中存放了一段时间，并没有安装最新补丁。必须在投入使用之前更新所有软件并安装所有安全补丁。</p>
<p>为了保护网络设备，使用强密码非常重要。以下是需要遵循的标准原则：</p>
<ul>
<li>使用的密码长度至少为 8 个字符，最好是 10 个或更多字符。密码越长越安全。</li>
<li>使用复杂密码。如果条件允许，密码中混合使用大写和小写字母、数字、符号和空格。</li>
<li>密码中避免使用重复的常用字词、字母或数字顺序、用户名、亲属或宠物的名字、个人传记信息（例如出生期、身份证号码、祖先的名字）或其他易于识别的信息。</li>
<li>故意将口令中的词拼错。例如，Smith = Smyth = 5mYth 或 Security = 5ecur1ty。</li>
<li>定期更改密码。如果密码不知不觉地遭到破坏，那么威胁发起者使用该密码的机会就会受到限制。</li>
<li>请勿将密码写出来并放在显眼位置上，比如桌面上或显示屏上。</li>
</ul>
<p>思科路由器会忽略密码中的前置空格，但第一个字符之后的空格不会忽略。因此，创建强密码的一种方法就是使用空格键和创建一个由多个词组成的短语。这就是所谓的<strong>密码短语</strong>。密码短语通常比简单密码更易记忆。而且猜到它所用时间更长，也更难猜到。</p>
<p>强密码只有在保持其机密性才是有用的。在思科路由器和交换机上可以采取以下几个步骤来确保密码的机密性：</p>
<ul>
<li>加密所有的明文密码</li>
<li>设置可接受的最小密码长度</li>
<li>阻止暴力密码猜测攻击</li>
<li>在指定时间后 禁用非活动的特权 EXEC 模式访问。</li>
</ul>
<p>启用<strong>SSH</strong></p>
<p>Telnet简化了远程设备访问，但并不安全。Telnet 数据包中包含的数据以未加密形式传输。因此，强烈建议在设备上启用安全外壳 (SSH) 以进行安全远程访问。</p>
<p>可以通过下列六个步骤来配置思科设备以支持 SSH。</p>
<p>步骤 1. 配置唯一的主机名。设备必须有一个唯一的主机名，而不是默认主机名。</p>
<p>步骤 2. 配置 IP 域名. 使用全局配置命令 ip-domain name 配置网络的 IP 域名。</p>
<p>步骤 3. 生成密钥来加密 SSH 流量. SSH 加密源和目的地之间的流量。但是，要这样做，必须使用全局配置命令 crypto key generate rsa general-keys modulus 位数 生成唯一的身份验证密钥。该模数位数确定密钥大小并且可配置为 360 位至 2048 位。位值越大，密钥越安全。然而，较大的位值也需要较长的时间来加密和解密信息。最小建议系数长度为 1024 位。</p>
<p>步骤 4. 验证或创建一个本地数据库条目。使用 username 全局配置命令来创建本地数据库用户名条目。在示例中，使用了参数 secret，因此密码将使用MD5加密。</p>
<p>步骤 5. 向本地数据库认证身份。使用 login local 线路配置命令对本地数据库的vty线路进行身份验证。</p>
<p>步骤 6. 启用 vty inbound SSH 会话. 默认情况下，在vty线路上不允许输入会话。您可以使用 transport input [ssh | telnet] 命令指定多个输入协议，包括 Telnet 和 SSH。</p>
<p>如示例所示，路由器R1配置在span.com域中。此信息与 crypto key generate rsa general-keys modulus 命令中指定的位值一起使用，用于创建加密密钥。</p>
<p>接下来，为名为 Bob 的用户创建本地数据库条目。最后，将vty线路配置为根据本地数据库进行身份验证，并且只接受传入的SSH会话。</p>
<pre class="line-numbers language-none"><code class="language-none">Router# configure terminal
Router(config)# hostname R1
R1(config)# ip domain name span.com
R1(config)# crypto key generate rsa general-keys modulus 1024
The name for the keys will be: Rl.span.com % The key modulus size is 1024 bits
% Generating 1024 bit RSA keys, keys will be non-exportable...[OK]
Dec 13 16:19:12.079: %SSH-5-ENABLED: SSH 1.99 has been enabled
R1(config)#
R1(config)# username Bob secret cisco
R1(config)# line vty 0 4
R1(config-line)# login local
R1(config-line)# transport input ssh
R1(config-line)# exit
R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我迷惑了。。</p>
<p>思科路由器和交换机启动时会有一列活动服务，这些活动在您的网络中可能需要或不需要。禁用任何未使用的服务以保留系统资源，如CPU周期和RAM，并防止威胁发起者利用这些服务。默认打开的服务类型将根据IOS版本而有所不同。例如，IOS-XE 通常只打开 HTTPS 和 DHCP 端口。您可以使用 show ip ports all 命令来验证这一点。</p>
<p>使用 no ip http server 全局配置命令禁用 HTTP。通过在行配置命令 transport input ssh 中指定仅 SSH 来禁用 Telnet 。</p>
<h1 id="构建小型网络"><a href="#构建小型网络" class="headerlink" title="构建小型网络"></a>构建小型网络</h1><p>欢迎来学习构建小型网络！</p>
<p>棒极了！您已经来到了网络简介 v7.0 课程的<strong>最后一个模块</strong>。您已经掌握了建立自己的网络所需的大部分基础知识。从现在开始怎么做？当然，你要构建一个网络。而且您不仅要构建它，还要验证它是否正常工作，甚至还要解决一些常见的网络问题。</p>
<h2 id="小型网络"><a href="#小型网络" class="headerlink" title="小型网络"></a>小型网络</h2><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>小型网络的设计通常很简单。与较大型网络相比，小型网络中设备的数量和类型都显著减少了。</p>
<p>在实施网络时，创建一个 IP编址方案并使用它。互联网络中的所有主机和设备都必须有一个唯一地址。</p>
<p>将纳入IP编址方案的设备包括以下内容：</p>
<p>终端用户设备-连接的数量和类型（即有线、无线、远程访问）<br>服务器和外部设备（如打印机和安全摄像头）<br>路由器、交换机和接入点都属于中间设备。<br>建议您根据设备类型规划、记录和维护 IP编址方案。使用计划好的IP编址方案可以更容易地识别设备类型并对排除故障，例如，在使用协议分析器排除网络流量问题时。</p>
<p>网络设计的另一个重要部分是可靠性。即使是小型企业，也常常非常依赖其网络以进行企业运营。网络故障的代价是非常大的。</p>
<p>为了保持高可靠度，网络设计中要求<strong>冗余</strong>。冗余有助于避免单点故障。</p>
<p>在网络中实现冗余有许多方法。可以通过安装重复设备实现冗余，但也可以通过为关键区域提供重复的网络链路来实现，如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210823164045084.png" alt="image-20210823164045084" style="zoom:67%;" />

<p>小型网络通常通过一个或多个默认网关提供单个互联网出口点。如果路由器发生故障，则整个网络都会失去与互联网的连接。因此，建议小型企业通过另一个服务提供商购买备份产品。</p>
<p><strong>流量管理</strong></p>
<p>小型网络中良好网络设计的目标也是为了提高员工工作效率和最大限度地减少网络中断。网络管理员应当考虑网络设计中的各种流量类型及其处理。</p>
<p>应当对小型网络中的路由器和交换机进行配置，以相对于其他数据流量的适当方式支持实时流量，如语音和视频。事实上，一个好的网络设计将实现服务质量（QoS），根据优先级对流量进行仔细分类，如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210823164630041.png" alt="image-20210823164630041" style="zoom:67%;" />





<h3 id="应用和协议"><a href="#应用和协议" class="headerlink" title="应用和协议"></a>应用和协议</h3><p>您的网络仍然需要某些类型的应用程序和协议才能工作。</p>
<p>网络只有在网络上存在应用程序时才有用。有两种形式的软件程序或进程可以提供网络访问：网络应用程序和应用层服务。</p>
<p><strong>网络应用程序</strong></p>
<p>应用程序是指用于网络通信的软件程序。有些终端用户应用程序是网络感知程序，即这些程序实现应用层协议，并<strong>可直接与协议栈的较低层通信</strong>。电子邮件客户端和 Web 浏览器就属于这种类型的应用程序。</p>
<p><strong>应用层服务</strong></p>
<p>其他程序可能需要通过应用层服务使用网络资源，例如文件传输或网络假脱机打印。虽然这些服务对员工而言是透明的，但它们正是负责与网络交互和准备传输数据的程序。无论数据类型是文本、图形还是视频，只要类型不同，就需要与之对应的不同的网络服务，从而确保 OSI 模型的下层能够正确处理数据。</p>
<p>每个应用程序或网络服务使用协议，定义要使用的标准和数据格式。如果没有协议，数据网络将不能使用通用的方式来格式化及引导数据。为了便于理解不同网络服务的功能，我们有必要先熟悉管理这些服务的底层协议。</p>
<p><strong>常见协议</strong></p>
<p>网络管理员通常需要访问网络设备和服务器。两种最常见的远程访问解决方案是 Telnet 和安全外壳 (SSH)。SSH 服务是 Telnet 的安全替代方案。连接后，管理员可以像在本地登录一样访问 SSH 服务器设备。</p>
<p>SSH 用于在 SSH 客户端和其他支持 SSH 的设备之间建立安全的远程访问连接：</p>
<ul>
<li><strong>网络设备</strong> - 网络设备（如路由器、交换机、接入点等）必须支持 SSH，才能为客户端提供远程访问 SSH 服务器的服务。</li>
<li><strong>服务器</strong> - 服务器（例如 Web 服务器、电子邮件服务器等）必须支持到客户端的远程访问 SSH 服务器的服务。</li>
</ul>
<p>网络管理员还必须支持公用网络服务器及其所需的相关网络协议：</p>
<p><strong>Web 服务器</strong></p>
<ul>
<li>Web 客户端和 Web 服务器使用超文本传输协议 (HTTP) 交换 Web 流量。</li>
<li>超文本传输协议安全 (HTTPS) 用于安全的 Web 通信。</li>
</ul>
<p><strong>邮件服务器</strong></p>
<ul>
<li>邮件服务器和客户端使用简单邮件传输协议 (SMTP)发送邮件。</li>
<li>邮件客户端使用邮局协议 (POP3) 和互联网消息访问协议 (IMAP)检索邮件。</li>
<li>使用 <a href="mailto:user@xyz.xxx">user@xyz.xxx</a> 格式指定收件人。</li>
</ul>
<p><strong>FTP 服务器</strong></p>
<p>文件传输协议 (FTP) 服务允许在客户端和 FTP 服务器之间下载和上传文件。<br>FTP 安全（FPS）和安全 FTP（SFTP）用于保护 FTP 文件交换。</p>
<p><strong>DHCP 服务器</strong></p>
<p>客户端使用动态主机配置协议 (DHCP) 从 DHCP 服务器获取 IP 配置（即 IP地址、子网掩码、默认网关等）。</p>
<p><strong>DNS 服务器</strong></p>
<p>域名服务（DNS）将域名解析为 IP 地址（例如，cisco.com = 72.163.4.185）<br>DNS 向请求主机提供网站的 IP 地址（即域名）。</p>
<p>这些网络协议将构成网络专家的基本工具集。每种网络协议都会定义：</p>
<ul>
<li>通信会话任意一端的流程</li>
<li>消息类型</li>
<li>消息语法</li>
<li>信息性字段的意义</li>
<li>消息发送方式和预期响应</li>
<li>与下一层的交互</li>
</ul>
<h3 id="增长"><a href="#增长" class="headerlink" title="增长"></a>增长</h3><p>不断扩展是许多小型企业必经的过程，而其网络也必须相应地扩展。理想情况是网络管理员有足够的时间根据公司发展做出关于网络发展的明智决策。</p>
<p>要扩展网络，要求有以下几个要素：</p>
<ul>
<li><strong>网络文档</strong> - 物理和逻辑拓扑</li>
<li><strong>设备清单</strong> – 使用或组成网络的设备列表</li>
<li><strong>预算</strong> – 逐项列出IT预算，包括财年设备采购预算</li>
<li><strong>流量分析</strong> - 应当记录协议、应用程序和服务以及它们各自的流量要求</li>
</ul>
<p>要确定流量模式，应做好以下几点：</p>
<p>通过捕获网络使用高峰期的流量准确了解各种不同的流量类型。<br>针对不同的网段和设备捕获流量，因为某些流量仅在特定的网段内传输。</p>
<p>协议分析器收集的信息根据流量的源和目标以及发送的流量类型进行分析。这种分析有助于决定提高流量管理效率的方法，例如减少不必要的流量，或通过移动某台服务器的逻辑位置来改变流量的总体模式。</p>
<p>除了要了解流量的变化趋势，网络管理员必须知道网络的使用是如何变化的。许多操作系统都提供内置工具来显示此类信息。Windows 主机提供任务管理器、事件查看器和数据使用情况工具等工具。</p>
<p>这些工具可用于捕获以下信息的 “快照”：</p>
<ul>
<li>操作系统和操作系统版本</li>
<li>CPU 使用率</li>
<li>内存利用率</li>
<li>驱动程序利用率</li>
<li>非网络应用程序</li>
<li>网络应用程序</li>
</ul>
<p>在一段时间内记录小型网络中的员工快照对于识别不断发展的协议需求和相关的流量流非常有用。这种资源利用率的转变就可能要求网络管理员相应地调整网络资源分配。</p>
<p>Windows 10 数据使用量工具对于确定哪些应用程序正在使用主机上的网络服务特别有用。数据使用量工具可以使用 <strong>Settings &gt; Network &amp; Internet &gt; Data usage &gt; network interface</strong> （从最近 30 天开始）访问。</p>
<h3 id="验证连接"><a href="#验证连接" class="headerlink" title="验证连接"></a>验证连接</h3><p>ping 命令是快速测试源和目的 IP 地址之间第 3 层连接的最有效方法。该命令还显示各种往返时间统计信息。</p>
<p>具体而言，该 ping 命令使用 Internet 控制消息协议 (ICMP) 来Echo请求（ICMP 类型 8）和Echo应答（ICMP 类型 0）消息。该 ping 命令可用于大多数操作系统，包括 Windows、Linux、macOS 和思科 IOS。</p>
<p>在 Windows 10 主机上，该 ping 命令发送四个连续的 ICMP Echo消息，并期望从目标收到四个连续的 ICMP Echo应答。</p>
<p>思科ios系统不同，它会发送5条信息，收到的指示符如下：</p>
<table>
<thead>
<tr>
<th align="left">元素</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>!</strong></td>
<td align="left">感叹号表示成功收到Echo应答消息。它验证了源和目标之间的第 3 层连接。</td>
</tr>
<tr>
<td align="left"><strong>.</strong></td>
<td align="left">句点意味着等待Echo应答消息的时间已过期。这表示路径中某处可能存在连接问题。</td>
</tr>
<tr>
<td align="left"><strong>U</strong></td>
<td align="left">大写 <strong>U</strong> 表示沿路径的路由器 回应了 ICMP 类型 3 “目的地 不可达” 的错误消息。可能的原因包括路由器不知道目标网络的方向， 或者在目标网络上 找不到主机。</td>
</tr>
</tbody></table>
<p>其他可能的 ping 回复包括 Q、M、? 或 &amp;。但是，这些含义超出了本模块的范围。</p>
<p>不学啦！到这已经明白很多很多网络知识啦~~</p>
<p>剩下的就交给专业的网络工程师吧！！！</p>
<h1 id="日后补充"><a href="#日后补充" class="headerlink" title="日后补充"></a>日后补充</h1><p>2.1.5终端仿真程序</p>
<p>2.3.8用Tera Term连接控制台</p>
<p>2.5.4捕获配置到文本中</p>
<p>10.3.5排除默认网关故障</p>
<h1 id="真-命令集"><a href="#真-命令集" class="headerlink" title="真*命令集"></a>真*命令集</h1><p><strong>转载自：<a href="https://blog.csdn.net/qq_42833924/article/details/89790004">https://blog.csdn.net/qq_42833924/article/details/89790004</a><br>为自己学习方便故转载，如果大家觉得有帮助，请为原文点赞。</strong></p>
<p>1.基本配置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token operator">></span> enable   从用户模式进入特权模式
<span class="token class-name">R</span># disable  从特权模式退到用户模式
<span class="token class-name">R</span># logout <span class="token punctuation">(</span>或exit<span class="token punctuation">)</span>   退出<span class="token class-name">Cisco</span>设备
<span class="token class-name">R</span># show history 查看先前输入的命令（默认<span class="token number">10</span>个）
<span class="token class-name">R</span># terminal history size #_of_commands  改变历史缓存的大小（最大<span class="token number">256</span>）
<span class="token class-name">R</span># terminal no editing  禁用编辑特性（移去no参数为启用）
<span class="token class-name">R</span># configure terminal   进入配置模式（退出为end或CTRL<span class="token operator">-</span><span class="token class-name">Z</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># hostname name    改变路由器的名称
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># banner motd delimiting_character banner_character delimiting_character   设置登录横幅
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># exec<span class="token operator">-</span>timeout minutes_# seconds_#    更改休止超时（默认<span class="token number">10</span>分钟）
<span class="token class-name">R</span># show hosts   查看路由器解析表中的静态和动态DNS条目
<span class="token class-name">R</span><span class="token operator">></span> show version 查看路由器综合信息
<span class="token class-name">R</span># show line    验证线路的配置
<span class="token class-name">R</span># show processes   查看设备的各个进程的CPU使用率
<span class="token class-name">R</span># show users   查看登录到这台设备上的所有用户
<span class="token class-name">R</span># show sessions    查看当前挂起的已经打开的telnet会话
<span class="token class-name">R</span># term ip netmask<span class="token operator">-</span>format bit<span class="token operator">-</span>count<span class="token operator">|</span>decimal<span class="token operator">|</span>hexadecimal 改变子网掩码显示方式（在当前登录会话期间有效，在子线路模式下即可保存）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip host name_of_host <span class="token punctuation">[</span><span class="token class-name">TCP_port_</span>#<span class="token punctuation">]</span> <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span> 创建主机静态解析表（可指定多达<span class="token number">8</span>个IP地址）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip name<span class="token operator">-</span>server <span class="token class-name">IP_address_of_DNS_server</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>  配置通过访问DNS服务器动态解析主机（可指定多达<span class="token number">6</span>个DNS服务器）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># no ip domain<span class="token operator">-</span>lookup  禁用DNS查询
<span class="token class-name">R</span><span class="token operator">></span> ping destination_IP_address_or_host_name 查看与目的主机的连通性
<span class="token class-name">R</span><span class="token operator">></span> traceroute destination_IP_address_or_host_name   查看与目的主机间的路由器
<span class="token class-name">R</span># <span class="token punctuation">[</span>telnet<span class="token operator">|</span>connect<span class="token punctuation">]</span> name_of_the_destination<span class="token operator">|</span>destination_IP_address  打开telnet会话
<span class="token class-name">R</span># resume connection_#  恢复一个特定的会话
<span class="token class-name">R</span># disconnect connection_#  结束一已挂起的telnet会话无须恢复它并随后从中退出
<span class="token class-name">R</span># clear line line_#    结束某人的会话
<span class="token class-name">R</span># no debug all <span class="token punctuation">(</span>或undebug all<span class="token punctuation">)</span>  禁用debug
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># service timestamps debug datetime msec   在debug输出中显示时间戳
<span class="token class-name">R</span># terminal monitor 从VTY或辅助线路端口登录执行，路由器将在屏幕上显示报告消息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># logging synchronous在该线路上报告信息后路由器在新提示符后重新显示未打完的命令
<span class="token number">123456789101112131415161718192021222324252627282930</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.文件操作</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span># show running<span class="token operator">-</span>config  查看正在运行（当前）的配置文件
<span class="token class-name">R</span># show startup<span class="token operator">-</span>config  查看NVRAM中的配置文件
<span class="token class-name">R</span># copy running<span class="token operator">-</span>config<span class="token operator">|</span>startup<span class="token operator">-</span>config tftp  将配置备份到TFTP服务器
<span class="token class-name">R</span># copy tftp startup<span class="token operator">-</span>config<span class="token operator">|</span>running<span class="token operator">-</span>config  从TFTP服务器将配置恢复到路由器
<span class="token class-name">R</span># copy startup<span class="token operator">-</span>config running<span class="token operator">-</span>config   从NVRAM中将配置恢复到RAM中
<span class="token class-name">R</span># copy running<span class="token operator">-</span>config startup<span class="token operator">-</span>config   将RAM中的配置文件保存到NVRAM
<span class="token class-name">R</span># erase startup<span class="token operator">-</span>config 删除NVRAM中的配置文件
<span class="token class-name">R</span># copy flash tftp  备份IOS镜像到TFTP服务器
<span class="token class-name">R</span># show flash   查看闪存中的文件
<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.启动配置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span># setup    运行系统配置会话
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system flash name_of_IOS_file_in_flash  启动时加载闪存中的指定IOS文件
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system tftp <span class="token class-name">IOS_image_name</span> <span class="token class-name">IP_address_of_server</span> 启动时加载TFTP服务器里的IOS文件
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># boot system rom  启动时加载ROM中的迷你IOS文件（启动与这三个命令的顺序有关）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># config<span class="token operator">-</span>register <span class="token number">0</span>x hexadecimal_value 改变寄存器的值
rommon <span class="token number">5</span><span class="token operator">></span> confreg <span class="token number">0x2142</span>    <span class="token number">2600</span>、<span class="token number">3600</span>系列启动后按CTRL<span class="token operator">-</span>BREAK进入ROMMON模式，改变寄存器的值
<span class="token class-name">R</span><span class="token operator">></span> o<span class="token operator">/</span>r <span class="token number">0x2142</span>   其他系列路由器改变寄存器的值的方法
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>4.密码设置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line console <span class="token number">0</span>   进入控制台接口配置模式
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password console_password   配置控制台口令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line vty <span class="token number">0</span> <span class="token number">4</span> 进入虚拟终端线路配置模式（根据路由器及IOS最少<span class="token number">5</span>个直到很多）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># login   接上条命令，允许进行<span class="token class-name">Telnet</span>访问
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password telnet_password    接上条命令，配置<span class="token class-name">Telnet</span>口令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># line aux <span class="token number">0</span>   进入辅助端口配置模式
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># password console_password   接上条命令，配置辅助端口口令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># enable password privileged_password  配置特权EXEC口令（不加密）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># enable secret privileged_password    配置特权EXEC口令（加密）
<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>5.接口配置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  进入接口子配置模式
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># description interface_description 添加接口描述
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># no shutdown   启用该接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> loopback port_#    创建环回接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># media<span class="token operator">-</span>type aui<span class="token operator">|</span><span class="token number">10</span>baset<span class="token operator">|</span><span class="token number">100</span>baset<span class="token operator">|</span>mii   指定该接口连接的介质类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># speed <span class="token number">10</span><span class="token operator">|</span><span class="token number">100</span><span class="token operator">|</span>auto 指定该接口速率
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> half<span class="token operator">-</span>duplex  指定该接口双工模式
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># clock rate rate_in_bits_per_second    指定该DCE串行接口速率
<span class="token class-name">R</span><span class="token operator">></span> show controller serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  验证该接口是DCE还是DTE，注意空格
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># bandwidth rate_in_Kbps    改变该接口的带宽值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address <span class="token class-name">IP_address</span> subnet_mask 配置该接口IP地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip subnet<span class="token operator">-</span>zero   IOS12<span class="token punctuation">.</span><span class="token number">0</span>前默认禁用<span class="token number">0</span>子网，此命令为启用
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip directed<span class="token operator">-</span>broadcast IOS12<span class="token punctuation">.</span><span class="token number">0</span>后默认禁用定向广播，此命令为启用
<span class="token class-name">R</span># show interfaces <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span>  验证接口配置
<span class="token class-name">R</span># show ip interfaces <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span> <span class="token punctuation">[</span>brief<span class="token punctuation">]</span>   验证接口IP配置
<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>6.CDP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> cdp run 启用<span class="token operator">/</span>禁用CDP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> cdp enable   基于接口启用<span class="token operator">/</span>禁用CDP
<span class="token class-name">R</span># show cdp 查看CDP状态
<span class="token class-name">R</span># show cdp <span class="token keyword">interface</span>   查看基于接口的CDP配置
<span class="token class-name">R</span># show cdp neighbors <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>  查看与用户<span class="token class-name">Cisco</span>设备相连的CDP邻居的摘要<span class="token operator">/</span>详细清单
<span class="token class-name">R</span># show cdp entry neighbor's_name   查看一个指定邻居的详细信息
<span class="token class-name">R</span># show cdp traffic 查看CDP通信量的统计信息
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>7.路由</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route destination_network_# <span class="token punctuation">[</span>subnet_mask<span class="token punctuation">]</span> <span class="token class-name">IP_address_of_next_hop_neighbor</span><span class="token operator">|</span>interface_to_exit <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span> <span class="token punctuation">[</span>permanent<span class="token punctuation">]</span> 配置IP静态路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span> <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span> <span class="token class-name">IP_address_of_next_hop_neighbor</span><span class="token operator">|</span>interface_to_exit <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span> <span class="token punctuation">[</span>permanent<span class="token punctuation">]</span> 配置默认路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip classless 使有类协议接受非一致性子网掩码或不连续子网
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">.</span> subinterface_# <span class="token punctuation">[</span>point<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>point<span class="token operator">|</span>multipoint<span class="token punctuation">]</span>  创建子接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>subif<span class="token punctuation">)</span># encapsulation isl<span class="token operator">|</span>dotlq VLAN_# 指定子接口中继类型和相关的VLAN
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router name_of_the_IP_routing_protocol   进入路由选择协议的配置模式
<span class="token class-name">R</span># show ip route    查看IP路由表
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>8.RIP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router rip   配置IP RIP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  指定哪些接口参与路由选择进程
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># version <span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span>   只接受和发送RIP版本<span class="token number">1</span>或<span class="token number">2</span>（默认只产生<span class="token class-name">RIPv1</span>更新，而两个版本的更新都接收）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># ip rip send<span class="token operator">|</span>receive version <span class="token number">1</span> <span class="token operator">|</span> version <span class="token number">2</span> <span class="token operator">|</span> version <span class="token number">1</span> <span class="token number">2</span>   在特定接口上控制在发送或接收RIP更新时使用哪个版本的RIP
<span class="token class-name">R</span># show ip protocols    查看在路由器上已配置并运行的所有IP路由选择协议
<span class="token class-name">R</span># show ip route <span class="token punctuation">[</span>name_of_the_IP_routing_protocol<span class="token punctuation">]</span>  查看路由选择表
<span class="token class-name">R</span># debug ip rip 帮助进行故障排除
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>9.IGRP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router igrp AS_# 配置IP IGRP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  通告网络号
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span>   配置单播更新
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># passive<span class="token operator">-</span><span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#   允许该接口在IGRP中通告但它不监听或发送IGRP更新
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># traffic<span class="token operator">-</span>share min across<span class="token operator">-</span>interfaces   使路由器只使用最佳路径但又在路由选择表中放入替代路径
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># timers basic update_# invalid_# holddown_# flush_# <span class="token punctuation">[</span>sleeptime_#<span class="token punctuation">]</span>  调整定时器（默认时，update<span class="token operator">=</span><span class="token number">90</span>，invalid<span class="token operator">=</span><span class="token number">270</span>，holddown<span class="token operator">=</span><span class="token number">280</span>，flush<span class="token operator">=</span><span class="token number">630</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no metric holddown    关闭压制定时器（默认）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distance administrative_distance_#    调整管理距离（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">255</span>，默认为<span class="token number">100</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>metric bandwidth_# delay_# reliability_# load_# MTU_# 调整度量值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># metric weights tos_# K1_# K2_# K3_# K4_# K5_# 调整度量权重值（默认时，<span class="token function">K1</span><span class="token punctuation">(</span>带宽<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K3</span><span class="token punctuation">(</span>可靠性<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span>，<span class="token function">K2</span><span class="token punctuation">(</span>延迟<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K4</span><span class="token punctuation">(</span>负载<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K5</span><span class="token punctuation">(</span>MTU<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># variance multiplier_# 启用IGRP非同等成本路径（变化因子值<span class="token number">1</span><span class="token operator">-</span><span class="token number">128</span>默认为<span class="token number">1</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># traffic<span class="token operator">-</span>share balanced    配置负载均衡
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># maximum<span class="token operator">-</span>paths paths_# 配置负载均衡的路径条数（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">6</span>）
<span class="token class-name">R</span># debug ip igrp events 提供路由器和邻居间发生的每一步操作信息
<span class="token class-name">R</span># debug ip igrp transactions   提供有关包含在路由更新中路由的详细信息
<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>10.EIGRP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router eigrp AS_#    配置EIGRP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_network_</span>#  通告网络号
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip bandwidth<span class="token operator">-</span>percent eigrp AS_# percent_# 设置pacing（调速）占给定接口带宽的百分数（默认为<span class="token number">50</span><span class="token operator">%</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distance administrative_distance_#    调整管理距离（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">255</span>，默认对于内部路由是<span class="token number">90</span>而外部是<span class="token number">170</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>metric bandwidth_# delay_# reliability_# load_# MTU_# 调整度量值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># metric weights tos_# K1_# K2_# K3_# K4_# K5_# 调整度量权重值（默认时，<span class="token function">K1</span><span class="token punctuation">(</span>带宽<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K3</span><span class="token punctuation">(</span>可靠性<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1</span>，<span class="token function">K2</span><span class="token punctuation">(</span>延迟<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K4</span><span class="token punctuation">(</span>负载<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">K5</span><span class="token punctuation">(</span>MTU<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip hello<span class="token operator">-</span>interval eigrp AS_# seconds_#    在给定接口上设置<span class="token class-name">Hello</span>间隔（默认对于低速的NBMA网络是<span class="token number">60</span>秒，其他是<span class="token number">5</span>秒）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip hold<span class="token operator">-</span>time eigrp AS_# seconds_# 在给定接口上设置<span class="token class-name">Hello</span>保持定时器（默认是<span class="token number">3</span>倍的<span class="token class-name">Hello</span>间隔）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># passive<span class="token operator">-</span><span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#   允许该接口在EIGRP中通告但它不监听或发送EIGRP更新
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no auto<span class="token operator">-</span>summary   取消对路由的自动汇总
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip summary<span class="token operator">-</span>address eigrp AS_# network_address network_mask    创建不在有类边界上的汇总地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># eigrp log<span class="token operator">-</span>neighbor<span class="token operator">-</span>changes   记录在某个邻居上发生的变化
<span class="token class-name">R</span># show ip route eigrp  查看被EIGRP学习到的路由
<span class="token class-name">R</span># show ip route network_address    查看指定目的地的路由信息
<span class="token class-name">R</span># show ip eigrp topology   查看EIGRP的拓扑表
<span class="token class-name">R</span># show ip eigrp interfaces     查看加入到EIGRP路由器所有接口的概述
<span class="token class-name">R</span># show ip eigrp neighbor <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>  显示和本路由器已形成邻居关系的所有路由器
<span class="token class-name">R</span># show ip eigrp traffic    显示每个包类型的发出和接收的数量
<span class="token class-name">R</span># show ip eigrp events 查看每个EIGRP事件的日志
<span class="token class-name">R</span># debug ip eigrp   提供路由器和它的邻居之间发生的每一步操作
<span class="token class-name">R</span># debug eigrp packets  查看在该路由器和它的邻居之间发送的数据包类型
<span class="token class-name">R</span># debug eigrp neighbors    查看邻居的信息
<span class="token number">12345678910111213141516171819202122</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>11.OSPF</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router ospf process_ID   配置OSPF
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network <span class="token class-name">IP_address</span> wildcard_mask area area_#  指定接口进入OSPF区域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip ospf cost cost_value   给接口指定成本（取值范围是<span class="token number">1</span><span class="token operator">-</span><span class="token number">65535</span>）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span>   手动配置邻居
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_of_neighbor</span> priority value    指定邻居的优先级（取值范围是<span class="token number">0</span><span class="token operator">-</span><span class="token number">255</span>，<span class="token number">255</span>为DR，<span class="token number">0</span>为不可能成为DR）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip ospf network non<span class="token operator">-</span>broadcast 手工配置非广播网络类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id stub 允许创建存根区域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id stub no<span class="token operator">-</span>summary  允许创建完全存根区域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id nssa 允许创建次存根区域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id virtual<span class="token operator">-</span>link router_id   连接不连续区域为骨干区域<span class="token number">0</span>
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># area area_id range network_address network_mask   在区域边界路由器上汇总在给定区域中的路由器使用的IP地址空间到其他的区域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># summary<span class="token operator">-</span>address network_address network_mask  在自治系统边界路由器上汇总外部路由
<span class="token class-name">R</span># show ip ospf 概述所有OSPF相关的信息
<span class="token class-name">R</span># show ip ospf process<span class="token operator">-</span>id  与上相同，而不仅仅是指定的进程
<span class="token class-name">R</span># show ip ospf border<span class="token operator">-</span>routers  显示在此自治系统中所有ABR和ASBR的路由器ID
<span class="token class-name">R</span># show ip ospf database    显示链路状态数据库
<span class="token class-name">R</span># show ip ospf <span class="token keyword">interface</span>   显示接口的OSPF参数和其他的指定到此接口上的OSPF信息
<span class="token class-name">R</span># show ip ospf neighbor <span class="token punctuation">[</span>detail<span class="token punctuation">]</span>   显示每个OSPF邻居和邻接状态
<span class="token class-name">R</span># debug ip ospf adj    报告路由器建立到其他路由器的邻接关系进程
<span class="token class-name">R</span># debug ip ospf events 报告路由器上的OSPF事件
<span class="token class-name">R</span># debug ip ospf packet 报告OSPF LSA分组的内容
<span class="token number">123456789101112131415161718192021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>12.ACL</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># access<span class="token operator">-</span>list <span class="token number">1</span><span class="token operator">-</span><span class="token number">99</span><span class="token operator">|</span><span class="token number">1300</span><span class="token operator">-</span><span class="token number">1999</span> permit<span class="token operator">|</span>deny source_IP_address <span class="token punctuation">[</span>wildcard_mask<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span>    创建标准编号IP ACL
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip access<span class="token operator">-</span>group ACL_# in<span class="token operator">|</span>out  在指定接口上启动ACL
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>line<span class="token punctuation">)</span># access<span class="token operator">-</span><span class="token keyword">class</span> standard_ACL_# in<span class="token operator">|</span>out  在指定若干线路上启动ACL以限制对路由器的<span class="token class-name">Telnet</span>访问
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># access<span class="token operator">-</span>list <span class="token number">100</span><span class="token operator">-</span><span class="token number">199</span><span class="token operator">|</span><span class="token number">2000</span><span class="token operator">-</span><span class="token number">2699</span> permit<span class="token operator">|</span>deny <span class="token class-name">IP_protocol</span> source_address source_wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> destination_address destination_wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span>  创建扩展编号IP ACL
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip access<span class="token operator">-</span>list standard <span class="token class-name">ACL_name</span> 创建标准命名ACL（从IOS11<span class="token punctuation">.</span><span class="token number">2</span>开始支持）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>std<span class="token operator">-</span>acl<span class="token punctuation">)</span># permit<span class="token operator">|</span>deny source_IP_address <span class="token punctuation">[</span>wildcard_mask<span class="token punctuation">]</span>    输入标准ACL命令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip access<span class="token operator">-</span>list extended <span class="token class-name">ACL_name</span> 创建扩展命名ACL（从IOS11<span class="token punctuation">.</span><span class="token number">2</span>开始支持）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>ext<span class="token operator">-</span>acl<span class="token punctuation">)</span># permit<span class="token operator">|</span>deny <span class="token class-name">IP_protocol</span> source_IP_address wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> destination_IP_address wildcard_mask <span class="token punctuation">[</span>protocol_information<span class="token punctuation">]</span> <span class="token punctuation">[</span>log<span class="token punctuation">]</span> 输入扩展ACL命令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip access_group <span class="token class-name">ACL_name</span> in<span class="token operator">|</span>out   启动命名ACL
<span class="token class-name">R</span># show ip interfaces   验证访问列表
<span class="token class-name">R</span># show access<span class="token operator">-</span>lists <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>    显示ACL中的语句
<span class="token class-name">R</span># show ip access<span class="token operator">-</span>list <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>  显示IP ACL中的语句
<span class="token class-name">R</span># clear access<span class="token operator">-</span>list counters <span class="token punctuation">[</span>ACL_#_or_name<span class="token punctuation">]</span>   对指定ACL中的匹配计数器清零
<span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>13.NAT PAT 配置负载分发</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source <span class="token keyword">static</span> inside_local_source_IP_address inside_global_source_IP_address   定义NAT静态转换
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat outside source <span class="token keyword">static</span> outside_global_destination_IP_address outside_local_destination_IP_address  定义NAT静态转换
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip nat inside<span class="token operator">|</span>outside 指定路由器上哪些接口在内部，哪些在外部
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat outside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span>  为重叠地址转换配置NAT
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span>   定义动态NAT，指定转换哪些内部设备的源地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat pool <span class="token class-name">NAT_pool_name</span> beginning_inside_global_IP_address ending_inside_global_IP_address netmask subnet_mask_of_addresses<span class="token operator">|</span>prefix<span class="token operator">-</span>length length   创建源内部全局IP地址池
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside source list standard_IP_ACL_# pool <span class="token class-name">NAT_pool_name</span> overload  定义PAT，指定哪台内部设备会转换其源地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat pool pool_name beginning_inside_local_IP_address ending_inside_local_IP_address prefix<span class="token operator">-</span>length subnet_mask_bits type rotary    指定提供服务的设备上配置的内部IP地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip nat inside destination list standard_ACL_# pool pool_name 指定外部设备用来访问内部资源的全局IP地址
<span class="token class-name">R</span># show ip nat translations <span class="token punctuation">[</span>verbose<span class="token punctuation">]</span>   查看路由器上的（详细）地址转换信息
<span class="token class-name">R</span># show ip nat statistics   查看路由器上的地址转换的统计信息
<span class="token class-name">R</span># clear ip nat translation <span class="token operator">*</span>   清除所有NAT表项
<span class="token class-name">R</span># clear ip nat translation inside<span class="token operator">|</span>outside global_IP_address<span class="token operator">|</span>local_IP_address   清除转换表中的指定动态条目
<span class="token class-name">R</span># clear ip nat translation protocol inside global_IP_address global_port local_IP_address local_port   清除转换表中的指定动态条目
<span class="token class-name">R</span># debug ip nat 提供IOS对每个已转换分组所做的转换
<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>14.DHCP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> service dhcp    启用<span class="token operator">/</span>禁用DHCP（默认启用）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp pool pool_name   创建地址池
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># network network_number <span class="token punctuation">[</span>subnet_mask<span class="token operator">|</span><span class="token operator">/</span>prefix_length<span class="token punctuation">]</span> 指定分配给客户的IP地址范围
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># domain<span class="token operator">-</span>name domain_name 向客户分配域名
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># dns<span class="token operator">-</span>server <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>   指定最多<span class="token number">8</span>台DNS服务器分配给客户
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># netbios<span class="token operator">-</span>name<span class="token operator">-</span>server <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>  指定最多<span class="token number">8</span>台WINS服务器分配给客户
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># netbios<span class="token operator">-</span>node<span class="token operator">-</span>type node_type 向微软客户分配节点类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>router <span class="token class-name">IP_address</span> <span class="token punctuation">[</span>…<span class="token punctuation">]</span>   指定最多<span class="token number">8</span>条默认路由给客户用于该地址范围
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>dhcp<span class="token punctuation">)</span># lease days <span class="token punctuation">[</span>hours<span class="token punctuation">]</span> <span class="token punctuation">[</span>minutes<span class="token punctuation">]</span> <span class="token operator">|</span>infinite  指定租约的期限（默认一天）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp ping timeout milliseconds    指定测试服务器地址池中的可用地址是否正在使用时服务器应等待时间
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip dhcp excluded<span class="token operator">-</span>address beginning_IP_address <span class="token punctuation">[</span>ending_IP_address<span class="token punctuation">]</span>    排除一些地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address dhcp   在路由器上建立DHCP客户
<span class="token class-name">R</span># show ip dhcp binding <span class="token punctuation">[</span>client_address<span class="token punctuation">]</span>    查看分配给客户的地址
<span class="token class-name">R</span># clear ip dhcp binding client_address<span class="token operator">|</span><span class="token operator">*</span>   清除分配给客户的指定<span class="token operator">/</span>所有地址
<span class="token class-name">R</span># debug ip dhcp server events<span class="token operator">|</span>packet<span class="token operator">|</span>linkage   查看DHCP服务器相关信息
<span class="token number">123456789101112131415</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>15.HDLC</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation hdlc    封装同步串行接口为HDLC（默认）
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>16.PPP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation ppp 在WAN接口上使用PPP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp pap sent<span class="token operator">-</span>username your_hostname password password 指定PAP用于认证并且提供在服务端用于执行认证的用户名和口令（此为客户端配置）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># hostname your_router's_hostname  为路由器指定惟一主机名（以下三个为服务端配置）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># username remote_hostname password matching_password  指定认证路由器时所使用的远端主机名称和口令
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication pap    指定PAP认证
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication chap<span class="token operator">|</span>pap<span class="token operator">|</span>chap pap<span class="token operator">|</span>pap chap 批定PPP认证类型
<span class="token class-name">R</span># debug ppp negotiation    查看LCP协商时的信息
<span class="token class-name">R</span># debug ppp authentication 查看PPP认证情况
<span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>17.FR</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation frame<span class="token operator">-</span>relay <span class="token punctuation">[</span>cisco<span class="token operator">|</span>ietf<span class="token punctuation">]</span>    指定封装类型为帧中继<span class="token punctuation">(</span>默认cisco）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># frame<span class="token operator">-</span>relay lmi<span class="token operator">-</span>type ansi<span class="token operator">|</span>cisco<span class="token operator">|</span>q933a 给该串行接口指定LMI类型
<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay lmi 查看详细的LMI统计信息
<span class="token class-name">R</span># debug frame<span class="token operator">-</span>relay lmi    报告路由器正在发送与接收的实际LMI信息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># frame<span class="token operator">-</span>relay map protocol_name destination_address local_dlci_# <span class="token punctuation">[</span>broadcast<span class="token punctuation">]</span> <span class="token punctuation">[</span>ietf<span class="token operator">|</span>cisco<span class="token punctuation">]</span>   将远端第<span class="token number">3</span>层地址手动映射到本地DLCI号
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> frame<span class="token operator">-</span>relay inverse<span class="token operator">-</span>arp <span class="token punctuation">[</span>protocol_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>DLCI_#<span class="token punctuation">]</span> 启用<span class="token operator">/</span>禁用逆向
<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>18.ARP（默认启用）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span> clear frame<span class="token operator">-</span>relay<span class="token operator">-</span>inarp    清除逆向ARP解析表
<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay traffic 查看逆向ARP统计
<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay pvc <span class="token punctuation">[</span>DLCI_#<span class="token punctuation">]</span>    查看终止于路由器的所有（指定）帧中继PVC及其统计信息
<span class="token class-name">R</span># show frame<span class="token operator">-</span>relay map 查看将第<span class="token number">3</span>层地址映射成本地DLCI号的虚电路解析表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">.</span> subinterface_# <span class="token punctuation">[</span>point<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>point<span class="token operator">|</span>multipoint<span class="token punctuation">]</span>  创建子接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>subif<span class="token punctuation">)</span># frame<span class="token operator">-</span>relay <span class="token keyword">interface</span><span class="token operator">-</span>dlci local_DLCI_#    配置子接口的帧中继
<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>19.ISDN</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">[</span><span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">]</span><span class="token punctuation">)</span># isdn <span class="token keyword">switch</span><span class="token operator">-</span>type <span class="token class-name">ISDN_switch_type</span>   在全局或接口配置模式下配置交换机类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isdn spid1 spid_#__for_1st_BRI local_dial_#   为第一个<span class="token class-name">B</span>信道配置SPID
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isdn spid2 spid_#__for_2st_BRI local_dial_#   为第二个<span class="token class-name">B</span>信道配置SPID
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># controller t1<span class="token operator">|</span>e1 <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    以下<span class="token number">6</span>个命令为控制卡配置
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># framing esf<span class="token operator">|</span>sf<span class="token operator">|</span>crc4<span class="token operator">|</span>nocrc4    在T1或E1上使用物理成帧
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># linecode ami<span class="token operator">|</span>b8zs<span class="token operator">|</span>hdb3    线路编码，定义<span class="token number">1</span>与<span class="token number">0</span>如何在线路上物理表示
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># clock source line primary<span class="token operator">|</span>secondary<span class="token operator">|</span>internal  定义路由器如何获得其时钟以用于同步数字连接
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># pri<span class="token operator">-</span>group timeslots <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">24</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">]</span>   指定路由器哪个或哪些时隙用于ISDN连接
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>controller<span class="token punctuation">)</span># <span class="token punctuation">[</span>no<span class="token punctuation">]</span> shutdown 启用<span class="token operator">/</span>禁用控制器
<span class="token class-name">R</span># show controllers t1<span class="token operator">|</span>e1 <span class="token punctuation">[</span>slot_#<span class="token operator">/</span>port_#<span class="token punctuation">]</span>   验证控制器卡配置
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token operator">:</span><span class="token number">23</span> 设置逻辑串口（T1使用）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> serial <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token operator">:</span><span class="token number">15</span> 设置逻辑串口（E1使用）
<span class="token class-name">R</span># show <span class="token keyword">interface</span> bri <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>    验证ISDN连接的状态（查看<span class="token class-name">B</span>信道）
<span class="token class-name">R</span># show isdn status 查看ISDN详细的物理层和数据链路层信息
<span class="token class-name">R</span># debug isdn q921  报告ISDN数据链路层详细信息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip route <span class="token class-name">IP_network_</span># subnet_mask remote_router's_IP_address<span class="token operator">|</span>router_interface <span class="token punctuation">[</span>administrative_distance<span class="token punctuation">]</span>  配置静态路由。以下<span class="token number">7</span>个命令配置传统DDR
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># dialer<span class="token operator">-</span>list list_# protocol protocol_name permit<span class="token operator">|</span>deny <span class="token punctuation">[</span>access<span class="token operator">-</span>list ACL_#<span class="token punctuation">]</span>    定义敏感流量
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer<span class="token operator">-</span>group dialer_list_#    激活拨号列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer map protocol_name address_of_destination_router <span class="token punctuation">[</span>name remote_router_name<span class="token punctuation">]</span> <span class="token punctuation">[</span>speed <span class="token number">56</span><span class="token operator">|</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>broadcast<span class="token punctuation">]</span> destination_phone_number   表明利用传统DDR进行电话呼叫
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer idle<span class="token operator">-</span>timeout #_of_seconds  定义空闲超时周期
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer fast<span class="token operator">-</span>idle #_of_seconds 定义快速空闲计时器
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer load<span class="token operator">-</span>threshold load either<span class="token operator">|</span>inbound<span class="token operator">|</span>outbound    通过BRI的两条<span class="token class-name">B</span>信道执行负载均衡（分配带宽）
<span class="token class-name">R</span># show dialer  查看哪个DDR接口进行了电话呼叫及其状态
<span class="token class-name">R</span># show isdn active 查看激活的ISDN呼叫
<span class="token class-name">R</span># show isdn history    查看路由器发出的呼叫或以前接收的呼叫
<span class="token class-name">R</span># debug dialer 显示建立或拆除一个连接的DDR过程
<span class="token class-name">R</span># debug isdn q931  显示ISDN电话连接建立及挂断的详细信息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># <span class="token keyword">interface</span> dialer port_#  创建逻辑拨号接口。以下全为配置拨号配置文件。以下<span class="token number">8</span>个为拨号接口配置
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># encapsulation ppp 指定封装类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ppp authentication pap<span class="token operator">|</span>chap<span class="token operator">|</span>chap pap<span class="token operator">|</span>pap chap 指定认证类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip address <span class="token class-name">IP_address</span> subnet_mask 指定接口IP地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer remote<span class="token operator">-</span>name name   指定远端路由器的名称
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer string phone_# <span class="token punctuation">[</span><span class="token keyword">class</span> map_name<span class="token punctuation">]</span>    指定映射类名称
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer pool pool_#    指定拨号接口能使用哪组物理接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer<span class="token operator">-</span>group dialer_list_#    激活拨号列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># dialer pool<span class="token operator">-</span>member pool_# <span class="token punctuation">[</span>priority priority_#<span class="token punctuation">]</span> <span class="token punctuation">[</span>min<span class="token operator">-</span>link #_of_B_channels<span class="token punctuation">]</span> <span class="token punctuation">[</span>max<span class="token operator">-</span>link #_of_B_channels<span class="token punctuation">]</span> 指定哪些拨号接能使用物理接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># map<span class="token operator">-</span><span class="token keyword">class</span> dialer map_name    进入映射子配置模式。以下<span class="token number">4</span>个为创建映射类
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer isdn speed <span class="token number">56</span> 指定ISDN中的<span class="token class-name">B</span>信道的速度（默认<span class="token number">64</span>kbps）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer idle<span class="token operator">-</span>timeout #_of_seconds 定义空闲超时周期
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>map<span class="token punctuation">)</span># dialer fast<span class="token operator">-</span>idle #_of_seconds    定义快速空闲计时器
<span class="token class-name">R</span># show dialer <span class="token keyword">interface</span> bri<span class="token operator">|</span><span class="token punctuation">&#123;</span>serial<span class="token operator">:</span><span class="token number">23</span><span class="token operator">|</span><span class="token number">15</span><span class="token punctuation">&#125;</span> <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span>port_# 显示与拨号接口关联的物理接口的进入和离开呼叫的DDR统计信息
<span class="token number">1234567891011121314151617181920212223242526272829303132333435363738394041</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>20.IS-IS</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router isis  启动IS<span class="token operator">-</span>IS
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># net areaID<span class="token punctuation">.</span>systemID<span class="token punctuation">.</span>SEL   配置NET
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># is<span class="token operator">-</span>type level_of_router   配置路由器的层次
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip router isis    在接口上启动IS<span class="token operator">-</span>IS
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># isis priority value level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span>   手动配置第一层或第二层路由器的优先级
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># clns router isis  为无连接网络服务启动IS<span class="token operator">-</span>IS
<span class="token class-name">R</span># show ip route isis   查看通过IS<span class="token operator">-</span>IS学习到的路由
<span class="token class-name">R</span># show isis database <span class="token punctuation">[</span>detail level_of_router<span class="token punctuation">]</span>  查看IS<span class="token operator">-</span>IS链路状态数据库中的所有（某层）LSP信息
<span class="token class-name">R</span># show clns protocol   显示IS<span class="token operator">-</span>IS详细配置信息
<span class="token class-name">R</span># show clns <span class="token keyword">interface</span>  显示配置为IS<span class="token operator">-</span>IS接口的相关信息
<span class="token class-name">R</span># show clns is<span class="token operator">-</span>neighbors   查看路由器的邻居
<span class="token class-name">R</span># show isis spf<span class="token operator">-</span>log    查看SPF计算情况
<span class="token class-name">R</span># debug isis adj<span class="token operator">-</span>packets   查看路由器发送和接收<span class="token class-name">Hello</span> PDU的情况
<span class="token class-name">R</span># debug isis update<span class="token operator">-</span>packets    提供路由器发送和接收的所有LSP详细内容及SNP信息
<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>events    查看写入路由表的IS<span class="token operator">-</span>IS路由
<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>triggers  查看触发SPF计算的原因
<span class="token class-name">R</span># debug isis spf<span class="token operator">-</span>statistics    查看执行SPF计算所用的时间
<span class="token number">1234567891011121314151617</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>21.BGP</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># router bgp AS_#  启动BGP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> remote<span class="token operator">-</span>as AS_#_remote_device    指定远端路由器作为对等体
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no synchronization    关闭BGP与IGP同步（默认启用）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> update<span class="token operator">-</span>source loopback #    使用环回接口作为对等体
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> ebgp<span class="token operator">-</span>multihop <span class="token punctuation">[</span>ttl<span class="token punctuation">]</span> 配置eBGP多跳（允许BGP邻居可以不在直连网络上）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> route<span class="token operator">-</span>reflector<span class="token operator">-</span>client  配置邻居为路由反射器客户
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># network network_address mask subnet_mask  向对等体通告路由（手动向BGP注入路由）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute protocol process_ID  将路由重新分配到BGP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute connected    将直连接口地址重新分配到BGP
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp cluster<span class="token operator">-</span>id cluster_ID 分配簇ID
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp confederation identifier confederation_ID 配置联邦ID
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># bgp confederation peers AS_#  配置联邦的对等自治系统成员
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> distribute<span class="token operator">-</span>list access_list_# <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>  过滤到或来自邻居的更新信息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip prefix<span class="token operator">-</span>list list_name <span class="token punctuation">[</span>seq seq_value<span class="token punctuation">]</span> permit<span class="token operator">|</span>deny network_address<span class="token operator">/</span>length <span class="token punctuation">[</span>ge ge_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>le le_value<span class="token punctuation">]</span>  配置前缀列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> prefix<span class="token operator">-</span>list list_name <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>  应用从邻居输入的前缀列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># route<span class="token operator">-</span>map route_map_name permit<span class="token operator">|</span>deny <span class="token punctuation">[</span>sequence_number<span class="token punctuation">]</span>   创建路由映射序列
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match as<span class="token operator">-</span>path <span class="token class-name">AS_path_accesslist_</span># 匹配BGP自治系统路径访问列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match community<span class="token operator">-</span>list community_list_#  匹配BGP团体
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#  发布任何下一跳是指定接口的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip address access_list_#<span class="token operator">|</span>prefix_list_name    匹配任何目的网络地址被指定的标准访问列表、扩展访问列表或前缀列表允许的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip next<span class="token operator">-</span>hop access_list_#<span class="token operator">|</span>prefix_list_name   匹配任何下一跳地址被指定的标准访问列表、扩展访问列表或前缀列表允许的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match ip route<span class="token operator">-</span>source access_list_#<span class="token operator">|</span>prefix_list_name   匹配任何由被指定的标准访问列表、扩展访问列表或前缀列表允许的地址通告的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match metric value 匹配任何具有指定的度量值的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match route<span class="token operator">-</span>type type_of_route 匹配任何具有指定类型的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># match tag value    匹配任何具有指定标识的路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set as<span class="token operator">-</span>path prepend AS_#   向AS_PATH属性添加自治系统号
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set as<span class="token operator">-</span>path tag    设置作为AS_PATH属性的标记
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set automatic<span class="token operator">-</span>tag  自动计算标记值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set community number<span class="token operator">|</span>aa<span class="token operator">:</span>nn<span class="token operator">|</span>additive<span class="token operator">|</span>local<span class="token operator">-</span>as<span class="token operator">|</span>no<span class="token operator">-</span>advertise<span class="token operator">|</span>no<span class="token operator">-</span>export<span class="token operator">|</span>none   设置BGP COMMUNITIES属性
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set dampening half_life start_reusing start_suppressing duration_to_suppress   设置BGP路由冷落参数
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set <span class="token keyword">default</span> <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    设置默认的输出接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set <span class="token keyword">interface</span> type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#    设置输出接口
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip <span class="token keyword">default</span> next<span class="token operator">-</span>hop <span class="token class-name">IP_address</span> 设置路径的默认下一跳地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip next<span class="token operator">-</span>hop <span class="token class-name">IP_address</span> 设置下一跳地址
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip precedence <span class="token punctuation">[</span>precedence<span class="token punctuation">]</span> 设置“IP <span class="token class-name">Precedence</span>”字段
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set ip tos type_of_service 设置“IP服务类型”字段
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set level level    设置导入路由的位置
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set local<span class="token operator">-</span>preference value 设置BGP LOCAL_PREF路径属性
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set metric value   设置目标路由协议的度量值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set metric<span class="token operator">-</span>type type_of_route  设置目标路由协议的度量类型
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set origin origin_code 设置BGP源代码
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set tag value  设置目标路由协议的标记值
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>route<span class="token operator">-</span>map<span class="token punctuation">)</span># set weight value   设置路由表的BGP权重
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> route<span class="token operator">-</span>map route_map_name <span class="token punctuation">[</span>in<span class="token operator">|</span>out<span class="token punctuation">]</span>   应用从邻居输入的路由映射
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> send<span class="token operator">-</span>community  向该邻居发送COMMUNITY属性
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span># ip community<span class="token operator">-</span>list community_list_# <span class="token punctuation">[</span>permit<span class="token operator">|</span>deny<span class="token punctuation">]</span> community_list_#    创建团体列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor peer_group_name peer<span class="token operator">-</span>group   创建对等组
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor peer_group_name option_to_use_in_update_policy   给对等组分配选项
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># neighbor <span class="token class-name">IP_address_remote_device</span> peer<span class="token operator">-</span>group peer_group_name  给对等组分配对等体
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># no auto<span class="token operator">-</span>summary   取消BGP的自动路由汇总功能
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># aggregate<span class="token operator">-</span>address <span class="token class-name">IP_address</span> mask <span class="token punctuation">[</span>summary<span class="token operator">-</span>only<span class="token punctuation">]</span>  创建汇聚地址（禁止通告其他特定路由）
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># aggregate<span class="token operator">-</span>address <span class="token class-name">IP_address</span> mask as<span class="token operator">-</span>set  创建汇聚地址，在AS_PATH中添加AS_SET类型
<span class="token class-name">R</span># clear ip bgp peer_address    重设特定BGP对等会话
<span class="token class-name">R</span># clear ip bgp AS_#    重设指定自治系统的所有对等体的BGP会话
<span class="token class-name">R</span># clear ip bgp <span class="token operator">*</span>   重设路由器上所有BGP会话
<span class="token class-name">R</span># show ip bgp  查看路由器从BGP学习到的所有路由
<span class="token class-name">R</span># show ip bgp summary  提供和路由器具有对等关系的所有路由器汇总
<span class="token class-name">R</span># show ip bgp neighbors    查看对等体连接详细信息
<span class="token class-name">R</span># debug ip bgp 查看在本地路由器与试图和其建立对等关系的路由器之间所发送和接收的OPEN信息
<span class="token class-name">R</span># debug ip bgp updates 提供路由器发送和接收所有UPDATE消息的信息
<span class="token class-name">R</span># debug ip bgp peer_address upadtes    提供关于BGP对等体之间发送的UPDATE消息
<span class="token class-name">R</span># debug ip bgp dampening   显示关于被冷落路由的信息
<span class="token class-name">R</span># debug ip bgp events  提供关于尝试成为BGP对等体的路由器的状态转换信息
<span class="token class-name">R</span># debug ip bgp keepalives  提供关于路由器发送和接收KEEPALIVE消息的信息
<span class="token number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>22.路由优化</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># distribute<span class="token operator">-</span>list ACL_#<span class="token operator">|</span>prefix prefix_list_name in<span class="token operator">|</span>out <span class="token punctuation">[</span>type <span class="token punctuation">[</span>slot_#<span class="token operator">/</span><span class="token punctuation">]</span> port_#<span class="token punctuation">]</span>   配置分配列表
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span># ip policy route<span class="token operator">-</span>map map_tag   识别一个接口上基于策略的路由选择使用的路由映射
<span class="token class-name">R</span># show ip policy   列出所有配置为基于策略的路由选择的接口及它们相关的路由映射
<span class="token class-name">R</span># show route<span class="token operator">-</span>map   查看所有路由映射
<span class="token class-name">R</span># debug ip policy  提供在该路由器上执行的路由策略的信息
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>information originate 重新分配默认路由到OSPF和IS<span class="token operator">-</span>IS
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># <span class="token keyword">default</span><span class="token operator">-</span>information originate always  引起一个默认路由到OSPF不管路由表中是否有一个默认路由
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># redistribute protocol <span class="token punctuation">[</span>process<span class="token operator">-</span>ID<span class="token punctuation">]</span> level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span> <span class="token punctuation">[</span>metric metric_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>metric<span class="token operator">-</span>type type_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>match internal<span class="token operator">|</span>external <span class="token number">1</span><span class="token operator">|</span>external <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>tag tag_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>route<span class="token operator">-</span>map map_tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>weight weight_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>subnets<span class="token punctuation">]</span>    重新分配路由选择信息从一个路由选择域到另一个路由选择域
<span class="token class-name">R</span><span class="token punctuation">(</span>config<span class="token operator">-</span>router<span class="token punctuation">)</span># summary<span class="token operator">-</span>address network_address network_mask <span class="token punctuation">[</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">|</span>level<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>  为起源于和重新分配到IS<span class="token operator">-</span>IS的路由创建一个汇总地址
<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>23.异步连接</p>
<pre class="line-numbers language-cisco" data-language="cisco"><code class="language-cisco">R# line number  进入线路配置模式
R(config-line)# login   允许一个连接
R(config-line)# password password   提供线路上使用的口令
R(config-line)# flowcontrol hardware|software   选择硬件流控制或软件流控制
R(config-line)# speed number    指定调制解调器和访问服务器或路由器之间使用的最大速度（单位：bps）
R(config-line)# transport input lat|mop|nasi|pad|rlogin|telnet|v120|all 定义反向Telnet连接使用的协议
R(config-line)# stopbits 1|1.5|2    定义每个字节的结束
R(config-line)# modem autoconfigure type modem_type 指示路由器使用modemcap数据库中的命令按照指定的类型对连接到一个端口上的调制解调器进行自动配置
R# show modemcap    显示modemcap数据库
R(config-line)# modem edit modem_profile_name   向modemcap数据库增加条目
R(config-line)# modemcap edit new_profile_name template existing_profile_name   创建名为new_profile_name的条目并从existing_profile_name中拷贝所有的配置
R(config-line)# modem autoconfigure discovery   发现和自动配置连接到一个端口上的调制解调器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>cisco</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学导论</title>
    <url>/2021/06/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数据科学导论"><a href="#数据科学导论" class="headerlink" title="数据科学导论"></a>数据科学导论</h1><h2 id="1-基础理论"><a href="#1-基础理论" class="headerlink" title="1 基础理论"></a>1 基础理论</h2><p>数据富足时代——大数据时代</p>
<ul>
<li>现代处理器功能增强，密集度up</li>
<li>存储、管理成本降低，新的存储技术使得数据运行更快，规模up</li>
<li>跨计算机集群分布计算处理能力，提高了分析复杂数据的能力</li>
<li>有更多业务数据集可供分析，而且大部分提供了API</li>
<li>机器学习算法的开源社区日渐庞大</li>
<li>可视化更容易使用</li>
</ul>
<p>很多过去的研究方法和理论思维有明显的“面向数据贫乏时代”特点，不再适用</p>
<h3 id="1-1-术语定义"><a href="#1-1-术语定义" class="headerlink" title="1.1 术语定义"></a>1.1 术语定义</h3><p>数据、信息、知识、智慧</p>
<p>结构化数据、半结构化数据、非结构化数据 （可否用传统关系数据库存储）</p>
<p><strong>结构化：先有结构，再捕获数据</strong></p>
<p>4V： Volume  Variety  Value  Velocity</p>
<p>涌现：质变</p>
<p>理解数据科学：现实映射到数据，研究问题，对现实进行预测、洞见、解释、决策</p>
<h3 id="1-2-研究目的"><a href="#1-2-研究目的" class="headerlink" title="1.2 研究目的"></a>1.2 研究目的</h3><p>最终目标：实现数据、物质、能量间的转换，降低后两者损耗、提高后两者效果和效率</p>
<p>具体：</p>
<ul>
<li>揭示大数据内容，元数据特征、规律，帮助人们理解大数据的本质特征</li>
<li>从数据到智慧的转换 P11</li>
<li>数据洞见：将数据转化为实际行动</li>
<li>数据业务化</li>
<li>数据驱动型决策支持，将数据当作驱动方式</li>
<li>数据产品研发：<strong>0-3次数据 原生 干净 增值 洞见数据</strong></li>
<li>数据生态系统建设<ul>
<li>数据生产</li>
<li>数据采集</li>
<li>数据处理</li>
<li>业务流程</li>
</ul>
</li>
</ul>
<h3 id="1-3-研究视角"><a href="#1-3-研究视角" class="headerlink" title="1.3 研究视角"></a>1.3 研究视角</h3><p>原本：我能为数据做什么</p>
<p>​            传统的数据工程、数据结构、数据库、数据仓库、数据挖掘都是这个</p>
<p>​            强调通过人的努力改变数据，使数据更有价值，便于后续利用</p>
<p>现在：数据能为我做什么</p>
<p>​            大数据辅助决策、决策支持，带来商业机会，降低不确定性，发现可用的新模式</p>
<p>​            新术语：数据驱动、数据业务化、让数据说话、以数据为中心、数据柔术 都强调该视角</p>
<h3 id="1-4-理论体系"><a href="#1-4-理论体系" class="headerlink" title="1.4 理论体系"></a>1.4 理论体系</h3><p>领域知识：决定数据科学的主要关注点、应用领域和未来发展，重要</p>
<p>理论基础：统计学、机器学习、数据可视化与故事化</p>
<p>核心内容：</p>
<ul>
<li>基础理论：理念、方法、技术、工具、原则、目标等等</li>
<li>数据加工：融入3C精神，更强调<strong>增值活动</strong></li>
<li>数据计算：过渡至云计算，则关注的问题发生根本变化</li>
<li>数据管理：出现新兴的NoSQL、NewSQL和关系云等</li>
<li>数据分析</li>
<li>数据产品开发</li>
</ul>
<h3 id="1-5-基本原则"><a href="#1-5-基本原则" class="headerlink" title="1.5 基本原则"></a>1.5 基本原则</h3><ol>
<li><p>三世界原则</p>
<p>数据世界，使用“痕迹数据”，更加客观，而不是”采访数据“</p>
<p>第四范式：数据密集型科学发现范式——更注重相关性而不是因果</p>
</li>
<li><p>三要素</p>
<p>理论、实践、精神（3C）</p>
<p>提升实践能力：参加竞赛+参加开源项目</p>
<p>Creative Working</p>
<p>Critical Thinking</p>
<p>Curious Asking</p>
</li>
<li><p>数据密集型原则</p>
<p>挑战来自数据本身复杂性而不是计算</p>
</li>
<li><p>数据中心原则</p>
<p>从数据出发，改变业务</p>
</li>
<li><p>数据范式</p>
<p><strong>用数据直接解决问题</strong></p>
</li>
<li><p>数据复杂性原则</p>
<p>复杂性被认为是大数据不可分割的属性，数据在先，模式在后或无模式</p>
</li>
<li><p>数据资产原则</p>
</li>
<li><p>数据驱动原则</p>
</li>
<li><p>协同原则</p>
</li>
<li><p>从简原则</p>
<p>数据科学追求简单高效，面向具体应用需求，不考虑通用而复杂的算法</p>
</li>
</ol>
<h3 id="1-6-能力要求"><a href="#1-6-能力要求" class="headerlink" title="1.6 能力要求"></a>1.6 能力要求</h3><ul>
<li>创新精神、独特视角、不断进取</li>
<li>团队合作、协同工作</li>
<li>提出“nice”研究假设和问题，能够完成对应试验设计</li>
<li>参与项目的经验</li>
<li>灵活运用领域实务知识经验</li>
<li>研发数据产品</li>
</ul>
<h3 id="1-7-学习"><a href="#1-7-学习" class="headerlink" title="1.7 学习"></a>1.7 学习</h3><p>加法：操作系极强，培养动手操作能力，利用python和R</p>
<p>减法：不同学科领域对数据科学的研究视角和侧重点不同，应优先学习领域共性的数据科学，再日后专精</p>
<p>乘法：经典理论X最佳实践，优先学习最代表数据科学的理论和实践，数据科学里<strong>实践领先于理论</strong></p>
<p>除法：注意学习知识的完整性和逻辑性，用最简单的逻辑和最清楚的语言来学习</p>
<p>八个步骤：</p>
<ol>
<li><p>数学、统计学、机器学习</p>
</li>
<li><p>学会写代码</p>
</li>
<li><p>理解数据库</p>
</li>
<li><p>探索数据科学流程</p>
<p>采集、探索、加工、建模、验证、报告</p>
</li>
<li><p>重视并学习大数据</p>
</li>
<li><p>竞赛，建立自己的项目，培养精神</p>
</li>
<li><p>实习、集训、进入职场</p>
</li>
<li><p>参与社区</p>
</li>
</ol>
<h2 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2 理论基础"></a>2 理论基础</h2><h3 id="2-1-学科地位"><a href="#2-1-学科地位" class="headerlink" title="2.1 学科地位"></a>2.1 学科地位</h3><p>跨学科视角</p>
<p>关注理论研究和<strong>领域务实知识（需要相关专家参与）</strong>的结合</p>
<p>主要精神是hacker精神</p>
<h3 id="2-2-统计"><a href="#2-2-统计" class="headerlink" title="2.2 统计"></a>2.2 统计</h3><p>从行为目的和思维方式看</p>
<p>描述统计+推断统计</p>
<p>从方法论角度看</p>
<p>基本分析法：对低层数据（0次1次）分析</p>
<p>回归、分类、时间序列、线性分析、方差分析、聚类分析、其他</p>
<p>元分析法：对高层数据（尤其是基本分析法得出的）进一步分析</p>
<p>方向：</p>
<ul>
<li>不再是随机样本，而是全体数据</li>
<li>不是精确性，而是复杂性，目的不再是追求精确性，而是提升效率</li>
<li>不是因果关系，而是相关关系</li>
</ul>
<h3 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h3><p>基础理论来自多个学科：</p>
<p>人工智能、贝叶斯方法、计算复杂性理论、控制论、信息论、哲学、心理学与神经生物学、统计学</p>
<p>分类P62</p>
<p>按照输出结果：</p>
<ul>
<li>概念学习：用结果推出未知的布尔函数，找到最好你和训练样本的假设</li>
<li>决策树学习：逼近离散值目标函数过程</li>
<li>分析学习：用先验知识分析每个样本，推算各特征与目标函数的相关性</li>
<li>归纳学习</li>
</ul>
<p>按照学习方式：</p>
<ul>
<li>人工神经网络</li>
<li>贝叶斯学习</li>
<li>遗传算法</li>
<li>基于实例学习</li>
<li>增强学习</li>
</ul>
<p>按照学习任务不同：</p>
<ul>
<li>监督学习<ul>
<li>最近邻</li>
<li>朴素贝叶斯</li>
<li>决策树</li>
<li>随机森林</li>
<li>线性回归</li>
<li>支持向量机</li>
<li>神经网络分析</li>
<li>。。。。</li>
</ul>
</li>
<li>无监督学习<ul>
<li>K-Means聚类</li>
<li>主成分分析</li>
<li>关联规则分析</li>
</ul>
</li>
<li>半监督学习<ul>
<li>半监督分类：生成式、判别式</li>
<li>半监督回归：基于差异、基于流形学习</li>
<li>半监督聚类：基于距离、大间隔方法</li>
<li>半监督降维：基于类标签、基于成对约束</li>
</ul>
</li>
</ul>
<p><strong>挑战</strong>：</p>
<ul>
<li><p>过拟合（Overfitting）</p>
<p>训练集准确率高，测试集准确率低</p>
</li>
<li><p>维度灾难（Curse of Dimensionality）</p>
<p>低维算法难以移植到高维</p>
</li>
<li><p>特征工程（Feature Engineering）</p>
<p>还得考虑相关领域知识</p>
</li>
<li><p>算法可拓展性（Scalability）</p>
</li>
</ul>
<p>P74常用统计模型和机器学习算法</p>
<h2 id="3-流程与方法"><a href="#3-流程与方法" class="headerlink" title="3. 流程与方法"></a>3. 流程与方法</h2><p><em><strong>数据科学没有统一的流程，不同专家、应用场景中所提出的流程可能不同，学习数据科学流程的母的在于掌握活动类型，而不是活动之间的严格先后顺序。</strong></em></p>
<h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>图P83</p>
<p>数据化、数据加工、数据规整化、探索性分析、数据分析与洞见、结果展现和数据产品的提供</p>
<ol>
<li><p>数据化</p>
</li>
<li><p>数据加工和规整化</p>
<p>本质是将低层数据化为高层数据0-&gt;1-&gt;2-&gt;3</p>
<p><strong>干净数据</strong>（相对脏）：质量没问题，没有缺失值，错误值和噪声信息</p>
<p><strong>规整数据</strong>（相对乱）：形态符合计算与算法要求，从数据形态分类</p>
<p>注意应该是<strong>增值过程</strong>，不等于传统的“数据预处理”和“数据工程”</p>
</li>
<li><p>探索性分析</p>
<p>在尽量少的先验假定下探索，通过作图、制表、方程拟合、计算特征量等<strong>探索数据的结构和规律</strong></p>
<p>先探索后验证</p>
<ul>
<li><p>耐抗性：</p>
<p>对局部不良行为的非敏感性，因为大数据难免有部分差错</p>
<p>耐抗性分析统计量：集中趋势、离散程度、分布状态、频度等</p>
</li>
<li><p>残差</p>
</li>
<li><p>重新表达</p>
<p>找到合适的尺度或数据表达方式进行准换，有利于化简分析，主语对称性，恒定性，线性和可加性，和线性代数概念类似，也叫变换</p>
</li>
<li><p>启示</p>
</li>
</ul>
</li>
<li><p>数据分析与洞见</p>
<p>在理解数据的基础上，设计、选择、应用具体的机器学习算法和统计模型进行分析</p>
<ul>
<li>描述性分析：转换为信息</li>
<li>预测性分析：转换为知识</li>
<li>规范性分析：转换为智慧</li>
</ul>
</li>
<li><p>结果展现，提供数据产品</p>
</li>
</ol>
<h3 id="3-2-数据加工"><a href="#3-2-数据加工" class="headerlink" title="3.2 数据加工"></a>3.2 数据加工</h3><p>需求：数据质量要求 和 数据计算要求</p>
<p>往往需要综合运用多种数据加工方法</p>
<p>图见P92</p>
<ol>
<li><p>数据清洗（多轮审计和清洗）</p>
<ul>
<li><p>缺失数据</p>
<p>识别、分析（特征，影响，原因）、处理（忽略，删除，插值）</p>
</li>
<li><p>冗余（重复、无关）数据</p>
<p>重复数据用重复过滤</p>
<p>无关数据用条件过滤</p>
</li>
<li><p>噪声（错误、虚假、异常）</p>
<p>分箱、聚类、回归</p>
</li>
</ul>
<hr>
</li>
<li><p>数据变换</p>
<p>使形式符合算法要求，常见策略：</p>
<ol>
<li>平滑处理——去噪声</li>
<li>特征构造——构造新属性，描述客观现实（体积+质量-&gt;密度）</li>
<li>聚集——汇总聚合数据，进行粗粒度计算（日销量-&gt;月销量）</li>
<li>标准化</li>
<li>离散化——用区间标签和概念标签表示属性值</li>
</ol>
</li>
<li><p>数据集成</p>
<p>内容集成：结构相同、描述不同对象，或可通过映射变为相同（同时进行冲突检测、处理等清洗操作）</p>
<p>结构集成：来源不同、描述同一对象，分结构和内容两层次，可进行<strong>属性选择</strong></p>
<p>难点：</p>
<ul>
<li>模式集成：如何匹配来自多个数据源的同一实体</li>
<li>数据冗余：冗余属性可以从其他属性推演出来，命名不一致，用相关分析P99</li>
<li>冲突检测和消除：比例尺度或编码不同（kg 和 g）</li>
</ul>
</li>
<li><p>数据脱敏（Data Masking）</p>
<ol>
<li>单向性：无法从脱敏数据 推导 出原始数据</li>
<li>无残留：用户无法用其他途径还原敏感信息，小心用户画像技术</li>
<li>易于实现：涉及数据量大，所以不能太复杂</li>
</ol>
</li>
<li><p>数据归约（Data Reduction）</p>
<p>在不影响数据完整性和分析结果正确性前提下，减少数据规模和数据量</p>
<ol>
<li><p>维归约</p>
<p>避免维度灾难，减少考虑的随机变量或属性，通常采用线代方法</p>
<p>主成分分析、奇异值分解、离散小波转换</p>
</li>
<li><p>值规约</p>
<p>用参数模型或非参数模型近似表示数据，只存储生成方法和参数？？</p>
</li>
<li><p>数据压缩</p>
<p>重构数据来压缩</p>
</li>
</ol>
</li>
<li><p>数据标注：</p>
<p>对目标数据补充必要的标签类元数据来提高检索、洞察、分析、挖掘效率</p>
<p>自动化程度：有手工、半自动、自动化标注</p>
<p>实现层次：语法标注和语义标注  不懂</p>
</li>
</ol>
<h3 id="3-3-数据审计"><a href="#3-3-数据审计" class="headerlink" title="3.3 数据审计"></a>3.3 数据审计</h3><p>按照数据质量的一般规律与评价方法审计，发现问题</p>
<p>比如缺失值、噪声值、不一致值（相互矛盾）、不完整值（被篡改或无法溯源）</p>
<p>P102</p>
<ol>
<li>预定义审计、自描述性规则</li>
<li>自定义审计</li>
<li>可视化审计</li>
</ol>
<p>常用技巧：第一数字定律、小概率原理、语言学规律、数据连续性理论、数据鉴别技术</p>
<h3 id="3-4-数据分析"><a href="#3-4-数据分析" class="headerlink" title="3.4 数据分析"></a>3.4 数据分析</h3><p>描述性-&gt;诊断性-&gt;预测性-&gt;规范性</p>
<p>​            ↑商务智能              ↑数据科学</p>
<ol>
<li><p>描述性</p>
<p>已经发生了什么</p>
<p>描述性统计分析方法</p>
</li>
<li><p>诊断性</p>
<p>为什么发生</p>
<p>关联分析法（数据科学家）和因果分析法（领域专家）</p>
</li>
<li><p>预测性</p>
<p>将要发生什么</p>
<p>分类分析方法、趋势分析方法</p>
</li>
<li><p>规范性</p>
<p>关注模拟与优化问题，如何从将要发生的事情受惠、如何优化将发生的事</p>
<p>运筹学、模拟与仿真技术</p>
</li>
</ol>
<h3 id="3-5-数据可视化"><a href="#3-5-数据可视化" class="headerlink" title="3.5 数据可视化"></a>3.5 数据可视化</h3><ol>
<li>科学可视化</li>
<li>信息可视化</li>
<li>可视分析学</li>
</ol>
<p>可视分析学以<strong>可视交互</strong>为基础，综合运用图形学、数据挖掘、人机交互，实现人机协同完成可视化任务</p>
<p>P112有一个模型，有以下特点:</p>
<ol>
<li><p>强调从数据到知识的转换过程</p>
<p>不是单纯的展示，而是转换成<strong>知识</strong>，两种途径 👇</p>
</li>
<li><p>强调可视化分析与自动化建模之间的<strong>相互作用</strong></p>
</li>
<li><p>强调数据映射和数据挖掘的重要性</p>
<p>（用来实现👆，作为重要支撑技术），配合使用</p>
</li>
<li><p>强调数据加工工作的必要性</p>
<p>不然会影响可视化效果</p>
</li>
<li><p>强调人机交互的重要性</p>
<p>人机互补和人机协同，重视互补优势</p>
</li>
</ol>
<p><strong>方法体系</strong></p>
<ol>
<li><p>方法论基础</p>
<p>主要指 <strong>视觉编码</strong> 作为数据可视化方法体系的根基</p>
<p>通常采用视觉图形元素和视觉通道两个维度进行视觉编码</p>
</li>
<li><p>基础方法</p>
<p>建立在👆之上，应用不局限于特定领域，提供高层不同应用领域的共性方法，比如统计图表、图论方法、视觉隐喻、图形符号学</p>
</li>
<li><p>领域方法</p>
<p>往往仅限于特定领域或任务范围，不具备跨领域/任务性</p>
<p>但在该领域的信度和效度高于基础方法的直接应用</p>
<p>比如地理信息可视化、时间数据可视化、不确定性、文本、媒体、实时数据之类的</p>
<p>很多领域已出现了自己独特的数据可视化方法，比如地铁路线图全球统一</p>
</li>
<li><p>视觉感知与视觉认知</p>
<p>视觉编码的关键在于找到符合目标用户群体的视觉感知习惯的表达方法</p>
<ul>
<li><p>视觉感知（Visual Perception）</p>
<p>指客观事物通过视觉感觉器官在人脑中产生直接反映的过程</p>
<p>应充分利用人类视觉感知特征</p>
</li>
<li><p>视觉认知（Visual Coginiton）</p>
<p>指个体对视觉感知信息的<strong>进一步加工</strong>处理过程</p>
<p>包括抽取、转换、存储、简化、合并、理解、决策等，很好的例子是<strong>完图法则</strong></p>
</li>
</ul>
</li>
<li><p>可视化视角下的数据类型</p>
<ul>
<li><p>定类数据</p>
<p>主要用于记录事物的所属类型或标签信息，只能进行相等判断</p>
</li>
<li><p>定序判断</p>
<p>主要记录事物的排信息，支持相等判断和大小比较运算</p>
</li>
<li><p>定距排序</p>
<p>用于记录事物的量化信息，“0”的位置具有任意性，不代表事物是否存在，如温度为0°</p>
</li>
<li><p>定比数据</p>
<p>用于记录事物的量化信息，“0”为基准，表示不存在，例如我的身高是他的1.5倍</p>
</li>
</ul>
</li>
<li><p>视觉通道的选择方法<strong>P118</strong></p>
<p>从人类的视觉感知和认知习惯看，数据类型与视觉通道时存在一定的关系的</p>
<p>一般有：位置、尺寸、数值、纹理、颜色、方向、形状，分别能够对应不同的数据类型</p>
<p>要综合考虑目标用户需求、可视化任务本身、原始数据的数据类型，成为数据可视化工作的重要挑战</p>
<p>不同视觉通道的<strong>数据表现力</strong>不同，评判标准：</p>
<ol>
<li><p>精确性</p>
<p>编码结果与原始数据间的吻合程度</p>
</li>
<li><p>可辨认性</p>
<p>字面意思，不要让视觉通道和背景混淆之类的</p>
</li>
<li><p>可分离性</p>
<p>不同视觉通道的表现力之间应具有一定的独立性，比如面积颜色表现力会受到面积大小影响</p>
</li>
<li><p>视觉突出性</p>
<p>编码结果能否在非常短的时间内迅速、精确传达出主要意图</p>
</li>
</ol>
<p>但是应注意：各种视觉通道的表现力往往是<strong>相对</strong>的，与原始数据、通道类型选择、用户感知习惯都有关</p>
</li>
<li><p>数据假象</p>
<p>不可忽视的特殊问题</p>
<p>目标用户产生的错误或不正确的视觉感知：</p>
<ol>
<li>可视化试图所处的上下文可能导致视觉假象</li>
<li>人眼对亮度和颜色的相对判断容易造成视觉假象</li>
<li>目标用户的经历和经验可能造成视觉假象</li>
</ol>
</li>
</ol>
<h3 id="3-6-数据故事化"><a href="#3-6-数据故事化" class="headerlink" title="3.6 数据故事化"></a>3.6 数据故事化</h3><p>“数据的故事化描述”是为了提升数据的可理解性、可记忆性、可体验性</p>
<p>将“数据”还原成成关联至特定的“情景”的过程，因此故事化也是数据转换的表现形式之一</p>
<p>三类“情景”：</p>
<ul>
<li><p>还原情景</p>
<p>还原数据所计算和计算信息的“原始情景”</p>
</li>
<li><p>移植情景</p>
<p>将数据移植到另一个真实发生（比如客户熟悉的情景）的情景中</p>
</li>
<li><p>虚构情景</p>
</li>
</ul>
<ol>
<li><p>重要地位</p>
<p>这被认为是“最后一公里”问题，直接影响整个数据科学项目的成败</p>
<ul>
<li><p>易于记忆</p>
</li>
<li><p>易于认知</p>
<p>可视化易于感知、故事化易于认知</p>
</li>
<li><p>易于体验</p>
<p>一是故事讲述者和倾听者之间共享相同、相似的情景</p>
<p>二是故事的具体表现形式和情节设计</p>
</li>
</ul>
</li>
<li><p>故事化描述与故事的展现方式</p>
<p>👆是两个不同的概念，电影、图书、海报等都是故事化处理后、选择特定的形式具体展现</p>
<ul>
<li>故事化描述是故事展现的前提条件，不同展现方式表现效果不同</li>
<li>故事的展现对故事化描述起反馈作用</li>
</ul>
</li>
<li><p>故事化描述的基本原则</p>
<ol>
<li><p>忠于数据原则</p>
<p>尤其不得以“提高故事生动性”为借口扭曲原始数据</p>
</li>
<li><p>设计共同情景原则</p>
<p>要真正了解目标倾听者，结合他们的经验和知识</p>
</li>
<li><p>体验式讲述原则</p>
<p>比如尽量用第一、第二人称，多一些交互式体验</p>
</li>
<li><p>个性化定制原则</p>
</li>
<li><p>有效性利用原则</p>
<p>有时候故事化不一定合适，要论证是否合适，是否应采取其他方法</p>
</li>
<li><p>3C精神原则</p>
<p>实现增值，避免套路化</p>
</li>
</ol>
</li>
</ol>
<p>近年来，自动化故事化描述成为新的关注点！</p>
<h3 id="3-7-数据科学项目管理"><a href="#3-7-数据科学项目管理" class="headerlink" title="3.7 数据科学项目管理"></a>3.7 数据科学项目管理</h3><p>遵循一般项目管理的原则和方法</p>
<p>涉及 <u>整体、范围、时间、成本、质量、人力资源、沟通、风险、采购</u> 九个方面的管理 P129</p>
<p>So Complex!</p>
<ol>
<li><p>主要角色 P130</p>
<p>项目发起人、项目经理、客户、数据科学家、数据工程师、操作人员</p>
</li>
<li><p>基本流程</p>
<p>都是双向的链条，主要活动包括六项</p>
<ul>
<li><p>项目目标的定义</p>
<p>我们通此项目解决什么问题</p>
</li>
<li><p>数据的获得与管理</p>
<p>我们需要哪些数据？如何获得？如何管理</p>
</li>
<li><p>模式/模型的洞见</p>
<p>我们从数据洞见了什么模式/模型？</p>
</li>
<li><p>模式/模型的验证与优化</p>
<p>已洞见的模式/模型是否可靠、适用以及如何优化</p>
</li>
<li><p>结果的可视化与文档化</p>
<p>我们用什么方式记录和展现数据预期结果</p>
</li>
<li><p>模式/模型的应用与维护</p>
<p>如何运用已确定的模式/模型解决实际问题，并根据数据和问题的动态变化优化模式/模型。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-8-数据科学常见错误"><a href="#3-8-数据科学常见错误" class="headerlink" title="3.8 数据科学常见错误"></a>3.8 数据科学常见错误</h3><p>主要原因在于人们尚未完全理解数据科学理念、理论、方法、工具</p>
<p>用自己一贯采用的习惯性思维和传统理论去“解决”大数据问题</p>
<ol>
<li><p>不检查数据</p>
<p>80%时间获取、清理数据，检查是否可用，谨慎使用模拟数据</p>
</li>
<li><p>不理解数据</p>
<p>应该在训练数据模型前仔细研究数据，更快的利用直觉</p>
</li>
<li><p>不评估数据</p>
<p>对数据内容及其模态和目标任务之间的匹配度进行评估，寻找新的途径而不老是局限于过去</p>
<p>从小目标开始、不要一开始就挑战技术难题</p>
</li>
<li><p>不测试模型</p>
</li>
<li><p>只有目标、没有假设</p>
<p>合情的假设可以从一开始缩小范围，减少在这个问题上浪费的时间</p>
</li>
<li><p>采用过时失效的模型</p>
<p>当你的竞争对手从你的市场表现中学习时就已经过时了</p>
</li>
<li><p>不评估最终结果</p>
</li>
<li><p>忽略业务专家的作用</p>
<p>比如在确定需要的特征时节省大量的时间</p>
<p>开始项目前，数据团队和业务专家之间进行对话，确保每个人都清楚项目要实现什么效果，然后做探索性的数据分析，看看能否实现它，如果不能，可能需要用一种新的方法重新表述该问题，或者采用不同的数据源，但这个具体领域的专家<strong>应该帮助确定目标是什么以及项目是否符合目标</strong></p>
</li>
<li><p>选择过于复杂的模型/算法</p>
<p>简单优先，先考虑简单的，注意到过拟合更可能发生在复杂的算法中</p>
</li>
<li><p>模型与算法选择上的偏见</p>
<p>最好从开源模型中构筑自己的版本</p>
</li>
<li><p>曲解基本概念和基础原理</p>
</li>
<li><p>低估目标用户的理解能力</p>
</li>
</ol>
<p>奥卡姆剃刀定律：</p>
<ol>
<li>剃掉不必要的假设</li>
<li>分割两个类似的结论来区分两个假设</li>
</ol>
<p>不应盲目追求数据量，以最必要的数据集为基础数据，不要追求”高大上“。。</p>
]]></content>
      <categories>
        <category>data science</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习实战</title>
    <url>/2021/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><p><a href="https://github.com/Darren-greenhand/handson-ml2">仓库地址</a></p>
<p>本书内容广博，不仅介绍了传统ML，还用sklearn演示了端到端训练实例。</p>
<p>尤其对DL进行了深入探讨，涵盖强化学习、利用TF/Keras构建和训练神经网络</p>
<h2 id="ML"><a href="#ML" class="headerlink" title="ML"></a>ML</h2><h3 id="1-前置补充"><a href="#1-前置补充" class="headerlink" title="1. 前置补充"></a>1. 前置补充</h3><ul>
<li>在机器学习里，属性是一种数据类型，而特征取决于上下文，通常意味着<strong>属性+值</strong>(很多人混淆)</li>
<li>一些回归算法和可用于分类任务，反之亦然。比如逻辑回归可以输出“属于某个给定类别的概率”，可用于分类</li>
<li>无监督应用：<ul>
<li>聚类</li>
<li>异常检测、新颖性检测</li>
<li>可视化、降维（可先用降维减少数据维度，再提供给别的算法）</li>
<li>关联规则学习</li>
</ul>
</li>
<li>比起在线学习，批量学习也可以适应变化，但是需要<strong>重新训练全新的系统</strong>，成本高</li>
<li>在线学习也可以用于超大数据集，因为超出了一台计算机的主存储器的数据</li>
<li>基于实例（相似度），和基于模型(我看到的好像都是这个)的学习</li>
<li>特征工程 vs 端到端学习</li>
<li>正则化实质是约束模型，限制变化范围，降低复杂度。</li>
<li>测试验证：保持验证、交叉验证</li>
<li>没有免费的午餐：<strong>如果你对数据绝对没有假设，那么就没有理由更偏好某个模型</strong>，必须得有假设，然后只评估部分合理的模型。</li>
</ul>
<h3 id="2-端到端的机器学习项目"><a href="#2-端到端的机器学习项目" class="headerlink" title="2.端到端的机器学习项目"></a>2.端到端的机器学习项目</h3><p>假设你是一个房地产公司最近雇佣的数据科学家，你会经历：</p>
<ol>
<li>观察大局</li>
<li>获得数据</li>
<li>从数据探索和可视化中获得洞见</li>
<li>机器学习算法的数据准备</li>
<li>选择并训练模型</li>
<li>微调模型</li>
<li>展示解决方案</li>
<li>启动、监控和维护模型</li>
</ol>
<p>（使用真实数据，详情见我的另一篇博文：<a href="https://darren-dong.com/2021/09/08/DS-Source/">DS资源</a>）</p>
<h4 id="观察大局"><a href="#观察大局" class="headerlink" title="观察大局"></a>观察大局</h4><p><strong>附录B，记录了一个数据科学项目的大致流程以供参考</strong></p>
<p>流水线：一个序列的数据处理组件称为一个数据流水线。在机器学习系统中非常普遍。</p>
<p>组件通常异步进行，组件间很独立，连接只有数据仓库。Robustness++，但需要适当的监控。</p>
<ol>
<li><p>问老板业务目标，公司期望如何使用该模型，如何从中获益才是重要问题：</p>
<p>这决定怎么设定问题，选择什么算法，通过什么方式评估模型性能，花多少精力来进行调整</p>
</li>
<li><p>问老板当前的解决方案（可能存在），当作建议、参考，获得洞察</p>
</li>
<li><p>开始设计系统，回答框架问题：有无监督/强化、分类/回归、批量/在线</p>
</li>
<li><p>选择性能指标：</p>
<ul>
<li><p>RMSE 均方根误差          欧几里得范数  L2</p>
</li>
<li><p>MAE   平均绝对误差      曼哈顿范数      L1   </p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/67120415">范数的定义</a></p>
<p><strong>指标越高越关注大值而不是小值</strong>，这就是为何RMSE比MAE对异常值更敏感</p>
</li>
</ul>
</li>
<li><p>检查假设，与数据流水线上下游团队沟通。</p>
</li>
</ol>
<p>获取数据（数据库），可以编写shell脚本来辅助</p>
<p>通过查看数据描述、部分数据，简单可视化来了解数据</p>
<h4 id="创建测试集"><a href="#创建测试集" class="headerlink" title="创建测试集"></a>创建测试集</h4><p><strong>在简单了解数据后，创建测试集</strong>（有点奇怪），因为大脑容易过拟合<strong>（数据窥探偏误）</strong>：</p>
<p>浏览数据，跌入某个看似有趣的测试数据模式，选择某个特殊的模型，估计结果过于乐观，但其实泛化能力一般。</p>
<p>所以要在没有进一步了解的时候创建测试集，有一些方法，比如用标签确定哪些是选出来的测试集，有时候要用纯随机，有时候要分层抽样。</p>
<p>这一步没有想象中的简单，而很多人忽视了它创建的时机。</p>
<h4 id="从数据探索和可视化中获得洞见"><a href="#从数据探索和可视化中获得洞见" class="headerlink" title="从数据探索和可视化中获得洞见"></a>从数据探索和可视化中获得洞见</h4><p>现在把测试集放在一边不要碰，只关注训练集。如果训练集太大，可以抽样一个<strong>探索集</strong></p>
<p>xs，通过设置透明度更好的看清密度</p>
<p>我们的大脑擅长从图片中发现模式，但这需要你玩转可视化的参数。</p>
<p>先试试寻找不同特征之间的相关性，既包括线性，也有非线性并可视化出来康康，有许多函数可以实现这一步</p>
<p>中间省略众多有趣的方法</p>
<p>最后我们应该尝试各种属性的组合，创建新属性（我感觉吴恩达教的更好），再检测一下相关性等指标。</p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>这个过程应该编写函数而不是手动操作：</p>
<ul>
<li>以便在任何数据集上轻松重现</li>
<li>可以逐渐建立起转换函数库，在以后的项目中重用</li>
<li>可以在实时系统中用函数转换新的数据，在输入给算法</li>
<li>可以轻松尝试多种转换方式，比较效果。</li>
</ul>
<p>回到干净的训练集，进行数据清理，处理文本和分类属性的时候用到了独热码</p>
<hr>
<p>ps：sklearn的API设计规则非常好，原则如下：</p>
<ul>
<li>一致性：所有对象共享一个简单的界面</li>
<li>估算器：能够根据数据集对某些参数进行估算</li>
<li>转换器：可以转换数据集</li>
<li>预测器：能够基于一个给定的数据集进行预测</li>
<li>检查：所有估算器的超参数都可以通过公共实例变量直接方位（例如imputer.strategy）</li>
<li>防止类扩散：数据集被表示为Numpy数组或Scipy稀疏矩阵，超参数只是普通的Python字符串或数值</li>
<li>构成：现有的构建尽最大可能重用</li>
<li>合理的默认值</li>
</ul>
<hr>
<p>而尽管sklearn提供了许多有用的转换器，你仍然需要为一些注入自定义清理操作或组合特定属性等任务编写自己的转换器。</p>
<p><strong>而sklearn依赖鸭子类型编译，而不是继承</strong>。</p>
<p>这些数据准备步骤的执行越自动化，你自动尝试的组合也就越多，从而有更大的可能找到一个重要的组合并节省大量时间。</p>
<p><strong>最重要也最需要应用到数据上的转换就是特征缩放</strong>，（仅用于拟合训练集）</p>
<p>两种常用方法：最小-最大缩放（归一化）、   标准化</p>
<p>前者是减去最小值然后除以（最大-最小），收缩到0—1，当然也可以更改</p>
<p>后者是减去平均值然后除以方差，<strong>标准化没有特定范围，但是受异常值的影响更小。</strong></p>
<p><strong>转换流水线</strong>（后来补充）</p>
<p>通过Pipeline类来支持，方法与最终的估算器方法相同。</p>
<p>如果要用于多列，可以用Column-Transformer，他与pandas DataFrame 一起使用时效果很好。</p>
<hr>
<h4 id="选择和训练模型"><a href="#选择和训练模型" class="headerlink" title="选择和训练模型"></a>选择和训练模型</h4><p>完成了前面的步骤后，事情现在变得比想象中容易很多。</p>
<p>别忘了使用<strong>交叉验证</strong>来更好地评估：</p>
<ul>
<li>可以将训练集分为较小的训练集和验证集，然后加以训练</li>
<li>也可以使用sklearn的K-折交叉验证功能。（更偏向于使用效用函数而不是使用成本函数）</li>
</ul>
<p>在深入某些算法之前，应该<strong>尝试一遍各种机器学习算法的其他模型</strong>（不同内核的支持向量机，神经网络。。）</p>
<p>但是别花太多时间调整超参数，我们的目的是<strong>筛选出几个（2~5）个有效的模型</strong>，每一个尝试的模型都应该妥善保管，以及对应的超参数和训练过的参数，以及交叉验证的评分和实际检测的结果。</p>
<p>可以用Python的pickle模块或joblib库来保存模型。</p>
<h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>有了有效模型的候选列表，现在进行微调。</p>
<p>你可以手动调整超参数直到找到一组不错的组合。。非常枯燥乏味，耗时间</p>
<p>你也可以用sklearn的GridSearchCV替你搜索，如果不知道超参数怎么赋值，可以先尝试10的连续次幂</p>
<p>当然也可以把它用在数据准备的步骤，还可以用来自动寻找处理问题的最佳方法。</p>
<p><strong>网格搜索👆</strong>是一项模型超参数（即需要预先优化设置而非通过训练得到的参数）优化技术，常用于优化三个或者更少数量的超参数，本质是一种穷举法。</p>
<p>但是如果超参数搜索的方法较大，建议使用<strong>随机搜索</strong>。</p>
<p>还有集成方法，组合方法往往比单一的模型更好。。。。。最后通过测试集评估系统。、</p>
<p>还是小心吴恩达说的那个问题，不要拼命调调超参数让测试集结果好看，这可能会使其“适应测试集”。。。</p>
<h4 id="启动！监控与维护"><a href="#启动！监控与维护" class="headerlink" title="启动！监控与维护"></a>启动！监控与维护</h4><p>预启动：展示解决方案（学了什么、什么有用、基于什么假设、系统的限制），记录所有的事情，通过可视化和故事化制作漂亮的演示文档。</p>
<p>你可以部署到服务器，通过web来让用户调用，但更流行的策略是将模型部署到云上：用joblib保存模型上传到Google Cloud Storage（GCS），然后转到Google Cloud AI Platform并创建一个新的模型版本，指向GCS文件。</p>
<p>你还要编写监控代码以定期检查系统的实时性能，在降低时触发警报，因为数据会过时，会腐朽。</p>
<p>各种层面，甚至包括相机的图像清晰度、格式变化，还有人们的偏好变化。。。</p>
<p>但是确定模型的性能并不总是可行的，你可能需要人工分析。。。反正建立一个监控系统和相关流程，包括如何定义故障以及如何做准备。</p>
<p>这个工作量甚至比构建和训练模型多得多。。你还要定期更新数据集并定期重新训练模型（数据发展），最好自动化：</p>
<ul>
<li>自动定期收集数据并标记（如聘用人工标注者）</li>
<li>编写脚本来训练模型并自动调微超参数。</li>
<li>编写脚本在更新的测试集上评估新旧模型，性能好则自动部署，差就调查原因。</li>
</ul>
<p>做好版本管理（包括每个版本的数据集），以防新模型故障时需要回滚</p>
<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h3><p>终于了解完了大概流程，有些麻烦，但不出所料，让我们正式进入学习吧！</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学手册（前半完结）</title>
    <url>/2021/05/17/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="前言和环境"><a href="#前言和环境" class="headerlink" title="前言和环境"></a>前言和环境</h1><p>跨学科是数据科学的关键</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210510110540.png" alt="公认的学科交叉图" style="zoom: 33%;" />

<h2 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h2><p>？和？？    ？几乎适用任何对象包括魔法指令</p>
<p>有时候？？不能显示源代码，因为该对象不是用python实现的，此时等价于一个？</p>
<p>Tab补全，配合通配符 * 使用</p>
<p>一般带下划线的私有方法和特殊方法不会被默认显示，可以通过显式输入 _ 再tab来获取他们</p>
<p>甚至可以 import &lt;TAB&gt; 查看你能导入的包</p>
<p><a href="https://www.cnblogs.com/Pythonzrq/p/11346578.html#:~:text=2%E3%80%81pycharm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%201%20%E3%80%81%E7%BC%96%E8%BE%91%EF%BC%88Editing%EF%BC%89%202%20%E3%80%81%E6%9F%A5%E6%89%BE%2F%E6%9B%BF%E6%8D%A2%20%28Search%2FReplace%29%203%20%E3%80%81%E8%BF%90%E8%A1%8C,History%209%20%E3%80%81%E6%A8%A1%E7%89%88%20%28Live%20Templates%29%2010%20%E3%80%81%E5%9F%BA%E6%9C%AC%20%28General%29"><strong>快捷键</strong></a></p>
<p>C + a/e </p>
<p>C + u/k 剪掉前面，后面</p>
<p>C + t 交换前两个字符，怪毙了</p>
<p>C + r对历史反向搜索，继续ctrl+r往前匹配下一个，找到后回车</p>
<p>C + l/c/d 清屏，中断当前python命令，退出ipython会话</p>
<p><strong>魔法指令</strong></p>
<p>ipython在普通python语法上的增强功能</p>
<p>行魔法 %</p>
<p>单元魔法 %%，用于处理多行输入比如%%timeit</p>
<pre class="line-numbers language-pytho" data-language="pytho"><code class="language-pytho">%quickref  快速参考卡
%magic 探索所有魔术命令
%debug从最后发生报错的底部进入交互式调试器  %pdb出现任意报错自动进入调试器
%hist
%paste   %cpaste 解决包含符号的多行输入&#x2F;复制问题
%reset 清空所有变量&#x2F;名称  %xdel variable 删除变量和相关引用
%page OBJECT  通过分页器更美观的打印一个对象
%run   %prun statement  使用CProfile执行语句，报告输出
%time 报告单个语句执行时间   %timeit 多次运行单语句，计算平均执行时间，用于估算代码最短执行时间
%who  %who_ls  %whos  依次更加详细的展示变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://developer.51cto.com/art/202007/620863.htm">这个厉害</a></p>
<p>集成matplotlib:</p>
<ul>
<li>在ipython命令行中 %matplotlib</li>
<li>在jupyter中 %matplotlib inline</li>
</ul>
<p>In是一个列表，记录了历史命令</p>
<p><strong>Out是一个字典</strong>，将输入的索引对应起输出，很多命令没有输出（None），则不会被记录！</p>
<p><strong>Out[x] 的简写是_x</strong></p>
<p>print(_) 一二三条下划线对应倒数第几个历史输出，这个厉害，或者直接 _3</p>
<p><strong>但是如果输入的最后加上；就不会被添加到历史，也不会把输出显示出来</strong>，这样当其他引用被删除时，该空间可以被释放。</p>
<p><strong>shell</strong></p>
<p>很多教材说是用 ! 加shell指令，但是pycharm全是%呀</p>
<p>可以用赋值将任何shell命令的输出保存到一个python列表，这是一个长得像列表的特殊返回类型</p>
<p>在shell里面用{varname}来调用变量</p>
<p>很多shell的指令可以直接使用，比如%cd 可以直接cd</p>
<p><strong>调试</strong></p>
<p>%xmode Plain/Context/Verbose 异常模式，改变异常时的打印信息</p>
<p>plain只会输出函数和行号，context是默认，会显示出错行上下几行代码，verbose还会显示每一级的参数和出错位置的变量值，好方便</p>
<p>标准调试工具pdb 的Ipython增强版ipdb，ipython专用</p>
<p>还有个很方便的%debug魔法指令，在最近的异常点打开一个交互式调试指令符（是用了ipdb）</p>
<p>%pdb on 会在抛出异常时自动启动，pdb有 up down 等命令配合print来检查</p>
<p>有一些常用调试命令：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span> 显示路径
h<span class="token punctuation">(</span><span class="token builtin">help</span><span class="token punctuation">)</span> 显示命令列表
q<span class="token punctuation">(</span>uit<span class="token punctuation">)</span> 退出调试器和程序
c<span class="token punctuation">(</span>ontinue<span class="token punctuation">)</span> 推出调试器，继续程序
n<span class="token punctuation">(</span>ext<span class="token punctuation">)</span> 跳到程序下一步
<span class="token operator">&lt;</span>enter<span class="token operator">></span> 重复前一个命令
p<span class="token punctuation">(</span>rint<span class="token punctuation">)</span> 打印变量
s<span class="token punctuation">(</span>tep<span class="token punctuation">)</span> 步入子进程
r<span class="token punctuation">(</span>eturn<span class="token punctuation">)</span> 从子进程跳出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>代码的分析与计时</strong></p>
<p>“大约百分之97的时间，我们应该忘记微小的效率差别；过早优化是不被推荐的”</p>
<p>但是当代码跑起来后，提高运行效率是有用的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">%</span>time 对单个语句的执行时间进行计时<span class="token punctuation">(</span>适合不可重复的，或者时间较长的<span class="token punctuation">)</span>
<span class="token operator">%</span>timeit 对单个语句的重复执行进行计时，以获得更高的精确度<span class="token punctuation">(</span>但需要保证可重复性，别对排序这样干<span class="token punctuation">)</span>
在进行相同操作时，timeit总是比time更快，因为timeit在底层采取了一些措施组织系统调用对计时过程的干扰，例如阻止清理未利用的python对象。

👇需要安装line_profiler 和 memory_profiler 拓展
python包含一个内置的代码分析器，可以通过魔法指令👇简单的调用
<span class="token operator">%</span>prun 使用分析器运行代码，输出一个时间报告 <span class="token operator">+</span> 函数<span class="token punctuation">(</span>参数<span class="token punctuation">)</span>
<span class="token operator">%</span>lprun 使用逐行分析器运行代码，逐行分析
<span class="token operator">%</span>memit 测量单个语句的内存使用
<span class="token operator">%</span>mprun 使用逐行的内存分析器运行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>%%file 来写一个简单的模块文件</p>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>将异构的各种数据都看成数组，第一步将这些数据转化成数值数组形式的可分析数据。</p>
<p>数据科学的绝对基础：有效存储数据，操作数值数组</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>标准的python实现是用C编写的，这意味着每一个python对象都是一个聪明的伪C结构体</p>
<p>比如python的整形变量其实是一个指针，它的结构体里包含了大量额外信息，所以可以自由，动态编码，但也会成为负担。</p>
<p>python<strong>列表</strong>实质：指向一个指针域，域里的每一个指针指向一个确切的对象</p>
<p>numpy牺牲了这一点，指向一块类似C的域，但是能更有效地存储和操作数据。</p>
<p>所以numpy要求数组必须包含同一类型的数据，不匹配则向上转换</p>
<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>手打l<span class="token punctuation">)</span>
np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token operator">/</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token operator">/</span>full<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3.14</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>full<span class="token punctuation">(</span>size<span class="token punctuation">,</span>fulfiller<span class="token punctuation">)</span> <span class="token comment">#用fulfiller填充</span>
np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#左闭右开 默认int</span>
np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#左闭右闭 默认float,找5个等间距点</span>
np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 0~1均匀分布</span>
np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 均值 方差 shape</span>
np<span class="token punctuation">.</span>random<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#左闭右开 区间[0,10)</span>
np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token comment">#n单位矩阵</span>
np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token comment">#未初始化的数组，数组值是内存空间中的任意值</span>
np<span class="token punctuation">.</span>mgrid<span class="token punctuation">(</span>坐标轴<span class="token number">1</span>（左开右闭）<span class="token punctuation">,</span>坐标轴<span class="token number">2</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span>拉直  <span class="token punctuation">.</span>c_<span class="token punctuation">(</span><span class="token punctuation">)</span>组合 看另一个教程吧
用来生成网格
还有各种_alike<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>dtype可以用字符串参数或者相关的Numpy对象来指定。</p>
<p>标准类型大概有bool_ int类 float类 complex类  可以查一查，还有更高级的数据类型指定P35</p>
<p>后面带一个下划线的代表默认的类型</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>ndim 维度  shape 形状（每个维度大小）   size 元素个数（数组大小）</p>
<p>dtype 数据类型   itemsize 每个元素的字节大小   nbytes  总字节大小</p>
<h3 id="索引切片"><a href="#索引切片" class="headerlink" title="索引切片"></a>索引切片</h3><p>与python类似，更改元素时自动发生类型变换</p>
<p>获取第一列x2[: , 0]</p>
<p>获取第一行x2[0 , :] #获取行时其实可以省略，直接x2[0]</p>
<p>抽取左上角的2x2数组，x2[:2，:2]</p>
<p><strong>切片返回的是视图</strong>，.copy() 才是复制，这意味着可以处理大型数据集的片段而不用花费额外的内存</p>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>.reshape() 大小必须一致</p>
<p>或者在索引中使用newaxis 关键字，插入一个新维度，不过记得要加上前缀，即np.newaxis,比如原来有个是3（一行），后插变成（3，1）（一列）</p>
<p>x = x[np.newaxis,:] 在前面加了一个维度，反之则是在后面插入</p>
<h3 id="拼接和分裂"><a href="#拼接和分裂" class="headerlink" title="拼接和分裂"></a>拼接和分裂</h3><p><strong>np.concatenate</strong>(默认沿着第一个轴) #二维就是列，用axis  = 1 可以改成行</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">grid <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span> concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>grid<span class="token punctuation">,</span>grid<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>前三维可以用<strong>np.vstack(垂直) np.hstack(水平) np.dstack(第三维)</strong> 来拼接</p>
<p>vertical horizontal deep</p>
<p>np.split(x, [3,5])#后面那个数组记录的是下一段首的索引位置，如果是3，那就在索引2（第3个元素）和3间断开，返回一个子元组</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> grid
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span>x3 <span class="token operator">=</span> np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>grid<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x1
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x2
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">#np.hsplit 和 np.vsplit 和 np.dsplit 差不多，记得后面那里要用索引列表</span>
upper<span class="token punctuation">,</span>lower <span class="token operator">=</span> np<span class="token punctuation">.</span>vsplit<span class="token punctuation">(</span>grid<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#上下四行均分成两行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>Numpy高效的关键是采用 <strong>向量化</strong> 操作，通常用通用函数（ufunc）实现——提高了数组元素重复计算的效率</p>
<p>Python灵活的数据类型导致序列操作不能被编译成有效的机器码，所以循环操作超级慢</p>
<p>很多方案试图解决，比如Cpython，Cython，LLVM字节码，但是Cpython是最流行的</p>
<p>Cpython的主要瓶颈在于每次循环时必须做<strong>数据类型检查和函数的调度</strong>。</p>
<p><strong>Numpy为许多类型的操作提供了方便，静态，可编译程序的接口，被称为向量操作。这将被循环推送至Numpy下的编译层。</strong></p>
<p>只要看到python脚本有循环，就可以考虑能否用向量替代。</p>
<p>通用函数有两种形式，一元和二元。</p>
<p>python原生的算术运算符被重构了，相当于调用一些通用函数，比如 * 相当于 np.mulitiply</p>
<p><code> + - * /  //  **  %</code>都被重构了，还有布尔/位运算符</p>
<p>Numpy可以理解python内置的某些函数比如绝对值函数 abs(x)，对应的是np.absolute 或者别名np.abs，但这个numpy的处理复数时返回幅值。</p>
<p>三角函数：sin cos tan arcsin arccos acrtan  还有很多别的</p>
<p>指对数：exp exp2(2^)  power(底数，操作的数组x)       ||log  log2  log10</p>
<p>还有<strong>专门用来处理小量</strong>的：np.expm1(x)  == exp(x) - 1               np.log1p(x)  == log(1+x)   #在x很小时精度较高</p>
<p>还有很多双曲三角啊，比特位运算，比较运算，弧度角度转化等等等。可以查<a href="https://numpy.org/">文档</a></p>
<p>还有一个更专用的子模块scipy.special 里面有一堆牛逼函数比如伽马（广义阶乘）， 高斯积分啥的，可以搜索xxx function python</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p><strong>指定输出</strong></p>
<p>有一个out参数指定输出结果的存放位置，此时不创建临时数组而直接写入目标位置，对于较大的数据能有效节约内存，但是注意要提前创建好用来存放的nparray</p>
<p><strong>聚合</strong></p>
<p><strong>二元通用函数</strong>指的是对两个输入操作，它们有些非常有趣的聚合功能，可以直接在对象上计算，会对给定的元素和操作重复执行，直到得到单个结果，这是任何通用函数都有的方法</p>
<p>比如reduce(压缩)，任何通用函数都有，可以重复计算直到获得单个结果</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>add<span class="token punctuation">.</span><span class="token builtin">reduce</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
x <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果需要存储每次计算的中间结果，可以使用accumulate，项数不会变，但是除了第一项其他依次被处理</p>
<p>np.add.accumulate(x)     –array([1,3,6,10,15])</p>
<p><strong>外积</strong></p>
<p>任何输入函数都可以使用<strong>outer</strong>方法获得 两个不同输入数组 <strong>所有元素对</strong> 的函数运算结果</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">.</span>outer<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>更多的通用函数信息可以在Numpy和SciPy的文档网站查到</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>在处理大量数据的时候第一步通常是计算相关概率的概括统计值，比如最常用的均值和方差。</p>
<p>Numpy又快速的内置聚合函数可用于数组，如下：</p>
<p>np.sum 和内置的sum都可以起作用，但是numpy的sum在编译码中运行，所以<strong>操作更快</strong>（1000倍），而且注意不要混淆，他们的参数有不同的意义，np.sum函数是知道数组的维度的</p>
<p>np.min  max啥的，还有一种更简洁的语法是数组对象直接调用这些方法: x.min()  x.sum()</p>
<p><strong>多维度聚合</strong></p>
<p>可以用axis指定处理的维度，但是要注意，这个指定的是数组将会被聚合（折叠）的维度，而不是要返回的维度，比如说axis = 0 意味着第一个轴（二维数组的列）将要被折叠。</p>
<p>numpy有很多内置的聚合函数，大多数聚合都有对NaN的安全处理策略，即计算的时候<strong>忽略所有缺失值</strong>。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span><span class="token builtin">sum</span>  np<span class="token punctuation">.</span>nansum
np<span class="token punctuation">.</span>prod np<span class="token punctuation">.</span>nanprod 积（product）
np<span class="token punctuation">.</span>mean  平均值
std  标准差 Standard deviation
var  方差  variance
<span class="token builtin">min</span> <span class="token builtin">max</span>  最小最大
argmin argmax 最小最大的索引
median  中位数

percentile  基于元素排序的统计值<span class="token punctuation">,</span>例子如下
In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x
Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">4.0</span>
In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">5.0</span>

<span class="token builtin">any</span>  <span class="token builtin">all</span>  存在  任意为真 <span class="token comment">#无安全版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>可以理解为将低维数组拓展，拓展到匹配的维度，但是其实并没有发生这样的内存分配，只是便于理解。</p>
<p>规则如下：</p>
<ol>
<li>如果两个数组的维度不同，小维度数组<strong>的形状在最左边补1</strong></li>
<li>如果数组在任何一个维度上大小不相等，而且数组<strong>该维度为1</strong>，则会沿着该维度拓展到匹配另一个数组</li>
<li>如果数组在任何一个维度上大小不相等，而且并没有某个数组维度为1，那么引发异常。</li>
<li>小心numpy的一维数组，也就是shape是（n,）<strong>这不等于列向量！</strong></li>
</ol>
<p>最值得注意的就是他补充一个维度是在左边补1而不是右边，如果希望右边补全，可以使用变形数组。</p>
<p>这些广播规则适用于<em><strong>任意二进制通用函数</strong></em></p>
<p><strong>实际应用</strong></p>
<p>数组的归一化</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Xmean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#沿着第一个维度聚合</span>
In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X_centered <span class="token operator">=</span> X <span class="token operator">-</span> Xmean
In <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> X_centered<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8.88178420e-17</span><span class="token punctuation">,</span>  <span class="token number">0.00000000e+00</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.11022302e-17</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
妙啊<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>画一个二维函数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">看不懂他的骚操作，可以翻一下书的P60页<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="比较，掩码，布尔"><a href="#比较，掩码，布尔" class="headerlink" title="比较，掩码，布尔"></a>比较，掩码，布尔</h2><p>当想<strong>基于某些准则</strong>来抽取，修改，技术或对一个数组中的值进行其他操作时，掩码就可以派上用场了，在Numpy中，布尔掩码是完成这类任务的最高效完成方式。</p>
<p>比较有六种运算符<code>== != &lt; &lt;= &gt; &gt;=</code> 两边可以是表达式，<strong>每次返回的结果是布尔数组</strong></p>
<p>利用复合表达式实现逐元素比较也是可行的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>x <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">,</span>  <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这些比较运算符也是<strong>借助通用函数</strong>来实现的，例如x &lt; 3 其实调用np.less(x,3) </p>
<h3 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h3><p>记录布尔数组中非零（其实就是True）的个数 np.count_nonzero(）</p>
<p>统计小于6的则np.count_nonzero(x&lt;6) </p>
<p>或者也可以 np.sum(x&lt;6) 都是返回为True的个数，sum的好处是可以沿着行或者列进行</p>
<p>np.any 和 np.all 快速检测全部 </p>
<p>需要提醒的是python有内置的sum，any，all函数，这些函数在numpy中有对应的版本，但是语法不同，如果在多维数组上混用这两个版本，会导致神奇的错误，请确保使用numpy版本</p>
<p><strong>布尔运算符</strong></p>
<p>逻辑运算符也被重载，可以实现对数组的逐位逻辑运算。有<code>&amp; | ^ ~</code></p>
<p>np.sum((inches &gt; 0.5) &amp; (inches &lt; 1))  注意用括号调整运算次序。表示inches在0.5到1间的数目</p>
<p>将布尔数组作为掩码</p>
<p>就是传说中的布尔矩阵作为索引呗，会得到一个一维数组</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">and</span> <span class="token keyword">or</span>  和  <span class="token operator">&amp;</span> <span class="token operator">|</span>  的区别<span class="token keyword">and</span> <span class="token operator">/</span> <span class="token keyword">or</span> 判断整个对象是真是假，而后两者是指每个对象中的比特位，依次化成二进制码进行操作而布尔矩阵可以被当成比特字符组成的，所以采用后者，而使用前者比较整个对象的时候会出错。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>记得布尔索引会被拉直成一个一维数组，所以还是当作索引用，不要单独用。</p>
<h2 id="花哨的索引"><a href="#花哨的索引" class="headerlink" title="花哨的索引"></a>花哨的索引</h2><p>花哨（fancy）的索引对多个维度也适用。</p>
<p><strong>花哨索引和前面的简单索引类似，但是传递的是索引数组，可以让我们快速获得并修改复杂的数组值的子数据集</strong></p>
<p>结果的形状与<strong>索引数组的形状</strong>一致，如果有广播，就是<strong>跟广播后的索引数组的形状</strong>一致,而不是被索引的数组</p>
<p>如果是普通的一维一维的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
           <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
           <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
col <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
b<span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span>那就像坐标一样
Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
但如果b<span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span><span class="token punctuation">,</span>col<span class="token punctuation">]</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
那就是广播，淦，当年为何困惑了我这么久，广播以后 索引数组的每一个位置其实都是一个坐标。。就这么简单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配合切片，简单索引，布尔效果更好。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>从一个矩阵中选择行的子集！</p>
<p>可以用花哨索引来修改值，但是重复的索引会有一些诡异的事情发生</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> i <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>

In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>

In <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x
Out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#应该看成x[i] = x[i] + 1就会发现神奇索引导致的诡异地方，解决方法是at👇</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>at函数可以对给定的操作，给定的索引，给定的值进行就地操作。</p>
<p>比如np.add.at(x,i,1) x为被操作的矩阵，i为索引，1为操作数（+1）</p>
<h2 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h2><p>python有内置的sort和sorted但是太慢了</p>
<p>np.sort 是快速排序【N log N】,另外可以选择归并排序和堆排序。</p>
<p>np.sort(X) 不会修改原始数组，x.sort()这种python内置的方法会<strong>替代原始数组</strong></p>
<p>np.argsort(X)返回的是<strong>如果排序</strong> 好的索引值。</p>
<p>利用axis可以选择行列排序噢,<strong>这是将行和列当成独立数组，任何关系都将丢失！</strong></p>
<p><strong>部分排序：分隔</strong></p>
<p>np.partition(x,3) 将最小的3个和其他的分隔开，两组数是任意排序的</p>
<p>当用<strong>axis时也会破坏行和列的关系</strong>，np.argpartition返回索引</p>
<h2 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h2><p>P82 <strong>数据类型</strong></p>
<p>Numpy的结构化数组和记录数组。</p>
<p>他们为复合的，异构的数据提供了非常有效的存储。</p>
<p>其实就是把dtype当作一个结构嘛</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span>
age <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">]</span>
weight <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">21.21</span><span class="token punctuation">,</span><span class="token number">4.43</span><span class="token punctuation">,</span><span class="token number">4334.65</span><span class="token punctuation">,</span><span class="token number">45.9</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'names'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'weight'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          <span class="token string">'format'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">'U10'</span><span class="token punctuation">,</span><span class="token string">'i4'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">#U10表示长度不超过10的字符串，</span>
data<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token operator">=</span>name
data<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">=</span>age
data<span class="token punctuation">[</span><span class="token string">'weight'</span><span class="token punctuation">]</span><span class="token operator">=</span>weight
这样可以用连续的内存存储异构的数据，反映了他们间的关系
可以用date<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>查看是<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">21.21</span><span class="token punctuation">)</span>
然后就有很多骚操作比如
data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token comment">#获得年龄小于30的人的年龄</span>
数值类型可以用python类型或者Numpy的dtype来指定<span class="token number">2</span>
<span class="token operator">&lt;</span> 和 <span class="token operator">></span> 分别表示低字节序 和 高字节序
b 字节型
i u 有、无符号整形
f 浮点型
c 复数浮点型
S a 字符串
U Unicode编码字符串
V 原生数据
<span class="token comment">#还有一种格式是元组列表</span>
np<span class="token punctuation">.</span>dtype<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'U10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
这样就直接生成一个结构化数组
结构化数组的dtype属性里，第n个反映了每个单元中第n个数据的索引和属性，比如
data
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">55.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">85.8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Cathy'</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">68.0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
data<span class="token punctuation">.</span>dtype
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'&lt;U10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span><span class="token string">'&lt;f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><code>np.dtype([(&#39;id&#39;,&#39;i8&#39;),(&#39;mat&#39;,&#39;f8&#39;,(3,3))])这样就定义了一个id和3x3矩阵的结构</code>由于numpy中的dtype直接映射到C结构定义，包含数组内容的缓存可以直接在C程序里使用，如果想写一个python接口与一个遗留的C\Fortran接口交互，非常有用</p>
<p>如果需要使用结构化数组，更好是掌握pandas包。</p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>Pandas是在Numpy基础上建立的新程序库，提供了一种高效的DataFrame结构。</p>
<p>DataFrame本质上是一种<u>带行标签和列标签、支持相同类型数据和缺失值的</u>多维数组。</p>
<p>Pandas不仅为各种带标签的数据提供了便利的存储界面，还实现了许多强大的操作，这些操作对数据库框架和电子表格程序的用户来说非常熟悉</p>
<p>当我们需要处理更灵活的数据任务（为数据添加标签，处理缺失值），或者需要分组数据计算，Numpy就会显露出限制，而Pandas为“数据清理”（data munging）任务提供了捷径</p>
<h2 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h2><p>如果从底层视角观察pandas对象，可以看成是增强版的Numpy结构化数组，行列不再是简单的整数索引，还可以带上标签！要理解基本数据结构内部的细节！</p>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>带索引数据的一维数组</p>
<p>可以用<strong>数组</strong>创建Series对象 data = pd.Series([0.25,0.5,0.75,1.0])</p>
<p>values属性返回Numpy数组的对象</p>
<p>index返回一个类型为pd.Index的类数组对象，后续介绍</p>
<p>name属性会作为dataframe的列标签</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
Darren     <span class="token number">21</span>
Jack       <span class="token number">37</span>
Jessica    <span class="token number">56</span>
Name<span class="token punctuation">:</span> one<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32

In <span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name
Out<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'one'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>Series比它模仿的一维Numpy数组更加通用，灵活！！</strong></p>
<p>本质差别在索引</p>
<p>Numpy数组用的是隐式定义的索引，Series是显式定义，索引完全可以是任意类型，不按顺序</p>
<p>pd.Series([2,2,22,],index = [‘a’,’c’,’d’])</p>
<p>字典将任意键映射到一组任意值，Series将类型键映射到一组类型值，</p>
<p>Pandas Series的类型信息使得她在某些操作上<u>比Python的字典更高效</u></p>
<p>可以用<strong>字典</strong>创建一个Series对象</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'dadaa'</span><span class="token punctuation">:</span> <span class="token number">1223</span><span class="token punctuation">,</span> <span class="token string">'tda'</span><span class="token punctuation">:</span> <span class="token number">12124</span><span class="token punctuation">,</span> <span class="token string">'dada'</span><span class="token punctuation">:</span> <span class="token number">341</span><span class="token punctuation">&#125;</span>
dict2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">)</span>
dict2
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
dadaa     <span class="token number">1223</span>
tda      <span class="token number">12124</span>
dada       <span class="token number">341</span>
dtype<span class="token punctuation">:</span> int64
<span class="token comment">#用字典创建对象时，索引按照排序好的默认顺序排列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Series支持索引切片！</p>
<p>dict2[‘dadaa’:’dada’] </p>
<p>在pd.Series(data,index = index)中，data若是标量，则会填充到每一项上</p>
<p>索引默认0-n整数序列，RangeIndex（start = 0, stop = n, step = 1）</p>
<p>data可以是列表，字典（index是默认的排序字典键,也就是先会按照默认方式排序一遍）</p>
<p>每种类型都可以通过<strong>显式指定索引筛选</strong>需要的结果：<strong>但是字典这样做只会保留显式定义的部分键值对！</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> b <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>a<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
ValueError                                Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">5bed21d603af</span><span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>a<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

D<span class="token punctuation">:</span>\Anaconda3\lib\site<span class="token operator">-</span>packages\pandas\core\series<span class="token punctuation">.</span>py <span class="token keyword">in</span> __init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> index<span class="token punctuation">,</span> dtype<span class="token punctuation">,</span> name<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> fastpath<span class="token punctuation">)</span>
    <span class="token number">348</span>                 <span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token number">349</span>                     <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">350</span>                         <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>
    <span class="token number">351</span>                             <span class="token string-interpolation"><span class="token string">f"Length of passed values is </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">, "</span></span>
    <span class="token number">352</span>                             <span class="token string-interpolation"><span class="token string">f"index implies </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">len</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">."</span></span>

ValueError<span class="token punctuation">:</span> Length of passed values <span class="token keyword">is</span> <span class="token number">5</span><span class="token punctuation">,</span> index implies <span class="token number">3</span><span class="token punctuation">.</span>
    <span class="token comment">#当列表的时候index和data长度需一致</span>

In <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>b<span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a1
Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
a    <span class="token number">4</span>
c    <span class="token number">7</span>
dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>和Series一样，它也既可以作为一个通用型Numpy数组，也可以看作特殊的Python字典</p>
<p>可以看成一种既有灵活行索引，又有灵活列名的<strong>二维数组</strong></p>
<p>可以看成有序排列的若干Series对象。这里的“排列”指的是它们拥有共同的索引</p>
<p>假设a，b是两个Series对象，而且拥有相同的索引，那么可以</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'column1'</span><span class="token punctuation">:</span>a<span class="token punctuation">,</span><span class="token string">'column2'</span><span class="token punctuation">:</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">#其中a和b为长度一样的Series对象</span>
c
			column1   column2
index1      <span class="token number">32423</span>     <span class="token number">32423</span>
index2      <span class="token number">2189</span>      <span class="token number">2198128</span>
index       <span class="token number">312312</span>    <span class="token number">21312</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>DataFrame的index属性和Series一样，返回Index对象（如果是默认生成的，则是RangeIndex）</p>
<p>还有个columns属性，也返回Index对象，不过是每列的标签</p>
<p>DataFrame可看成特殊的字典，每列映射一个Series数据，通过列索引c[‘column1’]可以得到该Series对象</p>
<hr>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a><strong>创建</strong></h4><p>ps：创建字典</p>
<ol>
<li><p>使用dict() 函数创建一个空字典并给变量赋值</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160413.png"  style="zoom:50%;" />

<p><strong>第二种方法应该是大规模处理中用的多的</strong></p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210706160432.png"  style="zoom:50%;" /></li>
</ol>
<p>创建<strong>DataFrame</strong></p>
<p>（1）可以用单个Series对象</p>
<p>pd.DataFrame(populations,columns = [‘population’])</p>
<p>（2）可以用<strong>元素是字典的列表</strong>来创建,若是字典有一些键(作为列索引)不在，会用NaN补全</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span>i<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
data
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>
    
pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
   a  b
<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>
<span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">2</span>
<span class="token number">2</span>  <span class="token number">2</span>  <span class="token number">4</span>

pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
     a  b    c
<span class="token number">0</span>  <span class="token number">1.0</span>  <span class="token number">2</span>  NaN
<span class="token number">1</span>  NaN  <span class="token number">3</span>  <span class="token number">4.0</span>
<span class="token comment">#这里的例子都是用默认Index</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（3）通过<strong>Series对象、列表字典</strong>创建</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">c <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'column1'</span><span class="token punctuation">:</span>a<span class="token punctuation">,</span><span class="token string">'column2'</span><span class="token punctuation">:</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
c
			column1   column2
index1      <span class="token number">32423</span>     <span class="token number">32423</span>
index2      <span class="token number">2189</span>      <span class="token number">2198128</span>
index       <span class="token number">312312</span>    <span class="token number">21312</span>
如果值是列表，索引是默认的<span class="token number">0</span>，<span class="token number">1</span>，<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(4)通过Numpy二维数组创建。假如有二维数组，就可以创建一个可以指定行列索引值的DataFrame，如果不指定，那么行列都是默认索引  IndexRange</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span><span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
        foo       bar
a  <span class="token number">0.855538</span>  <span class="token number">0.595667</span>
b  <span class="token number">0.575162</span>  <span class="token number">0.149108</span>
d  <span class="token number">0.034177</span>  <span class="token number">0.156297</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(5)通过Numpy结构化数组创建</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'i8'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A
Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'&lt;i8'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'&lt;f8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    
In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>A<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   A    B
<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0.0</span>
<span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">0.0</span>
<span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">0.0</span>
可以发现子结构的名字被作为了列标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>可以看成一个<strong>不可变数组</strong>或<strong>有序集合</strong>，可以包含重复值。这两种观点体现了其一些功能</p>
<ol>
<li><p>不可变数组</p>
<p>Index很多操作都像数组，比如切片，还有许多与Numpy数组相似的属性，比如</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ind <span class="token operator">=</span> pd<span class="token punctuation">.</span>Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> indOut<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Int64Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int64'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ind<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Int64Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int64'</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ind<span class="token punctuation">.</span>size<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>ndim<span class="token punctuation">,</span>ind<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token number">5</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token number">1</span> int64<span class="token comment">#这几个属性竟然还保留了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最大的不同在于<strong>Index对象的索引是不可变的</strong>，ind[1]=0会报错，这使得索引共享更安全</p>
</li>
<li><p>有序集合</p>
<p>Index遵循python标准库的集合（set）数据结构的许多惯用法 &amp; | ^ ~</p>
<p>indA &amp; indB 也有indA.intersection(indB)</p>
</li>
</ol>
<h2 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h2><p>类推Numpy的各种花式操作</p>
<h3 id="Series-1"><a href="#Series-1" class="headerlink" title="Series"></a>Series</h3><p>两个类比：<strong>一维Numpy数组和Python标准字典</strong>，很多操作是一样的。</p>
<p><strong>看作字典</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.75</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0.</span>5In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'a'</span> <span class="token keyword">in</span> dataOut<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> TrueIn <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#这个失败了</span>
In <span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>values
Out<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">0.5</span> <span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>keys
Out<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>bound method Series<span class="token punctuation">.</span>keys of a    <span class="token number">0.</span><span class="token number">25b</span>    <span class="token number">0.</span><span class="token number">50c</span>    <span class="token number">0.</span><span class="token number">75d</span>    <span class="token number">1.</span>00dtype<span class="token punctuation">:</span> float64<span class="token operator">></span>
In <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ata<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token builtin">zip</span> at <span class="token number">0x201ee3bbcc0</span><span class="token operator">></span>
In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.25</span>
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span>a    <span class="token number">0.</span><span class="token number">25b</span>    <span class="token number">0.</span><span class="token number">50c</span>    <span class="token number">0.</span><span class="token number">75d</span>    <span class="token number">1.</span><span class="token number">00e</span>    <span class="token number">1.</span>25dtype<span class="token punctuation">:</span> float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Series对象的可变性</strong>是一个非常方便的特性，pandas在底层已经为可能发生的<strong>内存布局和数据复制</strong>自动决策，用户不用担心。</p>
<p><strong>看作一维数组</strong></p>
<p>包括索引，掩码，花哨索引都有</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token comment">#显示索引包含最后一位Out[13]:a    0.25b    0.50c    0.75dtype: float64In [14]: data[0:2] #隐式索引不包含最后一位Out[14]:a    0.25b    0.50dtype: float64In [15]: data[(data>0.3) &amp; (data&lt;0.8)] #布尔索引yydsOut[15]:b    0.50c    0.75dtype: float64In [16]: data[['a','e']]#fancy indexOut[16]:a    0.25e    1.25dtype: float64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a><strong>索引器</strong></h4><p>切片和取值的习惯用法经常混乱，如果Series选了<strong>显式整数索引</strong>，那么data[1]这样取值会使用显式索引，而data[1:3]这样的切片操作却会使用隐式索引！</p>
<p>所以Pandas准备了一些索引器（indexer）来作为取值的方法</p>
<p>它们不是Series对象的方法，而是暴露切片接口的<strong>属性</strong></p>
<p><strong>loc属性</strong></p>
<p>表示使用显式切片和取值，<strong>左闭右闭！！</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'a'</span>
In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token number">1</span>    a
<span class="token number">3</span>    b
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>

    <span class="token comment">#不然的话默认是隐式的</span>
In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token number">3</span>    b
<span class="token number">5</span>    c
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同理，iloc 表示都是python形式的隐式索引，左闭右开</p>
<p>ix是前两者的混合，在Series对象中ix等价隐式，主要用于DataFrame。<strong>已经被弃用了</strong></p>
<p>Python的设计原则之一是“<strong>显式优于隐式</strong>”，loc和iloc让代码更容易维护。</p>
<h3 id="DataFrame-1"><a href="#DataFrame-1" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame有些方面像<strong>二维或结构化数组</strong>，有些方面又像一个<strong>共享索引的若干Series对象构成的字典</strong></p>
<p><strong>看作字典</strong></p>
<p>看作由若干Series对象组成的字典</p>
<p>比如 area 和 pop是索引一样的两个Series</p>
<p>data = pd.DataFrame({‘area’: area,’pop’: pop})来构建列索引为area和pop的数组</p>
<p>可以通过对列名进行字典形式取值，也可以用属性形式选择<strong>纯字符串列名</strong>的数据</p>
<p><code>data[&#39;area&#39;] is data.area True </code>都是选取同一个Series对象</p>
<p>但是如果<strong>列名不是纯字符串</strong>，或者<strong>列名与DataFrame的方法同名</strong>，那么就不能使用，比如pop方法</p>
<p>由此还要避免用data.pop = z 这种形式赋值，而要用 data[‘pop’] = z来赋值</p>
<p>和前面介绍的Series对象一样，还可以用字典形式的语法调整/增加对象，如果要增加一列可以这样：</p>
<p>data[‘c’] = data[‘a’]/data[‘b’] 顺便展示了两个Series对象算术运算的简便语法，(｡･∀･)ﾉﾞ嗨</p>
<hr>
<p><strong>看作二维数组</strong></p>
<p>可以看成是一个增强版的二维数组，用values属性按行查看数组数据(还记得Series是没有values属性的)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x
Out<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
          one      two
Darren    <span class="token number">123</span>   <span class="token number">123313</span>
Jack    <span class="token number">21212</span>  <span class="token number">2131132</span>

In <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>T
Out<span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     Darren     Jack
one     <span class="token number">123</span>    <span class="token number">21212</span>
two  <span class="token number">123313</span>  <span class="token number">2131132</span>

In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>values
Out<span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>    <span class="token number">123</span><span class="token punctuation">,</span>  <span class="token number">123313</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span>  <span class="token number">21212</span><span class="token punctuation">,</span> <span class="token number">2131132</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>items
Out<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token operator">&lt;</span>bound method DataFrame<span class="token punctuation">.</span>items of           one      two
Darren    <span class="token number">123</span>   <span class="token number">123313</span>
Jack    <span class="token number">21212</span>  <span class="token number">2131132</span><span class="token operator">></span>

In <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>columns <span class="token comment">#注意复数</span>
Out<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>index
Out<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>keys
Out<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token operator">&lt;</span>bound method NDFrame<span class="token punctuation">.</span>keys of           one      two
Darren    <span class="token number">123</span>   <span class="token number">123313</span>
Jack    <span class="token number">21212</span>  <span class="token number">2131132</span><span class="token operator">></span>

<span class="token comment">#因为索引被用在了列上，我们取行的能力收到了限制，x['one']可以取出一列</span>
x<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
Darren      <span class="token number">123</span>
Jack      <span class="token number">21212</span>
Name<span class="token punctuation">:</span> one<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32
<span class="token comment">#但是取行得用values属性</span>
x<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1213313</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>data.values，理解了”二维数组“这一点，就能引出很多骚操作：比如data.T转置</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#可以用索引器来帮助进行索引</span>
<span class="token comment">#loc 和 iloc 处理起来就像处理二维数组一样，而且行列标签会自动保存在结果中</span>
<span class="token comment">#ix的规则是，既可以使用隐式也可以使用显式，但是在遇到整数索引时，规则和之前的Series一样混乱</span>
<span class="token comment">#其他用于索引的功能全都可以用于这些索引器</span>
data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">87</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token string">'Jessica'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
data
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
         one  two  three  four
Darren    <span class="token number">21</span>   <span class="token number">34</span>     <span class="token number">12</span>    <span class="token number">45</span>
Jack      <span class="token number">37</span>   <span class="token number">23</span>     <span class="token number">76</span>    <span class="token number">23</span>
Jessica   <span class="token number">56</span>   <span class="token number">98</span>     <span class="token number">34</span>    <span class="token number">87</span>

data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
      three
Jack     <span class="token number">76</span>

data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">:</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token string">'one'</span><span class="token punctuation">:</span><span class="token string">'three'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
        one  two  three
Darren   <span class="token number">21</span>   <span class="token number">34</span>     <span class="token number">12</span>
Jack     <span class="token number">37</span>   <span class="token number">23</span>     <span class="token number">76</span>
<span class="token comment">#任何用于处理Numpy形式的方法都可用于这些索引器比如掩码和花哨</span>
<span class="token comment">#结合使用来筛选一部分，先筛选行，再筛选列噢</span>
In <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>data<span class="token punctuation">.</span>one<span class="token operator">></span><span class="token number">22</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
         two  four
Jack      <span class="token number">23</span>    <span class="token number">23</span>
Jessica   <span class="token number">98</span>    <span class="token number">87</span>
<span class="token comment">#记住一定要加loc索引器，不然报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p><strong>其他的取值方法</strong></p>
<p>有点奇怪但是很好用。对单个标签取值就是选择列，对<strong>多个标签</strong>用切片就选择行</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">#隐式切片Out[21]:          one  two  three  fourJack      37   23     76    23Jessica   56   98     34    87data['Darren':'Jessica'] #显式切片Out[22]:          one  two  three  fourDarren    21   34     12    45Jack      37   23     76    23Jessica   56   98     34    87data['two']Out[23]: Darren     34Jack       23Jessica    98Name: two, dtype: int32#掩码操作起到筛选某些 行 的作用data[data.three>20]Out[24]:          one  two  three  fourJack      37   23     76    23Jessica   56   98     34    87# 这两种操作方法其实和Numpy数组的语法类似，虽然它们与Pandas的操作习惯不太一致，但是非常好用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><p>Pandas继承了Numpy的功能，可以对元素进行快速运算</p>
<p>但是Pandas实现了一些高效的技巧：</p>
<ol>
<li>对于一元计算，通用函数在输出结果中<u>保留索引和列标签。</u></li>
<li>对于二元计算，Pandas在传递通用函数时会<strong>自动对齐索引</strong>进行计算</li>
</ol>
<p><strong>这意味着：保存数据内容  组合不同来源的数据  这两处在Numpy里容易出错的地方，成了Pandas杀手锏</strong></p>
<p>ps：补充一下伪随机数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span>这个设置的是全局随机数种子rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment">#设置单独的随机数种子</span>
arr <span class="token operator">=</span> rng<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">#这样生成的就是独立的</span>
seedpermutation<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">#返回一个序列的随机排列</span>
shuffle <span class="token comment"># 随机排列一个序列,直接更改原来的</span>
rand <span class="token comment">#从均匀分布[0,1)中抽取样本</span>
uniform <span class="token comment">#选定区间【】均匀分布</span>
randint <span class="token comment">#根据给定的从低到高（左闭右开，左边省略为0）的范围抽取随机一个整数，如果给一个元组，则在0-元组每一项之间取，输出一个列表</span>
randn <span class="token comment">#从均值0方差1的正态分布</span>
normal<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#平均值，标准差，</span>
shapebinomial <span class="token comment">#从二项分布中抽取样本</span>
beta <span class="token comment">#从beta分布中抽取样本</span>
chisquare <span class="token comment">#从卡方分布中抽取样本uniform(x1,x2,(shape)) #从均匀分布中抽取样本</span>
gamma <span class="token comment">#从伽马分布中抽取样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="索引对齐"><a href="#索引对齐" class="headerlink" title="索引对齐"></a>索引对齐</h3><p><strong>当在两个Series或DataFrame对象上进行二元计算时，Pandas会在计算过程中对齐两个对象的索引，在处理不完整的数据时，这一点非常方便</strong></p>
<p>结果数组的索引是两个输入数组索引的<strong>并集</strong>，缺失位置填充NaN，这是通过python内置集合运算规则实现的</p>
<p>我们也可以通过a.index | b.index 来获得这个新索引</p>
<p>两个对象的行列顺序可以是不一样的，结果的索引会<strong>自动排序</strong></p>
<p>当然也能自行设置缺失值，A.add(B,fill_value = 0) 这样会相加A和B并用0来填充</p>
<p>对于DataFrame其实大同小异：(下面有一些骚操作)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">:</span> rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'AB'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">:</span> B <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'BAC'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A
Out<span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    A   B
<span class="token number">0</span>   <span class="token number">6</span>  <span class="token number">19</span>
<span class="token number">1</span>  <span class="token number">14</span>  <span class="token number">10</span>

In <span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span> B
Out<span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   B  A  C
<span class="token number">0</span>  <span class="token number">7</span>  <span class="token number">4</span>  <span class="token number">6</span>
<span class="token number">1</span>  <span class="token number">9</span>  <span class="token number">2</span>  <span class="token number">6</span>
<span class="token number">2</span>  <span class="token number">7</span>  <span class="token number">4</span>  <span class="token number">3</span>

In <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span> A<span class="token operator">+</span>B
Out<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
      A     B   C
<span class="token number">0</span>  <span class="token number">10.0</span>  <span class="token number">26.0</span> NaN
<span class="token number">1</span>  <span class="token number">16.0</span>  <span class="token number">19.0</span> NaN
<span class="token number">2</span>   NaN   NaN NaN
<span class="token comment">#如果想要设置fill_value得用A.add(B,fill_value = x)</span>
python运算符   映射  Pandas方法
<span class="token operator">+</span>     add
<span class="token operator">-</span>     sub
<span class="token operator">*</span>     mul
<span class="token operator">/</span>     div
<span class="token operator">//</span>    floordiv
<span class="token operator">%</span>     mod
<span class="token operator">**</span>    <span class="token builtin">pow</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<p><strong>DataFrame和Series的混合运算</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df
Out<span class="token punctuation">[</span><span class="token number">66</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   Q  R  S  T
<span class="token number">0</span>  <span class="token number">7</span>  <span class="token number">7</span>  <span class="token number">2</span>  <span class="token number">5</span>
<span class="token number">1</span>  <span class="token number">4</span>  <span class="token number">1</span>  <span class="token number">7</span>  <span class="token number">5</span>
<span class="token number">2</span>  <span class="token number">1</span>  <span class="token number">4</span>  <span class="token number">0</span>  <span class="token number">9</span>

<span class="token comment">#df.iloc[0]选取的是第一列，有点类似广播，默认是按行计算！</span>
In <span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> df<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">67</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   Q  R  S  T
<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>
<span class="token number">1</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">-</span><span class="token number">6</span>  <span class="token number">5</span>  <span class="token number">0</span>
<span class="token number">2</span> <span class="token operator">-</span><span class="token number">6</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">-</span><span class="token number">2</span>  <span class="token number">4</span>

<span class="token comment">#按列计算就得调一下轴</span>
In <span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'R'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   Q  R  S  T
<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token operator">-</span><span class="token number">5</span> <span class="token operator">-</span><span class="token number">2</span>
<span class="token number">1</span>  <span class="token number">3</span>  <span class="token number">0</span>  <span class="token number">6</span>  <span class="token number">4</span>
<span class="token number">2</span> <span class="token operator">-</span><span class="token number">3</span>  <span class="token number">0</span> <span class="token operator">-</span><span class="token number">4</span>  <span class="token number">5</span>
<span class="token comment">#否则结果会很坑爹</span>
In <span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> df<span class="token punctuation">[</span><span class="token string">'R'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    Q   R   S   T   <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>
<span class="token number">0</span> NaN NaN NaN NaN NaN NaN NaN
<span class="token number">1</span> NaN NaN NaN NaN NaN NaN NaN
<span class="token number">2</span> NaN NaN NaN NaN NaN NaN NaN

<span class="token comment">#值得注意的是在二元运算中缺失的直接判定为NaN而不是不进行操作</span>
<span class="token comment">#还是得注意“按行操作”的含义。Series翻转成水平后的标签是否为dataframe的columns的子集</span>
In <span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">:</span> halfrow
Out<span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
Q    <span class="token number">7</span>
S    <span class="token number">2</span>
Name<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32

In <span class="token punctuation">[</span><span class="token number">71</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">-</span> halfrow
Out<span class="token punctuation">[</span><span class="token number">71</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     Q   R    S   T
<span class="token number">0</span>  <span class="token number">0.0</span> NaN  <span class="token number">0.0</span> NaN
<span class="token number">1</span> <span class="token operator">-</span><span class="token number">3.0</span> NaN  <span class="token number">5.0</span> NaN
<span class="token number">2</span> <span class="token operator">-</span><span class="token number">6.0</span> NaN <span class="token operator">-</span><span class="token number">2.0</span> NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>缺失值的问题十分普遍，处理不同数据源缺失值的方法不同</p>
<p>本节介绍一些处理缺失值的通用规则，Pandas对缺失值的表现形式，并演示Pandas自带的几个处理缺失值的工具</p>
<p>本书涉及的缺失值主要有三种形式：<strong>null 、NaN、 NA</strong></p>
<p>不愧是作者，列举了他在创建pandas时对于这个问题的看法，最终他选择了<strong>用标签方法表示缺失值</strong></p>
<p>这包括两种python原有的缺失值：浮点数据的NaN值，还有None对象</p>
<p>当然，Numpy支持掩码数据，Pandas也集成了这个功能，但由于存储、维护的资源浪费，并不可取</p>
<hr>
<p>P106</p>
<p><strong>None</strong></p>
<p>这是一个Python单体对象，不能作为任何Numpy/Pandas数组类型的缺失值，只能用于’object’数组类型</p>
<p>即由python对象构成的数组，dtype = object 就是这个意思。</p>
<p>这样的类型对数据的任何操作最终都会在python层面完成，进行常见快速操作时会消耗更多资源。</p>
<p>同时，python没有定义整数与None之间的加减运算，Sum和min（）这些都会出错。</p>
<p><strong>NaN</strong></p>
<p>这是一种按照IEEE浮点数标准设计，在任何系统中都兼容的<strong>特殊浮点数</strong>。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals1
Out<span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">object</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
In <span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span> vals2<span class="token punctuation">.</span>dtype
Out<span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dtype<span class="token punctuation">(</span><span class="token string">'float64'</span><span class="token punctuation">)</span><span class="token comment">#Numpy会自动为这个数组选择一个原生浮点类型，这意味着与object不同，该数组会被编译成C代码从而实现快速操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而且NaN无论进行何种操作，结果都是NaN，跟病毒一样。</p>
<p>但还记得Numpy提供了一些特殊的累计函数来规避NaN，np.nansum(vals2) == 8</p>
<p><strong>NA</strong></p>
<p>Pandas把NaN和None看作是可以等价交换的</p>
<p>Pandas会将没有标签的数据类型自动转换为NA，规则见P109</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存在缺失值时转换</th>
<th>NA标签值</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>无变化</td>
<td>np.nan</td>
</tr>
<tr>
<td>object</td>
<td>无变化</td>
<td>np.nan或None</td>
</tr>
<tr>
<td>integer</td>
<td>强制转换为float64</td>
<td>np.nan</td>
</tr>
<tr>
<td>boolean</td>
<td>强制转换为object</td>
<td>np.nan或None</td>
</tr>
</tbody></table>
<p>*Pandas中字符串类型的数据通常是用object类型存储的</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p><strong>发现缺失值</strong></p>
<p>isnull 和notnull 会返回布尔类型的掩码数组，以此可以直接用作索引</p>
<p><strong>剔除缺失值</strong></p>
<p>dropna </p>
<p>这两个操作在Series里没有什么问题</p>
<p>但在DataFrame中就需要注意，并没有办法单独剔除一个值，只能剔除缺失值所在整行或整列</p>
<p>dropna<strong>默认剔除整行</strong>（因为数据按行为一条），如果加参数df.dropna(axis = 1)或者axis = ‘columns’那就是整列，或者是“1”，但是有点诡异。</p>
<p>可以用how或参数设置阈值，默认是how =’any’，可以是all(必须整行、列都是缺失值才剔除)</p>
<p><u>thresh参数可以设置非缺失值的最小数量</u>，thresh = 3则正常数据&lt;3的行、列被剔除。</p>
<p><strong>填充缺失值</strong></p>
<p>fillna返回填充了缺失值后的数组副本</p>
<p>参数可以选择method = ‘ffill/bfill’ 用缺失值前/后的有效值来依次填充，也可以改axis来左右填充。</p>
<p>但是如果前面一直找不到有效值填充，那就还是缺失值。。。</p>
<h2 id="层级索引"><a href="#层级索引" class="headerlink" title="层级索引"></a>层级索引</h2><p>当我们遇到存储多维数据需求时，数据索引超过一两个键。</p>
<p>Pandas提供了Panel和Panel4D对象解决三维数据和四维数据。</p>
<p>这两种对象采用密集存储，在维度增加的情况下效率越来越低，作者更推荐层级索引</p>
<p>但更直观的形式是hierarchical indexing，层级索引，配合多个不同等级的以及索引一起用，将高维数组转换成类似一维和二维对象的形式。</p>
<p>P114有解释层级索引便利性的例子</p>
<h3 id="创建层级索引"><a href="#创建层级索引" class="headerlink" title="创建层级索引"></a>创建层级索引</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#最直接的方法是将index的参数设置为至少二维的索引数组</span>
In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>columns <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'data1'</span><span class="token punctuation">,</span><span class="token string">'data2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df
Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        data1     data2
a <span class="token number">1</span>  <span class="token number">0.290846</span>  <span class="token number">0.466652</span>
  <span class="token number">2</span>  <span class="token number">0.245400</span>  <span class="token number">0.860682</span>
b <span class="token number">1</span>  <span class="token number">0.697193</span>  <span class="token number">0.100121</span>
  <span class="token number">2</span>  <span class="token number">0.028793</span>  <span class="token number">0.633941</span>
    
<span class="token comment">#输出按照index顺序来，但是如果重复就会自动少显示，所以要手动确认哪个在前合适。</span>

In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>index
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
MultiIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
           <span class="token punctuation">)</span>
<span class="token comment">#index的类型变为了MultiIndex</span>


<span class="token comment">#第二种方法是把元组作为键的字典传递给Pandas</span>
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">32432</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">312312</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3241332</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3243252</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">32434532</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">3223432</span><span class="token punctuation">&#125;</span>

In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
a  <span class="token number">2000</span>       <span class="token number">32432</span>
   <span class="token number">2010</span>      <span class="token number">312312</span>
b  <span class="token number">2000</span>     <span class="token number">3241332</span>
   <span class="token number">2010</span>     <span class="token number">3243252</span>
c  <span class="token number">2000</span>    <span class="token number">32434532</span>
   <span class="token number">2010</span>     <span class="token number">3223432</span>
dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>unstack可以把一个多级索引的Series转化为DataFrame，而stack相反（用level来选择处理的层数）不过注意，unstack和stack默认竟然是后面那层，可以用level = 0 来选第一层。</p>
<p>注意DataFrame是用于二维的。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#显式创建MultiIndex也是很有用的#可以用不同等级的数组来创建In [17]: pd.MultiIndex.from_arrays([['a','a','b','b'],[1,2,1,2]])#可以用包含不同等级索引值的元组构成的列表来创建In [18]: pd.MultiIndex.from_tuples([('a',1),('a',2),('b',1),('b',2)])#可以用两个索引序列的笛卡尔积来创建（这个逻辑上妙一点）In [19]: pd.MultiIndex.from_product([['a','b'],[1,2]])#原有的levels和labels属性好像被删掉了？#可以加名字来方便管理In [29]: bOut[29]:a  2000       32432   2010      312312b  2000     3241332   2010     3243252c  2000    32434532   2010     3223432dtype: int64In [30]: b.index.names = ['owner','year']In [31]: bOut[31]:owner  yeara      2000       32432       2010      312312b      2000     3241332       2010     3243252c      2000    32434532       2010     3223432dtype: int64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#多级列索引</span>
In <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> index <span class="token operator">=</span> pd<span class="token punctuation">.</span>MultiIndex<span class="token punctuation">.</span>from_product<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">2014</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'year'</span><span class="token punctuation">,</span><span class="token string">'visit_time'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> columns <span class="token operator">=</span> pd<span class="token punctuation">.</span>MultiIndex<span class="token punctuation">.</span>from_product<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Bob'</span><span class="token punctuation">,</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'HR'</span><span class="token punctuation">,</span><span class="token string">'Temp'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#round是保留小数位，此处为1</span>

In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data
Out<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token punctuation">,</span>  <span class="token number">2.4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.1</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">1.6</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.3</span><span class="token punctuation">,</span>  <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">2.4</span><span class="token punctuation">,</span>  <span class="token number">0.9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1</span><span class="token punctuation">,</span>  <span class="token number">2.2</span><span class="token punctuation">,</span>  <span class="token number">0.1</span><span class="token punctuation">,</span>  <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*=</span><span class="token number">10</span>
In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token operator">+=</span><span class="token number">37</span>

In <span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span>index <span class="token operator">=</span> index<span class="token punctuation">,</span>columns <span class="token operator">=</span> columns<span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data
Out<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
name              Bob       Darren        Jack
<span class="token builtin">type</span>               HR  Temp     HR  Temp    HR  Temp
year visit_time
<span class="token number">2013</span> <span class="token number">1</span>           <span class="token number">30.0</span>  <span class="token number">37.0</span>   <span class="token number">29.0</span>  <span class="token number">36.1</span>  <span class="token number">37.0</span>  <span class="token number">39.4</span>
     <span class="token number">2</span>           <span class="token number">16.0</span>  <span class="token number">37.5</span>   <span class="token number">53.0</span>  <span class="token number">37.2</span>  <span class="token number">24.0</span>  <span class="token number">36.6</span>
<span class="token number">2014</span> <span class="token number">1</span>           <span class="token number">41.0</span>  <span class="token number">35.7</span>   <span class="token number">43.0</span>  <span class="token number">36.5</span>  <span class="token number">61.0</span>  <span class="token number">37.9</span>
     <span class="token number">2</span>           <span class="token number">36.0</span>  <span class="token number">39.2</span>   <span class="token number">38.0</span>  <span class="token number">37.9</span>  <span class="token number">28.0</span>  <span class="token number">35.6</span>

columns名字       多级columns
index名字          内容
多级index          内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="多级索引取值、切片"><a href="#多级索引取值、切片" class="headerlink" title="多级索引取值、切片"></a>多级索引取值、切片</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#Series</span>
In <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one
Out<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
year  visit_time
<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">53.0</span>
      <span class="token number">2</span>             <span class="token number">35.3</span>
<span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">34.0</span>
      <span class="token number">2</span>             <span class="token number">36.9</span>
dtype<span class="token punctuation">:</span> float64

<span class="token comment">#可以通过指定所有级别的索引值来获取单个元素</span>
In <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">53.0</span>

<span class="token comment">#也可以“局部取值”，取出来还是Series，不过貌似必须得从前到后</span>
In <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
visit_time
<span class="token number">1</span>    <span class="token number">53.0</span>
<span class="token number">2</span>    <span class="token number">35.3</span>
dtype<span class="token punctuation">:</span> float64

<span class="token comment">#切片类似</span>
In <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">:</span><span class="token number">2014</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
year  visit_time
<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">53.0</span>
      <span class="token number">2</span>             <span class="token number">35.3</span>
<span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">34.0</span>
      <span class="token number">2</span>             <span class="token number">36.9</span>
dtype<span class="token punctuation">:</span> float64

<span class="token comment">#巧妙</span>
In <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span> one<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
year
<span class="token number">2013</span>    <span class="token number">35.3</span>
<span class="token number">2014</span>    <span class="token number">36.9</span>
dtype<span class="token punctuation">:</span> float64
<span class="token comment">#布尔和花哨的使用方法类似，并无太大变化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#DateFrame</span>
单独取是列索引<span class="token punctuation">,</span>类似Series

In <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data
Out<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
name              Bob       Darren        Jack
<span class="token builtin">type</span>               HR  Temp     HR  Temp    HR  Temp
year visit_time
<span class="token number">2013</span> <span class="token number">1</span>           <span class="token number">53.0</span>  <span class="token number">35.3</span>   <span class="token number">34.0</span>  <span class="token number">36.9</span>  <span class="token number">37.0</span>  <span class="token number">37.0</span>
     <span class="token number">2</span>           <span class="token number">20.0</span>  <span class="token number">35.8</span>   <span class="token number">47.0</span>  <span class="token number">37.2</span>  <span class="token number">42.0</span>  <span class="token number">37.0</span>
<span class="token number">2014</span> <span class="token number">1</span>           <span class="token number">36.0</span>  <span class="token number">36.3</span>   <span class="token number">44.0</span>  <span class="token number">37.7</span>  <span class="token number">35.0</span>  <span class="token number">37.4</span>
     <span class="token number">2</span>           <span class="token number">28.0</span>  <span class="token number">37.4</span>   <span class="token number">32.0</span>  <span class="token number">33.7</span>  <span class="token number">40.0</span>  <span class="token number">38.0</span>

<span class="token comment">#对索引器来说，他们还是按照先行后列来操作，而且在loc和iloc中可以传递多个层级的索引元组，👇先取所有行，再对列进行层级索引，但在元组中使用切片会导致语法错误（不能确定范围），不是很方便</span>
In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token string">'Temp'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
year  visit_time
<span class="token number">2013</span>  <span class="token number">1</span>             <span class="token number">36.9</span>
      <span class="token number">2</span>             <span class="token number">37.2</span>
<span class="token number">2014</span>  <span class="token number">1</span>             <span class="token number">37.7</span>
      <span class="token number">2</span>             <span class="token number">33.7</span>
Name<span class="token punctuation">:</span> <span class="token punctuation">(</span>Darren<span class="token punctuation">,</span> Temp<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64 

<span class="token comment">#更好的方法时使用IndexSlice对象而不是python自带的slice函数，这样可以在内部使用切片</span>
In <span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span> health_data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>idx<span class="token punctuation">[</span><span class="token number">2013</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">[</span><span class="token string">'Darren'</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
name    <span class="token builtin">type</span>
Darren  HR      <span class="token number">47.0</span>
        Temp    <span class="token number">37.2</span>
Name<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">2013</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64
<span class="token comment">#ps：不要忘记使用loc，不然会报错而且错误贼长</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h3><p>局部切片和其他很多类似操作都要求<strong>MultiIndex的各级索引是有序</strong>的，否则大部分操作都会失败。</p>
<p>可以用data = data.sort_index() 或者<a href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index">data.sortlevel</a>()来搞定</p>
<p>sort_index有个参数ascending  True代表升序</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pop
Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span>California  <span class="token number">2000</span>    <span class="token number">3234234</span>            <span class="token number">2010</span>     324322NewYork     <span class="token number">2000</span>    <span class="token number">6434634</span>            <span class="token number">2010</span>      52364Texas       <span class="token number">2000</span>      <span class="token number">67573</span>            <span class="token number">2010</span>      43525dtype<span class="token punctuation">:</span> int32    <span class="token comment">#level设置转换的层数In [22]: stack = pop.unstack(level = 0)In [23]: stackOut[23]:      California  NewYork  Texas2000     3234234  6434634  675732010      324322    52364  43525In [24]: stack2 = pop.unstack(level = 1)In [25]: stack2Out[25]:               2000    2010California  3234234  324322NewYork     6434634   52364Texas         67573   43525In [26]: stack2.stack()Out[26]:California  2000    3234234            2010     324322NewYork     2000    6434634            2010      52364Texas       2000      67573            2010      43525dtype: int32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>在实践中处理数据集非常好用的方法：</p>
<p><strong>行列标签转换</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#reset_index可以生成一个DataFrame，之前的行索引将变成内容，行名变列名，可以指定name来设置原来内容的列名称</span>
In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pop<span class="token punctuation">.</span>index<span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">,</span><span class="token string">'year'</span><span class="token punctuation">]</span>

In <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pop<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'population'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        state  year  population
<span class="token number">0</span>  California  <span class="token number">2000</span>     <span class="token number">3234234</span>
<span class="token number">1</span>  California  <span class="token number">2010</span>      <span class="token number">324322</span>
<span class="token number">2</span>     NewYork  <span class="token number">2000</span>     <span class="token number">6434634</span>
<span class="token number">3</span>     NewYork  <span class="token number">2010</span>       <span class="token number">52364</span>
<span class="token number">4</span>       Texas  <span class="token number">2000</span>       <span class="token number">67573</span>
<span class="token number">5</span>       Texas  <span class="token number">2010</span>       <span class="token number">43525</span>

<span class="token comment">#反过来，也可以这样，将其中的几列变为行索引</span>
In <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> pop<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'population'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>set_index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">,</span><span class="token string">'year'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                 population
state      year
California <span class="token number">2000</span>     <span class="token number">3234234</span>
           <span class="token number">2010</span>      <span class="token number">324322</span>
NewYork    <span class="token number">2000</span>     <span class="token number">6434634</span>
           <span class="token number">2010</span>       <span class="token number">52364</span>
Texas      <span class="token number">2000</span>       <span class="token number">67573</span>
           <span class="token number">2010</span>       <span class="token number">43525</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="多级索引数据累计"><a href="#多级索引数据累计" class="headerlink" title="多级索引数据累计"></a>多级索引数据累计</h3><p>数据累计方法，如mean()、sum()、max()之类的，其实就是结合level参数，level取的是index的名字，表明保留该列、行，其他合并，通过axis表明沿行、列</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> pop<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>level <span class="token operator">=</span> <span class="token string">'state'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a
Out<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
state
California    <span class="token number">1779278</span>
NewYork       <span class="token number">3243499</span>
Texas           <span class="token number">55549</span>
dtype<span class="token punctuation">:</span> int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h2><p>这是非常有趣的事情，既包括简单拼接，也包括处理重叠片段，pandas提供了高效的函数</p>
<p><strong>concat 和 append</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

In <span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
AxisError                                 Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ipython<span class="token operator">-</span><span class="token builtin">input</span><span class="token operator">-</span><span class="token number">77</span><span class="token operator">-</span>cdd90a57a401<span class="token operator">></span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">1</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>x<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token operator">&lt;</span>__array_function__ internals<span class="token operator">></span> <span class="token keyword">in</span> concatenate<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

AxisError<span class="token punctuation">:</span> axis <span class="token number">1</span> <span class="token keyword">is</span> out of bounds <span class="token keyword">for</span> array of dimension <span class="token number">1</span>
<span class="token comment">#对于一维数组的concatenate好像是个特例。</span>

<span class="token comment">#pd.concat与np.concatenate语法类似，参数更多，功能更强</span>
DataFrame默认逐行合并<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>可以设置成axis <span class="token operator">=</span> <span class="token string">'col'</span><span class="token operator">/</span><span class="token number">1</span>
差异：
<span class="token number">1</span><span class="token punctuation">.</span> 索引重复，合并时保留哪怕是重复的索引
   可以设置verify_integrity <span class="token operator">=</span> <span class="token boolean">True</span> 来引发异常
   可以设置igonre_index <span class="token operator">=</span> <span class="token boolean">True</span> 会无视原有的索引，直接新建一个<span class="token number">0</span>，<span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">.</span>。。
   可以设置keys <span class="token operator">=</span> <span class="token punctuation">[</span>xxxx<span class="token punctuation">]</span>，keys会作为数据源的索引，就是高一层的多级索引。
<span class="token number">2</span><span class="token punctuation">.</span> 合并
   join <span class="token operator">=</span> <span class="token string">'outer'</span>取并集（默认），会出现NAN<span class="token punctuation">,</span>   inner 取交集
   join_axes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>xxx<span class="token punctuation">,</span>xx<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>直接确定结果使用的列名。

append语法方便<span class="token punctuation">:</span>df1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>df2<span class="token punctuation">)</span>，和pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">)</span>效果一样
但是不像原生的append可以直接更新原有对象，而是新建，所以效率不高，不如建立DF列表然后一次性concat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>merge(合并) and join(连接)</p>
<p>高性能的内存式数据连接是Pandas的卖点之一。</p>
<p><strong>关系代数</strong>是处理关系型数据的通用理论，绝大部分数据库的可用操作都以此为理论基础。</p>
<p>关系代数方法论的强大之处在于，它提出的若干简单操作规则经过组合就可以为任意数据集构建十分复杂的操作。Pandas 在 pd.merge() 函数与 Series 和 DataFrame 的 join() 方法里实现了这些基本操作规则。</p>
<h2 id="合并与链接"><a href="#合并与链接" class="headerlink" title="合并与链接"></a>合并与链接</h2><p>pd.merge() 函数实现了三种数据连接的类型：一对一、多对一和多对多。</p>
<p>一对一就是一对一呗。。merge至少要有一列是一样的</p>
<p>多对一连接是指，在需要连接的两个列中，有一列的值有重复。通过多对一连接获得的结果 DataFrame <strong>将会保留重复值</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910143623978.png" alt="image-20210910143623978"></p>
<p>在结果 DataFrame 中多了一个“supervisor”列，里面有些值会因为输入数据的对应关系而有所重复</p>
<p>多对多连接是个有点儿复杂的概念，不过也可以理解。如果左右两个输入的共同列都包含重复值，那么合并的结果就是一种多对多连接。来看下面的例子，里面有一个 DataFrame 显示不同岗位人员的一种或多种能力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910143833746.png" alt="image-20210910143833746"></p>
<p>真实数据集往往没有那么干净、整洁，下面介绍merge的一些功能。</p>
<h3 id="数据合并参数"><a href="#数据合并参数" class="headerlink" title="数据合并参数"></a>数据合并参数</h3><p>on = ‘列名’  两边都有的</p>
<p>left_on =  ‘’   right_on =  ‘’  分别指定左右的<strong>共同列作为键进行合并</strong></p>
<p>获取的结果中会有一个多余的列，可以通过 DataFrame 的 drop() 方法将这列去掉：</p>
<p><code>pd.merge(df1, df3, left_on=&quot;employee&quot;, right_on=&quot;name&quot;).drop(&#39;name&#39;, axis=1)</code>（drop的1是列）</p>
<p>除了合并列，你也可以把索引作为键来合并</p>
<p>left_index 和 right_index = True</p>
<p>也可以混合使用，<code>print(pd.merge(df1a, df3, left_index=True, right_on=&#39;name&#39;))</code></p>
<p>当然，这些参数都适用于多个索引和 / 或多个列名，函数接口非常简单，<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">点我</a></p>
<p>当一个值出现在一列，却没有出现在另一列时，就需要考虑<strong>集合操作规则</strong>了。</p>
<p>默认outer  还有inner  left   right  表示行保留哪一边输入列的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910145946446.png" alt="image-20210910145946446"></p>
<p><strong>重复列名</strong></p>
<p>由于输出结果中有两个重复的列名(这一列<strong>没有作为合并的键</strong>，所以多了一列)，因此 pd.merge() 函数会自动为它们增加后缀 _x 或 _y </p>
<p>可以通过 suffixes 参数自定义后缀名：pd.merge(df8, df9, on=”name”, suffixes=[“_L”, “_R”])</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911194551123.png" alt="image-20210911194551123"></p>
<p><strong>3.8的例子</strong>太秀了，好好看看</p>
<p>pd.any()它会检查每一列，然后用 列名  True/False 的格式一行一行打印出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911194705665.png" alt="image-20210911194705665"></p>
<p>pd.unique() 返回独一无二的。。就是集合嘛</p>
<p>pd.read_csv(‘xxxx.csv’) 通过csv文件生成DataFrame</p>
<p>pd.head() 查看前五行，tail查看后五行</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910152230379.png" alt="image-20210910152230379"></p>
<p>有点巧妙，行索引筛选哪些行的数据，列索引筛选state，然后unique一下，然后处理👇</p>
<p>merged.loc[merged[‘state/region’] == ‘PR’, ‘state’] = ‘Puerto Rico’<br>merged.loc[merged[‘state/region’] == ‘USA’, ‘state’] = ‘United States’</p>
<p>最巧妙的是随心所欲的操控数据，通过布尔索引和选出某列的某部分当新索引，完成神奇的工作。</p>
<p>pandas 中 inplace 参数 在很多函数 中 都会有，inplace = True：<strong>不创建新的对象，直接对原始对象进行修改；</strong></p>
<h2 id="累计与分组"><a href="#累计与分组" class="headerlink" title="累计与分组"></a>累计与分组</h2><p>在对较大的数据进行分析时，一项基本的工作就是有效的数据累计（summarization）：计算累计（aggregation）指标，如 sum() 、 mean() 、 median() 、 min() 和 max() </p>
<p>有一个非常方便的 describe() 方法可以计算每一列的若干常用统计值。让我们在行星数据上试验一下，首先丢弃有缺失值的行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154410670.png" alt="image-20210910154410670"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154441931.png" alt="image-20210910154441931"></p>
<p>但若想深入理解数据，仅仅依靠累计函数是远远不够的。数据累计的下一级别是 groupby操作，它可以让你  <u>快速、有效地计算数据各子集的累计值</u>。</p>
<h3 id="GroupBy：分割、应用和组合"><a href="#GroupBy：分割、应用和组合" class="headerlink" title="GroupBy：分割、应用和组合"></a>GroupBy：分割、应用和组合</h3><p>简单的累计方法可以让我们对数据集有一个笼统的认识，但是我们经常还需要对某些标签或索引的<strong>局部</strong>进行累计分析</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910154840571.png" alt="image-20210910154840571" style="zoom: 33%;" />

<p>• 分割步骤将 DataFrame 按照指定的键分割成若干组。<br>• 应用步骤对每个组应用函数，通常是累计、转换或过滤函数。<br>• 组合步骤将每一组的结果合并成一个输出数组。</p>
<p>虽然我们也可以通过前面介绍的一系列的掩码、累计与合并操作来实现，但是意识到<strong>中间分割过程不需要显式地暴露出来</strong>这一点十分重要。而且 GroupBy （经常）只需要一行代码，就可以计算每组的和、均值、计数、最小值以及其他累计值。 GroupBy 的用处就是<strong>将这些步骤进行抽象</strong>：<u>在底层解决所有难题</u>，用户不需要知道在底层如何计算，只要<strong>把操作看成一个整体就够了</strong>。</p>
<p>延迟计算：</p>
<p>groupby的返回值是一个 DataFrameGroupBy 对象。你可以将它看成是一种特殊形式的 DataFrame ，里面隐藏着若干组数据，但是在没有应用累计函数之前不会计算。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df
Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
  key  data
<span class="token number">0</span>   A     <span class="token number">0</span>
<span class="token number">1</span>   B     <span class="token number">1</span>
<span class="token number">2</span>   C     <span class="token number">2</span>
<span class="token number">3</span>   A     <span class="token number">3</span>
<span class="token number">4</span>   B     <span class="token number">4</span>
<span class="token number">5</span>   C     <span class="token number">5</span>

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>pandas<span class="token punctuation">.</span>core<span class="token punctuation">.</span>groupby<span class="token punctuation">.</span>generic<span class="token punctuation">.</span>DataFrameGroupBy <span class="token builtin">object</span> at <span class="token number">0x0000022CD3E6B088</span><span class="token operator">></span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     data
key
A       <span class="token number">3</span>
B       <span class="token number">5</span>
C       <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ol>
<li><p>支持按列取值，取出的对象叫SeriesGroupBy，也支持延迟计算</p>
</li>
<li><p>支持按组迭代，返回的每一组都是 Series 或 DataFrame </p>
<p>👇method取出的是索引，group取出的是DataFrame或Series</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210910161139054.png" alt="image-20210910161139054"></p>
<ol start="3">
<li>调用方法，让任何<strong>不由GroupBy对象直接实现的方法</strong>直接应用到每一组。👇这是因为Python类的魔力，继承。</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     data
key
A       <span class="token number">3</span>
B       <span class="token number">5</span>
C       <span class="token number">7</span>

In <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#这个方法本来是pd的，但是直接用在pdGrouoby上了</span>
Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
     data
    count mean      std  <span class="token builtin">min</span>   <span class="token number">25</span><span class="token operator">%</span>  <span class="token number">50</span><span class="token operator">%</span>   <span class="token number">75</span><span class="token operator">%</span>  <span class="token builtin">max</span>
key
A     <span class="token number">2.0</span>  <span class="token number">1.5</span>  <span class="token number">2.12132</span>  <span class="token number">0.0</span>  <span class="token number">0.75</span>  <span class="token number">1.5</span>  <span class="token number">2.25</span>  <span class="token number">3.0</span>
B     <span class="token number">2.0</span>  <span class="token number">2.5</span>  <span class="token number">2.12132</span>  <span class="token number">1.0</span>  <span class="token number">1.75</span>  <span class="token number">2.5</span>  <span class="token number">3.25</span>  <span class="token number">4.0</span>
C     <span class="token number">2.0</span>  <span class="token number">3.5</span>  <span class="token number">2.12132</span>  <span class="token number">2.0</span>  <span class="token number">2.75</span>  <span class="token number">3.5</span>  <span class="token number">4.25</span>  <span class="token number">5.0</span>

<span class="token comment">#unstack()是将列索引转换为行索引（成列的转换为成行的？）</span>
<span class="token comment">#但是注意，默认是准换到靠近数据的那一层。</span>
<span class="token comment">#而且如果没有行索引了，会自动颠倒，就像下面这个一样。</span>
In <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unstack<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
             key
data  count  A      <span class="token number">2.00000</span>
             B      <span class="token number">2.00000</span>
             C      <span class="token number">2.00000</span>
      mean   A      <span class="token number">1.50000</span>
             B      <span class="token number">2.50000</span>
             C      <span class="token number">3.50000</span>
      std    A      <span class="token number">2.12132</span>
             B      <span class="token number">2.12132</span>
             C      <span class="token number">2.12132</span>
      <span class="token builtin">min</span>    A      <span class="token number">0.00000</span>
             B      <span class="token number">1.00000</span>
             C      <span class="token number">2.00000</span>
      <span class="token number">25</span><span class="token operator">%</span>    A      <span class="token number">0.75000</span>
             B      <span class="token number">1.75000</span>
             C      <span class="token number">2.75000</span>
      <span class="token number">50</span><span class="token operator">%</span>    A      <span class="token number">1.50000</span>
             B      <span class="token number">2.50000</span>
             C      <span class="token number">3.50000</span>
      <span class="token number">75</span><span class="token operator">%</span>    A      <span class="token number">2.25000</span>
             B      <span class="token number">3.25000</span>
             C      <span class="token number">4.25000</span>
      <span class="token builtin">max</span>    A      <span class="token number">3.00000</span>
             B      <span class="token number">4.00000</span>
             C      <span class="token number">5.00000</span>
dtype<span class="token punctuation">:</span> float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p><strong>累计</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df
Out<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
  key  data1  data2
<span class="token number">0</span>   A      <span class="token number">0</span>      <span class="token number">3</span>
<span class="token number">1</span>   B      <span class="token number">1</span>      <span class="token number">9</span>
<span class="token number">2</span>   C      <span class="token number">2</span>      <span class="token number">8</span>
<span class="token number">3</span>   A      <span class="token number">3</span>      <span class="token number">8</span>
<span class="token number">4</span>   B      <span class="token number">4</span>      <span class="token number">5</span>
<span class="token number">5</span>   C      <span class="token number">5</span>      <span class="token number">4</span>

In <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'min'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>median<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    data1            data2
      <span class="token builtin">min</span> median <span class="token builtin">max</span>   <span class="token builtin">min</span> median <span class="token builtin">max</span>
key
A       <span class="token number">0</span>    <span class="token number">1.5</span>   <span class="token number">3</span>     <span class="token number">3</span>    <span class="token number">5.5</span>   <span class="token number">8</span>
B       <span class="token number">1</span>    <span class="token number">2.5</span>   <span class="token number">4</span>     <span class="token number">5</span>    <span class="token number">7.0</span>   <span class="token number">9</span>
C       <span class="token number">2</span>    <span class="token number">3.5</span>   <span class="token number">5</span>     <span class="token number">4</span>    <span class="token number">6.0</span>   <span class="token number">8</span>
<span class="token comment">#支持字符串、函数或函数列表</span>

<span class="token comment">#也可以通过python字典指定不同列需要的函数</span>
In <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'data1'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'min'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>median<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">^</span>M
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span> <span class="token string">'data2'</span><span class="token punctuation">:</span> <span class="token string">'max'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    data1        data2
      <span class="token builtin">min</span> median   <span class="token builtin">max</span>
key
A       <span class="token number">0</span>    <span class="token number">1.5</span>     <span class="token number">8</span>
B       <span class="token number">1</span>    <span class="token number">2.5</span>     <span class="token number">9</span>
C       <span class="token number">2</span>    <span class="token number">3.5</span>     <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>过滤</strong></p>
<p>过滤操作可以让你按照分组的属性丢弃若干数据。例如，我们可能只需要保留标准差超过某个阈值的组</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filter_func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token string">'data2'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span>
df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>filter_func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>转换</strong></p>
<p>累计操作返回的是对组内全量数据缩减过的结果，而转换操作会返回一个新的全量数据。数据经过转换之后，其形状与原来的输入数据是一样的，而</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transform<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">-</span> x<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
   data1  data2
<span class="token number">0</span>   <span class="token operator">-</span><span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.5</span>
<span class="token number">1</span>   <span class="token operator">-</span><span class="token number">1.5</span>    <span class="token number">2.0</span>
<span class="token number">2</span>   <span class="token operator">-</span><span class="token number">1.5</span>    <span class="token number">2.0</span>
<span class="token number">3</span>    <span class="token number">1.5</span>    <span class="token number">2.5</span>
<span class="token number">4</span>    <span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.0</span>
<span class="token number">5</span>    <span class="token number">1.5</span>   <span class="token operator">-</span><span class="token number">2.0</span>
<span class="token comment">#注意key那个标签没了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>apply（）方法</strong></p>
<p> apply() 方法让你可以在每个组上应用任意方法。这个<strong>函数输入一个DataFrame</strong> ，<u>返回一个 Pandas 对象（ DataFrame 或 Series ）或一个标量（scalar，单个数值）</u>。组合操作会适应返回结果类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911200326500.png" alt="image-20210911200326500"></p>
<h4 id="分组方法"><a href="#分组方法" class="headerlink" title="分组方法"></a>分组方法</h4><p>前面的简单例子一直在用列名分割 DataFrame 。这只是众多分组操作中的一种，下面将继续介绍更多的分组方法。</p>
<ol>
<li><p>将列表、数组、Series 或索引作为分组键（长度与 DataFrame 匹配）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911200714468.png" alt="image-20210911200714468"></p>
<p>这个就是用索引</p>
</li>
<li><p>用字典或 Series 将索引映射到分组名称</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2
Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
     data1  data2
key
A        <span class="token number">0</span>      <span class="token number">5</span>
B        <span class="token number">1</span>      <span class="token number">0</span>
C        <span class="token number">2</span>      <span class="token number">3</span>
A        <span class="token number">3</span>      <span class="token number">3</span>
B        <span class="token number">4</span>      <span class="token number">7</span>
C        <span class="token number">5</span>      <span class="token number">9</span>

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> mapping
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token string">'vowel'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token string">'consonant'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token string">'consonant'</span><span class="token punctuation">&#125;</span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token comment">#索引指代被操作的对象的分组依据。</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
A        vowel
B    consonant
C    consonant
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>

    <span class="token comment">#这里的映射后后面的哪个aggfunc不太一样</span>
In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
           data1  data2
consonant     <span class="token number">12</span>     <span class="token number">19</span>
vowel          <span class="token number">3</span>      <span class="token number">8</span>

In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> df2<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span>pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
           data1  data2
consonant     <span class="token number">12</span>     <span class="token number">19</span>
vowel          <span class="token number">3</span>      <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>任意 Python 函数。你可以将任意 Python 函数传入 groupby ，函数映射到索引，然后新的分组输出</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911201638120.png" alt="image-20210911201638120"></p>
<p>我才发现，str list这些原来是顶层对象，也有一般实例的方法，比如list.append是存在的。</p>
</li>
<li><p>此外，任意之前有效的键都可以组合起来进行分组，从而返回一个<strong>多级索引</strong>的分组结果</p>
<p>而且好像是按列表順序組合多級索引的。</p>
<p>mapping = {‘A’: ‘vowel’, ‘B’: ‘consonant’, ‘C’: ‘consonant’}</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911202123221.png" alt="image-20210911202123221"></p>
<p>pd.astype(str) #强制转换数据类型。</p>
</li>
</ol>
<h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><p>我们已经介绍过 GroupBy 抽象类是如何探索数据集内部的关联性的了。</p>
<p>数据透视表（pivot table）是一种类似的操作方法，常见于 Excel 与类似的表格应用中。</p>
<p>数据透视表更像是一种多维的 GroupBy 累计操作。也就是说，虽然你也可以分割 - 应用 - 组合，但是分割与组合不是发生在一维索引上，而是在二维网格上（行列同时分组）。</p>
<p>import seaborn as sns<br>titanic = sns.load_dataset(‘titanic’)    #翻墙可以下到</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#关于显示的设定</span>
<span class="token comment"># 显示所有列</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">#最多显示5列</span>
<span class="token comment"># 显示所有行</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_rows'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_rows'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#最多显示10行</span>
<span class="token comment">#显示小数位数</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.float_format'</span><span class="token punctuation">,</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">'%.2f'</span><span class="token operator">%</span>x<span class="token punctuation">)</span> <span class="token comment">#两位</span>
<span class="token comment">#显示宽度</span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.width'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#这是以前的做法，不过注意，分组的时候是不是列表也会有影响。</span>
titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
sex
female    <span class="token number">0.742038</span>
male      <span class="token number">0.188908</span>
Name<span class="token punctuation">:</span> survived<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64
        
titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
        survived
sex             
female  <span class="token number">0.742038</span>
male    <span class="token number">0.188908</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>虽然这样就可以更清晰地观察乘客性别、船舱等级对其是否生还的影响，但是代码看上去有点 <strong>复杂</strong>。尽管这个管道命令的每一步都是前面介绍过的，但是要理解这个长长的语句可不是那么容易的事，这个适合就到数据透视表出场的时候了。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">titanic<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'survived'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token string">'mean'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unstack<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#还是强调一点就是unstack他首先解压的是最后面的那一列，也就是这里的‘class’</span>
Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token keyword">class</span>      <span class="token class-name">First</span>    Second     Third
sex                                 
female  <span class="token number">0.968085</span>  <span class="token number">0.921053</span>  <span class="token number">0.500000</span>
male    <span class="token number">0.368852</span>  <span class="token number">0.157407</span>  <span class="token number">0.135447</span>

<span class="token comment">#对比一下</span>
titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token string">'sex'</span><span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token string">'class'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token keyword">class</span>      <span class="token class-name">First</span>    Second     Third
sex                                 
female  <span class="token number">0.968085</span>  <span class="token number">0.921053</span>  <span class="token number">0.500000</span>
male    <span class="token number">0.368852</span>  <span class="token number">0.157407</span>  <span class="token number">0.135447</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这行代码可读性更强，而且取得的结果也一样。</p>
<p><strong>多级数据透视表</strong></p>
<p>这里面有一个cut函数，可以将数据分段并用相应的数据段来替代，不过左开右闭。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">age <span class="token operator">=</span> pd<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>titanic<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
age
Out<span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">1</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">2</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">3</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">4</span>      <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     
<span class="token number">886</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">887</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">888</span>             NaN
<span class="token number">889</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
<span class="token number">890</span>    <span class="token punctuation">(</span><span class="token number">18.0</span><span class="token punctuation">,</span> <span class="token number">80.0</span><span class="token punctuation">]</span>
Name<span class="token punctuation">:</span> age<span class="token punctuation">,</span> Length<span class="token punctuation">:</span> <span class="token number">891</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> category
Categories <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> interval<span class="token punctuation">[</span>int64<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                                             
<span class="token comment">#然后就可以</span>
titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token keyword">class</span>               <span class="token class-name">First</span>    Second     Third
sex    age                                   
female <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>   <span class="token number">0.909091</span>  <span class="token number">1.000000</span>  <span class="token number">0.511628</span>
       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>  <span class="token number">0.972973</span>  <span class="token number">0.900000</span>  <span class="token number">0.423729</span>
male   <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>   <span class="token number">0.800000</span>  <span class="token number">0.600000</span>  <span class="token number">0.215686</span>
       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>  <span class="token number">0.375000</span>  <span class="token number">0.071429</span>  <span class="token number">0.133663</span>
<span class="token comment">#这里可以猜出来，第一个选的是数据，第二个是索引，第三个就是列。</span>
<span class="token comment">#但是这里自动求了个平均（后面讲）</span>
        
<span class="token comment">#这里又引出另一个分箱函数，按照分位数（默认等于2）来进行分箱</span>
fare <span class="token operator">=</span> pd<span class="token punctuation">.</span>qcut<span class="token punctuation">(</span>titanic<span class="token punctuation">[</span><span class="token string">'fare'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
fare
Out<span class="token punctuation">[</span><span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>
<span class="token number">1</span>      <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>
<span class="token number">2</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>
<span class="token number">3</span>      <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>
<span class="token number">4</span>       <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        
<span class="token number">886</span>     <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>
<span class="token number">887</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>
<span class="token number">888</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>
<span class="token number">889</span>    <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>
<span class="token number">890</span>     <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>
Name<span class="token punctuation">:</span> fare<span class="token punctuation">,</span> Length<span class="token punctuation">:</span> <span class="token number">891</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> category
Categories <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> interval<span class="token punctuation">[</span>float64<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment">#感觉这个函数比前面那个groupby清楚啊                                            </span>
pd<span class="token punctuation">.</span>set_option<span class="token punctuation">(</span><span class="token string">'display.max_columns'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
titanic<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span><span class="token string">'survived'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'sex'</span><span class="token punctuation">,</span> age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fare<span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
fare            <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">14.454</span><span class="token punctuation">]</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">14.454</span><span class="token punctuation">,</span> <span class="token number">512.329</span><span class="token punctuation">]</span>          
<span class="token keyword">class</span>                      <span class="token class-name">First</span>    Second  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            Second     Third
sex    age                                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                            
female <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>               NaN  <span class="token number">1.000000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">1.000000</span>  <span class="token number">0.318182</span>
       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>              NaN  <span class="token number">0.880000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.914286</span>  <span class="token number">0.391304</span>
male   <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>               NaN  <span class="token number">0.000000</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.818182</span>  <span class="token number">0.178571</span>
       <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span>              <span class="token number">0.0</span>  <span class="token number">0.098039</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token number">0.030303</span>  <span class="token number">0.192308</span>
<span class="token punctuation">[</span><span class="token number">4</span> rows x <span class="token number">6</span> columns<span class="token punctuation">]</span>
<span class="token comment">#结果是一个四位索引。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>其他的一些选项</strong></p>
<p> <strong>fill_value 和 dropna</strong> 这两个参数用于处理缺失值，用法很简单，我们将在后面的示例中演示其用法。</p>
<p><strong>aggfunc</strong> 参数用于设置累计函数类型，默认值是均值（ mean ），可以用一些常见的字符串（ ‘sum’ 、 ‘mean’ 、 ‘count’ 、 ‘min’ 、 ‘max’ 等）表示，也可以用标准的累计函数（ np.sum() 、 min() 、 sum() 等）表示。</p>
<p>也可以用字典为不同的列指定不同的累计函数，函数列表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911224133020.png" alt="image-20210911224133020"></p>
<p>这个函数和groupby的分组不太一样。但是思想类似。</p>
<p>不过上面的是以索引形式，这个是更高level的columns。</p>
<p>这里忽略了一个参数 values 。当我们为 aggfunc 指定映射关系的时候，待透视的数值就已经确定了。</p>
<p><strong>margins</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911224450628.png" alt="image-20210911224450628"></p>
<p> margin 的标签可以通过 margins_name 参数进行自定义，默认值是 “<strong>All</strong>“ 。</p>
<p>3.10.4 <strong>美国人口</strong></p>
<p>使用%matplotlib后，可以直接在生成的pivot_table后加.plot()来生成图表！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210911235307984.png" alt="image-20210911235307984"></p>
<p>到时候回来再看看吧。。</p>
<h2 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h2><p>使用 Python 的一个优势就是<strong>字符串处理起来比较容易</strong>。在此基础上创建的 Pandas 同样提供了一系列 向量化字符串操作（vectorized string operation），它们都是在处理（清洗）现实工作中的数据时不可或缺的功能</p>
<p>假如数据中出现了缺失值，那么很多时候就会引起异常</p>
<p>Pandas 为包含字符串的 Series 和 Index 对象提供的 <strong>str 属性</strong> 堪称两全其美的方法，它既<br>可以满足向量化字符串操作的需求，又可以<strong>正确地处理缺失值</strong>。例如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">names
Out<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>    peter
<span class="token number">1</span>     Paul
<span class="token number">2</span>     <span class="token boolean">None</span>
<span class="token number">3</span>     MARY
<span class="token number">4</span>    gUIDO
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>
    
names<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>    Peter
<span class="token number">1</span>     Paul
<span class="token number">2</span>     <span class="token boolean">None</span>
<span class="token number">3</span>     Mary
<span class="token number">4</span>    Guido
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>
<span class="token comment">#None这个缺失值被跳过了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>包括了python，re模块，和自带的方法</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210912004551786.png" alt="image-20210912004551786"></p>
<p>但是有些方法返回数值，比如len</p>
<p>有些方法返回布尔值，比如startwith</p>
<p>还有些方法返回列表或其他复合值</p>
<p>在接下来的内容中，我们将进一步学习这类由列表元素构成的 Series <strong>（series-of-lists）</strong>对象。</p>
<p><strong>正则化方法</strong></p>
<p>更好的是，str同样支持一些<strong>正则化方法</strong>，采用re模块的语法，太方便了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912102710571.png" alt="image-20210912102710571"></p>
<p>里面<strong>参数就填正则化式子（字符串）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912102822647.png" alt="image-20210912102822647"></p>
<p><strong>其他字符串方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912103033522.png" alt="image-20210912103033522"></p>
<p><strong>取值</strong>、<strong>切片</strong></p>
<p>slice取的是字符，比如df.str.slice(0,3)取的是前三个字符。等价于df.str[0:3]</p>
<p>df.str.get(i) 与 df.str[i] 的按索引取值效果类似</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">get<span class="token punctuation">(</span><span class="token punctuation">)</span> 与 <span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 操作还可以在 split<span class="token punctuation">(</span><span class="token punctuation">)</span> 操作之后使用。例如，要获取每个姓名的姓
（last name），可以结合使用 split<span class="token punctuation">(</span><span class="token punctuation">)</span> 与 get<span class="token punctuation">(</span><span class="token punctuation">)</span> ：
monte
Out<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>    Graham Chapman
<span class="token number">1</span>       John Cleese
<span class="token number">2</span>     Terry Gilliam
<span class="token number">3</span>         Eric Idle
<span class="token number">4</span>       Terry Jones
<span class="token number">5</span>     Michael Palin
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>
    
monte<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>    Chapman
<span class="token number">1</span>     Cleese
<span class="token number">2</span>    Gilliam
<span class="token number">3</span>       Idle
<span class="token number">4</span>      Jones
<span class="token number">5</span>      Palin
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>指标变量</strong></p>
<p>另一个需要多花点儿时间解释的是 get_dummies() 方法。当你的数据有一列包含了若干已被编码的指标（coded indicator）时，这个方法就能派上用场了。(转换成独热码)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">假设有一个包含了某种编码信息的数据集，如 A<span class="token operator">=</span> 出生在美国、B<span class="token operator">=</span> 出生在英国、C<span class="token operator">=</span> 喜欢奶酪、D<span class="token operator">=</span> 喜欢午餐肉：
full_monte
Out<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
             name   info
<span class="token number">0</span>  Graham Chapman  B<span class="token operator">|</span>C<span class="token operator">|</span>D
<span class="token number">1</span>     John Cleese    B<span class="token operator">|</span>D
<span class="token number">2</span>   Terry Gilliam    A<span class="token operator">|</span>C
<span class="token number">3</span>       Eric Idle    B<span class="token operator">|</span>D
<span class="token number">4</span>     Terry Jones    B<span class="token operator">|</span>C
<span class="token number">5</span>   Michael Palin  B<span class="token operator">|</span>C<span class="token operator">|</span>D

full_monte<span class="token punctuation">[</span><span class="token string">'info'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>get_dummies<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span> <span class="token comment">#选择分隔符</span>
Out<span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
   A  B  C  D
<span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span>
<span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>
<span class="token number">2</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>
<span class="token number">3</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">1</span>
<span class="token number">4</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">0</span>
<span class="token number">5</span>  <span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">1</span>  <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>3.11.3<strong>案例</strong></p>
<p>recipe的每个元素的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912105340844.png" alt="image-20210912105340844"></p>
<p><code>recipes.ingredients.str.len().describe()</code>  看看菜单食材的名字长度</p>
<p><code> recipes.name[np.argmax(recipes.ingredients.str.len())]</code>看看这个拥有最长食材列表的究竟是哪道菜</p>
<p>``recipes.description.str.contains(‘[Bb]reakfast’).sum()` 看看哪些食谱是早餐。</p>
<p>#以后再看吧，太难了</p>
<h2 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h2><p> Pandas 最初是为金融模型而创建的，因此它拥有一些功能非常强大的日期、时间、带时间索引数据的处理工具</p>
<ul>
<li><p>时间戳表示某个具体的时间点（例如 2015 年 7 月 4 日上午 7 点）。</p>
</li>
<li><p>时间间隔与周期表示<strong>开始时间点与结束时间点之间的时间长度</strong>，例如 2015 年（指的是<br>2015 年 1 月 1 日至 2015 年 12 月 31 日这段时间间隔）。</p>
<p>周期通常是指一种特殊形式的时间间隔，<strong>每个间隔长度相同</strong>，彼此之间不会重叠（例如，以 24 小时为周期构成每一天）。</p>
</li>
<li><p>时间增量（time delta）或持续时间（duration）表示精确的时间长度（例如，某程序运行持续时间 22.56 秒）</p>
</li>
</ul>
<h3 id="python原生工具"><a href="#python原生工具" class="headerlink" title="python原生工具"></a>python原生工具</h3><p>在开始介绍 Pandas 的时间序列工具之前，我们先简单介绍一下 <strong>Python</strong> 处理日期与时间数据的工具。</p>
<p>尽管 Pandas 提供的时间序列工具更适合用来处理数据科学问题，但是了解 Pandas 与 Python 标准库以及第三方库中的其他时间序列工具之间的关联性将大有裨益。</p>
<ol>
<li><strong>datatime 和 dateutil</strong></li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
datetime<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2015</span><span class="token punctuation">,</span> month<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> day<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">51</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">#可以利用dateutil对字符串格式的日期进行正确解析</span>
<span class="token keyword">from</span> dateutil <span class="token keyword">import</span> parser
date <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"4th of July, 2015"</span><span class="token punctuation">)</span>

date
Out<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> Python 的 datetime 文档（<a href="https://docs.python.org/3/library/datetime.html%EF%BC%89">https://docs.python.org/3/library/datetime.html）</a></p>
<p> dateutil 的其他日期功能可以通过在线文档（<a href="http://labix.org/python-dateutil%EF%BC%89%E5%AD%A6%E4%B9%A0">http://labix.org/python-dateutil）学习</a></p>
<p> pytz （<a href="http://pytz.sourceforge.net/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%A7%A3%E5%86%B3%E4%BA%86%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%9A%BE%E9%A2%98%EF%BC%9A**%E6%97%B6%E5%8C%BA">http://pytz.sourceforge.net/），这个工具解决了绝大多数时间序列数据都会遇到的难题：**时区</a>**</p>
<p>datetime 和 dateutil 模块在灵活性与易用性方面都表现出色，数量大时，速度就会比较慢。</p>
<ol start="2">
<li><strong>基于NumPy的datetime64类型（Numerical Python）</strong></li>
</ol>
<p>datetime64 类型将日期编码为 <strong>64 位整数</strong>，这样可以让日期数组非常紧凑（节省内存）。<br>datetime64 需要<strong>在设置日期时确定具体的输入类型</strong>。</p>
<p>因为 NumPy 的 datetime64 数组内元素的类型是统一的，所以这种数组的运算速度会比Python 的 datetime 对象的运算速度快很多（向量化计算）</p>
<p>NumPy 的 datetime64 文档（<a href="http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html%EF%BC%89%E6%80%BB%E7%BB%93%E4%BA%86%E6%89%80%E6%9C%89%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E4%B8%8E%E7%BB%9D%E5%AF%B9%E6%97%B6%E9%97%B4%E8%B7%A8%E5%BA%A6%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%8D%95%E4%BD%8D%E6%A0%BC%E5%BC%8F%E4%BB%A3%E7%A0%81">http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html）总结了所有支持相对与绝对时间跨度的时间与日期单位格式代码</a></p>
<p>datetime64内的位数是固定的，追求的精度越高，能表示的<strong>精度越高，能表示的范围就越小</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912114638942.png" alt="image-20210912114638942"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912114650874.png" alt="image-20210912114650874"></p>
<p>一般工作中用的就是ns，因为用它来表示时间范围精度可以满足绝大部分需求。</p>
<p>虽然 datetime64 弥补了 Python 原生的 datetime 类型的不足，但它缺少了许多 datetime （尤其是 dateutil ）原本具备的便捷方法与函数</p>
<ol start="3">
<li>Pandas的日期与时间工具：<strong>理想与现实的最佳解决方案</strong></li>
</ol>
<p>Pandas 所有关于日期与时间的处理方法全部都是通过 <strong>Timestamp 对象</strong>实现的。</p>
<p>它利用numpy.datetime64 的<strong>有效存储和向量化接口</strong>将 datetime 和 dateutil 的<strong>易用性</strong>有机结合起来。</p>
<p>Pandas 通过一组 Timestamp 对象就可以创建一个可以作为 Series 或 DataFrame 索引的DatetimeIndex，既有向量化的高效，又可以灵活的处理数据。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Pandas 时间序列工具非常适合用来处理带时间戳的索引数据，支持切片，取值等。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">index <span class="token operator">=</span> pd<span class="token punctuation">.</span>DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2014-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2014-08-04'</span><span class="token punctuation">,</span>
<span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-08-04'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span>index<span class="token punctuation">)</span>
data
Out<span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">2014</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">0</span>
<span class="token number">2014</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">1</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">3</span>
dtype<span class="token punctuation">:</span> int64
data<span class="token punctuation">[</span><span class="token string">'2014-07-04'</span><span class="token punctuation">:</span><span class="token string">'2015-07-04'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">2014</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">0</span>
<span class="token number">2014</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">1</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span>
dtype<span class="token punctuation">:</span> int64
data<span class="token punctuation">[</span><span class="token string">'2015'</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">2</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">3</span>
dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>时间戳数据—— Timestamp 类型。本质上是Python 的原生 datetime 类型的替代品。对应的索引数据结构是 DatetimeIndex 。</li>
<li>时间周期数据—— Period 类型。将固定频率的时间间隔进行编码。对应的索引数据结构是 PeriodIndex 。</li>
<li>时间增量或持续时间—— Timedelta 类型代替 Python原生 datetime.timedelta 类型的高性能数据结构。对应的索引数据结构是 TimedeltaIndex 。</li>
</ul>
<p><strong>以上都基于np.datetime64类型</strong></p>
<p>最基础的日期 / 时间对象是 Timestamp 和 DatetimeIndex 。这两种对象可以直接使用</p>
<p> pd.to_datetime() 函数，它可以解析许多日期与时间格式,传递一个日期会返回一个Timestamp 类型，传递一个时间序列会返回一个 DatetimeIndex 类型</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
dates <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_datetime<span class="token punctuation">(</span><span class="token punctuation">[</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'4th of July, 2015'</span><span class="token punctuation">,</span>
<span class="token string">'2015-Jul-6'</span><span class="token punctuation">,</span> <span class="token string">'07-07-2015'</span><span class="token punctuation">,</span> <span class="token string">'20150708'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#这个厉害</span>

dates
Out<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-08'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 用带分秒的康康</span>
dates <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_datetime<span class="token punctuation">(</span><span class="token punctuation">[</span>datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'4th of July, 2015'</span><span class="token punctuation">,</span>
<span class="token string">'2015-Jul-6'</span><span class="token punctuation">,</span> <span class="token string">'07-07-2015'</span><span class="token punctuation">,</span> <span class="token string">'20150708'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

dates
Out<span class="token punctuation">[</span><span class="token number">45</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03 18:30:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04 00:00:00'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-06 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07 00:00:00'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-08 00:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
dates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">47</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Timestamp<span class="token punctuation">(</span><span class="token string">'2015-07-03 18:30:00'</span><span class="token punctuation">)</span>
<span class="token comment">#单个就是TimeStamp</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> DatetimeIndex 类型都可以通过 to_period() 方法和一个频率代码转换成 PeriodIndex类型。下面用 ‘D’ 将数据转换成单日的时间序列</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">dates<span class="token punctuation">.</span>to_period<span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
PeriodIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span>
             <span class="token string">'2015-07-08'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            dtype<span class="token operator">=</span><span class="token string">'period[D]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span>
<span class="token comment">#我的小时和秒都没了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当用一个日期减去另一个日期时，返回的结果是 TimedeltaIndex 类型：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">dates <span class="token operator">-</span> dates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">49</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:30:00'</span><span class="token punctuation">,</span> <span class="token string">'2 days 05:30:00'</span><span class="token punctuation">,</span>
                <span class="token string">'3 days 05:30:00'</span><span class="token punctuation">,</span> <span class="token string">'4 days 05:30:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="间隔和频率"><a href="#间隔和频率" class="headerlink" title="间隔和频率"></a>间隔和频率</h3><p>为了能更简便地创建有规律的时间序列，Pandas 提供了一些方法： pd.date_range() 可以处理时间戳、 pd.period_range() 可以处理周期、 pd.timedelta_range() 可以处理时间间隔。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-05'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span>
<span class="token comment">#左闭右闭，默认freq是‘D’</span>
pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-04'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-05'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-06'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-10'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span>
<span class="token comment">#第二种方法</span>
pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'2015-07-03'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">61</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
DatetimeIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07-03 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 01:00:00'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-03 02:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 03:00:00'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-03 04:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 05:00:00'</span><span class="token punctuation">,</span>
               <span class="token string">'2015-07-03 06:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2015-07-03 07:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              dtype<span class="token operator">=</span><span class="token string">'datetime64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>
pd<span class="token punctuation">.</span>period_range<span class="token punctuation">(</span><span class="token string">'2015-07'</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
PeriodIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2015-07'</span><span class="token punctuation">,</span> <span class="token string">'2015-08'</span><span class="token punctuation">,</span> <span class="token string">'2015-09'</span><span class="token punctuation">,</span> <span class="token string">'2015-10'</span><span class="token punctuation">,</span> <span class="token string">'2015-11'</span><span class="token punctuation">,</span> <span class="token string">'2015-12'</span><span class="token punctuation">,</span>
             <span class="token string">'2016-01'</span><span class="token punctuation">,</span> <span class="token string">'2016-02'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            dtype<span class="token operator">=</span><span class="token string">'period[M]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">)</span>
pd<span class="token punctuation">.</span>timedelta_range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 01:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 02:00:00'</span><span class="token punctuation">,</span>
                <span class="token string">'0 days 03:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 04:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:00:00'</span><span class="token punctuation">,</span>
                <span class="token string">'0 days 06:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 07:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 08:00:00'</span><span class="token punctuation">,</span>
                <span class="token string">'0 days 09:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'H'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>掌握 Pandas 频率代码是使用所有这些时间序列创建方法的必要条件。</p>
<p>Pandas 时间序列工具的基础是时间频率或偏移量（offset）代码。我们可以用这些代码设置任意需要的时间间隔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912132206207.png" alt="image-20210912132206207"></p>
<p>发现有一些是period，有一些是时间戳</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912132256107.png" alt="image-20210912132256107"></p>
<p>在这些代码的基础上，还可以将频率组合起来创建的新的周期</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">pd<span class="token punctuation">.</span>timedelta_range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> periods<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">"2H30T"</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
TimedeltaIndex<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'0 days 00:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 02:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 05:00:00'</span><span class="token punctuation">,</span>
                <span class="token string">'0 days 07:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 10:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 12:30:00'</span><span class="token punctuation">,</span>
                <span class="token string">'0 days 15:00:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 17:30:00'</span><span class="token punctuation">,</span> <span class="token string">'0 days 20:00:00'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
               dtype<span class="token operator">=</span><span class="token string">'timedelta64[ns]'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'150T'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="重新取样、迁移和窗口"><a href="#重新取样、迁移和窗口" class="headerlink" title="重新取样、迁移和窗口"></a>重新取样、迁移和窗口</h4><p>用日期和时间直观地组织与获取数据是 Pandas 时间序列工具最重要的功能之一。</p>
<p>Pandas不仅支持普通索引功能（合并数据时自动索引对齐、直观的数据切片和取值方法等），还专为时间序列提供了额外的操作。</p>
<p>由于 Pandas 最初是为金融数据模型服务的，因此可以用它非常方便地获取金融数据。例如， pandas-datareader 程序包知道如何从一些可用的数据源导入金融数据，包含 Yahoo 财经、Google 财经和其他数据源。</p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">更多资料</a></p>
<ol>
<li>重新取样与频率转换</li>
</ol>
<p>处理时间序列数据时，经常需要按照新的频率（更高频率、更低频率）对数据进行重新取样。</p>
<p>你可以通过 resample() 方法解决这个问题，或者用更简单的 asfreq() 方法。</p>
<p> resample() 方法是以数据累计（data aggregation）为基础，而asfreq() 方法是以数据选择（data selection）为基础。</p>
<p>（由于下载数据出了问题，只能截图）原始数据👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145112857.png" alt="image-20210912145112857"></p>
<p>对于收盘价进行可视化结果👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145127584.png" alt="image-20210912145127584"></p>
<p><strong>向后取样，和向前取样大体相同。</strong></p>
<p>goog.resample(‘BA’).mean().plot(style=’:’)</p>
<p>goog.asfreq(‘BA’).plot(style=’–’);</p>
<p>重选频率（BA是每个年末）以后，如图，但是注意取样方式的差异，上一条是平均值，下一条是最后一个工作日。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912145205838.png" alt="image-20210912145205838"></p>
<p>感觉没看懂，不管了，以后再查resample和asfreq吧，还要配合一些填充。</p>
<ol start="2">
<li>时间迁移</li>
</ol>
<p>另一种常用的时间序列操作是对数据按时间进行迁移。Pandas 有两种解决这类问题的方法： shift() 和 tshift() 。简单来说， <strong>shift() 就是迁移数据，而 tshift() 就是迁移索引</strong>。两种方法都是按照频率代码进行迁移</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210912151509737.png" alt="image-20210912151509737"></p>
<p> shift(900) 将数据向前推进了 900 天，这样图形中的一段就消失了（最左侧就变成了缺失值），而 tshift(900) 方法是将时间索引值向前推进了 900 天。</p>
<ol start="3">
<li>移动时间窗口</li>
</ol>
<p>移动统计值（rolling statistics）。这些指标可以通过 Series 和 DataFrame 的 rolling() 属性来实现，它会返回与 groupby 操作类似的结果（详情请参见 3.9 节）。移动视图（rolling view）使得许多累计操作成为可能。</p>
<p><strong>3.12.7 案例：美国西雅图自行车统计数据的可视化。</strong></p>
<h2 id="高性能Pandas-eval-、query"><a href="#高性能Pandas-eval-、query" class="headerlink" title="高性能Pandas:eval()、query()"></a>高性能Pandas:eval()、query()</h2><p>Python 数据科学生态环境的强大力量建立在 NumPy 与 Pandas 的基础之上，并通过直观的语法将基本操作转换成 C 语言：在 NumPy 里是向量化 / 广播运算，在 Pandas 里是分组型的运算。虽然这些抽象功能可以简洁高效地解决许多问题，但是它们经常需要<strong>创建临时中间对象，这样就会占用大量的计算时间与内存。</strong></p>
<p>Pandas 从 0.13 版开始（2014 年 1 月）就引入了实验性工具，让用户可以直接运行 C 语言速度的操作，不需要十分费力地配置中间数组。它们就是 eval() 和 query() 函数，都依赖于 Numexpr (<a href="https://github.com/pydata/numexpr">https://github.com/pydata/numexpr</a>) 程序包。</p>
<h3 id="设计动机：复合代数式"><a href="#设计动机：复合代数式" class="headerlink" title="设计动机：复合代数式"></a>设计动机：复合代数式</h3><p>在进行复合代数式运算时，例如：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
y <span class="token operator">=</span> rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

mask <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
<span class="token comment">#在进行这个运算的时候，由于Numpy会计算每一个代数子式，相当于</span>
tmp1 <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span>
tmp2 <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
mask <span class="token operator">=</span> tmp1 <span class="token operator">&amp;</span> tmp2
<span class="token comment">#每段中间过程都需要显式地分配内存。Numexpr 程序库可以让你在不为中间过程分配全部内</span>
<span class="token comment">#存的前提下，完成元素到元素的复合代数式运算。</span>
<span class="token keyword">import</span> numexpr
mask_numexpr <span class="token operator">=</span> numexpr<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span><span class="token string">'(x > 0.5) &amp; (y &lt; 0.5)'</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask_numexpr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>马上要介绍的 Pandas 的 eval() 和 query()工具其实也是<strong>基于 Numexpr 实现</strong>的。</p>
<h3 id="eval实现高性能运算"><a href="#eval实现高性能运算" class="headerlink" title="eval实现高性能运算"></a>eval实现高性能运算</h3><p>就我自己试验的结果，还不如不优化。。可能是pandas已经内置了更厉害的吧。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
nrows<span class="token punctuation">,</span> ncols <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">100</span>
rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
df1<span class="token punctuation">,</span> df2<span class="token punctuation">,</span> df3<span class="token punctuation">,</span> df4 <span class="token operator">=</span> <span class="token punctuation">(</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token operator">%</span>timeit df1 <span class="token operator">+</span> df2 <span class="token operator">+</span> df3 <span class="token operator">+</span> df4
<span class="token number">100</span> ms ± <span class="token number">15.4</span> ms per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">10</span> loops each<span class="token punctuation">)</span>
<span class="token operator">%</span>timeit pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df1 + df2 + df3 + df4'</span><span class="token punctuation">)</span>
<span class="token number">99.2</span> ms ± <span class="token number">2.41</span> ms per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">10</span> loops each<span class="token punctuation">)</span>
<span class="token comment">#而且内存消耗更少</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>支持的运算</strong>：</p>
<ol>
<li><p>算术运算符</p>
<p> pd.eval() 支持所有的算术运算符</p>
<p>np.allclose()这个是用来确认两者相等的。</p>
</li>
<li><p>比较运算符</p>
<p>支持所有的比较运算符，包括链式代数式</p>
</li>
<li><p> 位运算符</p>
</li>
</ol>
<p>   另外，你还可以在布尔类型的代数式中使用 and 和 or 等字面值</p>
<p>   <code>result3 = pd.eval(&#39;(df1 &lt; 0.5) and (df2 &lt; 0.5) or (df3 &lt; df4)&#39;)</code></p>
<ol start="4">
<li> 对象属性与索引</li>
</ol>
<p>   可以通过 obj.attr 语法获取对象属性，通过 obj[index] 语法获取对象索引</p>
   <pre class="line-numbers language-python" data-language="python"><code class="language-python">result1 <span class="token operator">=</span> df2<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> df3<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df2.T[0] + df3.iloc[1]'</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span>——<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="5">
<li><p>目前 pd.eval() 还不支持函数调用、条件语句、循环以及更复杂的运算。如果你想要进行这些运算，可以借助 Numexpr 来实现。</p>
</li>
<li><p>用DataFrame.eval()实现列间计算。</p>
</li>
</ol>
<p>由于 pd.eval() 是 Pandas 的顶层函数，因此 DataFrame 有一个 eval() 方法可以做类似的运算。使用 eval() 方法的好处是可以借助列名称进行运算，示例如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rng<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
          A         B         C
<span class="token number">0</span>  <span class="token number">0.375506</span>  <span class="token number">0.406939</span>  <span class="token number">0.069938</span>
<span class="token number">1</span>  <span class="token number">0.069087</span>  <span class="token number">0.235615</span>  <span class="token number">0.154374</span>
<span class="token number">2</span>  <span class="token number">0.677945</span>  <span class="token number">0.433839</span>  <span class="token number">0.652324</span>
<span class="token number">3</span>  <span class="token number">0.264038</span>  <span class="token number">0.808055</span>  <span class="token number">0.347197</span>
<span class="token number">4</span>  <span class="token number">0.589161</span>  <span class="token number">0.252418</span>  <span class="token number">0.557789</span>
result1 <span class="token operator">=</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">+</span> df<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">"(df.A + df.B) / (df.C - 1)"</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span>
    
    <span class="token comment"># 不知道为啥还是负优化。。。还是这个inplace的用法有价值</span>
df<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'D = (A + B) / C'</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">102</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
          A         B         C          D
<span class="token number">0</span>  <span class="token number">0.375506</span>  <span class="token number">0.406939</span>  <span class="token number">0.069938</span>  <span class="token number">11.187620</span>
<span class="token number">1</span>  <span class="token number">0.069087</span>  <span class="token number">0.235615</span>  <span class="token number">0.154374</span>   <span class="token number">1.973796</span>
<span class="token number">2</span>  <span class="token number">0.677945</span>  <span class="token number">0.433839</span>  <span class="token number">0.652324</span>   <span class="token number">1.704344</span>
<span class="token number">3</span>  <span class="token number">0.264038</span>  <span class="token number">0.808055</span>  <span class="token number">0.347197</span>   <span class="token number">3.087857</span>
<span class="token number">4</span>  <span class="token number">0.589161</span>  <span class="token number">0.252418</span>  <span class="token number">0.557789</span>   <span class="token number">1.508776</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="DataFrame-query-方法"><a href="#DataFrame-query-方法" class="headerlink" title="DataFrame.query() 方法"></a>DataFrame.query() 方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)]'</span><span class="token punctuation">)</span>
<span class="token comment">#相当于</span>
result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; 0.5 and B &lt; 0.5'</span><span class="token punctuation">)</span>
<span class="token comment">#除了计算性能更优之外，这种方法的语法也比掩码代数式语法更好理解。</span>
<span class="token comment">#需要注意的是，query() 方法也支持用 @ 符号引用局部变量，eval不支持！</span>
Cmean <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
result1 <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>A <span class="token operator">&lt;</span> Cmean<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">.</span>B <span class="token operator">&lt;</span> Cmean<span class="token punctuation">)</span><span class="token punctuation">]</span>
result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; @Cmean and B &lt; @Cmean'</span><span class="token punctuation">)</span>

<span class="token comment">#什么叫反向优化啊草</span>
<span class="token operator">%</span>timeit result2 <span class="token operator">=</span> pd<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)]'</span><span class="token punctuation">)</span>
<span class="token number">20.8</span> ms ± <span class="token number">943</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1</span> loop each<span class="token punctuation">)</span>
<span class="token operator">%</span>timeit  result2 <span class="token operator">=</span> df<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">'A &lt; 0.5 and B &lt; 0.5'</span><span class="token punctuation">)</span>
<span class="token number">1.37</span> ms ± <span class="token number">9.18</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1000</span> loops each<span class="token punctuation">)</span>
<span class="token operator">%</span>timeit  result2 <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>A <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">.</span>B <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token number">520</span> µs ± <span class="token number">3.46</span> µs per loop <span class="token punctuation">(</span>mean ± std<span class="token punctuation">.</span> dev<span class="token punctuation">.</span> of <span class="token number">7</span> runs<span class="token punctuation">,</span> <span class="token number">1000</span> loops each<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>在考虑要不要用这两个函数时，需要思考两个方面：计算时间和内存消耗，而<strong>内存消耗是更重要的影响因素。</strong></p>
<p>如果临时 DataFrame 的内存需求比你的系统内存还大（通常是几吉字节），那么最好还是使用 eval() 和 query() 代数式。</p>
<p>可以用<code>df.value.nbytes</code>大概估算一下</p>
<p>在实际工作中，我发现普通的计算方法与 eval /  query 计算方法在计算时间上的差异并非总是那么明显，普通方法在处理较小的数组时反而速度更快！ eval /  query 方法的优点主要是节省内存，有时语法也更加简洁。</p>
<p>尤其需要注意的是，可以通过设置不同的解析器和引擎来执行这些查询，相关细节请 参 考 Pandas 文 档 中“Enhancing Performance”（<a href="http://pandas.pydata.org/pandas-docs/dev/enhancingperf.html%EF%BC%89%E8%8A%82%E3%80%82">http://pandas.pydata.org/pandas-docs/dev/enhancingperf.html）节。</a></p>
<p>剩下的东西放在notebook跑吧！！！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>但因篇幅有限，仍有许多知识无法介绍到</p>
<p>如果你想学习更多的 Pandas 知识，推荐参考下面的资源。</p>
<p>《利用 Python 进行数据分析》</p>
<p>PyVideo 上关于 Pandas 的教学视频（<a href="http://pyvideo.org/tag/pandas/%EF%BC%89">http://pyvideo.org/tag/pandas/）</a></p>
]]></content>
      <categories>
        <category>data</category>
      </categories>
      <tags>
        <tag>data-sience</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/03/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>来自<a href="https://www.runoob.com/regexp/regexp-tutorial.html">菜鸟教程</a></p>
<h2 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h2><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p>
<p>通过使用正则表达式，可以：</p>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
<p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ol>
<li><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
</li>
<li><p>非打印字符</p>
<p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
</li>
<li><p>特别字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。比如限定符</p>
</li>
<li><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p>
<p>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p>以下正则表达式匹配一个正整数，[1-9]设置第一个数字不是 0，[0-9]* 表示任意多个数字：</p>
</li>
<li><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p>
<p>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
</li>
<li><p>选择</p>
<p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p>
<p><strong>()</strong> 表示捕获分组，() 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)</p>
<p>但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 <strong>?:</strong> 放在第一个选项前来消除这种副作用</p>
</li>
<li><p>先/后行断言</p>
<p>个人感觉这是一种修饰，不会有括号那种缓冲的副作用</p>
<p>exp1(?=exp2)：查找 exp2 前面的 exp1</p>
<p>(?&lt;=exp2)exp1：查找 exp2 后面的 exp1。</p>
<p>exp1(?!exp2)：查找后面不是 exp2 的 exp1。</p>
<p>(?&lt;!exp2)exp1：查找前面不是 exp2 的 exp1。</p>
</li>
<li><p>修饰符：(置于表达式之后)</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">ignore - 不区分大小写</td>
<td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">global - 全局匹配</td>
<td align="left">查找所有的匹配项。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">multi line - 多行匹配</td>
<td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td>
<td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h3><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td>
</tr>
<tr>
<td align="left">(pattern)</td>
<td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>
</tr>
<tr>
<td align="left">(?:pattern)</td>
<td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td>
</tr>
<tr>
<td align="left">(?=pattern)</td>
<td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td align="left">(?!pattern)</td>
<td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td align="left">(?&lt;=pattern)</td>
<td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td>
</tr>
<tr>
<td align="left">(?&lt;!pattern)</td>
<td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td>
</tr>
<tr>
<td align="left">x|y</td>
<td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td align="left">[xyz]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td align="left">[^xyz]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td align="left">[^a-z]</td>
<td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td align="left">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td align="left">\xn</td>
<td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
</tr>
<tr>
<td align="left">\num</td>
<td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
</tr>
<tr>
<td align="left">\nm</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
</tr>
<tr>
<td align="left">\nml</td>
<td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
</tr>
<tr>
<td align="left">\un</td>
<td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
</tr>
</tbody></table>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">转义符</td>
</tr>
<tr>
<td align="left">(), (?:), (?=), []</td>
<td align="left">圆括号和方括号</td>
</tr>
<tr>
<td align="left">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="left">限定符</td>
</tr>
<tr>
<td align="left">^, $, \任何元字符、任何字符</td>
<td align="left">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td>
</tr>
</tbody></table>
<h2 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h2><p>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">^once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">bucket$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 <strong>^</strong> 和 <strong>$</strong> 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">^bucket$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p>
<pre class="line-numbers language-none"><code class="language-none">once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>与字符串</p>
<pre class="line-numbers language-none"><code class="language-none">There once was a man from NewYork
Who kept all of his cash in a bucket.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>是匹配的。</p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<p>可以使用非捕获元字符 <strong>?:<strong>、</strong>?=</strong> 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p>
<p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p>
<pre class="line-numbers language-none"><code class="language-none">Is is the cost of of gasoline going up up?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Is is the cost of of gasoline going up up"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> patt1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\b([a-z]+) \1\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>patt1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="小ps："><a href="#小ps：" class="headerlink" title="小ps："></a>小ps：</h2><ol>
<li>* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。</li>
</ol>
<h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><p>转自<a href="https://oddfar.com/archives/35/">https://oddfar.com/archives/35/</a></p>
<h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><pre class="line-numbers language-none"><code class="language-none">1、数字：^[0-9]*$
2、n位的数字：^\d&#123;n&#125;$
3、至少n位的数字：^\d&#123;n,&#125;$
4、m-n位的数字：^\d&#123;m,n&#125;$
5、零和非零开头的数字：^(0|[1-9][0-9]*)$
6、非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$
7、带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$
8、正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9、有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$
10、有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$
11、非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$
12、非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$
13、非负整数：^\d+$ 或 ^[1-9]\d*|0$
14、非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15、非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16、非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17、正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18、负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19、浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><pre class="line-numbers language-none"><code class="language-none">-  1、汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$
-  2、英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$
-  3、长度为3-20的所有字符：^.&#123;3,20&#125;$
-  4、由26个英文字母组成的字符串：^[A-Za-z]+$
-  5、由26个大写英文字母组成的字符串：^[A-Z]+$
-  6、由26个小写英文字母组成的字符串：^[a-z]+$
-  7、由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
-  8、由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$
-  9、中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
- 10、中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$
- 11、可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+
- 12、禁止输入含有~的字符：[^~\x22]+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><pre class="line-numbers language-none"><code class="language-none">-  1、Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
-  2、域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?
-  3、InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$
-  4、手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$
-  5、电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 
-  6、国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;
-  7、身份证号码(数字、字母x结尾)：^(\d&#123;15&#125;$|^\d&#123;18&#125;$|^\d&#123;17&#125;(\d|X|x))$
-  9、帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$
- 10、密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$
- 11、强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  
- 12、日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><pre class="line-numbers language-none"><code class="language-none">- 1、  中文字符的正则表达式：[\u4e00-\u9fa5]
- 2、  双字节字符：  [^\x00-\xff](包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
- 3、 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)
- 4、 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
- 5、 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)  (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
- 6、 腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)
- 7、 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)
- 8、 IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)
- 9、 匹配所有字符：(.*?)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>Regular expression</tag>
      </tags>
  </entry>
  <entry>
    <title>跨学科通识课</title>
    <url>/2021/08/09/%E8%B7%A8%E5%AD%A6%E7%A7%91%E9%80%9A%E8%AF%86%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="跨学科通识"><a href="#跨学科通识" class="headerlink" title="跨学科通识"></a>跨学科通识</h1><p><strong><a href="https://www.bilibili.com/cheese/play/ep6902">视频地址</a></strong></p>
<p>所长林超自阅读查理芒格观点后得出的感悟。本课程信奉 <strong>实用主义</strong></p>
<p>现实生活中的挑战并不是按照大学学科划分的，但每种学科，都为我们解决问题提供了重要的思维模型</p>
<p>本课程将介绍约22个学科和120个常见思维模型，以及部分应用：</p>
<p>热力学、函数、工程学、<strong>复杂性科学</strong>、系统论、信息论、会计学、概率论、金融学、生物学、投资学、社会学、管理学、物理学、脑科学、认知心理学、历史学、语言学、逻辑学、经济学、营销学、哲学</p>
<p> <strong>大多数人的一生都喜欢用一个单薄的知识结构解决所有问题，这是专业化带来的狭隘思维</strong></p>
<hr>
<p>像我这样的人才:laughing:（bushi），就应该逐步构建自己的知识体系，哈哈我就是这样做的，我在大一接触了应用数学、博弈论、经济学、投资学、心理学、信息论、运筹学，但是学习方法不对，我需要的不是变成所有领域的专家，而是专精一两门（数据科学+经济学），然后学到其他学科的思考模型，先拿林超大大的课试试水。</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140718.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140824.png"  style="zoom: 33%;" />



<p>20-35岁是人生的黄金时间，抓住啊！</p>
<h2 id="一、熵与热力学"><a href="#一、熵与热力学" class="headerlink" title="一、熵与热力学"></a>一、熵与热力学</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>S = k * lnW  也可以说熵正比于微状态数</p>
<p>可能性大 = 熵高 = 混乱程度高</p>
<p>这个世界上混乱才是常态，有序需要<strong>刻意营造</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142123.png"  style="zoom: 25%;" />

<p>熵增定律</p>
<p>封闭系统，与外界隔绝，随时间推移趋于混乱。</p>
<p>趋于有序的方法</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142524.png"  style="zoom: 25%;" />

<p>只要它能正确的做好这两件事，就能使事物变得更加有序。</p>
<hr>
<p><strong>应用：思维决策层</strong></p>
<p>在”脑子里放一个小人“，判断该不该继续思考数量繁多而无序的念头，就能让思维变得有序，这相当于是在正常人的思维输入输出模型里面又加了一个决策层啊！果然方法论决定对外界的反馈，厉害。</p>
<hr>
<p>耗散结构</p>
<p>感知和选择需要信息和能量，封闭系统变成开放系统，吸收外界的能量和信息</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142944.png"  style="zoom:33%;" />

<p>流水不腐就是一个耗散结构，人体也是，耗散结构是一个动态平衡体，变化又保持一个平衡状态。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143434.png"  style="zoom:33%;" />



<h3 id="运转策略"><a href="#运转策略" class="headerlink" title="运转策略"></a><strong>运转策略</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143513.png"  style="zoom: 33%;" />

<p>ps:虽然很多人都是这么做的，但是却没有总结成结论，没有总结成结论，运用的时候就会无效思考，心生犹豫，但若是作为一条公理、定理，一项判断决策，那就非常有价值了！</p>
<p><strong>人们应该把焦点全部放在蓝色部分的因，接纳红色的因，而不是因为红色的果而感到自责，反而阻止了身体继续排出熵。所以鸡汤里面的依靠决心和自责什么的假大空的，其实就是抓错了重点。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143954.png"  style="zoom:25%;" />

<p>我们改变不了整体系统，但我们可以改变 <strong>感知+选择</strong> 这件事</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144227.png"  style="zoom: 33%;" />

<p>有些人会困在先天的家庭环境带来的红色的果里，有些人会找到铁饭碗，陷入封闭系统里，这个世界充满辩证法，耗散里的选择才是最关键的，如果落实到具体做法，请看👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144756.png"  style="zoom:50%;" />

<p>逐渐的，两种模式都会形成坚固的闭环。B模式总会伴随痛苦，反人性，充满困难。</p>
<p>工程学告诉我们如何拆解困难，化为一件件小事，轻松KO。</p>
<h2 id="二、工程学"><a href="#二、工程学" class="headerlink" title="二、工程学"></a>二、工程学</h2><p>很多人知难而退，其实是知的不够</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809162445785.png"  style="zoom:50%;" />

<p>工程学的细分专业非常多：生物、农业、分子、土木、软件、森林。。。</p>
<p>这节课将提炼共通的重要方法论：<strong>行胜于言、分解结构、量化、列清单、取舍</strong></p>
<h3 id="行胜于言"><a href="#行胜于言" class="headerlink" title="行胜于言"></a><strong>行胜于言</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809163834216.png"  style="zoom: 33%;" />

<p>风口思维找到大方向，高风险，看准下手。</p>
<p>工程思维就喜欢看得见摸得着的，能清楚看清收益回报，也能付出实践的。</p>
<p>我个人还是更喜欢风口思维，因为确实难以忍受搬砖的枯燥，但找对风口后，要见成效确实得搬砖┭┮﹏┭┮</p>
<p><strong>激励</strong>来源：</p>
<p>要联系到后面讲的生理学：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164237881.png"  style="zoom:33%;" />

<p>内啡肽更长更持久，更有益身心健康，显然搬砖是后者。</p>
<p>人们往往习惯了多巴胺型快乐，它让人兴奋，但持续时间短，消散时会带来失落等负面情绪。</p>
<p>曾经物质不丰富，一般是一连串的内啡肽小快乐才等来一次多巴胺型大快乐。</p>
<p>但如今大刺激唾手可得，导致恶性循环👇：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164639424.png"  style="zoom:33%;" />



<p>真正公式：</p>
<p><strong>日常搬砖获得内啡肽型愉悦感，达到了成功再允许自己激发一些多巴胺型的快乐，彻底放松一次</strong></p>
<p><strong>要是没有达到成果，那就忍着，这才是良性循环</strong></p>
<h3 id="工程分解结构"><a href="#工程分解结构" class="headerlink" title="工程分解结构"></a>工程分解结构</h3><p>把任意问题拆解，是工程学最核心的思维。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165010342.png"  style="zoom:33%;" />

<p>这也有一项孪生能力：focus</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165516146.png" style="zoom:50%;" />

<p>focus like a laser, not like a flash</p>
<p>无限分解，直到找到抓手，从想-&gt;做就在那一瞬间，在脑科学里就是从一个新脑区的边缘神经元开始激活整个。</p>
<p>既见树木、也见森林</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170229459.png" alt="image-20210809170229459" style="zoom: 67%;" />

<hr>
<p><strong>应用：接触全新学科</strong></p>
<p>找到该领域最权威的教材，读目录，建框架</p>
<ul>
<li>读目录，查清所有不会的术语</li>
<li>推敲概念之间的关系，建立宏观全局框架</li>
</ul>
<p>这是知的部分，全局了解也是非常重要的。</p>
<hr>
<p>这才是知行合一，我就是那种喜欢看全局，然后分解不到位，最后懒得搬砖的人哈哈哈</p>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170731986.png" alt="image-20210809170731986" style="zoom:50%;" />

<p>一开始只想到房租、售价等几个变量</p>
<p>开始叙事，通过”讲故事“一步步推衍：</p>
<p>从开张开始，需要品牌，装修，开工后要培训，设备，原料。。。。</p>
<p>最后进行数学运算。</p>
<p>有两种厉害的商业思维分析框架，后面会讲：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171033121.png" alt="image-20210809171033121" style="zoom:50%;" />

<p>这件事其实非常简单，更何况我可是数学大佬。</p>
<p><strong>OKR模型</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171243197.png" alt="image-20210809171243197" style="zoom:67%;" />

<p>竖直分解目标，水平量化目标，案例：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171352398.png" alt="image-20210809171352398" style="zoom: 50%;" />

<p>这也为行动力提高打下了坚实的基础！</p>
<h3 id="清单思维"><a href="#清单思维" class="headerlink" title="清单思维"></a>清单思维</h3><p>对应to do list 和 time schedule</p>
<p>非常简单，但极其有用</p>
<p>列出来有利于</p>
<ul>
<li>确定优先级</li>
<li>让人专注，有利于“聚焦”。</li>
<li>利于推敲，找到不严谨的地方</li>
<li>节省脑资源！！（我就因为这个当年开始列清单的，记得难受死了</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191126647.png" alt="image-20210809191126647" style="zoom:50%;" />

<p>to do表和时间表就像一个事情的两个维度，一个以任务为核心一个以时间为核心，推荐飞书表</p>
<h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><p>对大多数人来说，难度更多在 <strong>舍</strong></p>
<p>一般最多选两样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191611562.png" alt="image-20210809191611562"></p>
<p>工程思维：便宜+快  （反完美主义，反本能的</p>
<p>艺术思维：好</p>
<h2 id="三、系统论"><a href="#三、系统论" class="headerlink" title="三、系统论"></a>三、系统论</h2><p>可以用来分析公司？</p>
<p>工程思想是拆分的还原论，那么这里就是整体论</p>
<p>观点：如果不着眼于系统，只改变局部，最终可能总被系统拉回来，比如一个闭环系统👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812003721985.png" alt="image-20210812003721985" style="zoom:33%;" />

<p> 系统论相当于是呈现这些“飞轮”的机制，让我们从整体把握这个逻辑</p>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a><strong>系统</strong></h3><p>很多实体通过相互 <strong>联系</strong> 形成了一个有运作规律的整体</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005240164.png" alt="image-20210812005240164" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005306703.png" alt="image-20210812005306703" style="zoom:33%;" /></p>
<p><strong>要素</strong></p>
<p>+ 正信息  正能量  资产</p>
<p>-  负信息  负能量  负债    负信息是让世界变得更加混乱的信息，如谎言、谣言</p>
<p><strong>关系</strong></p>
<p>+ 加强  - 减弱</p>
<p><strong>四种循环</strong></p>
<p>正要素+正关系 = 良性循环</p>
<p>负要素+正关系 = 恶性循环</p>
<p>负要素+负关系 = 贤者时刻（纠错）</p>
<p>正要素+负关系 = 回归平庸（后两个都是均值回归）</p>
<p>滞后效应</p>
<p><strong>负循环</strong></p>
<p>因果分析法，<strong>找到</strong>生活中的负循环</p>
<p>利用杠杆解，主要矛盾</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812010338719.png" alt="image-20210812010338719" style="zoom:33%;" />

<p>复杂的模型（混沌），如果能找到关键变量，便能牵一发动全身，彻底重构整个系统</p>
<hr>
<p><strong>建立仪式！</strong></p>
<p>所谓仪式，一旦开始，剩下的步骤就不需要控制，利用惯性执行</p>
<p>这可以尽可能地减少我们大脑的意识消耗。</p>
<hr>
<p>建立良性循环</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011007405.png" alt="image-20210812011007405" style="zoom:33%;" />

<p>我也要建立对自己的信任！</p>
<p><strong>均值回归</strong>，人是难以突破社会的。。。我跳出了这个圈子，所以我认识的人还是有点少、、、</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011253657.png" alt="image-20210812011253657" style="zoom:33%;" />

<p>我大概会抛弃回报公平吧，回报什么的没啥意思。</p>
<p>草，滞后效应，我现在熬夜会搞得以后难受。。。。哎呀好气</p>
<p>价值投资！也是滞后效应，这就是“确定性啊”</p>
<h3 id="储蓄池"><a href="#储蓄池" class="headerlink" title="储蓄池"></a><strong>储蓄池</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011807899.png" alt="image-20210812011807899" style="zoom:50%;" />

<p>保护自己的缓冲地带</p>
<p>一个人何以扛过滞后效应，凭借的是</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011901249.png" alt="image-20210812011901249" style="zoom: 50%;" />

<p>有储蓄机制的系统，也是一个有非常大适应力的系统。</p>
<p>这也引出好系统的三大特性：</p>
<ol>
<li>鲁棒性，可以<strong>建立模拟攻击（跳出舒适圈</strong></li>
<li>自组织，不依靠外部指令，按照某种内在规则自动自发地形成有序结构的一种现象(人体)</li>
<li>层次性，子系统，递归，封装思想（刚才的仪式</li>
</ol>
<h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>函数是这个世界上最美妙的事物之一。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812012642329.png" alt="image-20210812012642329" style="zoom: 80%;" />

<p>对大部分人来说，二号区是最方便的，实用而且简单直观</p>
<p>教科书为了严谨才把定义搞得那么抽象。函数重要的能力是可视化</p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><h4 id="高特纳曲线"><a href="#高特纳曲线" class="headerlink" title="高特纳曲线"></a><strong>高特纳曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813094417037.png" alt="image-20210813094417037" style="zoom: 50%;" />

<p><strong>不要高估短期能发生的变化</strong></p>
<p><strong>不要低估长期能发生的变化</strong></p>
<p>这是由神经科学的人性曲线和物性曲线（逻辑斯蒂函数（sigmoid））叠加构成的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095148856.png" alt="image-20210813095148856" style="zoom:33%;" />

<p>而逻辑斯蒂增长就是由指数增长+环境阻力构成的那个物种曲线hhh</p>
<h4 id="倒U曲线"><a href="#倒U曲线" class="headerlink" title="倒U曲线"></a><strong>倒U曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095346101.png" alt="image-20210813095346101" style="zoom:50%;" />

<p>可以用在生命机能等诸多现象中</p>
<p>正余弦函数——波动，周期</p>
<p>指数函数，跨过某个拐点，就开始起飞。</p>
<p>对数函数，玻璃顶的存在。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101214895.png" alt="image-20210813101214895" style="zoom: 50%;" />

<p>这只是个大概。</p>
<h2 id="五、脑科学"><a href="#五、脑科学" class="headerlink" title="五、脑科学"></a>五、脑科学</h2><p>又称神经科学，作为几乎所有研究人类行为的基础学科</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101722891.png" alt="image-20210813101722891" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101844649.png" alt="image-20210813101844649" style="zoom:50%;" />

<p>爬行脑是很难主管调节的，比如褪黑素得用化学药物，是生存本能。</p>
<p>所谓的刻意练习，就是利用人类脑对哺乳脑的驯化过程</p>
<p>新皮质四大脑区：</p>
<p>额叶、顶叶、</p>
<h3 id="额叶"><a href="#额叶" class="headerlink" title="额叶"></a>额叶</h3><p>最核心区域，智慧所在</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102929814.png" alt="image-20210813102929814" style="zoom:33%;" />

<p>分好几个区：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103133065.png" alt="image-20210813103133065" style="zoom:33%;" />

<p>ps: 布洛卡区和威尔尼克区就是语言中枢。</p>
<p>前额叶皮质是非常关键的部分，掌管诸多功能，最重要的是 <strong>社交和自控、专注</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102334506.png" alt="image-20210813102334506" style="zoom:50%;" />

<p>实际上这个距离就是自控和延迟满足，但如今人们的自控能力发展较慢，取而代之的是高维信息处理能力变强，所以人们自控力要在30岁左右才达到巅峰</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103419281.png" alt="image-20210813103419281" style="zoom:33%;" />

<p>镜像神经元</p>
<p>负则模仿能力和社交能力，还有共情能力，还有音乐。</p>
<p>分布在前运动皮质和初级运动皮层。向下直接连着脑干、脊椎。</p>
<p>还分布在布洛卡区。所以语言和音乐学习的捷径就是浸泡在大环境里面模仿别人，而不是考试。。</p>
<p>顶叶</p>
<p>负则统筹和协调，空间想象力</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103936139.png" alt="image-20210813103936139" style="zoom:50%;" />

<p>颞叶：语言理解，面部识别，洞察力，观察细节。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104113191.png" alt="image-20210813104113191" style="zoom:33%;" />

<p>枕叶：完全用于视觉</p>
<hr>
<h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>发现人类大脑里处理视觉的区域特别多！可视化yyds</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104345656.png" alt="image-20210813104345656" style="zoom:50%;" />

<p>依次激发更多的脑区！！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104325285.png" alt="image-20210813104325285" style="zoom: 33%;" />

<p>单纯语言沟通效率是很低的。</p>
<h3 id="哺乳脑"><a href="#哺乳脑" class="headerlink" title="哺乳脑"></a>哺乳脑</h3><p>（女发达）<strong>边缘系统</strong>：长期记忆、情绪管理、<strong>嗅觉</strong>（跟这些有关，所以体香很重要）、性唤醒</p>
<p>（女尤其发达）<strong>扣带回区域</strong>：情感、焦虑、痛苦、自我调节、负面想象</p>
<p><strong>杏仁核</strong>：恐惧、愤怒、兴奋、战或逃</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104933864.png" alt="image-20210813104933864" style="zoom: 50%;" />

<p>因此恐惧会抑制人类脑，再聪明也得服从本能，战或逃取决于过去的经历和基因。</p>
<p>可以通过训练，用经验告诉杏仁核不必恐惧，选择战而不是逃。</p>
<p>（商家最爱）<strong>基底神经节</strong>：操作技巧、习惯养成、奖赏系统、上瘾系统</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813105502624.png" alt="image-20210813105502624" style="zoom:33%;" />

<p>这个核是消费关键。</p>
<h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><p>刻意选择，不断重复。</p>
<p>就像是不同脑区的神经元链接，多次重复刺激以后形成坚固的道路</p>
<p>但关键步骤要放慢速度，可能调度更多的脑区观察这个过程。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813110129493.png" alt="image-20210813110129493" style="zoom:33%;" />

<p>所以贴标签是不可取的。</p>
<h2 id="六、复杂性科学"><a href="#六、复杂性科学" class="headerlink" title="六、复杂性科学"></a>六、复杂性科学</h2><p>还原论或还原主义（英语：Reductionism，又译化约论），是一种哲学思想，认为复杂的系统、事物、现象可以将其化解为各部分之组合来加以理解和描述。</p>
<p>在哲学上，还原论是一种观念，它认为某一给定实体是由更为简单或更为基础的实体所构成的集合或组合；或认为这些实体的表述可依据更为基础的实体的表述来定义。” 还原论方法是经典科学方法的内核，将高层的、复杂的对象分解为较低层的、简单的对象来处理；世界的本质在于简单性。</p>
<p>复杂性科学兴起于20世纪80年代的复杂性科学，是系统科学发展的新阶段，也是当代科学发展的前沿领域之一。复杂性科学的发展，不仅引发了自然科学界的变革，而且也日益渗透到哲学、人文社会科学领域。复杂性科学为什么会赢得如此盛誉，并带给科学研究如此巨大的变革呢？主要是因为复杂性科学在<strong>研究方法论上的突破和创新</strong>。在某种意义上，甚至可以说复杂性科学带来的首先是一场方法论或者思维方式的变革。</p>
<ol>
<li>它只能通过研究方法来界定，其度量标尺和框架是<strong>非还原</strong>的研究方法论</li>
<li>它不是一门具体的学科，而是分散在许多学科中，是学科互涉的</li>
<li>它力图打破传统学科之间互不来往的界限，寻找各学科之间的相互联系、相互合作的统一机制</li>
<li>它力图打破从<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E5%8A%9B%E5%AD%A6">牛顿力学</a>以来一直统治和主宰世界的线性理论，抛弃<a href="https://baike.baidu.com/item/%E8%BF%98%E5%8E%9F%E8%AE%BA">还原论</a>适用于所用学科的梦想</li>
<li>它要创立新的理论框架体系或范式，应用新的思维模式来理解自然界带给我们的问题</li>
</ol>
<p>复杂性科学是指以复杂性系统为研究对象，以超越还原论为方法论特征，以揭示和解释复杂系统运行规律为主要任务，以提高人们认识世界、探究世界和改造世界的能力为主要目的的一种“学科互涉”(inter—disciplinary)的新兴科学研究形态。</p>
<p><u>某学者定义：运用跨学科方法，研究不同复杂系统中的<strong>涌现</strong>行为和<strong>统一性规律</strong></u></p>
<p>《复杂》 入门必读</p>
<p>《规模》 研究增长</p>
<p>《系统论》  系统论入门</p>
<hr>
<h3 id="复杂系统"><a href="#复杂系统" class="headerlink" title="复杂系统"></a>复杂系统</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174046214.png" alt="image-20210815174046214" style="zoom:33%;" />

<ol>
<li>大量个体聚集</li>
<li>个体间的运作相对简单，但是叠加后产生群体的复杂行为</li>
<li>能通过不断进化，对环境产生适应性</li>
</ol>
<p>关键词：聚集，进化，适应性，涌现</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174524772.png" alt="image-20210815174524772" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174958056.png" alt="image-20210815174958056" style="zoom:33%;" />

<p>这样简单的三条原则不断循环后，就能发挥超凡的作用。</p>
<p>这就是单体简单-&gt;群体智慧。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815190757944.png" alt="image-20210815190757944" style="zoom:33%;" />



<h3 id="聚焦"><a href="#聚焦" class="headerlink" title="*聚焦"></a>*聚焦</h3><p>四段论：</p>
<ol>
<li><p>清理念头</p>
<p>整理、列出思绪，保证自己没有牵挂心无旁骛</p>
</li>
<li><p>忘我聚焦</p>
<p>进入超高效状态持续2个小时，完成大部分任务</p>
</li>
<li><p>刻意休息</p>
<p>只能玩，强迫自己玩，比如半个小时</p>
</li>
<li><p>惯性工作</p>
<p>接着大体完成的脉络继续，由于之前的基础，可以低能耗的工作。</p>
</li>
</ol>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>这里讲的是工程学里的迭代，尤其是软件开发里的敏捷开发。</p>
<p>找到自己的最小内核，一层一层递归、累加、迭代，最终涌现成为传奇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192540335.png" alt="image-20210815192540335" style="zoom: 25%;" />

<p>在3.0才找到拐点，我们要抱着正确的心理预期，不是每一次迭代都能升级。</p>
<p><strong>精益创业</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192654391.png" alt="image-20210815192654391" style="zoom:25%;" />



<p><strong>适应性</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192932647.png" alt="image-20210815192932647" style="zoom:33%;" />

<p>过犹不及。。彻底失败</p>
<h2 id="七、认知心理学"><a href="#七、认知心理学" class="headerlink" title="七、认知心理学"></a>七、认知心理学</h2><p>认知心理学（cognitive psychology），20 世纪 50 年代中期在西方兴起的一种心理学思潮和研究方向。广义指研究人类的高级心理过程，主要是认识过程，如注意、知觉、表象、记忆、创造性、问题解决、言语和思维等。狭义相当于当代的信息加工心理学。即采用信息加工观点研究认知过程。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>黑马dom&amp;bom预习</title>
    <url>/2021/04/02/%E9%BB%91%E9%A9%ACdom&amp;bom/</url>
    <content><![CDATA[<p>为了应付俩招新而学学黑马</p>
<p>结果学着学着忘记原先目的了。。。</p>
<p>既然都记了这么多了</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330093612480.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330093644248.png"  style="zoom:50%;" />



<p><strong>构造函数首字母大写</strong></p>
<p>this！</p>
<p>!(<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330213907799.png">https://gitee.com/darren-greenhand//picture/raw/master/image-20210330213907799.png</a>)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330214012724.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330225348643.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330225823667.png"></p>
<p>其实函数也能遍历到，但是很少用</p>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><p>对象分：自定义，内置，浏览器对象</p>
<p>前俩是ES里的，浏览器对象是JS独有的</p>
<p>内置对象就是JS自带的，提供了最常用的和最基本的功能</p>
<p>可以查询MDN文档</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330231721351.png"></p>
<p>Math.random()返回一个随机小数 0&lt;= x &lt; 1</p>
<p>MDN提供了以此为基础的得到各种随机数的方法</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>元素是标签</p>
<p>节点：所有内容，标签，属性，。。。</p>
<p>DOM把所有内容看作对象</p>
<p>因为文档页面从上往下加载，所以script</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330233811008.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330234121849.png"></p>
<p>如果没有</p>
<p>小心不要把伪数组当初对象哟</p>
<p>document.querySelector 返回指定选择器的第一个元素对象</p>
<p>document.querySelectorAll</p>
<p>获取<strong>body</strong>直接document.body，HTML 是documentElement</p>
<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><p>事件是可以被JS侦测到的行为</p>
<p>是一种触发–响应机制</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235606717.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235841646.png"></p>
<h2 id="改变内容"><a href="#改变内容" class="headerlink" title="改变内容"></a>改变内容</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235939513.png"></p>
<p>innerHTML是W3C推荐的</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331000356033.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331001227962.png"></p>
<p>所以标签的属性在DOM中被当作属性</p>
<p>记得表单里显示的内容是value属性</p>
<h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p><strong>行内样式（优先级最高）</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331084125584.png"></p>
<p>循环精灵图</p>
<p>onfocus</p>
<p>onblur</p>
<p>提前准备好另一个类，然后修改类名</p>
<p>element.className = “change”</p>
<p>这会覆盖原先的类名</p>
<p>不想覆盖则 .class<strong>Name</strong> += “ new”</p>
<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>先清除其他所有，再给自己设置</p>
<p>onmouseovr          onmouseout</p>
<h2 id="获得属性"><a href="#获得属性" class="headerlink" title="获得属性"></a>获得属性</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331234557420.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331234830475.png"></p>
<p>.removeAttribute(‘index’)</p>
<p>display none/block</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331235859797.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401000324162.png"></p>
<p><strong>自定义属性</strong>（在页面而不是服务器存储并使用数据）</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401000808430.png"></p>
<p>ie11以上才有dataset，一般使用getAttribute</p>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="获得节点"><a href="#获得节点" class="headerlink" title="获得节点"></a>获得节点</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401001133305.png"></p>
<p>dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>f1<span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> f2<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// Object &#123;f1: "foo", f2: "bar"&#125;</span>

console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>f1<span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> f2<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// Object</span>
<span class="token comment">//   f1: "foo"</span>
<span class="token comment">//   f2: "bar"</span>
<span class="token comment">//   __proto__: Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富。</p>
<p>该方法对于输出DOM对象非常有用，因为会显示DOM对象的所有属性。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401001628811.png"></p>
<p><strong>父子关系</strong></p>
<p>node.parentNode(离元素最近的父级节点，找不到返回null)</p>
<p>.node.childNodes()集合(包含元素节点和文本节点等等)，用nodetype加以筛选</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401103705538.png"></p>
<p>非官方但是被广泛支持<strong>：.children</strong>(集合)</p>
<p>.firstChild    .lastChild   这个会返回（元素节点或文本节点，超坑的是换行也是一个文本节点！）</p>
<p>兼容性问题👇IE9</p>
<p>.firstElementChild</p>
<p>.lastElementChild</p>
<p>兄弟节点用的很少</p>
<p>实际开发写法还是用ol.children[0]和ol.children[ol.children.length-1]或者自己知道数量</p>
<p>.node.nextSibling </p>
<p>.node.previousSibling</p>
<p>这俩也会看到文本节点</p>
<p>兼容性问题👇IE9</p>
<p>.node.nextElementSibling</p>
<p>node.previousElementSibling</p>
<h3 id="创建添加节点"><a href="#创建添加节点" class="headerlink" title="创建添加节点"></a>创建添加节点</h3><p>document.createElement(‘li’)</p>
<p>node.appendChild(child) node 父级  child子级</p>
<p>这是后面追加元素</p>
<p>node.insertBefore()</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401152243420.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401155757774.png"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.removeChild() 删的必须是子元素，</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401153308442.png"></p>
<h3 id="复制添加节点"><a href="#复制添加节点" class="headerlink" title="复制添加节点"></a>复制添加节点</h3><p>new = node.cloneNode()</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401154336923.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401160340035.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401160426412.png"></p>
<h1 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h1><h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401162928938.png"></p>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401164058073.png"></p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401164303889.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165042532.png"></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165508731.png"></p>
<p>兼容性问题 e = <strong>e||window.event</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165948856.png"></p>
<p>event有个类似this的属性 currentTarget,没啥鬼用</p>
<p><strong>兼容性问题处理👇</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401170039029.png"></p>
<p><strong>阻止默认行为</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401170434080.png"></p>
<p>或者直接return false; 谁都能用但是return后的代码不执行，而且只用于传统的注册方式</p>
<p>直接preventDefault吧，</p>
<p><strong>阻止冒泡</strong></p>
<p>event.stopPropagation(); 兼容性问题。。</p>
<p>event.cancelBubble;老版本</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172331089.png"></p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172602216.png"></p>
<p>配合e.target就很牛逼</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172819901.png"></p>
<h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><h3 id="禁止右键和选中文字"><a href="#禁止右键和选中文字" class="headerlink" title="禁止右键和选中文字"></a>禁止右键和选中文字</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401193332860.png"></p>
<p>然而做得好的网站也不知道用什么方法防住了偷取内容。。</p>
<h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p>MouseEvent</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401194638742.png"></p>
<p>mousemove 鼠标移动1px就会触发</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401195727163.png"></p>
<p>记得css修改img为position: absolute</p>
<h3 id="键盘数据对象"><a href="#键盘数据对象" class="headerlink" title="键盘数据对象"></a>键盘数据对象</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401200249491.png"></p>
<p>如果一直按着，down和press会一直输出。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401200749931.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401202950239.png"   />



<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205111068.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205237508.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205457047.png"></p>
<p>所以不要声明名叫name的全局变量</p>
<h2 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h2><p><strong>窗口加载</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205732846.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205907695.png"></p>
<p><strong>调整窗口大小</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210145839.png"></p>
<p>只要大小像素变化就会触发resize</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><em><strong>定时器</strong></em></h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210627622.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210647133.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210753231.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401211057397.png"></p>
<p>拯救男主角  clearTimeout(timerID)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401211607592.png"></p>
<p><strong>倒计时！</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401212252996.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401212543518.png"></p>
<h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401213938731.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401214513695.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401214628030.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215019237.png"></p>
<p>如定时器3秒，就是3秒后吧事件放到任务队列中</p>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215151934.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215422449.png"></p>
<p>传递参数</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220658628.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220733210.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220946122.png"></p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator.userAgent对象存储了用户使用的浏览器的信息</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401221612109.png"></p>
<h1 id="网页特效"><a href="#网页特效" class="headerlink" title="网页特效"></a>网页特效</h1><h2 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401221901011.png"></p>
<p>在用后面俩的时候记得加上 + ‘px’</p>
<p>没有带定位的父亲则以一直网上找直到。。body</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401222324755.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401222559804.png"></p>
<h3 id="拖动模态框"><a href="#拖动模态框" class="headerlink" title="拖动模态框"></a>拖动模态框</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401230220830.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401230651020.png"></p>
<h3 id="电商放大图"><a href="#电商放大图" class="headerlink" title="电商放大图"></a>电商放大图</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231203726.png"></p>
<p>大图片是一个图片，overflow:hidden</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231551677.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231934835.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401232233398.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401232246907.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401233200379.png"></p>
<h2 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h2><p>可视区</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401233316513.png"></p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>无需调用，立马自己执行的函数，第二个小括号可以看成是调用函数</p>
<p>最大的作用是独立创建了个作用域</p>
<ol>
<li><p>(function () {} )  ()</p>
<p>如 (function (a.b) {console.log(a+b); } )  (1,2)  //传参</p>
</li>
<li><p>(function () {} () )</p>
</li>
</ol>
<p>很多flexble核心源码是有关这个的</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401234824479.png"></p>
<h2 id="Scroll系列"><a href="#Scroll系列" class="headerlink" title="Scroll系列"></a>Scroll系列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235104065.png"></p>
<p>onscroll事件，滚动事件</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235720069.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235854824.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210402000122850.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210402000256076.png"></p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210402000309513.png"></p>
]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构实现</title>
    <url>/2021/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>考前抱佛脚┭┮﹏┭┮</p>
<p>记住这里大量用了c++的引用。。好方便，但是答题的时候记得换成 *和全局变量</p>
<p>一个算法应该具有以下特性：</p>
<ol>
<li>有穷性</li>
<li>确定性  不存在二义性</li>
<li>可行性</li>
<li>有输入</li>
<li>有输出</li>
</ol>
<p>1&lt;n&lt;log2n&lt;n&lt;nlog2n&lt;n2&lt;n3 (多项式)|| &lt;2n&lt;n!(指数)</p>
<h1 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>SqList 是线性表</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*基本运算：
InitList(&amp;L);
DestoryList(&amp;L);
ListEmpty(L);
ListLength(L);
DispList(L);
GetElem(L,i,&amp;e);
LocateElem(L,e);
ListInsert(&amp;L,i,e);
ListDelete(&amp;L,i,&amp;e);
*/</span>

<span class="token comment">/*线性表的顺序存储
i--; //转化为物理序号
if(i&lt;1 || i>L->length+1) //插入的时候是允许插入第 n+1 位置的，所以还要额外+1
最后不要忘了改一下k的符号
*/</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> SqList<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span>

<span class="token comment">//需要改变的就传入引用，不需要改变的就直接传入指针就好了。</span>
<span class="token keyword">void</span> <span class="token function">CreateList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//用来统计数量，i用来当索引，但是为什么不直接用i呢？</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    L<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListEmpty</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> L<span class="token operator">-></span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DispList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//记住逻辑序号和物理序号差了一个1嗷</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//插入的时候是允许插入最后一个位置的，所以还要额外+1</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//转化为物理序号</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    L<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">></span> L<span class="token operator">-></span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//转换成物理非常重要！</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    L<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//****************************************************************************************************</span>
<span class="token comment">//删除L中所有值等于 x 的元素，双指针扫描</span>
<span class="token keyword">void</span> <span class="token function">delnode1</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            L<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    L<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//用k记录个数</span>
<span class="token keyword">void</span> <span class="token function">delnode2</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            L<span class="token operator">-></span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    L<span class="token operator">-></span>length <span class="token operator">-=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//这一片巧妙利用“缺位，补位”的技巧，节省了许多空间和时间，直接对换会消耗一个额外内存，不如缺位补位</span>
<span class="token comment">//感觉不够通用,不过现在懒得改了，很多二分的其实都是pattition，跟python提供的key函数参数一样</span>
<span class="token keyword">void</span> <span class="token function">partition1</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> L<span class="token operator">-></span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    ElemType pivot <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//中文翻译：枢</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//顺序表归并算法,要求不改变原有的LA和LB</span>
<span class="token keyword">void</span> <span class="token function">UnionList</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>LA<span class="token punctuation">,</span> SqList <span class="token operator">*</span>LB<span class="token punctuation">,</span> SqList <span class="token operator">*</span><span class="token operator">&amp;</span>LC<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//i,j为两组下标</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>LA<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>LB<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>LA<span class="token operator">-></span>length<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>LB<span class="token operator">-></span>length<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        LC<span class="token operator">-></span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    LC<span class="token operator">-></span>length <span class="token operator">=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>p是遍历用的节点，有一个工具节点用来接受创建或者进行删除，insert用s，delete用q</p>
<p>尾插法的工具节点r</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*单链表
记得要设置最后一个是NULL
LinkNode *pre = L,*p = L->next   //这个初始化挺好的！！！
分析多或少1的时候，从开头0各和少数几个的极端情况分析。
头节点L是没有存放数据的，也不算进长度，这就解释了为什么p有时是L有时是L->next，
插入和删除都是先j&lt;i-1找到第i-1然后操作,所以初始化为p = L，因为是对后面那个操作
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> LinkNode<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span>

<span class="token comment">//头插法</span>
<span class="token comment">/*这里如果只传指针的话，只是传了一个指针的副本，相当于告诉你我的地址在这里，你可以修改我地址里的东西，但是这没有什么意义，因为我需要操作的是这个指针，不然操作全都传不回去，相当于你把一个副本连在一个结构里了，虽然这个副本和原来的指针有着相同的地址，但是此时我并不需要这个地址，我此时需要的是指针本身。加引用才是把原本的指针传过来了。*/</span>
<span class="token keyword">void</span> <span class="token function">CreateListF</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>s<span class="token punctuation">;</span> <span class="token comment">//工具节点上线</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//经典创建</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
        L<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token comment">//头插四件套</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//尾插法</span>
<span class="token keyword">void</span> <span class="token function">CreateListR</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> L<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        r <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//这个初始化挺好的！！！</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后一步别忘了！！</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListEmpty</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        n<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DispList</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//别漏了</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        e <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//</span>
<span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//逻辑修正</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
        s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">//多检验一次，因为检验不到这里</span>
<span class="token comment">/*不如直接if(!(p &amp;&amp; p->next)) return false;*/</span>
        e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//****************************************************************************************************</span>
<span class="token comment">//删除一个单链表L中元素最大的节点（假设唯一）插入一个标记就好了</span>
<span class="token keyword">void</span> <span class="token function">delmaxnode</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>pre <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>maxp <span class="token operator">=</span> p<span class="token punctuation">,</span> <span class="token operator">*</span>maxpre <span class="token operator">=</span> pre<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxp<span class="token operator">-></span>data <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            maxp <span class="token operator">=</span> p<span class="token punctuation">;</span>
            maxpre <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    maxpre<span class="token operator">-></span>next <span class="token operator">=</span> maxp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>maxp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//使元素递增有序排列，没有想象中巧妙</span>
<span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
    L<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//p接下了第二个节点，原来的头和首被当作了新的有序链表</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//保存原来剩下的链</span>
        pre <span class="token operator">=</span> L<span class="token punctuation">;</span>     <span class="token comment">//每次pre都从头扫描一遍。。。</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>next<span class="token operator">-></span>data <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span>
            pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//找到合适的位置</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>
        pre<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//p接在这</span>
        p <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment">//去q保存的地方继续操作</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">UnionList1</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>LA<span class="token punctuation">,</span>LinkNode <span class="token operator">*</span>LB<span class="token punctuation">,</span>LinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    LinkNode <span class="token operator">*</span>pa <span class="token operator">=</span> LA<span class="token operator">-></span>next<span class="token punctuation">,</span><span class="token operator">*</span>pb <span class="token operator">=</span> LB<span class="token operator">-></span>next<span class="token punctuation">,</span><span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token operator">*</span>s<span class="token punctuation">;</span><span class="token comment">//尾插法和创建</span>
    LC <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pa<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pb<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">-></span>data <span class="token operator">&lt;</span> pb<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            s <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s<span class="token operator">-></span>data <span class="token operator">=</span> pa<span class="token operator">-></span>data<span class="token punctuation">;</span>
            r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
            r <span class="token operator">=</span> s<span class="token punctuation">;</span>
            pa <span class="token operator">=</span> pa<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>pb<span class="token operator">-></span>data <span class="token operator">></span> pa<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            s <span class="token operator">=</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s<span class="token operator">-></span>data <span class="token operator">=</span> pb<span class="token operator">-></span>data<span class="token punctuation">;</span>
            r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
            r <span class="token operator">=</span> s<span class="token punctuation">;</span>
            pb <span class="token operator">=</span> pb<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pa<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> pa<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        r <span class="token operator">=</span> s<span class="token punctuation">;</span>
        pa <span class="token operator">=</span> pa<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pb<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> pb<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        r <span class="token operator">=</span> s<span class="token punctuation">;</span>
        pb <span class="token operator">=</span> pb<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*双链表
return true;//不要漏了
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DNode</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>prior<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">DNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> DLinkNode<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span>

<span class="token comment">//建立头插法</span>
<span class="token keyword">void</span> <span class="token function">CreateListF</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DLinkNode <span class="token operator">*</span>s<span class="token punctuation">;</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token comment">//一共要链4条，但是这一条可能不需要链接👇</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            L<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
        L<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">CreateListR</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DLinkNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
    L <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> L<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        s<span class="token operator">-></span>prior <span class="token operator">=</span> r<span class="token punctuation">;</span>
        r <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//其余操作很多类似单链表，插入和删除有点区别罢了,工具节点叫s</span>
bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
        s<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token comment">//不要漏了</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//****************************************************************************************************</span>
<span class="token comment">//工具节点叫q</span>
bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> i <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">;</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            q<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//逆置,头插法就能进行逆置,头节点还能保留</span>
<span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        p<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            L<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token operator">-></span>prior <span class="token operator">=</span> L<span class="token punctuation">;</span>
        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        p <span class="token operator">=</span> q<span class="token punctuation">;</span> <span class="token comment">//继续指向后继节点</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//双链表的删除是不需要工具节点的，这里用一个循环双链表的例子展示一下,删除第一个data为x的节点</span>
bool <span class="token function">delelem</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//不需要工具点，p可以直接指向操作节点，而不是前一个</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> L <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> x<span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> L<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token operator">-></span>prior<span class="token punctuation">;</span>
        p<span class="token operator">-></span>prior<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//循环双链表判断对称</span>
bool <span class="token function">Symm</span><span class="token punctuation">(</span>DLinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    bool same <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//这类题的典型flag</span>
    DLinkNode <span class="token operator">*</span>p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>
    DLinkNode <span class="token operator">*</span>q <span class="token operator">=</span> L<span class="token operator">-></span>prior<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>same<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span>
            same <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q <span class="token operator">||</span> p <span class="token operator">==</span> q<span class="token operator">-></span>prior<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//当相等（奇数）或相邻（偶数），为结束条件</span>
            q <span class="token operator">=</span> q<span class="token operator">-></span>prior<span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> same<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h1><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> SqStack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqStack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    s<span class="token operator">-></span>top<span class="token operator">++</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//判断字符串是否为对称串</span>
bool <span class="token function">Symmetry</span><span class="token punctuation">(</span>ElemType str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    ElemType e<span class="token punctuation">;</span>
    SqStack <span class="token operator">*</span>st<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">Pop</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
共享栈，适用于一方可能用到满，另一方还有很多空间
栈空：top1 == -1   top2 == MAXSIZE
栈满：top1 ==top2-1
进栈出栈的时候top2的操作和top1是反的
循环队列A[0..n-1]存放其元素值，F表示队头元素所在的前一个位置，R表示队尾元素的位置。则当前队列中的元素数是
当R>F时，元素个数为  R-F个
当R&lt;F时，元素个数为 n - （F-R）= R-F+n个
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//选用带头结点的，更加便捷</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">linknode</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    linknode <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> LinkStNode<span class="token punctuation">;</span> <span class="token comment">//这名字真长</span>

<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStNode <span class="token operator">*</span>pre <span class="token operator">=</span> s<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    p <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
    p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">Pop</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    e <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
    s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">GetTop</span><span class="token punctuation">(</span>LinkStNode <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//迷宫问题和逆波兰表达式在P87</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在队头进行删除，在队尾进行插入</span>
<span class="token comment">//记住，front指的是空的地方</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Elemtype<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    Elemtype data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> SqQueue<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    q <span class="token operator">=</span> <span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestoryQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">enQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    q<span class="token operator">-></span>rear<span class="token operator">++</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">deQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    q<span class="token operator">-></span>front<span class="token operator">++</span><span class="token punctuation">;</span>
    e <span class="token operator">=</span> q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/****************************************************************************************/</span>
<span class="token comment">//环形队列</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    q <span class="token operator">=</span> <span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//不是-1了</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">enQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE <span class="token operator">==</span> q<span class="token operator">-></span>front<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>
    q<span class="token operator">-></span>data<span class="token punctuation">[</span>q<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">dequeue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    q<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAXSIZE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//这两个if判断条件挺有趣的</span>
<span class="token comment">//队列非常有层次感，有很多妙用，既可以用于递归层次，又可以用于重复</span>
<span class="token comment">//比如书上这个很强的1212报到1出列的问题</span>
<span class="token keyword">void</span> <span class="token function">number</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    ElemType e<span class="token punctuation">;</span>
    SqQueue <span class="token operator">*</span>q<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">enQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"报数出列顺序：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">enQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//偶数惨遭重新排队哈哈</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DestoryQueue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//还可以定制双端队列什么的，其实原理都差不多</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">qnode</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">qnode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> DataNode<span class="token punctuation">;</span>

<span class="token comment">//需要一个链队节点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    DataNode <span class="token operator">*</span>front<span class="token punctuation">;</span>
    DataNode <span class="token operator">*</span>rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> LinkQuNode<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkQuNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyQueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DataNode <span class="token operator">*</span>pre <span class="token operator">=</span> q<span class="token operator">-></span>front<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
            p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这个怎么总是忘掉啊！</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span> <span class="token comment">//因为无限长度，所以类型是bool</span>
<span class="token punctuation">&#123;</span>
    DataNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    p <span class="token operator">=</span> <span class="token punctuation">(</span>DataNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
    p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//还要判断是不是空列表！！！</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        q<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
        q<span class="token operator">-></span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">dequeue</span><span class="token punctuation">(</span>LinkQuNode <span class="token operator">*</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    DataNode <span class="token operator">*</span>t<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    t <span class="token operator">=</span> q<span class="token operator">-></span>front<span class="token punctuation">;</span><span class="token comment">//两种情况都可以先将t指过来</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>front <span class="token operator">==</span> q<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token comment">//只有一个节点</span>
        q<span class="token operator">-></span>front <span class="token operator">=</span> q<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        q<span class="token operator">-></span>front <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="3-串"><a href="#3-串" class="headerlink" title="3.串"></a>3.串</h1><h2 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">若串S<span class="token operator">=</span>′software′<span class="token punctuation">,</span>其子串的数目是<span class="token punctuation">(</span><span class="token punctuation">)</span>
字符串的子串，就是字符串中的某一个连续片段。截取一个字符串长度需要一个起始位置和结束位置。字符串“software”有<span class="token number">8</span>个字符，可是设置间隔的位置有<span class="token number">9</span>个，使用<span class="token function">C</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">36</span>即可求得字符串“software”的所有子串。因为题目标明空串也是子串，故还需要加上<span class="token number">1</span>，总共<span class="token number">37</span>个子串。所以答案选<span class="token number">37</span>
空格串是指由空格字符所组成的字符串，其长度等于空格个数。 。
组成串的数据元素只能是字符。
<span class="token comment">/*
StrAssign(&amp;s,cstr)将cstr字符串内容赋给s
DestoryStr(&amp;s)销毁串
StrCopy(&amp;s,t)串复制，将串t赋给串s
StrEqual(s,t)
StrLength(s)
Concat(s,t)返回一个新串，不改变原来的串
SubStr(s,i,j)求子串
InsStr(s1,i,s2)字串插入
DelStr(s,i,j)字串删除
RepStr(s,i,j,t)字串替换
DispStr(s)串输出
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> SqString<span class="token punctuation">;</span>

<span class="token comment">//把字符串转换成串的数据结构</span>
<span class="token keyword">void</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span>length <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestoryStr</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//因为这个不是malloc分配的，会自动回收</span>
<span class="token keyword">void</span> <span class="token function">StrCopy</span><span class="token punctuation">(</span>SqString <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>length <span class="token operator">=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//判断相等</span>
bool <span class="token function">StrEqual</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    bool same <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">!=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//能用长度排除就直接去世吧</span>
        same <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                same <span class="token operator">=</span> false<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> same<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">StrLength</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//链接</span>
SqString <span class="token function">Concat</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    SqString str<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">+</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>s<span class="token punctuation">.</span>length <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//从这时起，下标注意进行简单的计算</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求子串，返回从第i个字符开始的，连续j个字符组成的字串</span>
SqString <span class="token function">SubStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    SqString str<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> 
        <span class="token comment">//i+j-1注意一下下，理解不了就最简单的i=1,j=2,s</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//i-1开始，因为逻辑和物理差1</span>
    <span class="token punctuation">&#123;</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//这个里面的加减1有点骚，理解好了这类题就不怕了。</span>
SqString <span class="token function">IntStr</span><span class="token punctuation">(</span>SqString s1<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> SqString s2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    SqString str<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s1<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//插入的时候是可以多插一位的</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>                  <span class="token comment">//返回空串</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>s2<span class="token punctuation">.</span>length <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s1<span class="token punctuation">.</span>length <span class="token operator">+</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

SqString <span class="token function">DelStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    SqString str<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//便于返回空串</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">-</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> j<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//将i开始到j的字串用t替换</span>
<span class="token comment">//我好像有点明白了，他在for循环里用的索引对标某个长度，很简单，其他的操作通过改变数组索引的表达式来实现。</span>
SqString <span class="token function">RepStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    SqString str<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        str<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>length <span class="token operator">-</span> j <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    str<span class="token punctuation">.</span>length <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> j <span class="token operator">+</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DispStr</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//比较大小</span>
<span class="token keyword">int</span> <span class="token function">Strcmp</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> comlen<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        comlen <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        comlen <span class="token operator">=</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//这里也包括了相等的情况</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> comlen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">==</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">></span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求s中出现的第一个最长连续相同字符构成的平台，用index开始索引，maxlen保存长度</span>
<span class="token keyword">void</span> <span class="token function">LongestString</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>index<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>maxlen<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    index <span class="token operator">=</span> maxlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">;</span> <span class="token comment">//用来保存局部的  这种全局和局部都有对应的变量！</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//留个物理索引</span>
        length <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            length<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxlen <span class="token operator">&lt;</span> length<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            maxlen <span class="token operator">=</span> length<span class="token punctuation">;</span>
            index <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">//Brute-Force</span>
<span class="token keyword">int</span> <span class="token function">BF</span><span class="token punctuation">(</span>SqString s<span class="token punctuation">,</span> SqString t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//i回退到最初的后一位，j清空</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>i<span class="token operator">-</span>t<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="链串（堆串）"><a href="#链串（堆串）" class="headerlink" title="链串（堆串）"></a>链串（堆串）</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token comment">//链串的创建都是用尾插法，因此都有一个工具节点r</span>
<span class="token comment">//带头节点的单链表作为链串，结点大小是每个结点存储的字符个数,未占用的用特殊符号（#）填补</span>
<span class="token comment">//链串中，节点大小越大，存储密度越大，基本操作有所不便，适合很少修改的情况，这里规定大小为1</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">snode</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span> <span class="token comment">//存放字符</span>
    <span class="token keyword">struct</span> <span class="token class-name">snode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> LinkStrNode<span class="token punctuation">;</span>

<span class="token comment">//要用尾插法保证顺序</span>
<span class="token keyword">void</span> <span class="token function">StrAssign</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">-></span>data <span class="token operator">=</span> cstr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
        r <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStrNode <span class="token operator">*</span>pre <span class="token operator">=</span> s<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">StrCopy</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">StrEqual</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//直接比较本身</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">==</span> q<span class="token operator">-></span>data<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q<span class="token operator">-></span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">StrLength</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//链接两个数组其实就是分别遍历一遍</span>
LinkStrNode <span class="token operator">*</span><span class="token function">Concat</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    p <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//这样直接转过来，少一个工具节点，是我蠢了</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//当参数不正确的时候返回一个空串，这里需要调用之前已经封装好的函数</span>
LinkStrNode <span class="token operator">*</span><span class="token function">Substr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span> <span class="token comment">//经典四件套哈哈</span>
    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//先把空串准备好在这里</span>
    r <span class="token operator">=</span> str<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这里的k取得是1，因为要取到逻辑顺序第i位的前一位，而不是物理顺序</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//怎么感觉这里所有的其实都差不多，都是链表啊啥的，没啥意思</span>

LinkStrNode <span class="token operator">*</span><span class="token function">InsStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>
    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> str<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p1<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p1 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//这个基本上都是完全一样的，直接copy一部分，瞬间刷完，我吐了，这些那么相似的还搞</span>
LinkStrNode <span class="token operator">*</span><span class="token function">DelStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这里的k应该是0，因为这个就不是逻辑序号，而是物理上的序号了</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

LinkStrNode <span class="token operator">*</span><span class="token function">RepStr</span><span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> LinkStrNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    LinkStrNode <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>
    str <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token function">StrLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这样的其实也是逻辑，所以i-1，使用哪种看自己喜欢吧</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStrNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkStrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token operator">-></span>data <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>
        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>
        r <span class="token operator">=</span> q<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    r<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//好垃圾啊，，真的全都一样的，我感觉我都能背下来了</span>

<span class="token keyword">void</span> <span class="token function">DispStr</span><span class="token punctuation">(</span>LinkStrNode s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    LinkStrNode <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h1><p>只要确保了子结构和大结构 <strong>结构一致</strong>，就不用考虑过多细节，在设计算法的时候留意递归调用的意义，比如求树的深度，在某个地方需要子树的深度了，<strong>就直接调用就好</strong>，只用关心你这最宏观的一层，不用考虑内在的东西，这就是递归的魔力。因此【递归模型】非常重要</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在算法设计中，任何间接递归都可以转换为直接递归，这是自顶向下，同时考虑最底部的</span>
<span class="token comment">//如果递归过程或者递归函数的递归调用语句是最后一条执行语句，则称为尾递归</span>
<span class="token comment">/* 三个条件：
1.问题可以转化为1个或多个
2.递归调用的次数必须是有限的
3.必须有用来结束递归的条件
*/</span>
用到递归的三种情况：
<span class="token number">1.</span> 数学公式，数列本身的定义就是递归的，比如n！和斐波那契数列
<span class="token number">2.</span> 数据结构是递归的，比如指向本身的链表，对于这样的结构，递归方法既方便又有效
但是要注意大结构和小结构保持一致性，比如对单链表设计递归算法时，通常采用不带头结点的单链表。
<span class="token keyword">int</span> <span class="token function">Sum</span><span class="token punctuation">(</span>LinkNode <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data <span class="token operator">+</span> <span class="token function">Sum</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token number">3.</span> 问题的求解是递归的，比如汉诺塔P149
<span class="token keyword">void</span> <span class="token function">Hanoil</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">char</span> X<span class="token punctuation">,</span><span class="token keyword">char</span> Y<span class="token punctuation">,</span><span class="token keyword">char</span> Z<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将第%d个盘片从%c移动到%c"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">)</span>
	<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
		<span class="token function">Hanoil</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">,</span>Y<span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将第%d个盘片从%c移动到%c"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Z<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>递归模型：递归出口和递归体，可以看P150</strong></p>
<p>可以说递归的思想来自数学归纳法</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">char</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
    bool flag<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> StackType<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyStack</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
bool <span class="token function">Push</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    s<span class="token operator">-></span>top<span class="token operator">++</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">Pop</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
    s<span class="token operator">-></span>top<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">GetTop</span><span class="token punctuation">(</span>StackType <span class="token operator">*</span>s<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    e <span class="token operator">=</span> s<span class="token operator">-></span>data<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
共享栈，适用于一方可能用到满，另一方还有很多空间
栈空：top1 == -1   top2 == MAXSIZE
栈满：top1 ==top2-1
进栈出栈的时候top2的操作和top1是反的
*/</span>

<span class="token comment">//********************************************************************</span>
<span class="token comment">//一般，尾递归算法可以通过循环或者迭代转换为等价的非递归算法</span>
<span class="token keyword">int</span> <span class="token function">Fib2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            s <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
            a <span class="token operator">=</span> b<span class="token punctuation">;</span>
            b <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*对于不是尾递归的复杂递归，可以在 理解递归调用实现过程 的基础上
用栈来模拟递归执行过程(这是关键啊)，从而将其转换为等价的非递归算法*/</span>
<span class="token comment">//汉诺塔问题的非递归实现：注意栈的结构决定了e1,e3的push顺序和实际执行顺序相反！</span>

<span class="token keyword">void</span> <span class="token function">Hanoi2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">,</span> <span class="token keyword">char</span> z<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    StackType <span class="token operator">*</span>st<span class="token punctuation">;</span>
    ElemType e<span class="token punctuation">,</span> e1<span class="token punctuation">,</span> e2<span class="token punctuation">,</span> e3<span class="token punctuation">;</span> <span class="token comment">//一共要用到这么多变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    e<span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    e<span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    e<span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>
    <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">Pop</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>flag <span class="token operator">==</span> false<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            e1<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            e1<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
            e1<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
            e1<span class="token punctuation">.</span>z <span class="token operator">=</span> e<span class="token punctuation">.</span>z<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e1<span class="token punctuation">.</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
                e1<span class="token punctuation">.</span>flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                e1<span class="token punctuation">.</span>flag <span class="token operator">=</span> false<span class="token punctuation">;</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>

            e2<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n<span class="token punctuation">;</span>
            e2<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
            e2<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>

            e3<span class="token punctuation">.</span>n <span class="token operator">=</span> e<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            e3<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
            e3<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>z<span class="token punctuation">;</span>
            e3<span class="token punctuation">.</span>z <span class="token operator">=</span> e<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e3<span class="token punctuation">.</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
                e3<span class="token punctuation">.</span>flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                e3<span class="token punctuation">.</span>flag <span class="token operator">=</span> false<span class="token punctuation">;</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> e3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"将%d个盘片从%c移动到%c\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>n<span class="token punctuation">,</span> e<span class="token punctuation">.</span>x<span class="token punctuation">,</span> e<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">DestroyStack</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//递归算法执行中，最长的递归调用的链长称为该算法的递归调用深度</span>
<span class="token comment">/*设计队规算法的基本步骤是先确定问题的递归模型，再转化成C/C++语言的函数
确定递归模型的步骤是：
1. 对原问题f(n)进行分析，假设出合理的小问题f(n-1)
2. 给出f(n)与f(n-1)甚至更多项之间的关系，也就是确定递归体，也
就是数学归纳法中的假设i = n-1成立，求证 i =n
3. 找到特定情况如f(1)作为递归出口 
4. 注意栈的次序和你的逻辑次序可能需要一定的调整*/</span>


<span class="token comment">//有0~i个元素，求最小值，思路是找到前面的最小值</span>
<span class="token keyword">double</span> <span class="token function">Min</span><span class="token punctuation">(</span><span class="token keyword">double</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> min<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        min <span class="token operator">=</span> <span class="token function">Min</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> min<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><p>通常只有读和写两种操作。</p>
<p>每个元素占k个存储单元，则LOC(ai) = LOC(a1)+(i-1) x k</p>
<p>二维数组大家都是按行存放的，为啥要搞出按列来。</p>
<h2 id="特殊矩阵压缩"><a href="#特殊矩阵压缩" class="headerlink" title="特殊矩阵压缩"></a>特殊矩阵压缩</h2><p>对于ai,j  = bk</p>
<ol>
<li><p>对称矩阵 P169</p>
<p>k = i(i+1)/2 + j   i&gt;=j                     k= j(j+1)/2  +i  j&gt;=i</p>
</li>
<li><p>下三角和对称矩阵十分相似，但是上三角还是有点差距的，最后一位有一个常数c P70</p>
<p>上三角：k = i(2n-i+1)/2 +j-i   i&lt;=j           n(n+1)/2   i&gt;j</p>
<p>下三角：k = i(i+1)/2 + j   i&gt;=j                  n(n+1)/2   i&lt;j</p>
</li>
<li><p>三对角矩阵且存储到一维数组时，k = 2i+j   b = 1</p>
</li>
</ol>
<p>这样的压缩存储只需在算法中按公式作映射就可以实现随机存取</p>
<h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p>非零元素具有随机性，用三元组表，十字链表比较复杂来存取</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">100</span>       </span><span class="token comment">//行数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">200</span>       </span><span class="token comment">//列数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>      <span class="token comment">//行号</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>      <span class="token comment">//列号</span>
    ElemType d<span class="token punctuation">;</span> <span class="token comment">//元素值</span>
<span class="token punctuation">&#125;</span> TupNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> rows<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cols<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nums<span class="token punctuation">;</span>
    TupNode data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> TSMatrix<span class="token punctuation">;</span>

<span class="token comment">//从二维稀疏矩阵创建三元组表示,有点新奇哈哈</span>
<span class="token keyword">void</span> <span class="token function">CreateMat</span><span class="token punctuation">(</span>TSMatrix <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> ElemType A<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span>rows <span class="token operator">=</span> M<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span>cols <span class="token operator">=</span> N<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
                t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>t<span class="token punctuation">.</span>nums<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> j<span class="token punctuation">;</span>
                t<span class="token punctuation">.</span>nums<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//三元组元素的赋值，不存在（0）时插入一个非零元素，存在时修改要理解好他这个数据结构是怎样的</span>
bool <span class="token function">Value</span><span class="token punctuation">(</span>TSMatrix <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> ElemType x<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k1<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> t<span class="token punctuation">.</span>rows <span class="token operator">||</span> j <span class="token operator">>=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//这个查找方式。。。秀啊</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> j<span class="token punctuation">)</span>
        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//存在这样的非0元素</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>k1 <span class="token operator">=</span> t<span class="token punctuation">.</span>nums <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k1 <span class="token operator">>=</span> k<span class="token punctuation">;</span> k1<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//这里注意带 =，不然第k项原本有意义的就被覆盖了</span>
        <span class="token punctuation">&#123;</span>
            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>
            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">;</span>
            t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>
        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> j<span class="token punctuation">;</span>
        t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> x<span class="token punctuation">;</span>
        t<span class="token punctuation">.</span>nums<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//最终四步处理</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


bool <span class="token function">Assign</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> t<span class="token punctuation">.</span>rows <span class="token operator">||</span> j <span class="token operator">>=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> j<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        x <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//返回0</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DispMat</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>nums <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t%d\t%d\t%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>rows<span class="token punctuation">,</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t------------------------\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\t%d\t%d\t%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">,</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//转置，把列号放在前面，那就要依次查找列号，高效的是快速转置</span>
<span class="token keyword">void</span> <span class="token function">TranTat</span><span class="token punctuation">(</span>TSMatrix t<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>tb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">,</span> k1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token comment">//k1记录tb中的元素个数</span>
    tb<span class="token punctuation">.</span>rows <span class="token operator">=</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">;</span>
    tb<span class="token punctuation">.</span>cols <span class="token operator">=</span> t<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>
    tb<span class="token punctuation">.</span>nums <span class="token operator">=</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>nums <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>cols<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//每一列都完整的遍历一遍，效率巨低。</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>nums<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">==</span> v<span class="token punctuation">)</span>
                <span class="token punctuation">&#123;</span>
                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">;</span>
                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>
                    tb<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k1<span class="token punctuation">]</span><span class="token punctuation">.</span>d <span class="token operator">=</span> t<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>
                    k1<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//接下来是十字链表的数据结构P178</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Max</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">?</span> M <span class="token operator">:</span> N<span class="token punctuation">)</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">mtxn</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> row<span class="token punctuation">;</span>
    <span class="token keyword">int</span> col<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mtxn</span> <span class="token operator">*</span>right<span class="token punctuation">,</span> <span class="token operator">*</span>down<span class="token punctuation">;</span>  <span class="token comment">//向右循环的行指针和向下循环的列指针</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">&#123;</span>
        ElemType value<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">mtxn</span> <span class="token operator">*</span>link<span class="token punctuation">;</span> <span class="token comment">//指向下个头节点</span>
    <span class="token punctuation">&#125;</span> tag<span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span> MatNode<span class="token punctuation">;</span>

<span class="token comment">//代价是运算算法比较复杂</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表的特征：</p>
<ol>
<li>广义表中的数据元素是有相对次序的</li>
<li>长度定义为最外层包含元素的个数</li>
<li>深度定义为包含括弧的重数，原子的深度为0，空表的深度为1</li>
<li>广义表可以共享，这种叫再入表</li>
<li>广义表可以是一个递归表，一个广义表可以是自己的子表，这种叫递归表，深度∞，长度有限</li>
</ol>
<p>不讨论再入表和递归表，小写字母表示原子，大写字母表示广义表的表名</p>
<p>没有给出表明的叫做<em>匿名表</em> ，用 <strong>·</strong> 表示</p>
<p>表头：head（GL）叫做表头，取第一个元素，tail（GL）为其余所有部分（<strong>包括原来的括号</strong>），显然一个广义表的表尾始终为一个广义表，空表无表头表尾：</p>
<p>A（）无表头表尾</p>
<p>B（e） 表头e   表尾（） <strong>空的也会被算上！！</strong></p>
<p>C（a，· （b,c,d）） 表头 a   表尾（（b,c,c））<strong>注意有两层括号</strong>，看来表尾会保持原有的深度</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">lnode</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> tag<span class="token punctuation">;</span> <span class="token comment">//标识符 0为原子节点，1为表节点</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">&#123;</span>
        ElemType data<span class="token punctuation">;</span>         <span class="token comment">//存放数据值</span>
        <span class="token keyword">struct</span> <span class="token class-name">lnode</span> <span class="token operator">*</span>sublist<span class="token punctuation">;</span> <span class="token comment">//指向子表的指针</span>
    <span class="token punctuation">&#125;</span> val<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">lnode</span> <span class="token operator">*</span>link<span class="token punctuation">;</span> <span class="token comment">//同一层的下一个元素</span>
<span class="token punctuation">&#125;</span> GLNode<span class="token punctuation">;</span>

<span class="token comment">//tag = 1的节点可以看成是一个单链表的头节点，指向子表的首节点,通过递归性，有两种解法</span>
<span class="token comment">//解法1，把整个看成一个带头节点的单链表，种类分原子和子表，子表类似整个表，而原子则仅仅是原子处理罢了。</span>
<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">fun1</span><span class="token punctuation">(</span>gl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//z</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原子处理语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//处理后继元素</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//解法2，对于元素节点，其兄弟域的节点和整个广义表是相似的，对于表节点，其元素域和兄弟域的处理均与整个广义表相似</span>
<span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment">//为子表</span>
            <span class="token function">fun2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先递归处理表节点的元素域</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原子处理语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">fun2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理两种节点的兄弟（不用分类，因为无论什么节点，兄弟都相似于整个表）</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//实际问题中根据求解问题的特点自行选择其中来设计递归求解，比如计数：</span>
<span class="token keyword">int</span> <span class="token function">Count1</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            n <span class="token operator">+=</span> <span class="token function">Count1</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>
        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">Count2</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            n <span class="token operator">+=</span> <span class="token function">Count2</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            n<span class="token operator">++</span><span class="token punctuation">;</span>
        n <span class="token operator">+=</span> <span class="token function">Count2</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>



<span class="token keyword">int</span> <span class="token function">GLLength</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    GLNode <span class="token operator">*</span>gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        n<span class="token operator">++</span><span class="token punctuation">;</span>
        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//只用算最表层的哈哈</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">GLDepth</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    GLNode <span class="token operator">*</span>gl<span class="token punctuation">;</span>
    <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dep<span class="token punctuation">;</span> <span class="token comment">//maxd是同一层子表中深度的最大值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    gl <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>gl <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">//这下面这个操作还是挺妙的</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>gl <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>gl<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            dep <span class="token operator">=</span> <span class="token function">GLDepth</span><span class="token punctuation">(</span>gl<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//dep代表该节点的深度！自顶向下</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dep <span class="token operator">></span> maxd<span class="token punctuation">)</span>
                maxd <span class="token operator">=</span> dep<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        gl <span class="token operator">=</span> gl<span class="token operator">-></span>link<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>maxd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回这一层的最大值到上一层的节点</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//要输出成括号的形式还是有点麻烦的，元素直接输出值，子表则输出 ‘（’，空表输出‘#’，非空子表递归，再输出‘）’</span>
<span class="token comment">//这里其实用到的就是递归思想，仅考虑一层。非常简单</span>
<span class="token keyword">void</span> <span class="token function">DispGL</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">DispGL</span><span class="token punctuation">(</span>g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这个括号不要漏了</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">-></span>link <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">DispGL</span><span class="token punctuation">(</span>g<span class="token operator">-></span>link<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//兄弟应该在子表后面输出</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//与输出对应的，建立广义表的链式存储结构,记得空表是 “#”，遇到则将g->val.sublist置空</span>
<span class="token comment">//扫描到 （ 则用g递归开启一个子表节点，遇到 ）说明已经处理完，g置空</span>
<span class="token comment">//时空复杂的均为O（n）</span>
<span class="token comment">//切记把链式结构和符号表示分开想，不要混在一起！</span>

<span class="token comment">//巧妙地递归逻辑，配合引用参数（注意这里默认一个元素是‘单个’字符）</span>
<span class="token comment">//这里我一开始理解难受是因为它既有嵌套递归，又有把子任务视为平级的递归，害。</span>
GLNode <span class="token operator">*</span><span class="token function">CreateGL</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    GLNode <span class="token operator">*</span>g<span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//取一个字符,直接操作指针的话，便于后续调用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        g <span class="token operator">=</span> <span class="token punctuation">(</span>GLNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            g<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist <span class="token operator">=</span> <span class="token function">CreateGL</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span>
            g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'#'</span><span class="token punctuation">)</span>
            g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            g<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            g<span class="token operator">-></span>val<span class="token punctuation">.</span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        g <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//若s扫描完，把g置空</span>
    ch <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">','</span><span class="token punctuation">)</span>
            g<span class="token operator">-></span>link <span class="token operator">=</span> <span class="token function">CreateGL</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            g<span class="token operator">-></span>link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> g<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//采用解法1,递归销毁，注意要灵活一点，顺序什么的不影响那么怎样方便怎样来</span>
<span class="token keyword">void</span> <span class="token function">DestroyGL</span><span class="token punctuation">(</span>GLNode <span class="token operator">*</span><span class="token operator">&amp;</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    GLNode <span class="token operator">*</span>g1<span class="token punctuation">,</span> <span class="token operator">*</span>g2<span class="token punctuation">;</span>
    g1 <span class="token operator">=</span> g<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>g1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>g1<span class="token operator">-></span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            g2 <span class="token operator">=</span> g1<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//保存兄弟节点</span>
            <span class="token function">free</span><span class="token punctuation">(</span>g1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            g1 <span class="token operator">=</span> g2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            g2 <span class="token operator">=</span> g1<span class="token operator">-></span>link<span class="token punctuation">;</span>
            <span class="token function">DestroyGL</span><span class="token punctuation">(</span>g1<span class="token operator">-></span>val<span class="token punctuation">.</span>sublist<span class="token punctuation">)</span><span class="token punctuation">;</span>
            g1 <span class="token operator">=</span> g2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>









<h1 id="6-树"><a href="#6-树" class="headerlink" title="6.树"></a>6.树</h1><h2 id="基本和存储"><a href="#基本和存储" class="headerlink" title="基本和存储"></a>基本和存储</h2><p>有树形表示法，文氏图表示法，凹入表示法和括号表示法等等。</p>
<p>树的定义是递归的，树的性质在P192</p>
<ol>
<li>结点数 = 所有节点的出度（其实就是边数） + 1</li>
<li>度为m的树（就是节点中最大出度为m）中第i层上最多有m^(i-1)个节点，若每一层都是满的，称为满m次树</li>
<li>高度为h的m次树最多有(m^h - 1)/(m-1) 个节点</li>
<li>具有n个结点的m次树的最小高度为logm(n(m-1)+1)向大取整</li>
</ol>
<p>其实性质2，3，4说的都是一种情况。。。</p>
<p>对于m次树，含有n个节点，那么最大高度maxh = n - (m-1) 显然，除了最后一个节点，其他度都为1就好了</p>
<p>基本运算有寻找特定节点，插入/删除特定节点，<strong>遍历</strong></p>
<p>遍历的先中后原来是根节点的输出次序，一般都习惯先左后右。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//存储结构</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token comment">//1.双亲存储，顺序存储，根节点的父节点设置为-1，其余设置为父节点在顺序中的位置</span>
<span class="token comment">//求双亲容易，但是求某个节点的子节点难，要遍历整个存储结构</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSons</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设树的度为100</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> PTree<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//2.子链存储，每个节点有指向所有孩子结点的指针，因为难以确定数目，统一用最大的【树的度】来分配</span>
<span class="token comment">//找双亲费时，找孩子很方便，树的度与平均度偏差较大时，浪费</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSons</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设树的度为100</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>sons<span class="token punctuation">[</span>MaxSons<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> TSonNode<span class="token punctuation">;</span>
<span class="token comment">//以此为基础求树的高度</span>
<span class="token keyword">int</span> <span class="token function">TreeHeight1</span><span class="token punctuation">(</span>TSonNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    TSonNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> h<span class="token punctuation">,</span> maxh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxSons<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            p <span class="token operator">=</span> t<span class="token operator">-></span>sons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                h <span class="token operator">=</span> <span class="token function">TreeHeight1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求子树的深度</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxh <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
                    maxh <span class="token operator">=</span> h<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>maxh <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//3.孩子兄弟链，每个节点三个域，一个元素，一个指向长子，一个指向兄弟</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tnode</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tnode</span> <span class="token operator">*</span>hp<span class="token punctuation">;</span> <span class="token comment">//指向兄弟 horizontal point</span>
    <span class="token keyword">struct</span> <span class="token class-name">tnode</span> <span class="token operator">*</span>vp<span class="token punctuation">;</span> <span class="token comment">//指向孩子 vertical point</span>
<span class="token punctuation">&#125;</span> TSBNode<span class="token punctuation">;</span>
<span class="token comment">//其实这种结构是把树转换为二叉树的存储结构</span>
<span class="token comment">//最大的优点就是方便的实现树和二叉树的相互转换,缺点时查找父节点麻烦</span>

<span class="token keyword">int</span> <span class="token function">TreeHeight2</span><span class="token punctuation">(</span>TSBNode <span class="token operator">*</span>t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    TSBNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> h<span class="token punctuation">,</span> maxh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    p <span class="token operator">=</span> t<span class="token operator">-></span>vp<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//遍历同一层的p</span>
    <span class="token punctuation">&#123;</span>
        h <span class="token operator">=</span> <span class="token function">TreeHeight2</span><span class="token punctuation">(</span>p<span class="token operator">-></span>vp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//求出这一层的最大值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxh <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
            maxh <span class="token operator">=</span> h<span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>hp<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> maxh <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>呜呜呜，好长这里，冲冲冲！</p>
<p>二叉树是区分左右的，任何m次数都可以转化为二叉树结构</p>
<p><strong>满二叉树</strong>：叶子节点都集中在二叉树的最下一层，所有分支节点都有左右孩子的树，只有度为0或2的节点。</p>
<p>可以进行层序编号，第一个是0，若节点为x，则左孩子为2x，右孩子为2x + 1</p>
<p><strong>完全二叉树</strong>：只有最下两层节点度数可以小于2，且叶子节点全都靠左排列。</p>
<p>最多只有1个出度为1的节点，且节点有左孩子，结点总数n为奇数时没有出度为1的结点</p>
<p><strong>满二叉树是完全二叉树的特例</strong></p>
<p>二叉树性质：</p>
<ol>
<li><p>非空二叉树上的<strong>叶子节点数</strong>等于<strong>双分支结点数+1</strong></p>
<p>用到了：m(度的和) = n-1   度的和 = n1 + 2n2    n = n0(叶子结点数) + n1 + n2</p>
</li>
<li><p>非空二叉树的第i层最多只有2^(i-1)个结点</p>
</li>
<li><p>高度为h的二叉树最多有 2^h - 1 个结点</p>
</li>
<li><p>若节点为x，则左孩子为2x，右孩子为2x + 1，父节点为x/2 向下取整</p>
</li>
<li><p>具有n个节点的完全二叉树高度为 log2(n+1)向上取整 或者log2n向下取整 +1</p>
</li>
</ol>
<p>树转二叉树：相邻兄弟加线，保留长子线，其余删除    森林则把根节点链接</p>
<p>二叉树转树：若某节点为双亲的左孩子，则把该节点的右孩子，右孩子的右孩子都与该节点的双亲连起来，</p>
<p>删除原二叉树中所有双亲结点与右孩子结点之间的连线。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token comment">/*先看看顺序存储结构
对于完全二叉树和满二叉树，可以实现随机存储，完全二叉树最后几个空的用 # 表示
对于一般的二叉树，可以增添一些不存在的空结点，使之成为一棵完全二叉树的形式。
图可以看看P204  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//假设最多只有100个非零项</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> ElemType SqBinTree<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//但是如果空的太多，会造成空间的大量浪费，但是查找子节点和父节点都很方便。</span>
<span class="token comment">//当然还有一般顺序存储结构的缺点，就是插入，删除很不方便</span>

<span class="token comment">//链式存储，称为二叉链，用根节点指针b唯一标识整个存储结构，称为二叉树b</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>
    <span class="token comment">//struct node *parent;</span>
<span class="token punctuation">&#125;</span> BTNode<span class="token punctuation">;</span>
<span class="token comment">//这样节省空间，但不方便访问父节点，可以增加一个指向父节点的指针域parent来解决。</span>
<span class="token comment">//后续一般假设一棵二叉树中所有结点值均不同，为单个字符</span>
<span class="token comment">//创建，销毁，按值查找（父），找孩子，求高度，输出   创建和输出都用括号表示法</span>

<span class="token comment">//首先得理解二叉树的括号表示，模拟一个栈来实现,因为栈的实现很简单，并没有封装</span>
<span class="token comment">//这个用栈保存双亲结点的思想太妙了！栈顶存放的是当前处理节点的父节点</span>
<span class="token keyword">void</span> <span class="token function">CreateBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>St<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//St为顺序栈</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//j为str索引,k用来判断孩子类型</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ch <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token string">'('</span><span class="token operator">:</span>
            top<span class="token operator">++</span><span class="token punctuation">;</span>
            St<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
            k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">')'</span><span class="token operator">:</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">','</span><span class="token operator">:</span>
            k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            p <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">-></span>data <span class="token operator">=</span> ch<span class="token punctuation">;</span>
            p<span class="token operator">-></span>lchild <span class="token operator">=</span> p<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
                b <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//这是只存在一次的还未建立根节点的情况</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token comment">//只有1和2的情况来回切换！</span>
                <span class="token punctuation">&#123;</span>
                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
                    St<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>lchild <span class="token operator">=</span> p<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
                    St<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        ch <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DestroyBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//查找x的结点</span>
BTNode <span class="token operator">*</span><span class="token function">FindeNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> <span class="token function">FindeNode</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token function">FindeNode</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//p</span>
        <span class="token comment">//这也把没找到的情况包含在内了，要学会简化代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

BTNode <span class="token operator">*</span><span class="token function">LchildNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

BTNode <span class="token operator">*</span><span class="token function">RchildNode</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求高度</span>
<span class="token keyword">int</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> lchild<span class="token punctuation">,</span> rchild<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        lchild <span class="token operator">=</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        rchild <span class="token operator">=</span> <span class="token function">BTHeight</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>lchild <span class="token operator">></span> rchild <span class="token operator">?</span> lchild <span class="token operator">:</span> rchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//终究还是比广义表简单不少啊,当是NULL的时候不操作，非常流弊</span>
<span class="token keyword">void</span> <span class="token function">DispBTree</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> b<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">DispBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">DispBTree</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//突然想玩一下下</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"A(B(D(,G))C(E,F))"</span><span class="token punctuation">;</span>
    BTNode <span class="token operator">*</span>BT<span class="token punctuation">;</span>
    <span class="token function">CreateBTree</span><span class="token punctuation">(</span>BT<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">DispBTree</span><span class="token punctuation">(</span>BT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nI prefer Python, C is to complex and confused"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">/*遍历，四种顺序，层次遍历是非递归的
一颗二叉树可以分为根节点和子树两类，根节点直接处理，子树递归处理
如果必须先处理子树，那就用后序，如果必须先处理根节点，那就用先序，否则随便
如果要区分左，右树，那就要考虑中序，但是比较少*/</span>
<span class="token keyword">void</span> <span class="token function">Preorder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Preorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Preorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">Inorder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">Inorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Inorder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求给定二叉树的所有结点个数</span>
<span class="token keyword">int</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Nodes</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//这个是先左后右后根，是后续遍历</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//输出所有的叶子节点</span>
<span class="token comment">/*递归模型很重要！
f(b) === 不做任何事情    b=NULL
f(b) === 输出b的data域   b为叶子结点
f(b) === f(b->lchild);f(b->rchild) 其他情况*/</span>
<span class="token keyword">void</span> <span class="token function">DispLeaf</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DispLeaf</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DispLeaf</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求深度，h置处置1，这个和之前那个稍微有点不同，具体分析</span>
<span class="token keyword">int</span> <span class="token function">Level</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">,</span> <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> l<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
        <span class="token keyword">return</span> h<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        l <span class="token operator">=</span> <span class="token function">Level</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span>
            <span class="token keyword">return</span> l<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">Level</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//又见到了这种操作</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求b树第k层的结点数,h是用来传递参数，初始为1</span>
<span class="token comment">//这是另一种递归思路，并没有回带的过程，利用了void和引用</span>
<span class="token comment">//如果在c语言中，可以用全局变量来代替所谓的引用。</span>
<span class="token keyword">void</span> <span class="token function">Lnodenum</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> h<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            n<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> k<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">Lnodenum</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">Lnodenum</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//输出x的结点的所有祖先,多判断一级的思维</span>
bool <span class="token function">ancestor</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>lchild<span class="token operator">-></span>data <span class="token operator">==</span> x <span class="token operator">||</span> b<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>rchild<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span>b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ancestor</span><span class="token punctuation">(</span>b<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">ancestor</span><span class="token punctuation">(</span>b<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        <span class="token function">putchar</span><span class="token punctuation">(</span>b<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//非递归算法区域P218</span>
<span class="token comment">//层次遍历算法</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> SqQueue<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    SqQueue <span class="token operator">*</span>qu<span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">deQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h2><p>由先序序列+中序序列，或者中序序列+后序序列唯一地确定一颗二叉树</p>
<p>实际上，先序序列的作用是确定一棵二叉树的根节点，中序序列的作用是确定左、右子树的中序序列，从而进一步确定先序序列，递归构造左右子树。</p>
<p>原理在P229</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">//二叉树的构造</span>
<span class="token comment">//pre存放先序序列，in存放中序序列，n为二叉树的节点个数</span>
<span class="token comment">//其实函数的参数选择同时得考虑递归时不同层级间需要的参数</span>
BTNode <span class="token operator">*</span><span class="token function">CreateBT1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span> <span class="token comment">//根节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> in<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> in <span class="token operator">+</span> n<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> <span class="token operator">*</span>pre<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    k <span class="token operator">=</span> p <span class="token operator">-</span> in<span class="token punctuation">;</span> <span class="token comment">//确定根节点在in中的位置</span>
    b<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> in<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//这里不能光考虑第一次的，要用通用的写法</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//和上面基本一致</span>
BTNode <span class="token operator">*</span><span class="token function">CreateBT2</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>post<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BTNode <span class="token operator">*</span>b
    <span class="token keyword">char</span> r<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//因为根节点在后头，所以得用一个变量单独保存</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>post <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token operator">-></span>data <span class="token operator">=</span> r<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> post<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> post <span class="token operator">+</span> n<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">==</span> r<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    k <span class="token operator">=</span> p <span class="token operator">-</span> post<span class="token punctuation">;</span>
    b<span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token function">CreateBT2</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> in<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token function">CreateBT2</span><span class="token punctuation">(</span>post <span class="token operator">+</span> k<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="哈夫曼"><a href="#哈夫曼" class="headerlink" title="哈夫曼"></a>哈夫曼</h2><p>WPL  Weighted Path Length 带权路径长度</p>
<p>定理：假如哈夫曼树有n个叶子结点，那么一共有2n+1个</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">//哈夫曼树采用数组存放，总的结点数可以算出来 P239</span>
<span class="token comment">//前n个存放原结点（叶子结点），剩下的存放分支节点。</span>
<span class="token comment">//思路是先将全部节点的parent、lchild、rchild赋值为-1,然后不断找最小的放在后面，同时补全信息</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span>
    <span class="token keyword">double</span> weight<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>
    <span class="token keyword">int</span> lchild<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> HTNode<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n0<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">;</span>
    <span class="token keyword">double</span> min1<span class="token punctuation">,</span> min2<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> n0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> n0 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        min1 <span class="token operator">=</span> min2 <span class="token operator">=</span> <span class="token number">32767</span><span class="token punctuation">;</span>
        lnode <span class="token operator">=</span> rnode <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token comment">//通过确定两个最小值的相对次序来巧妙地处理该问题</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span> <span class="token comment">//在尚未构造二叉树的结点中查找</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> min1<span class="token punctuation">)</span>
                <span class="token punctuation">&#123;</span>
                    min2 <span class="token operator">=</span> min1<span class="token punctuation">;</span>
                    rnode <span class="token operator">=</span> lnode<span class="token punctuation">;</span>
                    min1 <span class="token operator">=</span> ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
                    lnode <span class="token operator">=</span> k<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> min2<span class="token punctuation">)</span>
                <span class="token punctuation">&#123;</span>
                    min2 <span class="token operator">=</span> ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
                    rnode <span class="token operator">=</span> k<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> ht<span class="token punctuation">[</span>lnode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">+</span> ht<span class="token punctuation">[</span>rnode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">=</span> lnode<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild <span class="token operator">=</span> rnode<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>lnode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> i<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>rnode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//哈夫曼编码,规定左分支为0，右分支为1</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> cd<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放当前节点的哈夫曼编码</span>
    <span class="token keyword">int</span> start<span class="token punctuation">;</span>  <span class="token comment">//表明cd[start..n0]部分是哈夫曼编码</span>
<span class="token punctuation">&#125;</span> HCode<span class="token punctuation">;</span>

<span class="token comment">//这是个从下向上的过程，但是最终是顺序的</span>
<span class="token keyword">void</span> <span class="token function">CreateHCode</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> HCode hcd<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n0<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    HCode hc<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n0<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        hc<span class="token punctuation">.</span>start <span class="token operator">=</span> n0<span class="token punctuation">;</span>
        c <span class="token operator">=</span> i<span class="token punctuation">;</span>
        f <span class="token operator">=</span> ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span> <span class="token comment">//初始化</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span> <span class="token comment">//循环到根节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild <span class="token operator">==</span> c<span class="token punctuation">)</span>
                hc<span class="token punctuation">.</span>cd<span class="token punctuation">[</span>hc<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                hc<span class="token punctuation">.</span>cd<span class="token punctuation">[</span>hc<span class="token punctuation">.</span>start<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
            c <span class="token operator">=</span> f<span class="token punctuation">;</span>
            f <span class="token operator">=</span> ht<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        hc<span class="token punctuation">.</span>start<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//因为多减了一次，加回来</span>
        hcd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> hc<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="7-图"><a href="#7-图" class="headerlink" title="7.图"></a>7.图</h1><p>找强连通分量：先找一个有向环，如果外面的某个顶点到该环任意结点均有双向路径，则加入</p>
<p>带权图也称作网</p>
<h2 id="矩阵、表存储"><a href="#矩阵、表存储" class="headerlink" title="矩阵、表存储"></a>矩阵、表存储</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXV</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//最大结点数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INF</span> <span class="token expression"><span class="token number">32767</span> </span><span class="token comment">//所谓的正无穷，也就是没有路</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> InfoType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> no<span class="token punctuation">;</span>        <span class="token comment">//顶点编号</span>
    InfoType info<span class="token punctuation">;</span> <span class="token comment">//其他信息</span>
<span class="token punctuation">&#125;</span> VertexType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> edges<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵数组</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span>              <span class="token comment">//顶点数、边数</span>
    VertexType vexs<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放结点信息</span>
<span class="token punctuation">&#125;</span> MatGraph<span class="token punctuation">;</span>

<span class="token comment">/*适合储存边比较多的稠密图
邻接矩阵表示是唯一的，注意无向图、有向图每一行/列的意义
非常适合提取两个顶点之间的边，适用于该目的的算法*/</span>

<span class="token comment">//邻接表结构是后续众多算法的基础，一定要弄清楚P259</span>
<span class="token comment">//每个顶点一个链表，链接关联的边。其中的每个边结点表示一条！边！的信息，not 点</span>
<span class="token comment">//头节点存储的则是顶点的信息，并指向首节点。</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ANode</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>            <span class="token comment">//该边的临界点编号,指的是出边临界点</span>
    <span class="token keyword">struct</span> <span class="token class-name">ANode</span> <span class="token operator">*</span>nextarc<span class="token punctuation">;</span> <span class="token comment">//指向下个边的指针</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>            <span class="token comment">//该边的相关信息</span>
<span class="token punctuation">&#125;</span> ArcNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Vnode</span>
<span class="token punctuation">&#123;</span>
    InfoType info<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>firstarc<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> VNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    VNode adjlist<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//头节点数组</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> AdjGraph<span class="token punctuation">;</span>
<span class="token comment">//还有所谓的逆邻接表</span>
<span class="token comment">/*邻接表的表示不唯一，取决于算法和输入次序，适合边数目稀疏的图
对于无向图，第i个单链表的边数目是顶点i的度，有向图则为出度，入度得统计所有的adjvex域为i的数目
适合提取某个顶点的所有临界点*/</span>

<span class="token comment">//依次扫描，头插法插入。</span>
<span class="token keyword">void</span> <span class="token function">CreateAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INF<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                p <span class="token operator">=</span> <span class="token punctuation">(</span>ArcNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArcNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token operator">-></span>adjvex <span class="token operator">=</span> j<span class="token punctuation">;</span>
                p<span class="token operator">-></span>weight <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                p<span class="token operator">-></span>nextarc <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
                G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    G<span class="token operator">-></span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    G<span class="token operator">-></span>e <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//输出规则为先输出头结点的定点信息，再依次输出所有结点的顶点编号</span>
<span class="token keyword">void</span> <span class="token function">DispAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%3d[%d]"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">,</span> p<span class="token operator">-></span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DestroyAdj</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        pre <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            p <span class="token operator">=</span> pre<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                pre <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> pre<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//别忘了把头节点数组也释放掉</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//将邻接表转换为邻接矩阵</span>
<span class="token keyword">void</span> <span class="token function">ListToMat</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span><span class="token operator">&amp;</span>G<span class="token punctuation">,</span> MatGraph <span class="token operator">&amp;</span>g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>weight<span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    g<span class="token punctuation">.</span>n <span class="token operator">=</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span>
    g<span class="token punctuation">.</span>e <span class="token operator">=</span> G<span class="token operator">-></span>e<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*十字链表
是给有向图用的，是邻接表和逆邻接表的结合，现在看其实非常简单。。不知道当时为啥讲那么久。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="图遍历及应用"><a href="#图遍历及应用" class="headerlink" title="图遍历及应用"></a>图遍历及应用</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//图的遍历，要求每个顶点仅被访问一次。</span>
<span class="token comment">//因为图不像树，存在回路，得设置一个访问标记数组visited,当访问过时置1，否则为0</span>

<span class="token comment">//深度优先Depyh First Search DFS</span>
<span class="token keyword">int</span> visited<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//全局置0,从v开始遍历</span>
<span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//广度优先算法Breadth First Search BFS,显然这种结构要用到队列</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"linked_queue.cpp"</span></span>
<span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    LinkQuNode <span class="token operator">*</span>qu<span class="token punctuation">;</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> visited<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>qu<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">dequeue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token function">enqueue</span><span class="token punctuation">(</span>qu<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//遍历非连通图</span>
<span class="token keyword">void</span> <span class="token function">DFS1</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">BFS1</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">Connect</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    bool flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            flag <span class="token operator">=</span> false<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//图遍历算法的应用</span>

<span class="token comment">//深度搜索判断是否存在路径。</span>
<span class="token keyword">void</span> <span class="token function">ExitPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> bool <span class="token operator">&amp;</span>has<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> w<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        has <span class="token operator">=</span> true<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">ExitPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> has<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//输出从u到v的一条路径，假设已知u到v间有路径。</span>
<span class="token comment">//只要正常遍历就好，绝对会输出一条路径，不过非常随机就是了。</span>
<span class="token keyword">void</span> <span class="token function">FindaPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//d表示path中的路径长度，初始为-1</span>
    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    d<span class="token operator">++</span><span class="token punctuation">;</span>
    path<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">FindaPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//这个递归还是让人想了一会</span>
<span class="token keyword">void</span> <span class="token function">FindALLPath</span><span class="token punctuation">(</span>AdjGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>

    <span class="token comment">//d表示path中的路径长度，初始为-1</span>
    <span class="token keyword">int</span> w<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    d<span class="token operator">++</span><span class="token punctuation">;</span>
    path<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    p <span class="token operator">=</span> G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        w <span class="token operator">=</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">FindALLPath</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> w<span class="token punctuation">,</span> v<span class="token punctuation">,</span> path<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span> <span class="token comment">//递归体的核心就在这里</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//恢复环境，可以重复利用。</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//后面的广度优先算法的应用暂时没有更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>图的最小生成树是树的所有生成树中边上权值最小的。（实际上是选节点）</p>
<ul>
<li>n个顶点的话就有n - 1条边。</li>
<li>必须只使用该图中的边来构造</li>
<li>不能使用会产生回路的边。</li>
</ul>
<p>这个应用有很多，求最小生成树的算法：Prim 、克鲁斯卡尔</p>
<p>只要遍历一次，就能得到生成树，分为深度优先生成树和广度优先生成树。</p>
<p><strong>普利姆算法</strong></p>
<p>P281 依次选择最小边，因为需要频繁取边，所以图采用邻接矩阵更合适</p>
<p>这体现出了从算法逻辑设计到代码实现的过程也并非易事的，需要一些巧妙的构思</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Prim算法</span>
<span class="token comment">//建议先阅读一下P284,搞清楚lowcost(到U中的最小边)和closet（最小边对应的顶点）,这种实时更新最值的思想很有用，简化了算法</span>
<span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> MIN<span class="token punctuation">;</span>
    <span class="token keyword">int</span> closet<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        closet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token comment">//初始化</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//找出n - 1个顶点</span>
    <span class="token punctuation">&#123;</span>
        MIN <span class="token operator">=</span> INF<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> MIN<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                MIN <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最小边的顶点编号</span>
            <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"边(%d,%d)权为%d\n"</span><span class="token punctuation">,</span> closet<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> MIN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出最小生成树的一条边</span>
        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                 <span class="token comment">//标记k已经加入U中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                closet<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>克鲁斯卡尔算法</strong></p>
<p>这才是正儿八经的选边。P285</p>
<p>当一个图有多个最小生成树时，这两个算法的求解结果不一定是相同的。</p>
<p>因为同样要频繁取边，也采用邻接矩阵来处理。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//关键在于如何判断选取一条边(i,j)加入到T中是否出现回路，可以通过判断顶点i,j是否同属于一个连通分量来解决</span>
<span class="token comment">//利用vset[0..n-1]数组来完成，太厉害了，i和j处理时，改成i或j的vset值都可以</span>

<span class="token comment">// Prim算法</span>
<span class="token comment">//建议先阅读一下P284,搞清楚lowcost(到U中的最小边)和closet（最小边对应的顶点）,这种实时更新最值的思想很有用，简化了算法</span>
<span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> MIN<span class="token punctuation">;</span>
    <span class="token keyword">int</span> closet<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        closet<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token comment">//初始化</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//找出n - 1个顶点</span>
    <span class="token punctuation">&#123;</span>
        MIN <span class="token operator">=</span> INF<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> MIN<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                MIN <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最小边的顶点编号</span>
            <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"边(%d,%d)权为%d\n"</span><span class="token punctuation">,</span> closet<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> MIN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出最小生成树的一条边</span>
        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                 <span class="token comment">//标记k已经加入U中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                closet<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//克鲁斯卡尔</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> u<span class="token punctuation">;</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span>
    <span class="token keyword">int</span> w<span class="token punctuation">;</span>
    <span class="token comment">//起始顶点，终止顶点和权值</span>
<span class="token punctuation">&#125;</span> Edge<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Maxsize</span> <span class="token expression"><span class="token number">20000</span> </span><span class="token comment">//最大边数</span></span>
<span class="token keyword">void</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>MatGraph g<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> u1<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> sn1<span class="token punctuation">,</span> sn2<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> vset<span class="token punctuation">[</span>MAXV<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Edge E<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存放所有的边</span>
    k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//e数组的下标</span>
    <span class="token comment">//第一步，由g产生E</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INF<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>u <span class="token operator">=</span> i<span class="token punctuation">;</span>
                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> k<span class="token punctuation">;</span>
                E<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> g<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    <span class="token comment">//InsertSort(E,g.e)//对所有的边按照权值排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//初始化辅助数组</span>
    k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">//表示当前构造生成树的第几条边，初始为1</span>
    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//E中边的下标，初始为0</span>

    <span class="token comment">//主体</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token comment">//生成树有n-1条边</span>
    <span class="token punctuation">&#123;</span>
        u1 <span class="token operator">=</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">;</span>
        v1 <span class="token operator">=</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
        sn1 <span class="token operator">=</span> vset<span class="token punctuation">[</span>u1<span class="token punctuation">]</span><span class="token punctuation">;</span>
        sn2 <span class="token operator">=</span> vset<span class="token punctuation">[</span>v1<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sn1 <span class="token operator">!=</span> sn2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%d,%d):%d\n"</span><span class="token punctuation">,</span> u1<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> E<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出一条边</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> sn2<span class="token punctuation">)</span>
                    vset<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sn1<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>突然想研究一下能不能上传文件</p>
<p><a href="/papers/2021%E5%B9%BF%E4%B8%9C%E6%8B%9B%E7%94%9F%E8%AE%A1%E5%88%92.pdf">广东省2021招生计划</a></p>
<p>haha，那我到时候直接把源代码传上来好了，免得这个复制太难弄了</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//不想做了。。狄克斯特拉算法和弗洛伊德算法，反正只考概念罢了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV"><a href="#AOV" class="headerlink" title="AOV"></a>AOV</h3><p>AOV网，用顶点表示活动，用有向边表示活动之间优先关系的有向图称为AOV网（顶点表示活动的网）</p>
<p>选择没有前驱的顶点输出，删去该顶点以及该顶点发出的所有边，重复以上二步</p>
<p>若全部顶点被输出，则不存在回路，否则存在回路</p>
<h3 id="AOE"><a href="#AOE" class="headerlink" title="AOE"></a>AOE</h3><p>顶点表示事件，有向<strong>边表示活动</strong>，开始事件（源点），结束事件（汇点）</p>
<p>从源点到汇点所有路径中具有最大路径长度的路径称为<strong>关键路径</strong>。</p>
<p>建议看看P304</p>
<p>先进行一次拓扑排序，然后递归从头找最大，递归从尾找最小。</p>
<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找"></a>8.查找</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">//线性表分顺序和链式，只介绍顺序表，属于静态查找。</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> years<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    KeyType key<span class="token punctuation">;</span>   <span class="token comment">//关键字</span>
    InfoType data<span class="token punctuation">;</span> <span class="token comment">//其他数据</span>
<span class="token punctuation">&#125;</span> RecType<span class="token punctuation">;</span>

<span class="token comment">//顺序查找，ASL成功 = (n+1)/2 ASL失败 = n</span>
<span class="token keyword">int</span> <span class="token function">SeqSearch</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> n<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//逻辑值要加一</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//从精简算法，提高查找速度的角度说，可以在R末尾增加一个关键字为k的记录为哨兵，就不用判断i是否超界</span>
<span class="token keyword">int</span> <span class="token function">SeqSearch1</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    R<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//折半查找</span>
<span class="token comment">//要求有序表,mid = (low+high)/2向下取整，成功返回逻辑序号，失败返回0</span>
<span class="token keyword">int</span> <span class="token function">BinSearch</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//好精简的算法！</span>
<span class="token comment">//可以用判定树刻画，n种成功情况，成功时比较次数恰为层数和n+！种失败情况。失败时比较次数为层数-1</span>
<span class="token comment">//ASLbn = log2(n+1)-1  最坏性能和平均性能相当接近,归纳起来复杂度为O（log2n）</span>

<span class="token comment">//索引结构和分块查找</span>
<span class="token comment">/*索引项一般为（关键字，地址），可以现在有序索引表中快速查找，然后通过地址找到
提高了查找效率，但是需要建立索引表会增加时空开销*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXI</span> <span class="token expression"><span class="token number">10000</span> </span><span class="token comment">//索引表最大容量。</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    KeyType key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> link<span class="token punctuation">;</span> <span class="token comment">//对应在存储表里的下标</span>
<span class="token punctuation">&#125;</span> IdxType<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">IdxSearch</span><span class="token punctuation">(</span>IdxType I<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> b<span class="token punctuation">;</span> <span class="token comment">//s为每块的元素个数，I的长度为b</span>
    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>I<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> k<span class="token punctuation">)</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//接下来在该块中顺序查找</span>
    i <span class="token operator">=</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link<span class="token punctuation">;</span> <span class="token comment">//记住是high+1，总会取到偏小的一个</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link <span class="token operator">+</span> s <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> I<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>link <span class="token operator">+</span> s <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*折半查找配合时，成功查找的平均长度为ASLblk = ASLbn + ASLsq
= log2(b+1) -1 + (s+1)/2 = log2(n/s+1) + s/2 可见s即每块的长度越小越好*/</span>
<span class="token comment">/*顺序查找时，ASLblk = ((b+1)+(s+1))/2 =1/2(n/s +s) +1 因为b = n/s向上取值，当s=根号n时最佳*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="树表"><a href="#树表" class="headerlink" title="树表"></a>树表</h2><p>如果要进行表的删除、插入操作，会带来很多额外开销，若要对动态查找表进行查找，可以用几种树来。</p>
<p>二叉排序树的中序序列就是排好序的表</p>
<p>查找的ASL成功和ASL失败在P328</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">//假设各结点的关键字是唯一的</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> years<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    KeyType key<span class="token punctuation">;</span>
    InfoType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> BSTNode<span class="token punctuation">;</span>

<span class="token comment">//用根节点bt来唯一标识一棵二叉排序树</span>

<span class="token comment">//插入关键字k，若已有则返回假</span>
bool <span class="token function">InsertBST</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span><span class="token operator">&amp;</span>bt<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        bt <span class="token operator">=</span> <span class="token punctuation">(</span>BSTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bt<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        bt<span class="token operator">-></span>lchild <span class="token operator">=</span> bt<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//创建一棵二叉排序树是从一个空树开始，一直调用插入就好了。</span>
BSTNode <span class="token operator">*</span><span class="token function">CreateBST</span><span class="token punctuation">(</span>KeyType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BSTNode <span class="token operator">*</span>bt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">InsertBST</span><span class="token punctuation">(</span>bt<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> bt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//销毁算法和普通的二叉树算法一样</span>
<span class="token comment">//查找就要方便很多</span>
BSTNode <span class="token operator">*</span><span class="token function">SearchBST</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>bt<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt<span class="token operator">-></span>key <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> bt<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">)</span>
        <span class="token keyword">return</span> bt<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> bt<span class="token operator">-></span>key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//求最大\最小结点可以利用性质</span>
KeyType <span class="token function">maxnode</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
KeyType <span class="token function">minnode</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//一定是叶子节点</span>


<span class="token comment">//删除要分几种情况讨论，是最麻烦的。</span>
<span class="token comment">//是叶子就直接删除，只有左、右子树就接上去</span>
<span class="token comment">//同时有左右子树的话可以从左中选最大的结点r代替p，然后把r删除，也可以选右中最小的，一般前者</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡因子：左子树高度 - 右子树高度</p>
<p>平衡条件：平衡因子的绝对值小于1</p>
<p>前提是二叉排序树，</p>
<p>四种类型 调整前后中序序列相同是前提条件。这个建议看学校发的教材P283</p>
<p>删除的时候，如果不平衡了，可以通过左右孩子的平衡因子来判断做哪一种调整，P337</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>又称散列表，设要存储的元素个数为n，设置一个长度为m&gt;=n的连续内存单元，每个元素的关键字ki(i&lt;=n-1)</p>
<p>为自变量，通过哈希函数映射到内存单元的地址h(ki)，并存储在这个内存单元中。</p>
<p>哈希冲突，不同的自变量映射到同一个地址</p>
<p>通常情况是关键字的取值区间远大于哈希地址的变化区间</p>
<p>查找性能取决于：</p>
<ul>
<li>装填因子 α = n/m 应控制最终的α在0.6~0.9范围内</li>
<li>哈希函数应该使哈希地址尽可能均匀地分布在哈希地址空间上</li>
<li>合适的解决哈希冲突的策略。</li>
</ul>
<h3 id="构造哈希函数"><a href="#构造哈希函数" class="headerlink" title="构造哈希函数"></a>构造哈希函数</h3><p>构造哈希函数</p>
<p>根据关键字的结构和分布的不同可构造出许多不同的哈希函数，这里主要讨论几种常用的整数类型关键字的</p>
<ol>
<li><p>直接定址法 h(k) = k + c</p>
<p>当关键字分布基本连续时比较好</p>
</li>
<li><p>除留余数法 h(k) = k mod p (p &lt;= m) </p>
<p>这种该方法的关键是选好p，使得概率分布较平均，p奇数好，不大于m的素数效果最好</p>
</li>
<li><p>数字分析法</p>
<p>提取关键字较均匀的数字位，适合所有关键字值都已知的情况</p>
</li>
</ol>
<p>还有平方取中法，折叠法等。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>开放地址法(也叫再散列法)：</p>
<ol>
<li><p>线性探测法</p>
<p>容易产生堆积问题，d0 = h(k)  di = ( (d(i-1) + 1) mod m)</p>
</li>
<li><p>平方探测法</p>
<p>d0 = h(k)    di = ( (d0 +- i2) mod m)</p>
<p>不一定能探测到哈希表上的所有单元，但最少能探测到一半的单元</p>
</li>
<li><p>还有伪随机序列法，双哈希函数法等</p>
</li>
</ol>
<p>再哈希法：</p>
<p>同时构造多个哈希函数，一个冲突就换另一个</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">//用开放地址法构造的哈希表的运算算法</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULLKEY</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span> </span><span class="token comment">//空关键字值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DELKEY</span> <span class="token expression"><span class="token operator">-</span><span class="token number">2</span>  </span><span class="token comment">//被删除关键字值</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> KetType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    KetType key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">//探测次数域</span>
<span class="token punctuation">&#125;</span> HashTable<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InsertHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>                                         <span class="token comment">//adr是关键字k对应的哈希值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> NULLKEY <span class="token operator">||</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> DELKEY<span class="token punctuation">)</span> <span class="token comment">//可以直接放入</span>
    <span class="token punctuation">&#123;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//i 记录k发生的次数</span>
        <span class="token keyword">do</span>
        <span class="token punctuation">&#123;</span>
            adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> DELKEY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//设置探测次数</span>
    <span class="token punctuation">&#125;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//哈希表中总元素个数增1</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nl<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//由关键字序列keys[0..nl-1]创建哈希表</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> NULLKEY<span class="token punctuation">;</span>
        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nl<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">InsertHT</span><span class="token punctuation">(</span>ha<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> p<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//插入nl个</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//删除算法</span>
<span class="token comment">//在开放地址法处理的哈希表上不能简单的删除，因为在查找算法中空是查找失败，应该置特殊值</span>
bool <span class="token function">DeleteHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">&amp;</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> DELKEY<span class="token punctuation">)</span>
        adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> DELKEY<span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">SearchHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KetType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> NULLKEY <span class="token operator">&amp;&amp;</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        adr <span class="token operator">=</span> <span class="token punctuation">(</span>adr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span> <span class="token comment">//线性探测</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success:%d compare %d times"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ASL成功为关键字列表中每个关键字的比较次数的平均数</p>
<p>ASL失败为直到空时的探测次数，P357 记得要算上自己的这次</p>
<p>拉链法：</p>
<p>此时的装填因子可以设定为大于1</p>
<p>优点：无堆积现象，平均查找长度较短，适合无法定长的情况，元素较大时指针开销可忽略不计，删除操作容易实现</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">//拉链法</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    KeyType key<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> NodeType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    NodeType <span class="token operator">*</span>firstp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> HashTable<span class="token punctuation">;</span>

<span class="token comment">//理解这个HashTable ha数组，下标即为“地址”</span>
<span class="token keyword">void</span> <span class="token function">InsertHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>
    NodeType <span class="token operator">*</span>q<span class="token punctuation">;</span>
    q <span class="token operator">=</span> <span class="token punctuation">(</span>NodeType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NodeType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>key <span class="token operator">=</span> k<span class="token punctuation">;</span>
    q<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        q<span class="token operator">-></span>next <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nl<span class="token punctuation">)</span>
<span class="token comment">//由关键字序列keys[0..nl-1]创建哈希表</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        ha<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nl<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">InsertHT</span><span class="token punctuation">(</span>ha<span class="token punctuation">,</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//删除算法 在逻辑上更为简单，可以直接删除</span>
bool <span class="token function">DeleteHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span> <span class="token comment">//删除哈希表中的关键字k</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>
    NodeType <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>preq<span class="token punctuation">;</span>
    q <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//首节点不为k时</span>
    preq <span class="token operator">=</span> q<span class="token punctuation">;</span>
    q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        preq<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">SearchHT</span><span class="token punctuation">(</span>HashTable ha<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> KeyType k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> adr<span class="token punctuation">;</span>
    adr <span class="token operator">=</span> k <span class="token operator">%</span> p<span class="token punctuation">;</span>
    NodeType <span class="token operator">*</span>q <span class="token operator">=</span> ha<span class="token punctuation">[</span>adr<span class="token punctuation">]</span><span class="token punctuation">.</span>firstp<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>

    <span class="token punctuation">&#123;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>key <span class="token operator">==</span> k<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ASL成功就是比较次数求平均嘛</p>
<p>ASL不成功 就是每条链的结点数求平均哈哈，有几个结点就白比较了几次</p>
<h1 id="9-内排序"><a href="#9-内排序" class="headerlink" title="9.内排序"></a>9.内排序</h1><p>此处的关键字是可以重复的</p>
<p>根据相同关键字排序后相对次序是否改变可分为稳定和不稳定，这相对于<strong>所有可能的输入实例</strong></p>
<p>在排序中不需要进行数据的内、外存交换，称之为内排序。</p>
<p>需要关键字<strong>比较</strong>的方法有插入排序、选择排序、交换排序、归并排序</p>
<p>不需要的方法有基数排序</p>
<p>基于比较的排序主要进行两种操作：比较+移动</p>
<p>正序：关键字顺序正好和排序顺序相同，反序则相反。</p>
<p>比较排序的<strong>最好的平均理论时间</strong>复杂度为O(nlog2n) 比如堆排序、二路归并、快速排序 P367</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">//基本数据类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> one<span class="token punctuation">;</span>
    <span class="token keyword">char</span> two<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> InfoType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    KeyType key<span class="token punctuation">;</span>
    InfoType data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> RecType<span class="token punctuation">;</span>

<span class="token comment">//插入排序</span>
<span class="token comment">//直接插入排序</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token comment">//如果直接就大于有序区最大的，</span>
        <span class="token punctuation">&#123;</span>
            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">do</span>
            <span class="token punctuation">&#123;</span>
                R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">></span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//折半插入排序</span>
<span class="token comment">//在有序区查找位置时用折半查找就好了</span>
<span class="token keyword">void</span> <span class="token function">BinInsertSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
                R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            R<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//希尔排序</span>
<span class="token comment">//这和上一章查找好像啊，分组插入,原理我感觉是避免高次运算的爆炸增长</span>
<span class="token comment">//这里取di+1 = di/2向下取整,d1 = n/2</span>
<span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> d <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>d <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> d<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//这个上下界真是绝了，一步到位全部都排好，我还想了一会</span>
        <span class="token punctuation">&#123;</span>
            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j <span class="token operator">=</span> i <span class="token operator">-</span> d<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                R<span class="token punctuation">[</span>j <span class="token operator">+</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j <span class="token operator">=</span> j <span class="token operator">-</span> d<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            R<span class="token punctuation">[</span>j <span class="token operator">+</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        d <span class="token operator">=</span> d <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">//交换排序</span>
<span class="token comment">//冒泡排序,从后开始，把有序的冒到最前面</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                R<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//实际上，一旦某一趟不出现任何元素交换，就说明排好序了，可以用一个flag来达到这点</span>

<span class="token comment">//快速排序 当年初学感觉非常巧妙的算法哈哈</span>
<span class="token comment">//选一个枢纽（一般第一个），然后将所有的放在其前后，递归进行处理</span>

<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span> <span class="token comment">//从头尾向中扫描</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">,</span> j <span class="token operator">=</span> t<span class="token punctuation">;</span>
    RecType tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> j <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;=</span> tmp<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token comment">//对R[s...t]元素进行快速排序</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//选择排序</span>
<span class="token comment">//基本思路是每一趟都挑出最大、最小的，适合从大量元素中选择一部分排序元素</span>

<span class="token comment">//简单选择选择</span>
<span class="token comment">//分成有序区和无序区，从无序区选出最的后与无序区第一个元素交换，之所以叫简单排序是因为找最小值的方法是简单的两两比较</span>
<span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        k <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//k记录最值的位置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            R<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//堆排序</span>
<span class="token comment">/*看成是一颗完全二叉树的顺序存储结构，大根堆，小根堆，挑选最大元素是采用筛选方法实现的
筛选：假定某节点左右子树是大根堆，选择子节点和本身最大的上来，由于可能会破坏子树，因此递归判断*/</span>
<span class="token keyword">void</span> <span class="token function">sift</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token comment">//low是根节点,j指向当前结点的孩子</span>
    RecType tmp <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//看看两个孩子谁大</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>
            j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token comment">//这个索引的变换有点巧妙</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//筛选结束</span>
    <span class="token punctuation">&#125;</span>
    R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//构建初始堆，从最后一个分支点n/2向下取整开始，反复筛选</span>
<span class="token comment">//for(i = n/2;i>=1;i--) sift(R,i,n)</span>

<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>RecType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    RecType tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token function">sift</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//建立初始堆</span>
    <span class="token comment">//每次抽掉“根”，就是堆上最大那个</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        tmp <span class="token operator">=</span> R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token function">sift</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>多次将两个或以上的有序表合成一个新的有序表。我们研究二路归并</p>
<p>先分成n个长度为1的，两两归并成n/2个向上取整的有序序列，依次类推直到得到长度为n的有序序列</p>
<p>我不想写啦！！！！P389自己看图吧</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>借助多关键字排序的思想堆单关键字进行排序。通过“分配”、“收集”</p>
<p>单关键字R[i].key 由d位数字组成，每一位的值都在(0 , r)之间，二进制r为2</p>
<p>最低位LSD和最高位优先MSD。选择方式由数据序列特点决定，越重要的位越放在后面.</p>
<p>想看原理在P390</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">//基数排序</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXD</span> <span class="token expression"><span class="token number">10000</span> </span><span class="token comment">//最大关键字位数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXR</span> <span class="token expression"><span class="token number">10</span>    </span><span class="token comment">//每一位的取值上限（开区间）</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> data<span class="token punctuation">[</span>MAXD<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//存放关键字的各位</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向下一个结点</span>
<span class="token punctuation">&#125;</span> NodeType<span class="token punctuation">;</span>

<span class="token comment">//输入数据为p为首节点的单链表</span>
<span class="token keyword">void</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span>NodeType <span class="token operator">*</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    NodeType <span class="token operator">*</span>head<span class="token punctuation">[</span>MAXR<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">[</span>MAXR<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//初始化指针</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>             <span class="token comment">//将原链表所有节点分配到链队</span>
        <span class="token punctuation">&#123;</span>
            k <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span> <span class="token comment">//找到第k个链队</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                head<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
                tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//重新用p来收集所有节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//找到第一个非空链队,通过首位指针处理，中间已经连好了</span>
            <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token punctuation">&#123;</span>
                    p <span class="token operator">=</span> head<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    t <span class="token operator">=</span> tail<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span>
                <span class="token punctuation">&#123;</span>
                    t<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    t <span class="token operator">=</span> tail<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//如果不是第一个,就连上来</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        t<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//别忘了！！！！！卧槽结束了！</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>虽然课后习题一道没写</p>
<p>虽然后面跳过了一些明显不考的算法，但是终于在考试前5天写完了还是好开心</p>
<p>但是还有大雾和微积分:cry:</p>
<p>学弟学妹们，虽然这门数据结构在未来会被淘汰，但是它的绩点很重啊QWQ,不要向我一样临时抱佛脚QWQ</p>
<p>试验一下新功能，把我的代码看能不能直接放在这方便你们下载</p>
<p><a href="/papers/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.zip">数据结构</a></p>
<p>👆</p>
<h1 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h1><p>串：KMP</p>
<p>稀疏矩阵快速转置</p>
<p>二叉树遍历的非递归</p>
<p>最短路径的两种算法</p>
<p>AOV和AOE</p>
<p>平衡二叉树的算法实现</p>
<p>归并排序</p>
<p>明年学算法设计前应该会写完这些</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马移动端</title>
    <url>/2021/04/04/%E9%BB%91%E9%A9%AC%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404092048961.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404092110874.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404092902977.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404093501592.png"></p>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094158699.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094215546.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094229638.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094241052.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094749176.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404094809333.png"  style="zoom:50%;" />

<h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404095411161.png"></p>
<p>开发尺寸显示在开发者工具中，我们开发网页根据这个就好了</p>
<p><strong>开发尺寸 * 物理像素比 = 分辨率</strong>             所以一个px可能由多个（dpr）物理像素组成</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404095756776.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404100314630.png"></p>
<hr>
<p><strong>图片缩放使用的属性</strong>：</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404101151359.png"></p>
<p>cutterman插件可以直接切出多倍图</p>
<h2 id="开发选择"><a href="#开发选择" class="headerlink" title="开发选择"></a>开发选择</h2><p>单独设计和响应式</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404101658904.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404101754577.png"></p>
<p>肯定更喜欢单独。。。</p>
<h2 id="技术解决方案"><a href="#技术解决方案" class="headerlink" title="技术解决方案"></a>技术解决方案</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404101935867.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404102038130.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404102428587.png"  style="zoom:50%;" />

<p>重温一下。。。。。。。</p>
<p>传统的叫做box-sizing : content-box;</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404102542684.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404102815857.png"></p>
<p><strong>还有一些以后可以积累！！！</strong></p>
<h1 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404103152496.png"></p>
<p>所以需要提前了解想去的公司采用怎样的方案。。。</p>
<p>pink老师会依次介绍哟！(＾Ｕ＾)ノ~ＹＯ</p>
<h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404111307804.png"></p>
<p>流式布局主要看的是宽度，高度不管。。。高度好像都是px</p>
<p>但是拉伸的时候也会影响到内部内容，所以必须加以限制！</p>
<p>可以用max/min - width/height 来辅助实现</p>
<hr>
<h3 id="京东案例"><a href="#京东案例" class="headerlink" title="京东案例"></a>京东案例</h3><p>懒得做了。。。记笔记吧</p>
<p><strong>准备</strong></p>
<p>方案：单独制作页面</p>
<p>技术选型：流式布局</p>
<p>文件布局： css  images  upload  js  index.html</p>
<p>准备：设置视口标签，引入css移动端初始化，引入自己的css文件。。。</p>
<hr>
<p><strong>body</strong></p>
<p>因为竖直下来每个盒子基本都是百分百宽度</p>
<p>**所以可以直接给body一个宽度100%**，而子盒子都能继承</p>
<p>但是一味地放大缩小会拉伸的很丑！所以指定宽度限制！然后居中对齐</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404112849868.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404112952388.png"  style="zoom:50%;" />



<p><strong>顶栏展示</strong></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404114145471.png"  style="zoom:67%;" />

<p><strong>京东做法</strong></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404114233468.png"  style="zoom:67%;" />

<p>但是<strong>高度设置的是固定的45px</strong>，这个应该是总结和调试出来的</p>
<p><em>用一个ul代表这一长条，里面有4个小li，好像特别喜欢用列表</em></p>
<p><em>不过这样确实满足“语义化” 这是个顶栏列表，里面包含了若干元素</em></p>
<p>他那个小叉和图片竟然是<strong>固定尺寸</strong>的！记得verticle-align : center;</p>
<p>然后这个不用a，到时候用js来做跳转特效就好了。。。果然结构和功能也要分离</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404115119107.png"></p>
<p>宽度改变时，中间变短，俩边不变的效果</p>
<p>直接先做好两边的，用绝对定位和固定尺寸分别固定到这个长条盒子的两侧</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404115442039.png"  style="zoom:50%;" />

<p>然后中间放的是没有宽度（使其铺满）的标准流，然后指定左右margin，略大于两侧盒子的宽度即可</p>
<p>然后使其居中，通过加上边距，但这样会导致外边距合并，加overflow:hidden解决</p>
<hr>
<p><em>ps：在div里面有子元素div1时，若父元素div在没有设置overflow:hidden或者是border属性，则父元素div的margin-top的值为父元素div和子元素div1中的margin-top的最大值。</em></p>
<hr>
<p><strong>列表栏和登陆栏</strong>写法：</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404120242284.png"  style="zoom:67%;" />

<hr>
<p><strong>search栏</strong>：</p>
<p><strong>子元素均采用定位效果实现</strong></p>
<p>京东图标后面的小竖线：<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404120515491.png"></p>
<p>记得after和before是作为子元素，所以这里加个position:absolute定位</p>
<p>再调定位到合适的位置呗</p>
<hr>
<p>应该用一个盒子包起来，然后设置fixed属性！不过记得同样设置宽度的限制范围哦</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404130538927.png"  style="zoom: 80%;" />

<hr>
<p><em><strong>小放大镜是二倍精灵图</strong></em></p>
<p>错误做法：亮出精灵图相应图标的位置，直接用那个位置，然后缩放</p>
<p>这样是错误的，因为缩放是对整个图片进行缩放的，所以坐标也会发生变化</p>
<p>应该把坐标换为原来的n分之一，然后把图片缩放,background-size:</p>
<hr>
<p>主体内容部分是导航栏以下的所有内容的一个大盒子</p>
<p>包含了焦点图和商品啊，分类啊巴拉巴拉的</p>
<p>这些展示图，更新频率高的，记得放在upload文件夹里而不是images里面哟</p>
<p>竟然是三张图片分别放在3个盒子。。。。我以为背景一张图片，三个透明盒子。。。</p>
<hr>
<p>ps：<em>可以改成bottom/top/middle来改掉图片和边框间的空白缝隙，或者改成块元素</em></p>
<p>在设置图片边框样式中，图片或者表单等行内元素，这样会造成一个问题，就是图片底侧以及图片与图片之间会有一个空白缝隙。<strong>原因是行内元素之间的回车符系统默认为一个空格，占据了一定宽度。</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/20181109094353277.png" alt="在这里插入图片描述"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404131738535.png"  style="zoom:80%;" />

<hr>
<p><strong>导航栏</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404132002023.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404132022862.png"  style="zoom:50%;" />超链接里面放了一个图片和一个文字描述罢了。。复制20次</p>
<p>还有一些字体要用rem处理等巴拉巴拉。。</p>
<h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404133310817.png"></p>
<hr>
<p><strong>布局原理</strong></p>
<p>pink说flex布局比浮动布局好</p>
<p>因为flex有与浮动类似的性质，而且更好，所以float  clear失效</p>
<p>因为flex自带垂直居中的方法，所以vertical-align熟悉失效</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404202621904.png"  style="zoom: 80%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404202720250.png"></p>
<hr>
<h3 id="父级属性"><a href="#父级属性" class="headerlink" title="*父级属性"></a>*父级属性</h3><p>display:flex</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404203058261.png"  style="zoom:80%;" />

<hr>
<p><strong>flex-direction</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404203413186.png"></p>
<p>默认主轴是x轴（row）</p>
<hr>
<p><strong>justify-content</strong></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404203804127.png"  style="zoom: 67%;" />

<p>注意space-around是每个盒子的两边的外边距都一样</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404203910838.png"  style="zoom:50%;" />

<hr>
<p><strong>flex-wrap</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404204314797.png"></p>
<p>默认会自动缩小元素在排列方向的长度（水平则缩小宽度）</p>
<hr>
<p><strong>align-items</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404204924293.png"></p>
<p>stretch会拉到和父亲一个尺寸，当然隔着一个margin，如果设置了相应方向的尺寸，则失效</p>
<hr>
<p><strong>align-content</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404205130782.png"></p>
<p>为啥要搞出俩属性。。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404205514687.png"></p>
<hr>
<p><strong>flex-flow</strong></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404205750060.png"  style="zoom:50%;" />

<p>还有一些其他的属性，以后得补补</p>
<hr>
<h3 id="子项属性"><a href="#子项属性" class="headerlink" title="子项属性"></a>子项属性</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404205938407.png"></p>
<hr>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a><strong>flex</strong></h4><p>默认是0，分配剩余空间，所以不加宽度再设为1就可以占满剩下的所有</p>
<p>卧槽牛逼啊，横的竖的组合起来不是无敌了！顶多加个啥边距</p>
<p>无敌何须多言？？？！！！</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404211047059.png"></p>
<p>align-self属性不适用于块类型的盒模型和表格单元。如果任何 flexbox 元素的侧轴方向 margin 值设置为 auto，则会忽略 <code>align-self</code>。</p>
<p>这货的属性蛮多的。。不知道有啥用</p>
<hr>
<p><strong>order</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404211641830.png"></p>
<p>挺不错的欸，这个order</p>
<h3 id="携程网案例"><a href="#携程网案例" class="headerlink" title="携程网案例"></a>携程网案例</h3><p>仍然懒得做。。记笔记吧<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404211730880.png"  style="zoom:50%;" /></p>
<p><strong>初始化</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404212240317.png"></p>
<p>overflow-x:hidden 不出现水平滚动条</p>
<p>还是技术选型。。。flex，好无聊，高度还是定死的，巧用flex一下就完了</p>
<p><strong>固定在上方的导航栏</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404213131595.png"></p>
<p>要兼容的话，在transform前加上一句-webkit-transform : translateX(-50%);</p>
<p>里面一个搜索框一个头像，给头像（右）加个宽度，搜索框不加宽度，用flex:1，tql吧！！</p>
<p>这边突然有个坑，CSS3模型，如果有边框，那么行高=高来垂直居中会偏下，必须行高=内容区域</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404232317142.png"  style="zoom:80%;" />

<hr>
<h3 id="图-文字结构"><a href="#图-文字结构" class="headerlink" title="图+文字结构"></a><strong>图+文字结构</strong></h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404232725505.png"></p>
<p>上面一个span背景设成2倍精灵图，下面一个span里面写字，然后整个放进a里面</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210404232851846.png"></p>
<p><code>flex-direction: column</code></p>
<p><code>align-items : center</code></p>
<hr>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405000418333.png"></p>
<p>好像支持不太好，注意格式哟</p>
<hr>
<p><strong>subnav</strong></p>
<p>卧槽，flex的指可以是百分比，按照父亲的给</p>
<p>虽然flex为主，但是也可以搭配其他的做</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405001344268.png"></p>
<p>这边用了传统布局，h2标签是为了SEO优化。。。</p>
<p><strong>传统布局有时候一些盒子最好不用设置宽度，而是用内容+padding挤开</strong>，比如：</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405001902452.png"></p>
<h2 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h2><p>非常重要！<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405002252282.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405003212779.png"></p>
<hr>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405003354284.png"  style="zoom:67%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405003444816.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405003529315.png"></p>
<p>screen….</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405092324456.png"  style="zoom:67%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405092639075.png"></p>
<hr>
<p>tips：</p>
<p><strong>如果判断最小值，应该从小到大写（pink推荐。。），如果判断最大值，应该从大到小写</strong></p>
<p><strong>min-width 和 max-width  是自带等于号的！</strong>and两边要留下空格。数字后必须跟单位</p>
<p>媒体查询并没有增加权重，所以如果特殊的是媒体查询的，要放在后面覆盖</p>
<p> <code>@media screen and (min-width:540px) and (max-width:969px)</code> 在540和970分界</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405093944821.png"></p>
<hr>
<p><strong>引入资源</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405094452887.png"></p>
<h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405113156180.png"></p>
<h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405113258345.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405113608309.png"></p>
<p><strong>但是注意页面元素的px值和页面一开始设置的px值是统一标准下的（美工图里的标准👇）</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405114113453.png"></p>
<hr>
<h4 id="苏宁案例"><a href="#苏宁案例" class="headerlink" title="苏宁案例"></a>苏宁案例</h4><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405114359486.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405114524912.png"  style="zoom:67%;" />

<p>别忘了写最常见的（默认大小，兜底）：</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405114745174.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405115111146.png"></p>
<p>这是引入样式的另一种思路，但其实都差不多感觉</p>
<hr>
<p><strong>body</strong></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405115339700.png"  style="zoom:50%;" />



<p>因为没有手机是小于320px的，宽度直接设为<strong>你分的份数</strong>就好了</p>
<p>而在750px宽的设计图下，html大小可以直接给个变量50就好了</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405145326438.png"></p>
<hr>
<p>导航栏基本一样。。。再强调一下居中不是auto，fiex下要用left和transform</p>
<p><strong>虽然这里主体是用rem，但是哪个好用用哪个，不要局限死，这里明显flex好用嘛</strong></p>
<p>对于字体大小，美工一般会给可以直接看出大小的效果图。</p>
<p>不过这个搜索框的格式很怪</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405130326915.png"></p>
<p>图片最好是给装图片的框设置大小和方位巴拉巴拉</p>
<p>然后图片长宽 100%</p>
<hr>
<p>苏宁的导航栏不是用flex</p>
<p>是一堆a，（竟然没用ul和li）每个a里放一张图片和一个span</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405150455700.png"  style="zoom: 50%;" />

<p>全都用rem来写，5个a的宽度刚好是一行的宽度</p>
<hr>
<h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405150949559.png"></p>
<p><strong>我就说嘛。那么高的精度，不管分几份好像都没关系</strong></p>
<p>初始化css叫normalize.css</p>
<p>cssrem修改默认html尺寸，按照设计图的样式来。</p>
<p><strong>flexible默认全屏。若要限制最大宽度</strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">
<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 750px<span class="token punctuation">)</span></span><span class="token punctuation">&#123;</span>
    <span class="token selector">html</span><span class="token punctuation">&#123;</span>
        <span class="token property">font-size</span> <span class="token punctuation">:</span> 75px <span class="token important">!important</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>rem + flexible + less 用的挺好的，再配上cssrem插件</p>
<p>flexible.js划分是按全屏幕的10等份，在移动端需要更改一下</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210406083616174.png"></p>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>一个网站，所有设备！！！</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405204535363.png"></p>
<p><strong>常见划分尺寸👇</strong>，并不是绝对！原来屏幕竟然是定死的！</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405204933124.png"></p>
<p>尺寸稍小是因为两侧流出空白比装不下好看</p>
<p>调整cssrem，在插件的设置栏可以调整默认一html单位的大小</p>
<hr>
<h4 id="条件注释"><a href="#条件注释" class="headerlink" title="条件注释"></a>条件注释</h4><p>由于浏览器版本的不同，对CSS里某些元素的解释也不一样，针对浏览器版本不同而选择不同CSS的代码，<br>其实我们还可以利用条件注释的方法来达到类似的目的，什么是条件注释，在此简单介绍一下，无非就是一些if判断啦，呵呵，但这些判断不是在脚本里执行的，而是直接在html代码里执行的，下面来介绍一下使用方法吧。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;!--[if XXX]>
这里是正常的html代码
&lt;![endif]–>
这里XXX是一些特定的东东，在此列表几个出来，详细介绍各自的含义：
&lt;!–[if IE]> / 如果浏览器是IE /
&lt;!–[if IE 5]> / 如果浏览器是IE 5 的版本 /
&lt;!–[if IE 6]> / 如果浏览器是IE 6 的版本 /
&lt;!–[if IE 7]> / 如果浏览器是IE 7 的版本 /


上面是几个常用的判断IE浏览器版本的语法，下面再来介绍一下相对比较少用的逻辑判断的参数：
有几个参数：lte，lt，gte，gt及!
各自的详细解释如下：
lte：就是Less than or equal to的简写，也就是小于或等于的意思。
lt ：就是Less than的简写，也就是小于的意思。
gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
gt ：就是Greater than的简写，也就是大于的意思。

<span class="token property">例句</span><span class="token punctuation">:</span>

&lt;!--[if gt IE 5.5]> / 如果IE版本大于5.5 /
&lt;!–[if lte IE 6]> / 如果IE版本小于等于6 /
&lt;!–[if !IE]> / 如果浏览器不是IE /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405210248567.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405210651094.png"  style="zoom:50%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405210706832.png"></p>
<p><strong>3.xx偏向于移动端和响应式哟！！</strong></p>
<hr>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405211033985.png"  style="zoom: 67%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405211207765.png"></p>
<p>在中文文档找到“<strong>基础模板</strong>”，然后复制，但是基本和vscode一样，多了一个条件注释复制过来</p>
<p>然后引入css样式文件（内置了normalize.css）。。主要通过类来控制，默认border-box</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405212232101.png"></p>
<p>得了解深一些才能自由diy</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405212740845.png"></p>
<p>不用自己再手动写了。。。这到底是好是坏</p>
<hr>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>与rem布局很相似，不过rem是划分屏幕，栅格是划分<strong>页面内容</strong>（container）</p>
<p>想要更好的使用，得了解这些封装的实质，比如分成12份最终是由百分比实现的</p>
<p>可以多用开发者工具查看网站的最终源码，多去查查文档</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405213028685.png"></p>
<p>卧槽。<strong>container可以有很多个，可以单独适用于某些行，挺棒的</strong></p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405213715077.png"></p>
<p><strong>行数</strong></p>
<p>行应始终位于容器中。</p>
<p>该行为列提供了一个居住的地方，理想情况下，列的总数为12。它还可以作为包装器使用，因为所有列都向左浮动，当浮动变得怪异时，其他行不会重叠。</p>
<p>行的每边也有15px的负边距。组成该行的div通常会被限制在容器的填充内部，而不是粉红色区域的边缘，但不能超出。15px的负边距将行压到容器顶部15px的填充上方，从而使行基本无效。此外，行确保您其中的所有div都显示在自己的行上，与上一行和下一行分开。</p>
<hr>
<p><strong>列</strong></p>
<p>列现在具有15px的填充。这种填充意味着列实际上接触行的边缘，由于行具有负边距，而容器具有正的填充，列本身就接触容器的边缘。但是，列上的填充将列内的任何内容推入所需的位置，并且在列之间提供了30px的装订线。切勿在行外使用列，否则将无法使用。</p>
<hr>
<p>如果份数相加小于12：</p>
<p>占不满整个屏幕，默认左对齐</p>
<p>如果分数相加大于12：</p>
<p>装不开的那些，超出的整体另起一行</p>
<p>通过给同一个盒子添加不同情况下的自定义类名来决定。卧槽，我悟了！</p>
<hr>
<p><strong>列嵌套</strong></p>
<p>跟flex一样开始套起来了</p>
<p>不要加margin值，因为分列他最后是变成百分比的宽度</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405214657467.png"></p>
<p>这个的边距是一开始栅格划分4个大盒子，每个大盒子里面嵌套一个小盒子搞的（又有默认15px内边距）。</p>
<hr>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405215012191.png"  style="zoom:67%;" />

<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405215429060.png"></p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405215608395.png"></p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405220014929.png"></p>
<hr>
<h3 id="阿里百秀"><a href="#阿里百秀" class="headerlink" title="阿里百秀"></a>阿里百秀</h3><p>宏观布局</p>
<p>一个大container装下三大列</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405223837878.png"></p>
<p>然后放缩屏幕观察变化</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405224219100.png"></p>
<p>这个策略很重要！</p>
<hr>
<p>这个时候有个小问题，美工给的设计图是1280px，但默认最大宽度是1170px</p>
<p>所以就手动修改一下下</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405225000595.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405225308492.png"></p>
<p>有时候需要去掉padding，记得权重，而小心margin带来的影响</p>
<p><strong>字体图标组件，在boostrap选对应的类名加上去，实质是一个before元素</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405230516077.png"></p>
<p>高度不需要太在意，因为不同大小直接换布局，高度是定死的？？？</p>
<p>所以在响应式布局中，也有一些其实是不变的，或者说比起那种rem，它不变的地方很多</p>
<p>每个小的container都得分析四种或更多情况下的新布局哟</p>
<p>久违的清除浮动，可以直接加类 “ clearfix “来实现</p>
<p>卧槽，需要怎样的样式直接去中文文档里的排版里面查，它设定好了许多最通用的样式</p>
<p>然后如果需要改变一些文字样式，可以直接去辅助类 -&gt;上下文选择，，</p>
<p>然后他这些模块不是写死的，比如按钮的类可以加到span上，也有类似的外观</p>
<hr>
<p>完成了大屏幕的制作，现在针对小屏幕情况修饰一下</p>
<p>根据实际情况选择不同的处理方式，比如有个大图片，不要让它设置成宽度100%，而是设置居中</p>
<p>再小一点的时候就不合适，可以把图片隐藏，换成一个新元素（放了文字的盒子（平时隐藏，小显示））</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405233441558.png"></p>
<p>有两个贼方便的属性：visible-x和hidden-x</p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405233637111.png"></p>
<p>大屏幕竖直排列，小屏幕水平排列，很简单！别忘了媒体条件</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405233726919.png"></p>
<p>然后在其中再加上修饰，比如文字变小啊，</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405234026831.png"  style="zoom:50%;" />小小的修饰一下背景颜色嘿嘿</p>
<p>我们看样式的时候要切换到手机的尺寸检查，不然在pc端随意拖动宽度效果可能有些不一样</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405234244136.png"  style="zoom:50%;" />

<p>小屏幕时把内边距记得也改小一点，不像👆</p>
<h2 id="总结！"><a href="#总结！" class="headerlink" title="总结！"></a>总结！</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405235002988.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405235128420.png"></p>
<p>感觉rem为主，配合flex确实很好，flex毕竟太规整了些，也可能是我现在接触不多</p>
<p>再见！55个小时，刚好2周学完，谢谢pink老师，带我入了前端的门！</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405235913519.png"></p>
<h1 id="Less基础"><a href="#Less基础" class="headerlink" title="Less基础"></a>Less基础</h1><p>怎么风评less 没有 sass好。。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405095114785.png"></p>
<hr>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405095201588.png"></p>
<hr>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。</p>
</blockquote>
<p>因为 Less 和 CSS 非常像，因此很容易学习。而且 Less 仅对 CSS 语言增加了少许方便的扩展，这就是 Less 如此易学的原因之一。</p>
<ul>
<li><em>有关 Less 语言特性的详细文档，请参阅 <a href="https://less.bootcss.com/features/">Less 语言特性</a> 章节</em></li>
<li><em>有关 Less 内置函数的列表，请参阅 <a href="https://less.bootcss.com/functions/">Less 函数手册</a> 章节</em></li>
<li><em>有关详细的使用说明，请参阅 <a href="https://less.bootcss.com/usage/">Less.js 用法</a> 章节</em></li>
<li><em>有关第三方工具的详细信息，请参阅 <a href="https://less.bootcss.com/tools/">工具</a> 章节</em></li>
</ul>
<p>Less 到底为 CSS 添加了什么功能？以下就是这些新加功能的概览。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>无需多说，看代码一目了然：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@width<span class="token punctuation">:</span></span> 10px<span class="token punctuation">;</span>
<span class="token variable">@height<span class="token punctuation">:</span></span> <span class="token variable">@width</span> <span class="token operator">+</span> 10px<span class="token punctuation">;</span>

<span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@height</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译为：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/features/#variables-feature">了解关于变量的更多信息</a></strong></p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。假设我们定义了一个类（class）如下：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.bordered</span> <span class="token punctuation">&#123;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> dotted 1px black<span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> solid 2px black<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果我们希望在其它规则集中使用这些属性呢？没问题，我们只需像下面这样输入所需属性的类（class）名称即可，如下所示：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">#menu a</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> #111<span class="token punctuation">;</span>
  <span class="token mixin-usage function">.bordered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token selector">.post a</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token mixin-usage function">.bordered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>.bordered</code> 类所包含的属性就将同时出现在 <code>#menu a</code> 和 <code>.post a</code> 中了。（注意，你也可以使用 <code>#ids</code> 作为 mixin 使用。）</p>
<p><strong><a href="https://less.bootcss.com/features/#mixins-feature">了解关于混合（Mixin）的更多信息</a></strong></p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>Less 提供了使用嵌套（nesting）代替层叠或与层叠结合使用的能力。假设我们有以下 CSS 代码：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">#header .navigation</span> <span class="token punctuation">&#123;</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">#header .logo</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用 Less 语言我们可以这样书写代码：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
  <span class="token selector">.navigation</span> <span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token selector">.logo</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用 Less 书写的代码更加简洁，并且模仿了 HTML 的组织结构。</p>
<p>你还可以使用此方法将伪选择器（pseudo-selectors）与混合（mixins）一同使用。下面是一个<strong>经典的 clearfix 技巧</strong>，重写为一个混合（mixin） (<code>&amp;</code> 表示当前选择器的父级）(伪元素也要这样)：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.clearfix</span> <span class="token punctuation">&#123;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>

  <span class="token selector">&amp;:after</span> <span class="token punctuation">&#123;</span>
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/features/#parent-selectors-feature">了解有关夫选择器的详细信息</a></strong></p>
<h3 id="规则嵌套和冒泡"><a href="#规则嵌套和冒泡" class="headerlink" title="@规则嵌套和冒泡"></a>@规则嵌套和冒泡</h3><p>@ 规则（例如 <code>@media</code> 或 <code>@supports</code>）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的<strong>其它元素的相对顺序</strong>保持不变。这叫做冒泡（bubbling）。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.component</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token atrule">@media <span class="token punctuation">(</span>min-width<span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
    <span class="token atrule">@media  <span class="token punctuation">(</span>min-resolution<span class="token punctuation">:</span> 192dpi<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
      <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/img/retina2x.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token atrule">@media <span class="token punctuation">(</span>min-width<span class="token punctuation">:</span> 1280px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 800px<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译为：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.component</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
  <span class="token selector">.component</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-resolution</span><span class="token punctuation">:</span> 192dpi<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
  <span class="token selector">.component</span> <span class="token punctuation">&#123;</span>
    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/img/retina2x.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 1280px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
  <span class="token selector">.component</span> <span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 800px<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>算术运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行<strong>单位换算</strong>。<strong>计算的结果以最左侧操作数的单位类型为准</strong>。如果<strong>单位换算无效或失去意义，则忽略单位</strong>，<strong>结果以第一个单位为准</strong>。若只有一个单位，以该单位为准<strong>无效</strong>的单位换算例如：px 到 cm 或 rad 到 % 的转换。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token comment">// 所有操作数被转换成相同的单位</span>
<span class="token variable">@conversion-1<span class="token punctuation">:</span></span> 5cm <span class="token operator">+</span> 10mm<span class="token punctuation">;</span> <span class="token comment">// 结果是 6cm</span>
<span class="token variable">@conversion-2<span class="token punctuation">:</span></span> 2 <span class="token operator">-</span> 3cm <span class="token operator">-</span> 5mm<span class="token punctuation">;</span> <span class="token comment">// 结果是 -1.5cm</span>

<span class="token comment">// conversion is impossible</span>
<span class="token variable">@incompatible-units<span class="token punctuation">:</span></span> 2 <span class="token operator">+</span> 5px <span class="token operator">-</span> 3cm<span class="token punctuation">;</span> <span class="token comment">// 结果是 4px</span>

<span class="token comment">// example with variables</span>
<span class="token variable">@base<span class="token punctuation">:</span></span> 5%<span class="token punctuation">;</span>
<span class="token variable">@filler<span class="token punctuation">:</span></span> <span class="token variable">@base</span> <span class="token operator">*</span> 2<span class="token punctuation">;</span> <span class="token comment">// 结果是 10%</span>
<span class="token variable">@other<span class="token punctuation">:</span></span> <span class="token variable">@base</span> <span class="token operator">+</span> <span class="token variable">@filler</span><span class="token punctuation">;</span> <span class="token comment">// 结果是 15%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>乘法和除法不作转换。因为这两种运算在大多数情况下都没有意义</strong>，一个长度乘以一个长度就得到一个区域，而 CSS 是不支持指定区域的。Less 将按数字的原样进行操作，并将为计算结果指定明确的单位类型。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@base<span class="token punctuation">:</span></span> 2cm <span class="token operator">*</span> 3mm<span class="token punctuation">;</span> <span class="token comment">// 结果是 6cm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>你还可以对<strong>颜色</strong>进行算术运算：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@color<span class="token punctuation">:</span></span> #224488 <span class="token operator">/</span> 2<span class="token punctuation">;</span> <span class="token comment">//结果是 #112244</span>
<span class="token property">background-color</span><span class="token punctuation">:</span> #112244 <span class="token operator">+</span> #111<span class="token punctuation">;</span> <span class="token comment">// 结果是 #223355</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>运算符两侧尽量有空格，<em>除法必须用括号括起来</em>！！！！</strong></p>
<p>不过，Less 提供的 <a href="https://less.bootcss.com/functions/#color-operations">色彩函数</a> 更有使用价值。</p>
<h3 id="calc-特例"><a href="#calc-特例" class="headerlink" title="calc() 特例"></a>calc() 特例</h3><p><em>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v3.0.0</a></em></p>
<p>为了与 CSS 保持兼容，**<code>calc()</code> 并不对数学表达式进行计算**，但是在嵌套函数中会计算变量和数学公式的值。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@var<span class="token punctuation">:</span></span> 50vh<span class="token operator">/</span>2<span class="token punctuation">;</span>
<span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>50% <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token variable">@var</span> <span class="token operator">-</span> 20px<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 结果是 calc(50% + (25vh - 20px))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>转义（Escaping）允许你使用<strong>任意字符串作为属性或变量值</strong>。任何 <code>~&quot;anything&quot;</code> 或 <code>~&#39;anything&#39;</code> 形式的内容都将按原样输出，除非 <a href="https://less.bootcss.com/features/#variables-feature-variable-interpolation">interpolation</a>。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@min768<span class="token punctuation">:</span></span> ~<span class="token string">"(min-width: 768px)"</span><span class="token punctuation">;</span>
<span class="token selector">.element</span> <span class="token punctuation">&#123;</span>
  <span class="token atrule">@media @min768</span> <span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2rem<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译为：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token atrule">@media <span class="token punctuation">(</span>min-width<span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
  <span class="token selector">.element</span> <span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2rem<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，从 Less 3.5 开始，可以简写为：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@min768<span class="token punctuation">:</span></span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token selector">.element</span> <span class="token punctuation">&#123;</span>
  <span class="token atrule">@media @min768</span> <span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1.2rem<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 Less 3.5+ 版本中，许多以前需要“引号转义”的情况就不再需要了。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。这些函数在<a href="https://less.bootcss.com/functions/">Less 函数手册</a>中有详细介绍。</p>
<p>函数的用法非常简单。下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@base<span class="token punctuation">:</span></span> #f04615<span class="token punctuation">;</span>
<span class="token variable">@width<span class="token punctuation">:</span></span> 0.5<span class="token punctuation">;</span>

<span class="token selector">.class</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">percentage</span><span class="token punctuation">(</span><span class="token variable">@width</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns `50%`</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token variable">@base</span><span class="token punctuation">,</span> 5%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">spin</span><span class="token punctuation">(</span><span class="token function">lighten</span><span class="token punctuation">(</span><span class="token variable">@base</span><span class="token punctuation">,</span> 25%<span class="token punctuation">)</span><span class="token punctuation">,</span> 8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/functions/">参见：函数手册</a></strong></p>
<h2 id="命名空间和访问符"><a href="#命名空间和访问符" class="headerlink" title="命名空间和访问符"></a>命名空间和访问符</h2><p>(不要和 <a href="http://www.w3.org/TR/css3-namespace/">CSS <code>@namespace</code></a> 或 <a href="http://www.w3.org/TR/css3-selectors/#typenmsp">namespace selectors</a> 混淆了)。</p>
<p>有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对混合（mixins）进行分组。你可以用 Less 更直观地实现这一需求。假设你希望将一些混合（mixins）和变量置于 <code>#bundle</code> 之下，为了以后方便重用或分发：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">#bundle()</span> <span class="token punctuation">&#123;</span>
  <span class="token selector">.button</span> <span class="token punctuation">&#123;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> grey<span class="token punctuation">;</span>
    <span class="token selector">&amp;:hover</span> <span class="token punctuation">&#123;</span>
      <span class="token property">background-color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token selector">.tab</span> <span class="token punctuation">&#123;</span> ... <span class="token punctuation">&#125;</span>
  <span class="token selector">.citation</span> <span class="token punctuation">&#123;</span> ... <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在，如果我们希望把 <code>.button</code> 类混合到 <code>#header a</code> 中，我们可以这样做：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">#header a</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> orange<span class="token punctuation">;</span>
  <span class="token mixin-usage function">#bundle.button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 还可以书写为 #bundle > .button 形式</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：如果不希望它们出现在输出的 CSS 中，例如 <code>#bundle .tab</code>，请将 <code>()</code> 附加到命名空间（例如 <code>#bundle()</code>）后面。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>从 Less 3.5 版本开始，你还可以将<strong>混合（mixins）和规则集（rulesets）作为一组值的映射（map）</strong>使用。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">#colors()</span> <span class="token punctuation">&#123;</span>
  <span class="token property">primary</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">secondary</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token selector">.button</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> #colors[primary]<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #colors[secondary]<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出符合预期：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.button</span> <span class="token punctuation">&#123;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid green<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/features/#maps-feature">参见： 映射（Maps）</a></strong></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Less 中的作用域（scope）与 CSS 中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@var<span class="token punctuation">:</span></span> red<span class="token punctuation">;</span>

<span class="token selector">#page</span> <span class="token punctuation">&#123;</span>
  <span class="token variable">@var<span class="token punctuation">:</span></span> white<span class="token punctuation">;</span>
  <span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@var</span><span class="token punctuation">;</span> <span class="token comment">// white</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与 CSS 自定义属性一样，混合（mixin）和变量的<strong>定义不必在引用之前事先定义</strong>。因此，下面的 Less 代码示例和上面的代码示例是相同的：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@var<span class="token punctuation">:</span></span> red<span class="token punctuation">;</span>

<span class="token selector">#page</span> <span class="token punctuation">&#123;</span>
  <span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@var</span><span class="token punctuation">;</span> <span class="token comment">// white</span>
  <span class="token punctuation">&#125;</span>
  <span class="token variable">@var<span class="token punctuation">:</span></span> white<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/features/#variables-feature-lazy-loading">参见：懒加载</a></strong></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>块注释和行注释都可以使用：</p>
<pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token comment">/* 一个块注释
 * style comment! */</span>
<span class="token variable">@var<span class="token punctuation">:</span></span> red<span class="token punctuation">;</span>

<span class="token comment">// 这一行被注释掉了！</span>
<span class="token variable">@var<span class="token punctuation">:</span></span> white<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>“导入”的工作方式和你预期的一样。你可以导入一个 <code>.less</code> 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 <code>.less</code> 扩展名，则可以将<strong>扩展名省略掉</strong>：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@import</span> <span class="token string">"library"</span><span class="token punctuation">;</span></span> // library.less
<span class="token atrule"><span class="token rule">@import</span> <span class="token string">"typo.css"</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><a href="https://less.bootcss.com/features/#imports-feature">了解更多关于导入(Importing)的知识</a></strong></p>
<p>这里有个巨坑，如果用了导入，要连续保存才能显示</p>
<h2 id="进阶指南"><a href="#进阶指南" class="headerlink" title="进阶指南"></a><a href="https://less.bootcss.com/features/#mixins-feature">进阶指南</a></h2><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="蓝湖-慕客"><a href="#蓝湖-慕客" class="headerlink" title="蓝湖/慕客"></a>蓝湖/慕客</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405162122127.png"></p>
<p>蓝湖10人免费，慕客100人免费，直接注册账号，下载就自动装好了</p>
<p>卧槽，可以选择图层然后上传，选的图层会单独保留以供下载</p>
<p>可以直接查看一堆参数甚至代码，图片直接下好1，2，3倍，无敌啊</p>
<p>美工会分享项目给开发者</p>
<hr>
<h2 id="Swiper神器"><a href="#Swiper神器" class="headerlink" title="Swiper神器"></a>Swiper神器</h2><p>很有必要好好学一学</p>
<p>直接下载，最新那个，现在到6了（2021.4）解压解压</p>
<p>package -&gt; js/css  复制引入swiper.min.js 和 swiper.min.css</p>
<p>在swiper演示的那里选一个大概样式差不多的，后面可以自己调整</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405171415870.png"  style="zoom:67%;" />

<p>进去后右键查看网页源代码嘿嘿，然后引入需要的文件</p>
<p>把HTML代码插入到需要的位置，再把CSS代码放到合适的位置，接下来开始定制！</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405171916821.png"></p>
<p>为了避免多个轮播图冲突，放在立即执行函数中</p>
<p>然后去查看API，描述了各组件的功能，少了东西可以去别的实例里面弄过来，（比如箭头啥的）这封装的挺好啊</p>
<p>然后去他的css或者html代码里面调那些东西。</p>
<p>我们可以通过查看API来选择我们需要的组件添加，也可以更改一下提供的css样式，毕竟他提供的子项都是盒子，但js逻辑是封装好的，只留下了几个API供调整</p>
<p>记得调一下swiperprivew，调一下显示的个数。。查手册yyds</p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>多轮播图冲突</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405195233991.png"></p>
<p>给上面html的container换类名或者加新的类名</p>
<p>然后给对应的js改类名</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210405195429469.png"></p>
<h2 id="提交网站到github"><a href="#提交网站到github" class="headerlink" title="提交网站到github"></a>提交网站到github</h2><p>首先建立与远程的链接</p>
<p>然后建立page。。。没了</p>
<p>或者直接用readme.md初始化，然后把文件拽进来。。。</p>
]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>html&amp;&amp;css入门</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马html&amp;css</title>
    <url>/2021/03/20/%E9%BB%91%E9%A9%AChtml&amp;css/</url>
    <content><![CDATA[<h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>本教程缺失一些不常用的知识，以后见到了再学</p>
<h2 id="html标签（上）"><a href="#html标签（上）" class="headerlink" title="html标签（上）"></a>html标签（上）</h2><p>浏览器内核</p>
<p>（又称渲染引擎）负责读取网页内容，整理信息，计算网页的显示方式并显示页面</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210320214750898.png"></p>
<p>Web标准</p>
<p>由W3C规定，规定了不同浏览器解析出的效果基本一样，</p>
<p>三大部分：结构（整理），表现（外观样式），行为（交互）</p>
<p>标准提出的最佳体验方案：结构，样式，行为分离！！！！！</p>
<p>可以简单理解为分别对应H C J</p>
<p>语义：strong  em   del  ins</p>
<p>图像标签：src  alt  title width height border</p>
<p>超链接：href（#空连接   指向文件可以下载 视频） target(_self _blank)   </p>
<p>锚点链接：href（#id）</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210320222646217.png"></p>
<p>记得加分号</p>
<h2 id="html标签（下）"><a href="#html标签（下）" class="headerlink" title="html标签（下）"></a>html标签（下）</h2><p>表格：展示数据，而不是布局页面！</p>
<p>table : tr : th/td</p>
<p>table属性：align  border  cellpadding(内容与边框)  cellspacing(单元格间的缝隙) w h</p>
<p>thead  tbody语义化  （thead是区域，th是表头单元格）</p>
<p>合并单元格：rowspan（行）colspan（列）这里作为属性colspan=”2”占据两个行/列</p>
<p>也可以使用colgroup和col巴拉巴拉</p>
<p>列表：用来布局！无序，有序，自定义</p>
<p>ul只准放 li，但li里可以放任意    ol同上</p>
<p>自定义列表常用于对术语或名词进行解释或描述</p>
<p>dl（不能放别的） dt（名词）dd（用来说明的小弟） 但是dt和dd是兄弟关系！</p>
<p>表单：收集用户信息，主要交互之一</p>
<p>分为表单域，表单控件（表单元素），提示信息</p>
<p>表单域：包含表单元素的区域，把范围内的表单信息提交给服务器</p>
<p>form  action：指定接受并处理表单数据的服务器程序的url</p>
<p>method get/post这是REST规范吗？</p>
<p>name 表单域名称</p>
<p>表单控件：</p>
<ol>
<li><p>input：输入表单元素</p>
<p>单标签，必选属性type=“”</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210320231453362.png"></p>
<p>提示直接写在input标签前面:</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>  
    男 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 女 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>免费注册(显示的内容)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>重新设置(显示的内容)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--回到默认--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>name: input元素的名称  单/复选框通过该属性合并</p>
<p>value：input属性的值，输入前默认值（不是提示语），按钮的value是送到后台的数据</p>
<p>placeholder：设置提示词，一输入就消失</p>
<p>name和value主要给后台人员使用</p>
<p>checked：针对单/复选框，设置成默认勾选checked</p>
<p>maxlength：正整数</p>
</li>
<li><p>select：下拉表单元素,至少包含一对option</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>山东<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    ............
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
<span class="token comment">&lt;!-->可以在option中定义selected=“selected”来选为默认选中项&lt;--></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>textarea：文本域元素（大量输入文字，多行文本输入）</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>
    今日反馈：
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        哇哦（这就是默认文本）
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!--</span><span class="token punctuation">></span></span>一般cols和rows没人用，都是用CSS来搞！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>label：搭配input使用，绑定一个表单元素，点击lable里的文本时，浏览器自动聚焦到相应表单元素</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lable</span> <span class="token attr-name">for</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 用户名 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lable</span><span class="token punctuation">></span></span>lable><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>学会查阅文档！</p>
<h2 id="CSS1"><a href="#CSS1" class="headerlink" title="CSS1"></a>CSS1</h2><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210328202816143.png"  style="zoom: 33%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210328202925727.png"  style="zoom:33%;" />

<p>代码风格：展开（一行一属性）虽然不区分大小写（除了字符串）单尽量小写</p>
<p>冒号和值之间空格，选择器和 { 间加个空格</p>
<h3 id="字体："><a href="#字体：" class="headerlink" title="字体："></a>字体：</h3><p>font-family：“宋体”可以，但由于兼容性不好，最好用英文写</p>
<p>font-family:  “Microsoft Yahei”,…..依次向后检索，用逗号分隔，但是多个单词组成的最好引号包起来</p>
<p>尽量使用系统默认自带字体，一般给body指定好看的</p>
<p>font-size：px像素，谷歌默认16px，<em><strong>标题标签比较特殊，需要单独指定文件大小，即使是子标签</strong></em></p>
<p>font-weight：好多属性。。更提倡使用数字</p>
<p>font-style：normal italic </p>
<p>复合属性：font</p>
<p>style weight <strong>size</strong>/line-height <strong>family</strong> 但是必须有size和family？</p>
<p><strong>此处这个line-height可以不加单位，如1.5  则继承的子元素默认行高为当前字体大小的1.5倍</strong></p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>color: 关键词 十六进制 rgba</p>
<p>text-align</p>
<p>text-decoration: underline none  overline line-through</p>
<p>text-indent 首行缩进</p>
<p>line-height （行高）= 上+下+字高</p>
<h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h3><p>前身为Zen coding，用来缩写提高html/css速度，vscode集成该语法</p>
<p>html骨架：</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321093355251.png"></p>
<ol start="8">
<li>[]可以填充自己需要的属性，值无空格就不用引号</li>
<li>$$$连用则是001，002.。。</li>
<li>$后面加@-3*5表示逆序，终点为3，一共五次</li>
<li>为空格是Emmet停止缩写解析的<em>停止符号</em>，不要用来增加可读性</li>
<li>  :+值！</li>
</ol>
<p>css标签：</p>
<p>每个单词第一个字母+值（可不加单位，用默认）直接tab</p>
<p>tac  -&gt; text-align: center;</p>
<p>lh26 -&gt; line-height: 26px;</p>
<p>这种链接伪类先后顺序被称为 <em>LVHA 顺序</em>：<code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E4%BC%AA%E7%B1%BB">参考列表</a></p>
<p>常用<code>*:hover</code></p>
<p>:focus，选择获得光标的元素，可用于表单</p>
<h3 id="CSS元素显示"><a href="#CSS元素显示" class="headerlink" title="CSS元素显示"></a>CSS元素显示</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321113400485.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321113748159.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321113952029.png"></p>
<p>display</p>
<p>垂直居中：行高等于盒子高度就可以，line-height = height</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-color(默认transparent) 单用一个rgba（0，0，0，0.3）;调整背景颜色透明度，而不影响别的</p>
<p>background-image(便于控制位置)</p>
<p>background-repeat:repeat,no-repeat,repeat-x/y</p>
<p>background-position: 方位词(tcblcr) length(具体/百分比)x和y(默认center)</p>
<p>background-attachment:fixed(固定在视口),scroll(默认，固定在页面),local(固定在元素)</p>
<p>简写：无顺序要求，有约定顺序：</p>
<p>颜色  图片地址  平铺   滚动  位置</p>
<p>opacity: 影响全部！</p>
<h3 id="CSS三特性"><a href="#CSS三特性" class="headerlink" title="CSS三特性"></a>CSS三特性</h3><p>层叠性：同级后覆盖前</p>
<p><em><strong>简写的后面覆盖前面，并不会选择不冲突的覆盖，而是全部覆盖！！！！！</strong></em></p>
<p>继承性：子元素可以继承父元素的部分样式（text-,font-,line-这些开头的可以继承，以及color）</p>
<p>优先级：</p>
<p>一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</p>
<ol>
<li><p><strong>千位</strong>： 如果声明在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style"><code>style</code></a> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</p>
</li>
<li><p><strong>百位</strong>： 选择器中包含ID选择器则该位得一分。</p>
</li>
<li><p><strong>十位</strong>： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</p>
</li>
<li><p><strong>个位</strong>：选择器中包含元素、伪元素选择器则该位得一分。</p>
</li>
</ol>
<p><strong>注</strong>: 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
<p><strong>警告:</strong> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
<p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — <code>!important</code>。</p>
<p>这是个属性值！！用于修改特定属性的值， 能够覆盖普通规则的层叠。</p>
<p>继承也不会影响优先级，有些浏览器给予默认样式的如a{}相当于个位，所以比继承高</p>
<p>后代选择器权重叠加</p>
<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h3><p>边框:</p>
<p>border-width  粗细</p>
<p>border-style 样式</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321190451586.png"></p>
<p>border-color 颜色</p>
<p>简写：border: width style color  决定顺序，非强制</p>
<p>也可以border-tlrb：。。。</p>
<p>border-collapse collapse 合并相邻的边框  separate独立（重合会都显示（如加粗））</p>
<p>padding-left….. </p>
<p>直接padding就是那种：</p>
<p><em><strong>1个：全部   2个：上下 左右  3个：上  左右  下  4个：上右下左</strong></em></p>
<p>加padding会撑大盒子，而content内容不会变</p>
<p><em><strong>如果width没指定，则padding会压缩content，但只要指定，即使width=100%也会撑大，高度也一样</strong></em></p>
<p>块级元素子元素原本就和父元素一样宽，上面那条规则适用</p>
<p>margin-top。。。</p>
<p>margin简写同上。。。。</p>
<p>两个嵌套关系（父子）块元素在top有外边距，保留大的作为父元素的外边距，（塌陷）</p>
<p><strong>补充外边距合并及其解决方案</strong>：<a href="https://blog.csdn.net/songyi160/article/details/87891222">https://blog.csdn.net/songyi160/article/details/87891222</a></p>
<p>浮动盒子不会有该问题!!!!</p>
<p>解决方法：</p>
<ol>
<li>父元素加上边框</li>
<li>父元素加上内边距</li>
<li>父元素加overflow：hidden</li>
</ol>
<p>块级盒子水平居中：</p>
<ol>
<li>必须设定一个width</li>
<li>设定左右外边距为auto就行，一般是 margin: 0 auto;</li>
</ol>
<p>行内/行内块水平居中：</p>
<ul>
<li>给父元素text-align:center</li>
</ul>
<p>浏览器有默认内外边距，而且有时候不一样，清除：</p>
<p>在最第一行用*{margin:0 ; padding: 0}</p>
<p>行内元素尽量只设置左右，上下没效果</p>
<p>ps</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321204859160.png"></p>
<p>css3新盒子属性</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>border-radius</code></strong> 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/border-radius-sh.png" alt="Images of CSS3 rounded corners: no rounding, rounding w/ an arc of circle, rounding w/ an arc of ellipse"></p>
<p>1个值:全部  2个：左上右下  右上左下  3个：左上  右上左下   右下    4个：左上开始顺时针</p>
<p>百分比是相对于宽度和高度的，高度一半就变成操场哈哈</p>
<p>也可以俩值 a/b或是分别指定椭圆的长轴和短轴</p>
<p>也可以分开：border-top-left-radius:</p>
<p>盒子阴影(box-shadow)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321214655930.png"></p>
<p><em><strong>但只准写inset不能写outset！！影子不占空间</strong></em></p>
<p>其中blur代表模糊程度</p>
<p>spread代表对模糊范围的等密度放缩</p>
<p>文字阴影：（text-shadow）</p>
<p>h-shadow  v-shadow   blur   color</p>
<p>css三种传统布局方式</p>
<ul>
<li>普通流/标准流/文档流（标签按规定好的默认方式排列，块/行内这些规则）（最基本）</li>
<li>浮动</li>
<li>定位</li>
</ul>
<p>实际开发中，一个页面基本包含了这三种布局方式（移动端有新的）</p>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>一个准则：块级元素纵向选标准流，横向用浮动</p>
<p>float属性用于创建浮动框，将其移动到一边，直到左/右边缘触及 <strong>包含块</strong> 或 <strong>另一个浮动框</strong> 的边缘</p>
<p>float : none（默认）  left   right</p>
<p>三个主要特性：</p>
<ol>
<li>浮动元素会脱离标准流（脱标），不再占用原来的位置</li>
<li>浮动元素会一行内显示，不会有缝隙（可用margin），并且元素顶部对齐</li>
<li>浮动元素会具有Inline-block元素的特性</li>
</ol>
<p><em><strong>浮动元素经常和标准流父级搭配使用！</strong></em>，先用标准流父级划分大模块，实现纵向布局</p>
<p>浮动只会影响浮动盒子后面的标准流，不会影响前面的标准流！！！！</p>
<p><em><strong>清除浮动：</strong></em></p>
<p>若父盒子没指定高度，子元素浮动时高度则没高度了，</p>
<p>clear： left  right  both（几乎只用both）策略是：闭合浮动</p>
<p>四方法：</p>
<ol>
<li><p>额外标签法（隔墙法），W3C推荐</p>
<p><strong>在后面添加一个新标签（必须是<em>块级元素</em>），并且添加clear属性</strong></p>
<p>其实是这个空的块级标签左右不能有浮动，所以它把父级撑开了罢了</p>
<p>多了无意义标签，结构化较差</p>
</li>
<li><p>父级添加overflow属性：hidden/auto/scroll</p>
<p> <strong>overflow</strong> 定义当一个元素的内容太大而无法适应 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">块级格式化上下文</a> 时候该做什么。它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-x"><code>overflow-x</code></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties">简写属性 </a>。（这只是把溢出隐藏了，不推荐）</p>
</li>
<li><p>父级添加：：after伪元素（结构简单，比较常用，上流）</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.clearfix::after</span><span class="token punctuation">&#123;</span>
    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span> <span class="token comment">/*必须*/</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden
<span class="token punctuation">&#125;</span>
<span class="token selector">.clearfix</span><span class="token punctuation">&#123;</span>
    *<span class="token property">zoom</span><span class="token punctuation">:</span>1 <span class="token comment">/*使兼容IE6.7*/</span>
<span class="token punctuation">&#125;</span>
然后给盒子加上clearfix类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>父级添加双伪元素(代码更简介，腾讯用)</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.clearfix::before .clear:after</span><span class="token punctuation">&#123;</span>
    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.clearfix::after</span><span class="token punctuation">&#123;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.clearfix</span><span class="token punctuation">&#123;</span>
    *<span class="token property">zoom</span><span class="token punctuation">:</span>1 &lt;!--使兼容IE6.7-->
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="*BFC"></a>*BFC</h3><p><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187">https://blog.csdn.net/sinat_36422236/article/details/88763187</a></p>
<h3 id="PS切图"><a href="#PS切图" class="headerlink" title="PS切图"></a>PS切图</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210321235346203.png"></p>
<p>图层切图</p>
<p>找到PSD其中的图片，快速导出为PNG</p>
<p>按住shift选择多个，-&gt;图层菜单-&gt;合并图层（Ctrl+E），导出（合并完不能分开/。。）</p>
<p>切片切图</p>
<p>（长按裁剪工具选择切片）切片工具选择区域-&gt;文件-&gt;导出选中的切片（存储为web所用格式JPEG好）</p>
<p>透明格式是拉到最底，把背景去掉（显示为黑白网格），导出为png或gif格式的</p>
<p>PS插件切图</p>
<p>Cutterman是插件，自动将需要的图层输出</p>
<p>用辅助线帮忙，左边拉俩线，再用选框工具量！</p>
<h3 id="小项目"><a href="#小项目" class="headerlink" title="小项目"></a>小项目</h3><p>css属性建议书写顺序</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210322130017462.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210322205425707.png"></p>
<p>当好多一排里的元素都有margin-right然后装不下时，可以让父元素大一点，这样最边上的元素能装下，而margin看不见所yi没关系</p>
<h3 id="favicon-ico图标"><a href="#favicon-ico图标" class="headerlink" title="favicon.ico图标"></a>favicon.ico图标</h3><ol>
<li>制作，先制作png图片，可以用<a href="http://www.bitbug.net/">比特虫</a>啥的转为ico文件</li>
<li>放到根目录的某处</li>
<li>然后引入<code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;url&quot;?&gt;</code></li>
</ol>
<h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p><strong>TDK</strong>三大标签</p>
<p>虽然有专门的SEO人员，但是前端也要做好一些工作</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325220057276.png"></p>
<ol>
<li><p>title </p>
<p>不可替代的第一个超重要标签</p>
<p>建议：网站名（产品名）-网站介绍（尽量不要超过30个汉字）</p>
<p>如：京东(JD.COM)综合网购首选-正品低价-品质保证-配送及时-轻松购物</p>
</li>
<li><p>description</p>
<p><em><strong>简要说明网站主要是做什么的</strong></em> 一般由SEO准备这些内容，前端复制就好了</p>
</li>
<li><p>keywords</p>
<p>是搜索引擎重要的标准，最好限制为6-8的关键词，中间用<strong>英文逗号</strong>隔开，展示<strong>最重要的</strong>产品或功能</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325220548104.png"></p>
</li>
</ol>
<p><strong>logo优化</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325235111811.png"></p>
<p><strong>所以这个a应该和logo块一样大，要改成block，h1可以不用设置</strong></p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>浮动可以让多个块级盒子横向排列</p>
<p>定位则是可以让盒子自由的在某个盒子内移动位置或固定屏幕中的某个位置，而且可以压住其他盒子。</p>
<h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>*定位组成</p>
<p>定位：即把盒子定在某个位置</p>
<p>定位=定位模式+边偏移</p>
<p>定位模式(position)： </p>
<p>static(静态)  relative(相对)   absolute(绝对)   fixed(固定)</p>
<p>边偏移：定位的盒子移动到最终位置，有top bottom left right四个属性</p>
<p>静态定位(static):</p>
<p>默认定位方式，按照标准流特性摆放，他没有边偏移。</p>
<p>静态定位在布局时很少用到</p>
<p>相对定位(relative)：</p>
<p>元素移动位置时相对它原来的位置来说的。参考点是自己原来的位置！</p>
<p>它走了以后它的位置仍会保留，并未脱离标准流。</p>
<p><strong>它最典型的应用是作为绝对定位的父元素</strong></p>
<p>绝对定位(absolute):</p>
<p>元素移动位置时，以父元素为基准</p>
<ul>
<li><p>如果没有祖先元素，<strong>或祖先元素没有定位</strong>，则以浏览器为准定位（Document文档）</p>
</li>
<li><p>如果祖先有定位（相对，绝对，固定定位），则以最近一级的有定位祖先元素为参考点移动位置</p>
</li>
<li><p>绝对定位会脱标，不占有原来的位置，覆盖下面的任何盒子（甚至浮动）</p>
</li>
</ul>
<p>子绝父相是通常，当然不是绝对的，只是用的多</p>
<p>固定定位(fixed)：</p>
<ul>
<li>以<strong>浏览器的可视窗口</strong>作为基准！</li>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
<li>固定定位不再占有原先的位置，可看为特殊的移动定位</li>
</ul>
<p>固定定位小技巧：固定在版心右侧位置</p>
<ol>
<li>让固定定位的盒子left：50%  走到浏览器可视区（版心的一半）</li>
<li>让固定定位的盒子margin-left：版心宽度的一般距离+一点点空隙</li>
</ol>
<p>粘性定位 (sticky):</p>
<p>粘性定位可以被认为是相对定位和固定定位的混和，特点：</p>
<ul>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li>
<li>占有原先的位置（相对定位特点）</li>
<li><strong>必须添加tlrb中的一个才有效</strong></li>
</ul>
<p>跟页面滚动搭配，兼容性一般般，IE不支持，去尼玛的破IE</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323090921464.png"></p>
<h4 id="叠放次序"><a href="#叠放次序" class="headerlink" title="叠放次序"></a>叠放次序</h4><p>用z-index来控制前后次序</p>
<p>z-index: ..</p>
<ul>
<li>数值可以是正负整数/0（无单位），默认auto（当前级别为0），数值越大，盒子越靠上</li>
<li>如果属性值相同，则按照书写顺序层叠</li>
<li>只有定位的盒子才有z-index属性</li>
</ul>
<h4 id="定位拓展"><a href="#定位拓展" class="headerlink" title="定位拓展"></a>定位拓展</h4><ol>
<li><p>绝对定位的盒子居中</p>
<p>不能再用margin：0 auto</p>
<p><code>left:50%        margin-left: - 1/2*self-width</code></p>
<p>垂直类似</p>
</li>
<li><p>特殊的特性</p>
<ul>
<li>行内元素添加绝对/固定定位，<strong>可以直接设置高度和宽度</strong></li>
<li>块级元素添加绝对/固定定位，如果不给宽度或高度，默认大小是内容大小</li>
<li>浮动元素/绝对/固定定位都不会触发外边距合并的问题</li>
</ul>
</li>
<li><p>浮动的元素不会压住下面标准流的文字（最初浮动产生的目的就是做文本环绕效果）</p>
<p>但是绝对定位/固定定位会压住所有内容</p>
<p><strong>如果一个盒子既有left属性又有right属性，两者不是重叠，会默认left，同理，默认top</strong></p>
</li>
</ol>
<p>用并集选择器减少代码重复</p>
<p>再单独增加特殊的，或用类思想</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323095911579.png"></p>
<h4 id="元素显示-隐藏"><a href="#元素显示-隐藏" class="headerlink" title="元素显示/隐藏"></a>元素显示/隐藏</h4><ol>
<li><p>display 显示隐藏</p>
<p><strong>none隐藏对象</strong>    两者对立   block还有显示元素的意思</p>
<p>隐藏后，不再占有原来的位置！</p>
</li>
<li><p>visibility 显示隐藏<br>默认inherit  visible  hidden  collapse(不常用)</p>
<p>仍保留原来的位置！</p>
</li>
<li><p>overflow 溢出显示隐藏</p>
<p>hidden  scroll(一直滚动)   visible  auto(需要时滚动)</p>
</li>
</ol>
<h2 id="CSS高级技巧"><a href="#CSS高级技巧" class="headerlink" title="CSS高级技巧"></a>CSS高级技巧</h2><h4 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h4><p>Sprites</p>
<p>为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度。</p>
<p><strong>核心原理</strong>：将网页中的一些<strong>小背景图</strong>像整合到一张大图中，这样服务器只需要请求一次就好了</p>
<ol>
<li>精灵技术主要针对于背景图片使用，其他图片可能更换频率高，不适合使用</li>
<li>这个大图片也成为sprites精灵图/雪碧图</li>
<li>主要通过background-position来显示部分。。</li>
<li>就是要盒子和移动距离刚好合适。。真麻烦</li>
<li>用ps的框选，打开窗口里的信息，查看x和y坐标，则位置就是-x,-y巴拉巴拉</li>
</ol>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323214406626.png"></p>
<h4 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h4><p>iconfont</p>
<p>为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210323214740389.png"></p>
<p><em><strong>icomoon的使用方法</strong></em></p>
<ol>
<li><p>选好，（编辑）下载成一个压缩包并解压</p>
<p>将fonts文件夹放到html文件根目录，4个字体文件是为了兼容所有噢！</p>
</li>
<li><p>在CSS样式中全局声明字体，打开icomoon文件夹，复制“style.css”里的代码到css里，</p>
<p>复制到<code>font-display:block</code>为止，记得更改到fonts的路径</p>
</li>
<li><p>在icomoon的demo.html文件查看对应代码最右边的小方框，粘贴就好了,也可以（\+编码）</p>
<p>在对应的标签加入样式里的<code>font-family:&#39;icomoon&#39;;</code> 其他文字属性仍然可用</p>
</li>
<li><p>追加，若原账户则默认存储，未保存则import icons，把selection.json文件上传，再继续挑选，仍然生成，这样会生成新的文件，替换原来的文件就好了</p>
</li>
</ol>
<p><em><strong>阿里的symbol引用</strong></em></p>
<p>确实挺好用的吧，先打开demo.html文件，复制生产的js和css代码，然后将类改成它提供的就好了，只是注意要改一下文件路径！</p>
<h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><p>如果一个盒子没有大小，只有边框，且颜色不同，则可以发现边框竟然是4个三角形</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210324084613633.png"></p>
<p>所以如果三个边框透明，只留下一个边框就可以做出一个三角形，大小取决于边框尺寸</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> xxpx solid transparent<span class="token punctuation">;</span>
    <span class="token property">line-height</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token comment">/*这行是兼容性*/</span>
    <span class="token property">border-left-color</span><span class="token punctuation">:</span>pink<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>底边是border尺寸*2，要完全出去就是移动这么多</p>
<h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h3><h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><p><strong>鼠标样式</strong></p>
<p>cursor : default  pointer  move  text  not-allowed</p>
<p>**input{outline : none}**不会出现默认的蓝色框</p>
<p>同样可以用于文本域等其他出现了该现象的元素们</p>
<p><strong>文本域原本右下角可以拉大，取消</strong>：</p>
<p>textarea{resieze: none;}</p>
<p><strong>textarea如果俩标签分行写输入时会有一个padding？</strong></p>
<p><strong>vertical-align</strong>（块级元素没有）</p>
<p>文本域也是行内块，也可以用</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210324090646156.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210324090857405.png"></p>
<p>图片默认是与文字基线对齐</p>
<p><strong>可以改成bottom/top/middle来改掉图片和边框间的空白缝隙，或者改成块元素</strong></p>
<p><strong>单行文字溢出省略号表示</strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*1.先强制一行内显示文本，默认(normal自动换行)*/</span>
<span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>
<span class="token comment">/*2.超出部分隐藏*/</span>
<span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>
<span class="token comment">/*3.修改文本溢出样式*/</span>
<span class="token property">text-overflow</span> <span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>多行文字溢出省略号表示</strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">有较大兼容性问题，适合于webKit浏览器或移动端
<span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>
<span class="token comment">/*弹性伸缩盒子显示*/</span>
<span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
<span class="token comment">/*限制在一个块元素内显示的文本行数*/</span>
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span>2<span class="token punctuation">;</span>
<span class="token comment">/*设置或检索伸缩盒对象的子元素排列方式*/</span>
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span>vertical<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>建议后台人员来做这个效果</strong>，<strong>操作更简单</strong></p>
<h4 id="常见布局技巧"><a href="#常见布局技巧" class="headerlink" title="常见布局技巧"></a><strong>常见布局技巧</strong></h4><ol>
<li><p>margin负值运用</p>
<p>原本浮动的盒子会发生边框加粗，可以用margin的负值使其重合</p>
<p>但是hover时会发生边框覆盖属性，可以在hover里面改成相对定位，<strong>压住其他标准流和浮动</strong>，但如果其他li都设置了定位，就用z-index来提高层级</p>
</li>
<li><p>文字围绕浮动元素</p>
<p>大盒子里放一个小浮动盒子，文字会被挤到一边就好了</p>
</li>
<li><p>行内块的巧妙运用</p>
<p>就是一排盒子嘛。。。</p>
</li>
<li><p>css三角强化</p>
<p>自由决定各方向边框的尺寸，如果缺少某底边，那左右两边会被截成一半，就这样构造出各种三角形，有些可以直接去掉，尺寸变为0，有些必须存在以辅助构建三角形，把颜色改成透明,格式：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">border-color</span><span class="token punctuation">:</span>transparent red transparent transparent<span class="token comment">/*右边红*/</span>
<span class="token property">border-style</span><span class="token punctuation">:</span>solid  
border-width 100px 50px 0 0<span class="token punctuation">;</span><span class="token comment">/*高100，宽50*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h4><p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS初始化 CSSreset</p>
<p><strong>每个网页都必须首先进行CSS reset</strong></p>
<p>把字体如“宋体”转化成Unicode编码就不会有兼容性问题</p>
<p>如黑体\93d1\4f53</p>
<p>宋体\5b8b\4f53</p>
<p>微软雅黑\5FAE\8F6F\96C5\9ED1</p>
</li>
</ol>
<h2 id="HTML5新增"><a href="#HTML5新增" class="headerlink" title="HTML5新增"></a>HTML5新增</h2><p>针对以前的不足，增加了新的标签，表单，表单属性。。</p>
<p>新特性大多存在兼容性问题，但是时代在发展</p>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325130724672.png"></p>
<ul>
<li>都是块级元素</li>
<li>针对搜索引擎，都可以在页面中多次使用</li>
<li>在IE9中要把这些转化为块级元素</li>
<li>移动端更喜欢使用这些标签</li>
</ul>
<h3 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h3><p>video</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325131250427.png"></p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>video/mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>video/ogg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    您的浏览器不支持video标签
    <span class="token comment">&lt;!--依次向下检索，最后显示文字，处理兼容性问题--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-autoplay.html">autoplay</a></td>
<td align="left">autoplay</td>
<td align="left">如果出现该属性，则视频在就绪后马上播放。(谷歌要加muted)</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-controls.html">controls</a></td>
<td align="left">controls</td>
<td align="left">如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-height.html">height</a></td>
<td align="left"><em>pixels</em></td>
<td align="left">设置视频播放器的高度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-loop.html">loop</a></td>
<td align="left">loop</td>
<td align="left">如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-muted.html">muted</a></td>
<td align="left">muted</td>
<td align="left">如果出现该属性，视频的音频输出为静音。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-poster.html">poster</a></td>
<td align="left"><em>URL</em></td>
<td align="left">规定视频正在下载时显示的图像，直到用户点击播放按钮。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-preload.html">preload</a></td>
<td align="left">auto metadata none</td>
<td align="left">如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-src.html">src</a></td>
<td align="left"><em>URL</em></td>
<td align="left">要播放的视频的 URL。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/tags/att-video-width.html">width</a></td>
<td align="left"><em>pixels</em></td>
<td align="left">设置视频播放器的宽度。</td>
</tr>
</tbody></table>
<p>真正开发不用controls，用js自己搞控件</p>
<p>兼容性写法同上</p>
<p>音频Audio</p>
<p>除了width，height，poster都有，而且谷歌也把音频自动播放禁了</p>
<h3 id="新input"><a href="#新input" class="headerlink" title="新input"></a>新input</h3><p><strong>都必须放在form域里噢</strong></p>
<p>type =email url date time month week number显示用户输入类型</p>
<p>当输入不正确时，会自动提示不正确，尤其在手机端优化的很好</p>
<p>tel 手机号码</p>
<p>search搜索框</p>
<p>color生成一个颜色选择表单</p>
<p>新表单属性</p>
<ol>
<li><p>requried   required   必须输入</p>
</li>
<li><p>placeholder   显示文字   </p>
<p><strong>可以调样式<code>input::placeholder</code>可以选中placeholder</strong></p>
<p>但是它的边距其实也是文本的边距，直接调input内边距就好了</p>
</li>
<li><p>autofocus   autofocus   自动聚焦</p>
</li>
<li><p>autocomplete  on（默认）/off  显示历史填写，必须加上name同时成功提交过，一般改成off</p>
</li>
<li><p>multiple   multiple  可以多选文件</p>
</li>
</ol>
<h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><p>都有兼容性问题，ie9+才才支持</p>
<p>移动端支持优于pc端</p>
<p>不断改进中</p>
<p>应用相对广泛</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>新增了属性选择器，结构伪类，伪元素。。</p>
<p>我直接把另一个汇总复制过来吧</p>
<p>当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。</p>
<p>但是在被组合起来以后，整个规则都会失效，无论是<code>h1</code>还是这个class都不会被样式化。</p>
<p>这组选择器包含了伪类，用来样式化一个元素的特定状态。</p>
<p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">学习CSS的教程</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">类型选择器</a></td>
<td align="left"><code>h1 &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Type_selectors">类型选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通配选择器</a></td>
<td align="left"><code>* &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#The_universal_selector">通配选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a></td>
<td align="left"><code>.box &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#Class_selectors">类选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID选择器</a></td>
<td align="left"><code>#unique &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/user:chrisdavidmills/CSS_Learn/CSS_Selectors/Type_Class_and_ID_Selectors#ID_Selectors">ID选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">标签属性选择器</a></td>
<td align="left"><code>a[title] &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Attribute_selectors">标签属性选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类选择器</a></td>
<td align="left"><code>p:first-child &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-class">伪类</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素选择器</a></td>
<td align="left"><code>p::first-line &#123; &#125;</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Pseuso-classes_and_Pseudo-elements#What_is_a_pseudo-element">伪元素</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代选择器</a></td>
<td align="left"><code>article p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Descendant_Selector">后代运算符</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">子代选择器</a></td>
<td align="left"><code>article &gt; p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Child_combinator">子代选择器</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">相邻兄弟选择器</a></td>
<td align="left"><code>h1 + p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#Adjacent_sibling">相邻兄弟</a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器</a></td>
<td align="left"><code>h1 ~ p</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/User:chrisdavidmills/CSS_Learn/CSS_Selectors/Combinators#General_sibling">通用兄弟</a></td>
</tr>
</tbody></table>
<p>a+b  -  b必须紧跟a后且同级，插入br都不行</p>
<p>a ~b - 选择！后面的！所有兄弟</p>
<p>将所有类连成一串代表匹配包含所有这些类的元素</p>
<p>.a.b.c{}匹配同时含有a,b,c类的标签</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>a b<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>此处li拥有a和b类<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 属性</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[*attr*]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[*attr*=*value*]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[*attr*~=*value*]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">`[<em>attr</em></td>
<td align="left">=<em>value</em>]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<p>子字符串匹配选择器（类似正则）</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[*attr*^=*value*]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[*attr*$=*value*]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[*attr**=*value*]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">li[class^="a" i]</span> <span class="token punctuation">&#123;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>结构伪类：</strong></p>
<p><strong>:first-child     last-child    nth-child（n）</strong></p>
<p><strong>:first-of-type   last-of-child   nth-of-child(n)</strong></p>
<p>n可为数字，关键字（odd/even）或公式（不是从0开始！）</p>
<p>如果真的写一个n则<strong>从0开始</strong>自增查找，依次添加css格式，依次可以衍生其他公式</p>
<p>5n，选择5的倍数    n+5,从第五个开始选    -n+5前五个</p>
<p>nth-child   和   nth-of-type区别</p>
<p>nth-child是先看序号，再看是否满足标签，会给所有的盒子部分种类先排个序</p>
<p>nth-of-type则是先看标签，再给这些标签排序号</p>
<p>还有<strong>用户行为伪类（结构伪类）</strong>，有时叫做<strong>动态伪类</strong></p>
<p><strong>伪元素原则器</strong></p>
<p>通过css创建新标签元素，不需要HTML标签，从而简化HTML结构</p>
<p>以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325171240102.png"></p>
<p><em><strong>是在父元素的里面创建的</strong></em>，content=””，这样啥都不加就不会有子，但一定要有</p>
<p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p>
<p><em><strong>遮罩层的顺序竟然是.tudou:hover::before{}，。。。</strong></em></p>
<p>div:hover .class 是鼠标经过div时里面的class类子元素变化</p>
<h3 id="过渡"><a href="#过渡" class="headerlink" title="*过渡"></a>*过渡</h3><p>CSS3颠覆性的特征之一，可以在不使用Flash动画或JavaScript的情况下，当元素从一种样式变换为另一种样式时为元素添加效果</p>
<p>ie9以下版本不支持但不会影响页面布局</p>
<p>如果想要多个属性，使用逗号分隔</p>
<p>transition: 属性 时间 运动曲线 何时开始,具体如下：</p>
<p>transition-property -duration -timing-function -delay</p>
<ol>
<li><p>属性：宽度高度背景颜色内外边距，若全部就写all</p>
</li>
<li><p>时间：单位是 秒（必须写单位）</p>
</li>
<li><p>运动曲线：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>
</tr>
<tr>
<td align="left">ease</td>
<td align="left">规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。(默认是ease)</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>
</tr>
<tr>
<td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>
</tr>
</tbody></table>
</li>
<li><p>何时开始，必须有单位 秒，可以设置延迟触发时间，默认是0s（可以忽略）</p>
</li>
</ol>
<h3 id="其他新的"><a href="#其他新的" class="headerlink" title="其他新的"></a>其他新的</h3><h4 id="新盒子"><a href="#新盒子" class="headerlink" title="新盒子"></a>新盒子</h4><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210325174427516.png"></p>
<h4 id="图片模糊（滤镜）"><a href="#图片模糊（滤镜）" class="headerlink" title="图片模糊（滤镜）"></a>图片模糊（滤镜）</h4><p>filter属性有很多提供给UI人员的值</p>
<p>filter:blur(15px)数值越大图像越模糊,0则不模糊，blur是个函数噢</p>
<p>calc函数让开发者在声明值时执行一些计算(+ - * / )</p>
<p>比如：calc(100%-30px)</p>
<p>还增加了一些动画 2D 3D等特性</p>
<p>ps：肝了一天案例，在另一篇博文里</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210326211235526.png"></p>
<p>我的网站地址：<a href="http://darrenisme.usa3v.vip/">http://darrenisme.usa3v.vip/</a></p>
<h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><h2 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h2><p><strong>transform 位移，旋转，缩放，不过是二维的哟</strong></p>
<p><strong>配合transition牛逼极了</strong></p>
<p><strong>translate(x,y</strong>) 在x，y轴上移动的位置</p>
<p>或translateX(n)           translateY(n)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403113752031.png"></p>
<p>所以水平垂直居中就可以:</p>
<p>position: absolute  left:50%   top:50%</p>
<p>transform : translate(-50%, -50%)</p>
<p><strong>rotate</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403114931593.png"></p>
<p>可以用边框旋转来弄出三角哈哈哈哈</p>
<p><strong>旋转中心点</strong></p>
<p>transform-origin : x,y</p>
<p>可以是百分比，像素值，关键词tblrc</p>
<p>案例：</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403125024006.png"  style="zoom:33%;" />

<p>overflow:hidden  默认转90  hover时转上来</p>
<p><strong>scale</strong></p>
<p>transform:scale(x,y);</p>
<p>里面的参数是不跟参数的数字，表示倍数</p>
<h3 id="综合写法"><a href="#综合写法" class="headerlink" title="综合写法"></a>综合写法</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403130305541.png"></p>
<p>注意顺序，如果先旋转后位移，则位移是按照旋转瞬间的角度位移的</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>animation 颠覆性 </p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403130558562.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403130710410.png"  style="zoom:50%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403130745131.png"></p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210403130917882.png"  style="zoom:50%;" />

<p>duration 单位是秒 s  或毫秒ms</p>
<h3 id="属性一览"><a href="#属性一览" class="headerlink" title="属性一览"></a>属性一览</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403131802217.png"></p>
<p><strong>animation - play -state  应该是paused</strong></p>
<p><strong>经常与hover 配合使用 就可以鼠标放上去就停止，鼠标离开继续走</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403132727955.png"></p>
<p>注意时间如果有俩 必然先是持续时间 后是何时开始</p>
<p>steps可以做出诡异的效果👇</p>
<p>可以用那种做出那种连续动画的效果，准备好不同动作的图片就好了</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403150156949.png"></p>
<h3 id="热点图案例"><a href="#热点图案例" class="headerlink" title="热点图案例"></a>热点图案例</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403132930592.png"></p>
<p>大致结构（1个城市）</p>
<p>city相对定位到小圆点除</p>
<p>先放1个小圆点，再放几圈波纹</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403143518688.png"  style="zoom:50%;" />

<p>css波纹</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403143925973.png"  style="zoom:50%;" />

<p>动画效果</p>
<p>pink用的是 0%- 70%长宽变大，透明度不变，70 -100 长宽变大 ，透明度变为0，scale会导致阴影本身也变大</p>
<p>然后选择匀速，无限循环  小心权重问题</p>
<p>然后单独给后面几个加上delay  注意间隔相等。比如一共1.2秒 3个波纹 则第二个0.4 第三个0.8</p>
<p>元素可以添加多个动画，用逗号分隔</p>
<h2 id="3D！！！"><a href="#3D！！！" class="headerlink" title="3D！！！"></a>3D！！！</h2><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403173429153.png"   />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403173546861.png"  style="zoom:50%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403174500115.png"></p>
<h3 id="透视原理图"><a href="#透视原理图" class="headerlink" title="透视原理图"></a><strong>透视原理图</strong></h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403175448612.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403175954749.png"></p>
<p>这个沿着。。其实是以。。为轴</p>
<p>方向正负可以用左手。。大拇指指向某轴正方向，。。。</p>
<p>rotate3d(x,y,z,deg) 其中xyz表示旋转轴矢量</p>
<p>这个3d旋转也可以使用 transform-origin: 但是z轴属性必须用&lt;length&gt;,没有关键字</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403191246272.png"></p>
<p>盒子选择案例：</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403193245498.png"  style="zoom:50%;" />

<p>他这种做法比较好，比起更改甚么旋转轴来说</p>
<p>还有一个属性perspective-origin  可以更改视角，而不是简单的就是沿着z轴看过去</p>
<h3 id="旋转木马"><a href="#旋转木马" class="headerlink" title="旋转木马"></a>旋转木马</h3><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403200440564.png"  style="zoom:50%;" />

<p>代码如下：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">
        <span class="token selector">body</span> <span class="token punctuation">&#123;</span>
            <span class="token property">perspective</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token selector">section</span> <span class="token punctuation">&#123;</span>
            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 185px<span class="token punctuation">;</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 500px auto<span class="token punctuation">;</span>
            <span class="token property">transform-style</span><span class="token punctuation">:</span> preserve-3d<span class="token punctuation">;</span>
            <span class="token property">animation</span><span class="token punctuation">:</span> rotate 4s infinite linear<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>1.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
            <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token selector">section:hover</span> <span class="token punctuation">&#123;</span>
            <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>
            <span class="token property">animation-play-state</span><span class="token punctuation">:</span> paused<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token atrule"><span class="token rule">@keyframes</span> rotate</span> <span class="token punctuation">&#123;</span>
            <span class="token selector">0%</span> <span class="token punctuation">&#123;</span>
                <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token selector">100%</span> <span class="token punctuation">&#123;</span>
                <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div</span> <span class="token punctuation">&#123;</span>
            <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
            <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>example.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
            <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
            <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div:nth-child(1)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token selector">//这里是先转了个角度，然后轴也跟着变化了，Z轴表示各个图正对的，直接走就好了

        section div:nth-child(2)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>60deg<span class="token punctuation">)</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div:nth-child(3)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>120deg<span class="token punctuation">)</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div:nth-child(4)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>180deg<span class="token punctuation">)</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div:nth-child(5)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>240deg<span class="token punctuation">)</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>

        <span class="token selector">section div:nth-child(6)</span> <span class="token punctuation">&#123;</span>
            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotateY</span><span class="token punctuation">(</span>300deg<span class="token punctuation">)</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>500px<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">&#125;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403204706921.png"></p>
<p>浏览器私有前缀</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210403204317033.png"></p>
<p>因为制定HTML和CSS标准的组织W3C动作是很慢的。<br>通常，有w3c组织成员提出一个新属性，比如说圆角border-radius，大家都觉得好，但w3c制定标准，要走很复杂的程序，审查等。而浏览器商市场推广时间紧，如果一个属性已经够成熟了，就会在浏览器中加入支持。<br>为避免日后w3c公布标准时有所变更，加入一个私有前缀，比如-webkit-border-radius，通过这种方式来提前支持新属性。<br>等到日后w3c公布了标准，border-radius的标准写法确立之后，再让新版的浏览器支持border-radius这种写法。</p>
<p>移动端见另一篇博文~~~</p>
]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
      </tags>
  </entry>
  <entry>
    <title>数模word基础</title>
    <url>/2021/04/15/word%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="排版格式"><a href="#排版格式" class="headerlink" title="排版格式"></a>排版格式</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416163718840.png"  style="zoom:33%;" />

<p>表格，图形之类的，还有Excel可视化啥的</p>
<p>公式，公式识别</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>word vs Latex</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416164354583.png"  style="zoom: 33%;" />

<p>国赛Latex用得少，而美赛用得很多Latex</p>
<p><strong>优秀论文排版</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210416165419679.png"  style="zoom:50%;" />

<p>图形的配色。。避免大段的空行，不要水空间。格式规范，审美哈哈哈</p>
<h2 id="word基础"><a href="#word基础" class="headerlink" title="word基础"></a>word基础</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000312818.png"  style="zoom:50%;" />

<h3 id="常用功能和快捷键"><a href="#常用功能和快捷键" class="headerlink" title="常用功能和快捷键"></a>常用功能和快捷键</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000618699.png"  style="zoom:50%;" />

<p>比如空格显示为小点</p>
</li>
<li><p>打印预览功能</p>
</li>
</ul>
<hr>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417000906546.png"  style="zoom:50%;" /></li>
<li><p>强大的F4，在ppt和excel都能用，重复上一步操作，但是仅仅记录一步噢</p>
<p>对光标所在的符合要求的对象进行该操作</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001349006.png"  style="zoom: 67%;" /></li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001611043.png"  style="zoom:50%;" /></li>
<li><p>“书签栏” 对选中的功能使用“添加到快速访问工具栏”</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417001949722.png"  style="zoom:33%;" /></li>
<li><p>每个功能区的<strong>右下角是完整菜单</strong></p>
</li>
</ul>
<hr>
<p><strong>字体功能区</strong></p>
<ul>
<li>粘贴选项，常用的只保留文本，还有强大的粘贴为图片，比如把ppt的形状复制过来</li>
<li>格式刷：单击只能用一次，双击可以连续使用，Esc取消</li>
<li>上下标是俩个X2<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417103542242.png"></li>
<li>字体颜色，背景颜色，艺术字！加拼音，更改大小写，清除所有格式</li>
</ul>
<hr>
<p><strong>段落功能区</strong></p>
<ul>
<li><p>对齐，两端对齐一般好看，行间距，底纹，框线（用光标）</p>
</li>
<li><p>加编号，调整缩进量</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417105224584.png"></p>
</li>
<li><p>重复编号，左边有一个自动更重编号，按住ctrl选中多行再添加编号</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417105657108.png"></p>
<p>这两个勾，很可能会<strong>坑人</strong></p>
</li>
<li><p>图片上方紧接着有文字，可以设置段前行距</p>
<p><img src="C:/Users/Lenovo/Desktop/image-20210417105834906.png"></p>
</li>
</ul>
<hr>
<p><strong>插入功能区</strong></p>
<ul>
<li>页面-&gt;封面 空白页（原理是分页符）</li>
<li>插入表格记得行和列是和线性代数反的，选中文本-&gt;<strong>文本转换为表格</strong></li>
<li>插入图片-&gt;此设备，调段落格式，小心首行缩进导致左边间距更大</li>
<li>插入形状，新建画布，和ppt一样</li>
<li>插入页眉，每一页都有，去掉横线方法：去除格式，改一改缩进，还有页码</li>
<li>插入文本框，四周型和嵌入性，浮于文字上方，改边框的形状轮廓</li>
</ul>
<hr>
<p><strong>布局功能区</strong></p>
<ul>
<li>页边距，页面方向，分成两栏，但是图片太宽则不行，两栏三栏</li>
<li>分隔符里的分节符，默认整个文档是一节，要分节来<strong>防止全局操作</strong></li>
<li>视图有标尺，选中表格，双击标尺，就可以改一些设置，包括纸张方向</li>
</ul>
<h3 id="样式和多级列表"><a href="#样式和多级列表" class="headerlink" title="样式和多级列表"></a>样式和多级列表</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417111817711.png"  style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417112018930.png"  style="zoom: 33%;" />

<p>还可用于导航窗格导航</p>
<p><strong>目录！！！</strong></p>
<p>引用-&gt;目录，直接根据标题插入目录，还可以直接设置格式</p>
<p>导出为PDF的时候！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417112706180.png"  style="zoom:33%;" />



<h3 id="国赛规范和模板制作"><a href="#国赛规范和模板制作" class="headerlink" title="*国赛规范和模板制作"></a>*国赛规范和模板制作</h3><p>在官网查资料。。这里是2020版的，最后两页为纸质版才有的</p>
<p>第二页开始编号，</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417114000963.png"  style="zoom:50%;" />

<p>页边距2.5厘米，其他细节格式根据赛区自定，如果没有赛区要求，则自己定：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417114133736.png"  style="zoom: 50%;" />

<hr>
<ul>
<li>调出标题三，样式右下角，管理样式，推荐，显示标题3</li>
<li>右键样式进入设置，先设置中文，再设置英文</li>
<li>段落直接用所有脚本设置黑体，记得取消加粗</li>
<li>新建一个“图片和表格”样式</li>
</ul>
<hr>
<p><strong>多级列表</strong></p>
<p>空白处创建新的多级列表，更多，链接到样式，加上标题的格式</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417140707541.png"  style="zoom:33%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417140728583.png"></p>
<p>编号之后改成空格</p>
<p>二级标题勾选：正规格式编号</p>
<p>关闭文档，重新打开，把标题的缩进都去掉</p>
<p>国赛控制在页边距，可以根据内容调整页边距大小</p>
<hr>
<p>加个页码，记得把缩进关了，把上面的横线清除格式</p>
<h3 id="表格制作"><a href="#表格制作" class="headerlink" title="表格制作"></a>表格制作</h3><p>左上角的十字，全选表格和拖动位置，右下角拖动更改表格大小，居中对齐</p>
<p>退格键删除表格，delete键清空内容，虚线是“查看网格线”，其实啥都没有</p>
<p>布局里面调一下布局方式，还有个自动调整功能，用的不是很多</p>
<p>左下角和右上角分别是插入行和列</p>
<p>可以用边框刷，也可以设置上下左右边框这样的</p>
<p>记得在上面写一行字，写表格标题</p>
<hr>
<p>表格样式就是模板一样的</p>
<p>把文字环绕设置成无，因为一拖动就会自动设置成环绕</p>
<p>改了样式后，记得在段落里把样式里的首行缩进改成无</p>
<h4 id="长表格"><a href="#长表格" class="headerlink" title="长表格"></a>长表格</h4><p>行数太多了，把标题多复制一份，然后套用三线表，改一下对齐方式，加一条中间的竖直边框</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145355812.png"></p>
<h4 id="宽表格"><a href="#宽表格" class="headerlink" title="宽表格"></a>宽表格</h4><p>列数太多了，可以使用横向排列之类的，但是建模肯定要分行，用Excel帮忙</p>
<p>记得加上续表俩字</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145727529.png"></p>
<h4 id="拼接表格"><a href="#拼接表格" class="headerlink" title="拼接表格"></a>拼接表格</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417145851642.png"></p>
<p>当作一个整体，中间这一列设置为无边框</p>
<h4 id="有合并单元格"><a href="#有合并单元格" class="headerlink" title="有合并单元格"></a>有合并单元格</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417150114299.png"></p>
<p>在Excel里面就可以使用合并单元格，给特定单元格加框线</p>
<p>分隔效果是加了无色的竖线</p>
<p>有一些特殊软件生成的表格跳过了</p>
<h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417150937068.png"></p>
<p>取消所有框线，加上部分下框线</p>
<h4 id="自动编号"><a href="#自动编号" class="headerlink" title="自动编号"></a>自动编号</h4><p>引用-&gt;插入题注，勾选自动插入题注，来自动更新</p>
<p>还可以关联你写的引用和相应表：交叉引用，引用类型为表，这样会自动变化，要刷新F9</p>
<p>但其实比赛论文不太需要这些，直接手打就好了。</p>
<p>表前的文字和表格间距0.5行。。可以用上面的段后</p>
<h3 id="图形制作和排版"><a href="#图形制作和排版" class="headerlink" title="图形制作和排版"></a>图形制作和排版</h3><p>国赛风格简约，黑白，而美赛。。。很酷</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155000260.png"  style="zoom:50%;" />

<p>以后得自学前两者</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155446780.png"></p>
<h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417155639823.png"></p>
<p>调好缩进，直接右键转化为smartart，先选大类，再选小类</p>
<p>设计里更改颜色啥的，然后再在格式里面调整具体的样式，粘贴为图片</p>
<p>还有Xmind和process on</p>
<h4 id="简单示意图"><a href="#简单示意图" class="headerlink" title="简单示意图"></a>简单示意图</h4><p><strong>ppt绘制</strong></p>
<p>插入各种形状，无填充等样式，添加形状，文本窗格</p>
<p>格式里有<strong>对齐和横向分布在右边</strong>，旋转</p>
<p>C + 按住图形可以直接拖出新的，按住shift拉线不会歪</p>
<p>选中需要的图形，右键组合，还能取消组合</p>
<p>图表标题通用的。。写在下面就好了</p>
<p>强大的ppt组合图形，组合可以嵌套</p>
<hr>
<p><strong>任意多边形</strong>记住shift不动，Esc就画完了</p>
<p>曲线大致描几个点，格式，形状轮廓，箭头和样式啥的</p>
<p>竟然是iconfont阿里巴巴卧槽，下SVG格式的，没想到哇</p>
<hr>
<p><strong>ppt后期加工</strong></p>
<p>其实也还是加一堆图形哈哈，</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417171000183.png"  style="zoom:50%;" />



<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417171042537.png"  style="zoom: 50%;" />

<p>选择全部，居中对齐什么的，processOn</p>
<p>YeD之类的</p>
<h4 id="物理示意图"><a href="#物理示意图" class="headerlink" title="物理示意图"></a>物理示意图</h4><p>直接ppt，哈哈哈，AxGlyph软件，和Axmath一样是word插件</p>
<p>ppt，绘制圆，按照ctrl就是标准⚪，还能调节角度卧槽。还有旋转。</p>
<hr>
<p>还有亿图（有水印），有很多模板，美赛用的多</p>
<p>GeoGraph，动态的，免费的</p>
<p><strong>Echarts，需要一定的前端，数据可视化方向的</strong></p>
<p>也可以学python中的pyecharts这个包</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417181153530.png"  style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417181547695.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417184523976.png"  style="zoom:50%;" />



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417213014215.png"  style="zoom:50%;" />

<p>直接查到论文，然后引用</p>
<p>正文格式，编号格式，手动添加上标</p>
<h3 id="公式编辑"><a href="#公式编辑" class="headerlink" title="公式编辑"></a>公式编辑</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417213539208.png"></p>
<p><strong>mathpix</strong></p>
<h1 id="写作方法"><a href="#写作方法" class="headerlink" title="写作方法"></a>写作方法</h1><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417184905778.png"></p>
<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>基于啊哈哈。。50%</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185146499.png"  style="zoom:50%;" />

<p>表达准确。。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185252729.png"  style="zoom:50%;" />

<p>最后写，反复修改</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185510665.png"  style="zoom:50%;" />

<p>平均800-1000</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185558584.png"  style="zoom:50%;" />

<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417185925628.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190146004.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190320644.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190458831.png"  style="zoom:50%;" />

<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190805813.png"  style="zoom:50%;" />

<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417190834259.png"  style="zoom:50%;" />

<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191010259.png"  style="zoom:50%;" />

<p>多放主要模型！</p>
<h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h2><p>一级标题的第一个</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191206893.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191311203.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191358234.png"  style="zoom:50%;" />



<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191500357.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417191905011.png"  style="zoom:50%;" />

<p>甚至思维导图和思维框图</p>
<h2 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417192156795.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417192226678.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417195904468.png"  style="zoom:50%;" />

<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417200139452.png"  style="zoom:50%;" />



<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417200444421.png"></p>
<p>写在最后。。不是所有都要放。</p>
<h2 id="模型建立与求解"><a href="#模型建立与求解" class="headerlink" title="模型建立与求解"></a>模型建立与求解</h2><p>ps：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201120942.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201501252.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201700798.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201731556.png"  style="zoom:50%;" />

<p>这就是结合的利用</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201821269.png"  style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417201950243.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202044451.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202306738.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202327970.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202413624.png"  style="zoom: 33%;" />



<h2 id="模型分析或检验"><a href="#模型分析或检验" class="headerlink" title="模型分析或检验"></a>模型分析或检验</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417202623048.png"  style="zoom:33%;" />

<h3 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417203408032.png"  style="zoom: 25%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211229051.png"  style="zoom:33%;" />



<h3 id="稳定性检验"><a href="#稳定性检验" class="headerlink" title="稳定性检验"></a>稳定性检验</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211856247.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417211955682.png"  style="zoom:33%;" />



<h3 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212037424.png"  style="zoom:33%;" />

<h2 id="评价，改进-推广"><a href="#评价，改进-推广" class="headerlink" title="评价，改进(推广)"></a>评价，改进(推广)</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212142176.png"  style="zoom:33%;" />



<h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212253184.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212402948.png"  style="zoom:33%;" />



<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212528558.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210417212627609.png"  style="zoom:33%;" />]]></content>
      <categories>
        <category>memory</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>《最优化导论》笔记</title>
    <url>/2021/07/17/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="无约束优化"><a href="#无约束优化" class="headerlink" title="无约束优化"></a>无约束优化</h1><h2 id="6、基础知识"><a href="#6、基础知识" class="headerlink" title="6、基础知识"></a>6、基础知识</h2><p>导数矩阵</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091058869.png" alt="image-20211203203532220" style="zoom:60%;" />

<p>$Df(x)$是一行，$D\pmb{f}(x)$是好几行。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059786.png" alt="image-20211203203643378" style="zoom:60%;" />

<ul>
<li><p>约束集可以表示为Ω = {x: h(x) = 0 , g(x) &lt;= 0} 其中h,g是函数向量</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210930185250441.png" alt="image-20210930185250441" style="zoom:50%;" /></li>
<li><p>局部最小一阶必要：对某点$x^*$ 所有可行方向$d$，上式均&gt;=0</p>
<p>推理：$\triangledown f(x^*) = 0$</p>
</li>
<li><p>局部最小二阶必要：f二阶可微，对x* 点处任意可行方向 d，有$d^T F(x^*)d$ &gt;=0</p>
<p>推论：当局部最小点x*是约束集内点时，所有方向都是可行方向。</p>
</li>
<li><p>局部最小二阶充分：f 二阶可微</p>
<ol>
<li>$\triangledown f(x^*) = 0$</li>
<li>$F(x^*)&gt; 0$</li>
</ol>
</li>
<li><p>接下来的章节中，将着重关注这类问题的迭代求解方法，这些方法具有很高的使用价值。可以避免巨大的工作量。</p>
</li>
</ul>
<p><code>还要这个用得很多的二次型求导</code>👇：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211002104901010.png" alt="image-20211002104901010" style="zoom:67%;" />

<h2 id="7、一维搜索"><a href="#7、一维搜索" class="headerlink" title="7、一维搜索"></a>7、一维搜索</h2><ul>
<li>黄金分割法  （f）</li>
<li>斐波那契数列方法（f）</li>
<li>二分法（f导）连续可微</li>
<li>割线法（f导）</li>
<li>牛顿法（f导，f二阶导）连续二阶可微，还可用于求解方程。</li>
</ul>
<p>一维搜索法是多变量问题求解算法的一部分。</p>
<p>${1/2}^n$ 比斐波那契和黄金分割速度快，但是求导比较复杂。</p>
<p>黄金分割：$(\frac{3-\sqrt{5}}{2})^n$       斐波那契： $\frac{1+2\varepsilon}{F_{N+1}}$</p>
<p>牛顿法可以求解出方程的数值解！它能不断地迫使目标函数f的一阶导数趋向于0，<br>$$<br>x^{(k+1)} = x^{(k)}-\frac{g(x^{(k)})}{g^{‘}(x^{(k)})}\<br>其中 g(x) = f^{‘}(x)<br>$$<br>所以在某些点处若$f^{‘’}&lt;0$，可能收敛到极大点，而且初始点的比值 $g(x^{0})/g^{‘}(x^{0})$ 必须够大，否则牛顿切线法可能失效，因此初始点的选择非常重要。</p>
<p>以上方法各有优缺，实际中可以联合使用，还有许多改进、优化的算法，比如布伦特方法。</p>
<hr>
<p>前面的方法都需要目标极小值所在的区间，而找到区间的方法是【划界法】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107174028873.png" alt="image-20211107174028873" style="zoom: 80%;" />

<p>多维优化问题的迭代求解算法通常每次迭代都要用到一维搜索过程。</p>
<p>但有时候计算极小点需要极大的计算量，甚至不存在。经验表明，实际应用中<u>应该将更多的计算资源配置到多维优化算法而不是追求高精度的一维搜索上。</u></p>
<p>因此需要设计<strong>合适的停止条件</strong>，使得一维搜索精度低时，目标函数f的值仍能得到足够下降。</p>
<p>比如Armijo划界法等方法，（感觉这个也tm是炼丹。。预设步长等条件。</p>
<h2 id="8、梯度下降"><a href="#8、梯度下降" class="headerlink" title="8、梯度下降"></a>8、梯度下降</h2><p>梯度下降方法包括很多不同的具体算法，最常用的方法为最速下降法</p>
<p>梯度方法便于实现，且在大部分情况下能够很好地运行。</p>
<p>最速下降法：</p>
<ul>
<li>相邻搜索方向正交</li>
<li>只要$\bigtriangledown f(x^{(k)}\neq 0 $ 那么</li>
</ul>
<p>$f(x^{(k+1)})&lt;f(x^{(k)})$ </p>
<p>👆 = 0说明达到局部最小点，可以作为停止规则，但是实际应用中采用数值计算很难恰好得到该结果，</p>
<ul>
<li>一种是用的规则是计算梯度的范数，若小于某个阈值则停止，</li>
<li>也可以计算相邻两点函数值差的绝对值，小于阈值则停止，</li>
<li>当然也可以用迭代点的差值，</li>
<li>还有相对值版本。相对值更优。相对值为了避免规则的分母过小，分母可以取 $max{1,||\pmb{x^{(k)}||} }$</li>
</ul>
<p><strong>P94的这几个👆停止规则，适用于本书第二部部分讨论的所有迭代求解方法！</strong></p>
<p>P97 最速下降法对二次型的公式。<br>$$<br>f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx} - \pmb{b}^T\pmb{x}\ 这个形式挺一般\<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)} - \frac{g^{(k)T}g^{(k)}}{g^{(k)T}Qg^{k}}g^{(k)}\<br>其中\  g^{(k)} = \bigtriangledown f(x^{(k)}) = Qx^{(k)} -b<br>$$</p>
<p>最速下降法需要归一化，不然搜索效率低。</p>
<hr>
<p>性质分析：</p>
<p>如果要求初始点足够靠近极小点，算法产生的迭代点序列才能够收敛到满足局部极小点一阶必要条件的点，那么算法就不是全局收敛而是局部收敛的。</p>
<p>算法的收敛性决定能否收敛，而评价算法多快收敛的指标是收敛率。</p>
<p><code>有一堆证明，暂时先不管了、、、</code>P98</p>
<p>反正最速下降一定收敛，定长下降有个条件。</p>
<p>收敛阶数的概念不难理解，【显然、任意收敛序列的收敛级数$\geq 1$】</p>
<p>可以证明，在最坏情况下，最速下降法的收敛阶数为1</p>
<h2 id="9、牛顿法"><a href="#9、牛顿法" class="headerlink" title="9、牛顿法"></a>9、牛顿法</h2><p>思路和泰勒一样，在每个迭代点处构造二次型函数，一阶导、二阶导与原函数相等。然后求出该近似函数的极小值点作为下一个迭代点。</p>
<p>若目标函数就是二次型函数，则与近似函数极小点一致，否则只能找出大体位置。</p>
<p>迭代公式：<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-\pmb{F}(\pmb{x}^{(k)})^{-1}\pmb{g}^{(k)}\<br>g^{(k)} = \triangledown f(x^{(k)})<br>$$<br>【不是确定了表达式就确定了矩阵性质，要带入值后才能确定。】</p>
<p>可以分两步</p>
<ul>
<li>求解$\pmb{F}(\pmb{x}^{(k)})\pmb{d}^{(k)} = -\pmb{g}^{(k)}$得到$\pmb{d}^{(k)}$这个d就是搜索方向</li>
<li>$\pmb{x}^{(k+1)} = \pmb{x}^{(k)}+\pmb{d}^{(k)}$</li>
</ul>
<p><strong>优势</strong>：当初始点和目标函数极小点足够接近时，收敛效果非常好</p>
<p><strong>缺点</strong>：F（x）不正定，或初始点离最小值太远，都可能无法收敛。还有n比较大时计算量太大</p>
<p>不过后续都有修正来解决。</p>
<hr>
<ul>
<li><p>当目标函数是二次型函数时，对任意初始点，一步就可收敛，收敛阶数为$\infty$</p>
</li>
<li><p>f 三阶连续可微，存在点$x^<em>\in R^n$且满足$\triangledown f(x^</em>) = 0$且$F(x^*)$可逆</p>
<p>则对所有与$x^*$足够接近的$x^{(0)}$，牛顿法至少以2的阶数收敛。【可能收敛到极大值点】</p>
</li>
</ul>
<p>一个修正是引入搜索方向并开展一维搜索，<code>定理给出在搜索方向上一定有一个区间是一直下降的</code></p>
<p>LM（Levenberg-Marquardt）修正还解决了黑塞矩阵不正定的问题。<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-(\pmb{F}(\pmb{x}^{(k)})+\mu_k\pmb{I})^{-1}\pmb{g}^{(k)}<br>$$<br>当$\mu_k$趋于无穷时，其实相当于是步长较小时梯度方法的特征。</p>
<p>实际应用时‘’$\mu_k$从小向大调，直到函数表现下降特征。</p>
<p>P116介绍了处理非线性最小二乘问题的<code>高斯牛顿法</code>，方便之处在于可忽略二阶导数项。</p>
<p>雅可比矩阵：就是函数的一阶导矩阵 $J(x)$<br>$$<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}-(\pmb{J}(\pmb{x})^T\pmb{J}(\pmb{x})+\mu_k\pmb{I})^{-1}\pmb{J}(\pmb{x})^T\pmb{f}(\pmb{x})<br>$$<br><code>注意一个思维，是把m个样本的处理（比如loss）看作m个函数，原来如此。</code>比如👆这个$f(x)$其实是一列，每行代表一个输入的$f(x_m)$</p>
<h2 id="10、共轭方向法"><a href="#10、共轭方向法" class="headerlink" title="10、共轭方向法"></a>10、共轭方向法</h2><p><a href="https://zhuanlan.zhihu.com/p/338838078">大佬的直观理解，和相比GD的提升</a></p>
<p>核心思想：相比于GD的全维度更新，共轭是解耦合，分成各个维度一次性更新一整个维度，共轭和正交差了个空间变换。</p>
<blockquote>
<p>GD每次更新一般都会改变迭代点的所有维度的值，因此，每次迭代一次后得到的迭代点就不一定是之前搜索方向上的最优点了。反观共轭方向法，共轭方向法每次只在影响一个维度的方向上搜索，就以上图为例，在更新完 <img src="https://www.zhihu.com/equation?tex=x_1" alt="[公式]"> 后，共轭方向法选择朝 <img src="https://www.zhihu.com/equation?tex=d_2" alt="[公式]"> 这个方向搜索，而 <img src="https://www.zhihu.com/equation?tex=d_2" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=d_1" alt="[公式]"> 是正交的，因此第二次搜索不会改变迭代点的第一个维度， 也就是不会对第一次搜索得到的成果造成影响。而GD算法的每一次搜索都会对上一次搜索的成果造成影响。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059148.png" alt="img" style="zoom: 50%;" />
</blockquote>
<p>介于最速下降（低）和使用得当的牛顿法、拟牛顿法（高）中间。</p>
<p>从之前的例子可以看出，影响迭代搜索算法的<strong>关键因素为每次搜索的方向</strong>。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>n维二次型问题，能在n步内得到结果</li>
<li>共轭梯度法不需要计算黑塞矩阵。</li>
<li>不需要存储 $n*n$ 的矩阵，也不需要对其求逆。</li>
</ul>
<p>共轭方向定义：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016142133692.png" style="zoom: 50%;" />

<p>该方法的原理是证明对于n变量的二次型函数 $f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}\ ,x\in R^n，Q = Q^T&gt;0$来说，最好的搜索方向为Q的共轭方向。（$Q&gt;0$的意思是Q正定）。</p>
<hr>
<p>通过解方程来求解共轭向量效率太低，参考Gram-Schmidt过程可以设计一种<strong>系统化构造关于Q共轭向量</strong>的算法流程：<br>$$<br>\pmb{g}^{(k)} = \triangledown f(\pmb{x^{(k)}}=\pmb{Qx}^{(k)}-\pmb{b} \<br>\alpha_k = -\frac{\pmb{g}^{(k)T}\pmb{d}^{(k)}}{\pmb{d}^{(k)T}\pmb{Qd}^{(k)}}\<br>\pmb{x}^{(k+1)} = \pmb{x}^{(k)}+\alpha_k\pmb{d}^{(k)}<br>$$<br>k 表示迭代次数。$g^{(k)}$代表在$x^{(k)}$处的梯度。</p>
<p>定理：目标函数为 $n$ 维二次型函数时，共轭方向法能够在 $n$步迭代后收敛到最小点，即 $x^{(n)} = x^*$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016162919706.png" alt="image-20211016162919706" style="zoom:50%;" />

<p>$g^{(k+1)}正交于由d^{(0)}…d^{(k)}张成的子空间$</p>
<p>该引理可以证明共轭方向法一个很有意思的最优性性质。</p>
<p>$f(\pmb{x}^{(k+1)})$ 不仅满足👇<br>$$<br>f(\pmb{x}^{(k+1)}) = min_\alpha f(\pmb{x}^{(k)}+\alpha\pmb{d}^{(k)})\<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211016163458980.png" alt="image-20211016163458980" style="zoom:50%;" /></p>
<p>一直保持最优。</p>
<p>如同逐维度扩张的子空间般，随着k增大，子空间不断扩展指导充满整个$R^n$，将 $x^*$也包含其中，因此又称扩张子空间定理。</p>
<hr>
<p>共轭方向法效率很高，但是必须给定一组 Q 共轭方向。</p>
<p>幸运的是存在一种方法能随迭代的进行，逐一产生Q共轭方向而无需提前指定——<code>共轭梯度法</code>，这种方法不需要预先给定共轭方向，而是随着迭代的进行不断产生共轭方向。</p>
<p>仍考虑 $f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}\ ,x\in R^n，Q = Q^T&gt;0$</p>
<p>在第$k+1$次迭代中，$d^{(k+1)}可以写为g^{(k+1)}和d^{(k)}$的线性组合，有了<a href="https://zhuanlan.zhihu.com/p/338838078">直观理解</a>就显然了。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020103111931.png" alt="image-20211020103111931" style="zoom:50%;" />

<hr>
<h3 id="非二次型问题的共轭梯度"><a href="#非二次型问题的共轭梯度" class="headerlink" title="非二次型问题的共轭梯度"></a>非二次型问题的共轭梯度</h3><p>我们之前的算法和分析都是建立在研究的函数是二次型的假设下，这未免过于理想，要知道，深度学习中大部分loss关于前馈网络参数的函数甚至都不是凸函数，那么将我们得到的共轭梯度法进行泛化就显得很有必要了。</p>
<p>若将函数$f(\pmb{x}) = \frac{1}{2}\pmb{x}^T\pmb{Qx}-\pmb{x}^T\pmb{b}$<strong>视为某个目标函数泰勒展开式的二阶近似</strong>，就可以推广。</p>
<p>二次型中的矩阵Q，黑塞矩阵是常数矩阵，但是一般非二次型每次迭代都要重算Q，计算量太大，需要修改，消除该环节。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020110719239.png" alt="image-20211020110719239" style="zoom:50%;" />

<ul>
<li><p>Hestenes-Stiefel</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020110952754.png" alt="image-20211020110952754" style="zoom:50%;" /></li>
<li><p>Polak-Ribiere</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020111024535.png" alt="image-20211020111024535" style="zoom:50%;" /></li>
<li><p>Fletcher-Reeves</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211020111044047.png" alt="image-20211020111044047" style="zoom:50%;" /></li>
</ul>
<p>对二次型，这仨是等价的，但是对一般非线性函数，并不一致。。。。</p>
<p>ps：</p>
<p>还要选择合适的停止规则，而不是$\triangledown f(\pmb{x}^{(k+1)})=0$，还有合适的一维搜索方法，如果一维搜索方法不精确，建议用Hestenes公式来计算。。。</p>
<h2 id="11、拟牛顿法"><a href="#11、拟牛顿法" class="headerlink" title="11、拟牛顿法"></a>11、拟牛顿法</h2><p>牛顿法有较高实用性，且如果收敛，阶数至少为2.</p>
<p>但是起始点如果没选好，那么可能牛顿法根本下降不了。</p>
<p>牛顿法可通过每次进行一维搜索保证一定下降。但是还有计算黑塞矩阵和求解的困难。</p>
<p>拟牛顿法通过设计 $\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$的近似矩阵$\pmb{H}_k$来替代，以此来规避计算，只用目标函数值和梯度就能算。用来优化牛顿法的计算问题。</p>
<p>而只需要 $H$ 满足👇的后几行，就能与$\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$拥有类似的性质。当$\pmb{H}_k$正定时，必然下降。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211021104113854.png" alt="image-20211021104113854" style="zoom: 50%;" align = "left"/>

<p>而从$H^{(k)}$需要满足的方程看，该矩阵不能唯一确定。这就给了一定的发挥空间</p>
<p>作者给出了三种算法，这三种算法$H^{(k+1)}$均是在$H^{(k)}$的基础上增加修正项得出来的。</p>
<hr>
<ol>
<li>秩一修正公式</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107202703202.png" alt="image-20211107202703202" style="zoom: 50%;" />

<p>研究，给定$H_k,\Delta\pmb{g}^{(k)},\Delta\pmb{x}^{(k)}$后，如何确定$\alpha$和$\pmb{z}^{(k)}$使得近似矩阵满足性质$\pmb{H}_{k+1}\Delta\pmb{g}^{(i)}=\Delta\pmb{x}^{(i)}$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107203753608.png" alt="image-20211107203753608" style="zoom: 50%;" />

<p>秩一算法产生的$H_{k+1}$不一定正定，所以$d_{k+1}$不一定时下降方法。其次计算时如果分母接近0，有点难算</p>
<ol start="2">
<li>DFP算法</li>
</ol>
<p>又称秩二算法、变尺度法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107204005135.png" alt="image-20211107204005135" style="zoom:50%;" />

<p>DFP算法能保持H正定，但是处理规模较大的非二次型问题时，迭代无法开展，因为$\pmb{H}_k$接近成为奇异矩阵了。</p>
<ol start="3">
<li>BFGS算法</li>
</ol>
<p>推导需要用到对偶、互补的概念。</p>
<p>除了构造$\pmb{F}(\pmb{x}^{(\pmb{k})})^{-1}$的近似矩阵$\pmb{H}<em>k$，还构造$\pmb{F}(\pmb{x}^{(\pmb{k})}$的近似矩阵<br>$$<br>\pmb{B}</em>{k+1}\ 满足\<br>\Delta\pmb{g}^{(i)}=\pmb{B}_{k+1}\Delta\pmb{x}^{(i)}\ , 0\leq i\leq k<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107204938015.png" alt="image-20211107204938015" style="zoom:50%;" /></p>
<p>BFGS除了一定保持正定，<strong>即使一维搜索精度不高，依然比较稳健</strong>，有助于将计算资源解放出来、</p>
<p>效率上，很多情况下BFGS算法远超DFP算法</p>
<p>处理非二次型问题，拟牛顿法便不会在n步内收敛到极小点，与共轭梯度法类似，需要进行一些修正，</p>
<p>比如每经过几次迭代，搜索方向重置为梯度负方向。</p>
<h2 id="12、求解线性方程组"><a href="#12、求解线性方程组" class="headerlink" title="12、求解线性方程组"></a>12、求解线性方程组</h2><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p><strong>原最小二乘法</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107210727224.png" alt="image-20211107210727224" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107210824973.png" alt="image-20211107210824973" style="zoom:50%;" />

<p>其实这就是strang讲的投影那里，感觉比这个讲的清楚。</p>
<hr>
<p><strong>递推最小二乘算法</strong></p>
<p>当在已有计算基础上给出新的数据时，不需要合并数据重新计算，可以对已有的计算结果进行更新，从而免去不必要的计算。<br>$$<br>\pmb{G}<em>0 = \pmb{A}<em>0^T\pmb{A}<em>0\<br>\pmb{G}</em>{k+1} = \pmb{G}</em>{k}+\pmb{A}</em>{k+1}^T\pmb{A}<em>{k+1}\<br>\pmb{x}^{(k+1)} =\pmb{x}^{(k)} +\pmb{G}</em>{k+1}^{-1}\pmb{A}<em>{k+1}^T(\pmb{b}^{(k+1)} -\pmb{A}</em>{k+1}\pmb{x}^{(x)})<br>$$<br>其中向量 $\pmb{b}^{(k+1)} -\pmb{A}_{k+1}\pmb{x}^{(x)}$ 通常成为新息，如果为0，那么其实没有进行更新。</p>
<p>为了简单计算$\pmb{G}_{k+1}^{-1}$，有下面这个引理。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107212218536.png" alt="image-20211107212218536" style="zoom:50%;" />



<hr>
<h3 id="最小范数解"><a href="#最小范数解" class="headerlink" title="最小范数解"></a>最小范数解</h3><p><strong>线性方程组的最小范数解</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107212749533.png" alt="image-20211107212749533" style="zoom: 50%;" />

<hr>
<p><strong>Kaczmarz算法</strong>【卡茨马兹】</p>
<p>针对上一节的最小范数解问题，虽然有解析解，但是很难算</p>
<p>该<strong>迭代</strong>算法能够在不直接计算$\pmb{AA}^T$逆矩阵的情况下收敛到解析解，非常实用，尤其是矩阵太大的情况。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213508375.png" alt="image-20211107213508375" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213438836.png" alt="image-20211107213438836" style="zoom:50%;" />

<p>如果设定$\mu = 1$会有非常有趣的性质👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107213851207.png" alt="image-20211107213851207" style="zoom:50%;" />

<hr>
<p><strong>一般意义下线性方程组的求解</strong></p>
<p>本节研究在m*n矩阵A的秩为 r 时，没有逆，那就定义<strong>伪逆、广义逆</strong>，特别的，本节将讨论矩阵A的 Moore-Penrose逆。</p>
<p>何谓<strong>伪逆</strong>：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214616275.png" alt="image-20211107214616275" style="zoom:50%;" />

<p><u>这其实也是一种通过奇异值分解计算伪逆的方式。</u></p>
<p>左伪逆和右伪逆，伪逆的唯一性。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214853701.png" alt="image-20211107214853701" style="zoom: 50%;" />

<p>还是给出strang的图，直观理解就是把对应关系限制在行和列空间上，不考虑零空间</p>
<p>而幸运的是，可以证明，行空间和列空间（秩都为r ）里的向量是一一对应的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107222544879.png" alt="image-20211107222544879" style="zoom: 80%;" />

<hr>
<p>然后补充一些线代的知识，<strong>满秩分解</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107214239226.png" alt="image-20211107214239226" style="zoom:50%;" />

<p>伪逆和满秩分解的关系。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107215833293.png" alt="image-20211107215833293" style="zoom:50%;" />

<p>或者化简为<br>$$<br>\pmb{A}^\dagger = \pmb{C}^T(\pmb{B}^T\pmb{A}\pmb{C}^T)^{-1}\pmb{B}^T<br>$$</p>
<hr>
<p>那么$A^\dagger$在求解线性方程组时为什么重要呢？</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107221048200.png" alt="image-20211107221048200" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211107221407945.png" alt="image-20211107221407945" style="zoom:50%;" />

<p>别的定义方式不是重点。</p>
<h2 id="13、无约束优化问题和神经网络"><a href="#13、无约束优化问题和神经网络" class="headerlink" title="13、无约束优化问题和神经网络"></a>13、无约束优化问题和神经网络</h2><p>本章将前面讨论的方法应用于前馈神经网络的训练中。</p>
<p>神经网络的核心是神经元之间的连接权重，也称为学习参数，常用的训练方法为反向传播算法。</p>
<p>神经网络可视为<strong>函数逼近器</strong></p>
<p>神经网络的学习可以归纳为一个优化问题。利用前面的方法来设计训练过程。</p>
<p>多层反向传播其实确实也是归结为一个优化问题，只不过参数有点多，可以用前面的各种方法完成</p>
<p>吴恩达给出的是一种普通的梯度下降法。</p>
<h2 id="14、全局搜索算法"><a href="#14、全局搜索算法" class="headerlink" title="14、全局搜索算法"></a>14、全局搜索算法</h2><p>前面的迭代算法，往往只能收敛到局部极小点，而且还需要计算目标函数的一阶导数。</p>
<p>本章讨论一些全局意义上的搜索方法，这些方法也不需要对目标函数求导。因此适用面更广。</p>
<p>在某些情况下，这些方法产生的解，可以作为梯度、牛顿法<strong>“较好的”初始点。</strong></p>
<p>在本章讨论的方法中，某些方法还可用于求解组合优化问题。</p>
<h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><p>Nelder-Mead单纯形法</p>
<p>定义👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108145806398.png" alt="image-20211108145806398" style="zoom: 67%;" />

<p>初始单纯性的构造方法：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108150312958.png" alt="image-20211108150312958" style="zoom:67%;" />

<p>初始单纯形确定后，接下来就是一步步对其进行修改，朝着函数极小点收敛。</p>
<p>下面给出迭代过程中单纯形的更新规则，Amazing，先上一个二维单纯性搜索的图：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108151531733.png" alt="image-20211108151531733" style="zoom:50%;" />

<hr>
<ul>
<li><p>首先选定初始的n+1个点，构成最初的单纯形。</p>
</li>
<li><p>计算n+1个点的目标函数值，按照从小到大进行排序，令 $\pmb{p}_s$位最小的点，$\pmb{p}<em>b$为最大的点。$\pmb{p}</em>{2b}$为第二大的点</p>
</li>
<li><p>计算重心$\pmb{p}_g$为除去$\pmb{p}_b$后，其他所有点的几何平均点。</p>
</li>
<li><p>开展反射操作，利用反射系数$\rho$对最差点$\pmb{p}_s$进行<strong>反射</strong> $\pmb{p}_r = \pmb{p}_g + \rho(\pmb{p}_g-\pmb{p}_r)$，就是相对重心反射。一般$\rho = 1$</p>
</li>
<li><p>判断反射是否成功</p>
<ul>
<li><p>如果$f_r &lt; f_s$说明反射方向正确，进行**延伸**$\pmb{p}_e = \pmb{p}_g + \chi(\pmb{p}_r-\pmb{p}_g)$，$\chi&gt;1$</p>
<ul>
<li>如果$f_e&lt;f_r$说明延伸成功，$\pmb{p}_e$取代$\pmb{p}_b$，取代最小点</li>
<li>否则$\pmb{p}_r$取代$\pmb{p}_b$</li>
</ul>
</li>
<li><p>如果$f_r\geq f_{2b}$说明反射个der，开展<strong>收缩</strong>操作。</p>
<p>如果$f_{2b}\leq f_r &lt; f_b$那么采用<u>外收缩</u> $\pmb{p}_c =\pmb{p}_g + \gamma(\pmb{p}_r - \pmb{p}_g)$，其实就是让它不要伸太长了，回来点</p>
<p>否则$f_r&gt;f_b$那就无药可救，采用<u>内收缩</u>，直接用$\pmb{p}_b$代替$\pmb{p}_r$，$\pmb{p}_c =\pmb{p}_g + \gamma(\pmb{p}_b - \pmb{p}_g)$。</p>
<ul>
<li>如果$f_c&lt;f_b$至少收缩成功了，用$\pmb{p}_c$替换$\pmb{p}_l$</li>
<li>否则开展<strong>压缩</strong>操作：除了$p_s$不变，其他各点距离$\pmb{p}_l$距离减半，$\pmb{p}_i = \pmb{p}_s + \sigma(\pmb{p}_i-\pmb{p}_s)$，$\sigma = 1/2$</li>
</ul>
</li>
</ul>
</li>
<li><p>然后计算新的顶点回到第二步</p>
</li>
</ul>
<p>（新点和旧点数值相等，新点排在右边。）</p>
<h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>是一种随即搜索方法，也成为概率搜索方法，在优化问题的可行集$\Omega$中随机采样，逐步完成搜索。</p>
<p>基本假设为<u>可以从可行集$\Omega$中随机采样</u>。</p>
<p>随机采样：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108154621465.png" alt="image-20211108154621465" style="zoom:67%;" />

<p>先来看一种简单的随机搜索算法，称为朴素随即搜索算法：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108154726543.png" alt="image-20211108154726543" style="zoom:67%;" />

<p>牛啊，还有这样的下降算法。</p>
<p>朴素算法可能在局部极小点附近“卡住”，xs，为了解决这一问题，需要一种方法让它跳出来那片$N(x)$。</p>
<p>一种思路是<strong>保证邻域够大</strong>，但是邻域设置太大将导致搜索过程变慢。</p>
<p>另一种思路（模拟退火采用）是，设计让其能够爬出$N(x)$的算法，也就意味着<strong>算法产生的新点可能比当前点差</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108155706037.png" alt="image-20211108155706037" style="zoom:67%;" />

<p>主要的进步在步骤3，有一定的概率【<strong>接受概率</strong>】选择备选点作为下一次迭代点，即使这个备选点比当前迭代点差，</p>
<p>接受概率要进行合理的设定，常用的为：<br>$$<br>p(k,f(\pmb{z}^{(k)}),f(\pmb{x}^{(k)})) = min{1,exp(-f(\pmb{z}^{(k)})-f(\pmb{x}^{(k)}))/T_k)}<br>$$<br>$T_K$构成一组正数序列，成为温度进度表 或 <strong>冷却进度表</strong>，该接受概率使模拟退火算法等价于Gibbs采样器</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108190854122.png" alt="image-20211108190854122" style="zoom: 80%;" />

<p>需要指出的是，$f(\pmb{z}^{(k)})$和$f(\pmb{x}^{(k)}))$之间的差异越大，采用$\pmb{z}^{(k)}$作为下一个迭代点的可能’性就越小。类似地，$T_k$越小，采用$Z _{( k )}$作为下一个迭代点的可能性就越小。通常的做法是令温度$T_k$单调递减到O (表示冷却过程)。</p>
<p>也就是说，随着迭代次数k的增加，算法趋向于更差点的可能性越来越小。换句话说，最开始，算法在可行集内跳来跳去，以尽可能跳出局部极小点附近的区域，随着时间的推移，算法开始稳定在全局极小点附近的区域，将更多的时间投入到这一区域的搜索中。</p>
<blockquote>
<p>“退火”一词来自于冶金业，是一种能够改善金属品质的技术。</p>
<p>基本的操作方式为先将金属加热到一定程度，然后以可控的方式对其进行冷却。首先，当金属被加热时，其中的原子始变得活跃，脱离了原来的位置，内能增加。然后，随冷却的进行，原子逐渐变得有序，内能减少。如果冷却过程足够慢，那么可以保证最终的内能将低于开始阶段的内能，这样可以改善金属的晶体结构，并减少存在的缺陷。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211108193912140.png" alt="image-20211108193912140" style="zoom:80%;" />

<p>模拟退火法经常用于求解组合优化问题。</p>
<p>这类问题的可行集是有限的(但通常会非常大)。著名的旅行商问题就是一个组合优化问题。</p>
<h3 id="粒子群优化"><a href="#粒子群优化" class="headerlink" title="粒子群优化"></a>粒子群优化</h3><blockquote>
<p>由一位社会心理学家和工程师提出，在社交互动原理的启发下得到的。</p>
<p>粒子群优化算法与模拟退火算法存在一个主要区别:在一次迭代中，粒子群优化算法并不是只更新单个迭代点$\pmb{x}^k$，而是更新一群(组)迭代点，称为群。群中每个点称为一个粒子。可以将群视为一个无序的群体，其中的每个成员都在移动，意在形成聚集，但移动方向是随机的。</p>
<p>粒子群优化算法旨在模拟动物或昆虫的社会行为，如蜂群、鸟群和羚羊群等的形成过程。</p>
</blockquote>
<p><strong>算法的大致描述</strong>：</p>
<p>利用粒子群优化算法求取目标函数在$R^n$上极小点的过程。</p>
<p>首先，在$R^n$中随机产生一组数据点为每个点赋予一个速度构成一个速度构成一个速度向量。这些点视为粒子所在的位置，以指定的速度运动。接下来，针对每个数据点计算对应的目标函数值。基于计算结果，产生一组新的数据点，赋予新的运动速度，这可以通过对原有的数据点及其运动速度进行某些操作完成。</p>
<ul>
<li>pbest:某个粒子到目前为止经历过的最好的位置</li>
<li>gbest:到目前为止，每一轮的所有粒子中，出现的最小$f(x^{(k)})$</li>
</ul>
<p>根据粒子的个体最好位置和群的全局最好位置，调整各粒子的运动速度，以此实现粒子的”交互”。</p>
<p>在下面给出的gbest版本的粒子群优化算法中，每次迭代中，产生两个随机数，分别作为个体最好位置pbest和全局最好位置gbest的权重，以此构成pbest和gbest的一个组合值，可称为速度的随机项；再加上加权后的原有速度，可以实现对速度的更新。</p>
<p>因此，<u>粒子在个体最好位置和整个群的全局最好位置的共同作用下，朝着某个方向运动</u>。与前面相同，常用的停止规则为达到预先设定的迭代次数，或者目标函数达到了某个值。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173142921.png" alt="image-20211109173142921" style="zoom: 80%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173155527.png" alt="image-20211109173155527" style="zoom:80%;" />

<p>粒子群优化算法还有许多变种，👇是一种。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173353403.png" alt="image-20211109173353403" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211109173406495.png" alt="image-20211109173406495" style="zoom:80%;" />





<h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a><strong>遗传算法</strong></h3><p>是一种基于种群的随即搜索方法，在借鉴了遗传理论的基础上得到。</p>
<p>概括起来，遗传算法就是针对群迭代开展交叉和变异操作，产生新种群直到满足预定的停止条件。</p>
<p>PS：为了便于对遗传算法进行描述，将优化问题设定为最大化问题。</p>
<p><strong>基本概念</strong></p>
<p>首先有个约束集$\Omega$不能直接针对约束集$\Omega$中的点进行操作，而是需要将$\Omega$映射为一个字符串的集合【编码】，这些<u>字符串全部是等长</u>的，称为<u>染色体</u>。每个染色体中的元素都是从一个字符串集合中提取的，该集合称为<u>字符表</u>。{0,1}字符表得出的染色体都是二进制。</p>
<p>L表示染色体的长度即字符串中字符的数量。用 x 表示染色体，则f (x)表示适应度。可假设f是一个非负函数。</p>
<p><em>L，字符表，编码方式</em>(将$\Omega$映射为染色体) 统称为<em>表达模式</em>。选择合适的表达模式是利用遗传算法求解最优化问题的第一步。</p>
<p><strong>选择和进化步骤</strong></p>
<p>选定了表达模式，<em>初始化</em>染色体的第一代种群P(0)：通常是从染色体集合中随机抽取一定数量的染色体。</p>
<p><em>开展交叉和变异操作</em>：在第k次迭代中，计算种群P(k)中<u>每个个体$x^{(k)}$对应的适应度$f(x^{(k)})$</u>。</p>
<p><em>选择步骤</em>：</p>
<p>用选择操作构造一个新的种群$M(k)$，使其个体的数量与$P(k)$相等。种群中个体的数量称为种群容量，用$N$表示。$M(k)$称为<u>配对池</u>，是在$P(k)$的基础上进行随机处理后得到的</p>
<ul>
<li>轮盘赌模式：</li>
</ul>
<p>$M(k)$中每个个体$m ^{( k )}$以概率<br>$$<br>\frac{f(x^{(k)})}{F(k)}\ 其中F(k) = \sum f(\pmb{x}_i^{(k)}),对整个P(k)进行求和<br>$$<br>等于$P(k)$中的$\pmb{x}^{(k)}$，也就是说，<u>染色体选人配对池的概率与其适应度成正比</u>【精髓】</p>
<ul>
<li>锦标赛模式</li>
</ul>
<p>从P(k)中随机选定两个染色体，比较它们的适应度，将适应度大的放人配对池M(k)。持续开展类似操作，直到配对池M(k)中的染色体达到N个。</p>
<p><em>进化步骤</em>：</p>
<p>开展交叉和变异操作。从配对池中随机抽取一对染色体，称为父代，通过开展交叉操作，产生一对新染色体称为子代。</p>
<p>交叉操作指的是<u>两个父代字符串相互交换一段子字符串</u>。</p>
<p><code>父代染色体的选择</code></p>
<p>某个染色体被抽中用作交叉的概率为$p_c$。相互独立。</p>
<p>如果从配对池中随机抽取两个染色体作为父代，假定配对池中有N个染色体，可令$p_c=2/N$。类似地，如果从配对池中随机抽取2k个染色体，构成k组父代染色体(k &lt;N/2)，可令$p_c=2k/N$。在这两种情况下，<u>父代的数量是固定的</u>，概率$p_c$取决于父代的数量。</p>
<p>还有一种选择父代染色体的方式，即给定概率$p_c$，确定一个随机数作为父代的数量，以此选出需要进行交叉的父代，但需要保证<u>父代数量的均值应该为$p_cN/2$</u></p>
<p><code>开展交叉操作</code></p>
<p>有许多种不同类型的交叉操作。</p>
<p>最简单的交叉操作为单点交叉，在这种交叉方式下，按照<u>均匀分布</u>的原则，首先在1到L-1之间抽取一个<u>随机整数，称为</u><u>交叉点</u>，L表示染色体的长度。然后对父代的两个染色体交叉点右侧的字符串片段进行交换，即完成了交叉操作。</p>
<p>交叉操作还可以在多个交叉点上同时进行。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059844.png" alt="image-20211203140541937" style="zoom: 50%;" />

<p>完成交叉操作之后，利用子代染色体替代配对池中对应的父代染色体。这样，就实现了对配对池的修改，并使其保持了原来的容量。</p>
<p><code>变异操作</code></p>
<p>从配对池中逐一抽取染色体，以变异概率Pm随机改变其中的字符。二进制编码时，字符的改变指的是求染色体对应位的补，即以概率$P_m$将0修改为1，或将1修改为0。如果符表中包括两个以上的字符，那么从字符表中<u>随机抽取一个其他字符</u>来替换该字符。</p>
<p>通常情况下，变异概率$P_m$比较小(如0.01，因此，只有<u>很少的染色体</u>会经历变异操作，在这些变异了的染色体中，也是只有<u>很少的字符</u>被改变。这意味着相对于交叉操作，变异操作在遗传算法中起到的作用比较小。</p>
<p><code>步骤概括</code></p>
<p>1.令k =0，产生一个初始种群P (0)。</p>
<p>2 .评估$P_(k)$即计算$P_(k)$中各个体的适应度。</p>
<p>3 .如果满足停止规则，就停止迭代。</p>
<p>4 .从$P(k)$中选择$M(k)$。</p>
<p>5 .进化$M(k)$，构成新种群$P(k+1)$。</p>
<p>6 .令k = k + 1，回到第2步。</p>
<p>持续追踪当前为止最好的染色体，即适应度最高的染色体。在一次迭代后，当前为止最好的染色体作为最优解的备选。实际上，甚至可以将其复制到新一代种群中。这是精英主义者的做法，这种<em>精英主义的策略</em>容易导致种群被”超级染色体”主导。但是，实际应用经验表，<u>精英主义的策略很多时候可以提高算法的性能。</u></p>
<p>遗传算法有很多种<em>不同的停止规则</em>。<br>一种比较简单的停止规则为指定最大的迭代次数;<br>另外一种停止规则为相邻两次迭代中，当前为止最好的染色体对应的造应度不再显著变化。</p>
<p>与前面几章中讨论的方法相比，遗传算法存在以下<em>四个方面的差异</em>。<br>第一，不需要计算目标函数的导数(本章中讨论的其他方法也有这个性质)。<br>第二，在每次迭代中，采用的是随机操作(与其他随机搜索方法是一致的)。<br>第三，每次迭代是利用一组点而不是一个点开展搜索(与粒子群优化算法相似)。<br>第四，对约束集进行编码，而不是直接在约束集本身上开展搜索。</p>
<hr>
<p><strong>性质分析</strong></p>
<p>模仿 “适者生存”，为了定量化深入描述遗传算法，需要先定义一些术语。</p>
<p>模式：就是指一组染色体，同一位置上的字符是相同的，扩展字符表（原字符表+*）上的字符串来表示模式。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059845.png" alt="image-20211203160654460" style="zoom:50%;" />

<p>如果一个模式具有$r$个$*$，那么它包括$2^r$个染色体。此外长度为L的染色体对应着$2^L$个模式。</p>
<p>$H$表示某个给定的模式</p>
<p>$e(H,k)$表示$P(k)$中能够匹配$H$的染色体数量</p>
<p>$m(H,k)$表示$M(k)$中能够匹配$H$的染色体数量</p>
<p>$f(H,k)$表示$P(k)$中能够匹配$H$的染色体的平均适应度。$f(H,k) = \frac{f(x_1)+…+f(x_{e(H,k)})}{e(H,k)}$</p>
<p>$o(xxx)$ 阶次，等于L减去模式S中字符$*$的数量，就是确定的字符数，模式S的长度为$S(L)$</p>
<p>N表示种群中染色体的数量，<u>$F(k)$表示$P(k)$中所有染色体的适应度值和。</u>$\overline{F}(k) = \frac{F(k)}{N} = \frac{1}{N}\sum f(\pmb{x}_i^{(k)})$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059846.png" alt="image-20211203163022004" style="zoom:40%;" />

<p>引理14.1从定量的角度说明，如果模式$H$中染色体的平均适应度要超过种群的平均适应度，那么配对池$μ(k)$中能够匹配 H 的<em>染色体数量</em> 的期望值大于种群$P(k)$中匹配 H 的染色体数量的期望值。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059847.png" alt="image-20211203170540710" style="zoom:43%;" />

<p>同样，对于$M(k)$中满足模式H的染色体，没有被选中进行交叉操作，或被选中交叉后产生的子代中至少一个有染色体属于H的概率下届为1-上式</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059848.png" alt="image-20211203171959815" style="zoom:40%;" />

<p>最终得到定理14.1</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059849.png" alt="image-20211203172205148" style="zoom:40%;" />



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059850.png" alt="image-20211203173927159" style="zoom: 40%;" />

<p>遗传算法问题特别适合于求解组合优化问题（因为需要编码），也就是约束集$\Omega$不是$R^n$而是离散的。</p>
<hr>
<p><strong>实数编码</strong></p>
<p>但是二进制字符串编码有一些问题。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059851.png" alt="image-20211203195926941" style="zoom: 67%;" />

<p>遗传算法最好能够直接针对原始的优化问题进行求解操作。希望能够设计一种遗传算法，能够直接在$R^n$上操作。这种算法的步骤应该与二进制编码方式下的算法<u>步骤相同</u>，只是种群中的元素是约束集$\Omega$中的点，而不是二进制字符串。为此，需要定义合适的交叉和变异操作。</p>
<p><em>交叉操作</em>存在多种不同的处理方式，比如①求平均值 ②或$z_1 = (x+y)/2+\omega_1$，$z_2 = (x+y)/2+\omega_2$，其中$\omega1$和$\omega2$是两个均值为0的随机变量，y最后$z_1$和$z_2$落在$\Omega$外，要通过投影等方式拉回来；③构造x 和 y的随机凸组合，产生一个随机数$\alpha \in (0,1)$，然后计算$z_1 = \alpha x+(1-\alpha)y$和$z_2 = \alpha y+(1-\alpha)x$作为子代染色体。④对第三种方式产生的子集稍加干扰，如同②对①一般。</p>
<p><em>变异操作</em>，简单的方式是在染色体上增加一个随机向量，$x^{‘} =x+\omega$，也叫实数蠕变，同样得保证变异后的染色体位于约束集。也可以产生$\alpha \in (0,1)$，$x^{‘} = \alpha x+(1-\alpha)\omega$，这种方式，当约束集为凸集时，变异后的染色体一定位于约束集。</p>
<h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><h2 id="15、线性规划概述"><a href="#15、线性规划概述" class="headerlink" title="15、线性规划概述"></a>15、线性规划概述</h2><p>一般基本可行解的数量相当庞大，穷举法自讨苦吃。</p>
<p>1947年<code>单纯形法</code>——高效简洁，但最差情况有指数复杂度。</p>
<p>1984Karmarkar提出多项式复杂度的方法。此后出现了一些非单纯形法，统称<code>内点法</code></p>
<hr>
<p><code>P218用凸多面体揭示了几何意义——找到正确的支撑超平面</code></p>
<p>标准模型为：<br>$$<br>minimize\ \pmb{c}^T\pmb{x}\<br>subject\ to\ \pmb{Ax}=\pmb{b}\<br>\pmb{x}\geq\pmb{0}<br>$$<br>其他变体（比如Ax&gt;=b，maximize cTx）都可以转换为标准形式。</p>
<p>而且线性规划问题的定理和求解方法大部分是针对标准型得到的。通过引入<strong>剩余变量\松弛变量$y$<strong>可以将任何形式的线性规划问题转变为标准型<code>P219</code><br>$$<br>\boldsymbol{Ax}\pm\boldsymbol{I_my} =[\boldsymbol{A},\boldsymbol{I}_m]\begin{bmatrix}x \y \\end{bmatrix} = \boldsymbol{b}\x\geq0\y\geq0<br>$$<br>代数意义上的等价是显然的，而几何意义可以</strong>用高维向低维的投影解释</strong>。</p>
<hr>
<p>此后的讨论都针对标准型：</p>
<ul>
<li>基本解：通过重组A解出的基本的一组基<code>P224</code> </li>
<li>可行解：满足限定条件的，【其实就是基本解加上零空间的基的组合那个。。】</li>
<li>最优解：能够最大、最小化目标且满足限定条件的。</li>
</ul>
<p>可行解和基本解不是包含关系，满足两者就叫基本可行解。基本解的某些基变量为零成为<strong>退化</strong></p>
<p>基本解的求法很有意思。。。直接把A重组，列空间放前面，左零空间不要了。</p>
<p>基本解的个数最多$\begin{pmatrix}n\m\end{pmatrix}$个，选择一组无关的向量，对应一个可行解。</p>
<p>:star: 线性规划基本定理：</p>
<ul>
<li>如果存在可行解，那么存在基本可行解</li>
<li>如果存在最优可行解，那么存在最优基本可行解</li>
</ul>
<p>这让几乎$\infin$的可行解转换为在有限数量的基本可行解上进行搜索。但是还是很大，因此需要一种更加有效的方法来求解线性规划问题——》几何含义——》单纯形法</p>
<p>满足👉$\pmb{Ax}=\pmb{b},\pmb{x}\geq\pmb{0}$的点集可证明一定为凸集。</p>
<p>极点不在集合中其他两点的连线上。可以证明：<code>满足👆的基本可行解就是极点！</code></p>
<p>因此，求解线性规划问题时，只需要检查约束集的极点即可。其实这一点早就在多胞形那里体现了，最终答案要么在点上，要么在支撑超平面上，而这都可以通过检查极点找到。</p>
<h2 id="16、单纯形法"><a href="#16、单纯形法" class="headerlink" title="16、单纯形法"></a>16、单纯形法</h2><p>从某个极点转移到另一个极点的操作方式的精细化描述和处理。</p>
<p><code>P238</code>枢轴变换提供了对$Ax = b$的新解释。考虑到mxn矩阵，秩为m的情况<br>$$<br>[\pmb{I}<em>m,\pmb{Y}</em>{m,n-m}]\pmb{x}= \pmb{y_0}<br>$$<br>这种形式成为【典式】</p>
<p>一般情况下，基变量不一定是前m个，这只是便于表示而已。</p>
<p>对应的基本解为$\pmb{x}=\begin{bmatrix}\pmb{y}_0\\pmb{0}\end{bmatrix}$</p>
<p><strong>增广矩阵标准型</strong>，如下<br>$$<br>[\pmb{I}<em>m,\pmb{Y}</em>{m,n-m},\pmb{y_0}]<br>$$<br><strong>此时该标准型的每一列元素都是关于基${a_1,a_2,…a_m}$的坐标。</strong></p>
<p>如果用非基变量$a_q(q&gt;m)$代替$a_P(1\leq p \leq m)$，首先得有$y_{pq}\neq 0$才能保持基继续线性无关。则结果👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211006161841012.png" alt="image-20211006161841012" style="zoom: 50%;" />

<p>则可以推导出新的增广矩阵规范型，称为关于元素$(p,q)$的枢轴变换。</p>
<hr>
<p><u>单纯形法的思想就是从某基本可行解变换到另一个基本可行解，直到找到最优基本可行解为止。</u></p>
<p>按照上文的思路，用一个非基向量代替某个基向量，求解新基下的增广矩阵规范型。</p>
<p>增广矩阵规范型的最后一列是基本解中的基变量，$x_i = y_{i0},1\leq i\leq m$</p>
<p>但是基本解不一定是可行解，因为可能为负，在单纯形法中希望能变换到另一个基本可行解而不是基本解。本节将讨论这个问题。</p>
<p>三个问题：</p>
<ul>
<li>寻找被替换的$a_p$的方法，以及异常情况的解释</li>
<li>如何选定最初的基向量</li>
<li>如何判断基本可行解是否为最优解。</li>
</ul>
<p>判断基本可行解巧妙地通过化简比较函数值z表达式，引入$r_i=(0\ while\ [1,m],\ (c_i-z_i)\ while (m,n])$当且仅当$r_i$全都非负时为最优解。</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p><code>P244</code>例题给出了单纯形法的求解！而且这些推论可拓展到包含退化基本可行解的情况。</p>
<p>注意的点：选择$r_j$中最小的值对应的列向量$a_j$作为进基向量。</p>
<p>选离基时，$p = arg\ min{y_{i0}/y_{ij}:y_{ij}&gt;0}$ <strong>要注意这里的 $i$ 是只看原来的基！！！</strong></p>
<p>$z_i = \pmb{c}^t\pmb{x_i}$ ，$r_i=c_i-z_i$ 这里的 $ i $ 针对的是<strong>非基</strong>。</p>
<p>:star: 步骤:</p>
<ol>
<li><p>根据初始基本可行解构造增广矩阵规范型。</p>
</li>
<li><p>计算非基变量的检验数，如果均$\geq 0$就找到最大基</p>
</li>
<li><p>否则选择最小的 $r_q$ 作为新入基 ，可用 $r^T_D = c^T_D-c_B^TB^{-1} D$直接算出所有的。</p>
</li>
<li><p>如果不存在$y_{iq}&gt;0$ 则停止运算，问题有无界解。否则令$p = arg\ min_i{y_{i0}/y_{iq}:y_{iq}&gt;0}$【只看原来的基，不看非基】，如果求解出多个满足条件的下标 $i$ 按约定选最小的。</p>
</li>
<li><p>以元素（p，q）进行枢轴转换，更新增广矩阵规范型<br>$$<br>y^{‘}<em>{ij} = y</em>{ij} - \frac{y_{pj}}{y_{pq}}y_{iq}\ ,i\neq p\<br>y^{‘}<em>{pj} = \frac{y</em>{pj}}{y_{pq}}<br>$$</p>
</li>
<li><p>转到步骤2</p>
</li>
</ol>
<p>单纯形表为单纯形法提供了一种便捷的实现方式，在更新单纯形表的过程中，可以同时得到基变量和检验数，甚至右下角还有（取负的）目标函数值。</p>
<p><code>P247</code> 给出了矩阵形式的求法，非常666，当最后一行除了最后一个元素都非负的时候就出结果了，而且最后一个元素就是结果取负，而 $x_i$ 的取值就在它上面。</p>
<hr>
<h3 id="二阶段单纯形法"><a href="#二阶段单纯形法" class="headerlink" title="二阶段单纯形法"></a>二阶段单纯形法</h3><p>初始基本可行解并不是显而易见的。</p>
<p>为了利用单纯形法求解一般形式的线性规划问题，需要设计一种<strong>系统化</strong>的方法来寻找初始基本可解。</p>
<p>简单的证明表示，若原问题存在基本可行解，等价于人工问题存在一个使目标函数值为0的最优解。</p>
<p>而且人工问题有个显然的初始基本可行解$\begin{bmatrix}\pmb{0}\\pmb{b}\end{bmatrix}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211006190811386.png" alt="image-20211006190811386"></p>
<p>因此多出了个求解初始基本可行解的新阶段。该阶段x作为参数而非变量。</p>
<p>从第一阶段到第二阶段只需要删除与人工变量有关的列向量，把价值系数还原就好了。</p>
<p>补充人工变量需要刚好凑足一组可行解$\begin{bmatrix}\pmb{0}\\pmb{b}\end{bmatrix}$ ，和原有的 $e_i$ 加起来能够凑足m个，才能满足条件。</p>
<hr>
<p>如果m远远小于n，很多列从来没成为过基向量，那么进行更新枢轴变换其实是无用的。</p>
<p>修正单纯形法能够避免这些无用的计算，降低了求解最优解的计算器。</p>
<p>原理是可以无视A = B,D中的D，从里面挑出需要的，操作得出下一个单纯形表后再扔掉。</p>
<p>:star2: 步骤：</p>
<ol>
<li><p>针对初始基本可行解构造修正的单纯形表$[B^{-1},y_0]$，一开始B-1应该是一个E</p>
</li>
<li><p>计算当前的检验数 $r^T_D = c^T_D-c_B^TB^{-1} D$ 这里建议<strong>先算</strong> $c^TB^{-1}$ 再与D计算，大大省了计算量。</p>
<p>这里的B-1其实就是每次你看到的 $y_0$前面那个矩阵。</p>
</li>
<li><p>如果所有 $r_j$都大于0，则找到最优解，否则挑选最小的$r_q&lt;0$，计算<br>$$<br>y_q = B^{-1}a_q<br>$$</p>
</li>
<li><p>如果不存在$y_{iq}&gt;0$ 则停止运算，问题有无界解。否则令$p = arg\ min{y_{i0}/y_{ij}:y_{ij}&gt;0}$【只看原来的基，不看非基】，如果求解出多个满足条件的下标 $i$ 按约定选最小的。</p>
<p>这里很好算，只要用倒数第二行【y_0】/新增的最后一行【y_q】就能比较出来。</p>
</li>
<li><p>构造增广修正单纯形表 $[B^{-1},y_0,y_q]$，以最后一列的第p个元素开展枢轴变换，得到m+1列作为新表。</p>
</li>
<li><p>返回步骤2</p>
</li>
</ol>
<h2 id="17、对-偶"><a href="#17、对-偶" class="headerlink" title="17、对 偶"></a>17、对 偶</h2><p>对偶问题的最优解可以由原问题的最优解得到，vice versu。</p>
<p>而在某些情况下，利用对偶理论求解线性规划问题更为简单，而且有助于深入了解待求解问题的本质。</p>
<p>在对偶理论的启发下，单纯形法——&gt;对偶单纯形法，改善了性能。</p>
<p>涌现出了一些非单纯形法。【第十八章】</p>
<p><strong>对称形式和非对称形式</strong>的对偶关系：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007113216063.png" alt="image-20211007113216063"  /></p>
<p>这两种形式：对偶的对偶是原问题<code>所以这个表是可以双向看的，但是注意列向量还是行向量，最大值还是最小值。。。</code>。先用前面章节的方法转换成<u>“原方法”的标准形式</u>，再利用对偶关系将其转换为对偶问题。记住b、c互换，x、λ互换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007122511694.png" alt="image-20211007122511694">————&gt;<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007122520805.png" alt="image-20211007122520805"></p>
<p><code>P261底有个食谱和药店的对偶问题，有一点nb</code>，求解对偶问题的时候注意<strong>有转置</strong>。。烦死了</p>
<hr>
<p>对偶问题的性质：</p>
<p><strong>弱对偶引理</strong></p>
<p>假设 $x$ 和 $\lambda$ 分别是线性规划的原问题和对偶问题的<strong>可行解</strong>，则$c^Tx \geq \lambda^T b$,</p>
<p>（对 对称或非对称都成立。）<code>这都是在满足标准形式👆的基础上讨论的</code></p>
<p>这说明对偶问题的目标函数值不大于原问题的目标函数值。”极大值&lt;极小值”，当一个问题的目标函数值是无界的，里一个问题就没有可行解。比如极小化问题的极小值为$-\infin$，自然引出定理👇</p>
<p><code>定理1：如果原问题和对偶问题的可行解使得两个问题的目标函数值都相同，那么相应的可行解一定是各自问题的最优解</code></p>
<p><strong>对偶定理</strong></p>
<p>如果原问题（对称或非对称）有最优解，那么其对偶问题也有最优解，且目标函数最优值相同。或者说只要出现了👇这个形式，那么就找到了最优解。</p>
<p>并且有以下结论：<br>$$<br>\pmb{\lambda}^T\pmb{b} = \pmb{c}_B^T\pmb{B}^{-1}\pmb{b} = \pmb{c}_B^T\pmb{x}_B<br>$$<br>可以用$\pmb{\lambda}^T\pmb{b} = \pmb{c}_B^T$来计算，特别地，如果 rand D = m 有👇</p>
<p>当我们采用单纯形法求解原问题，得到最终单纯形表后，可依此计算对偶问题的最优解。<br>$$<br>\pmb{\lambda}^T\pmb{D} = \pmb{c}^T_D - \pmb{r}_D^T<br>$$<br>当rand D &lt; m时，<br>$$<br>\pmb{\lambda}^T\pmb{A} = \pmb{c}^T - \pmb{r}^T \<br>while\ \pmb{r}^T = [\pmb{0},\pmb{r}^T_D]<br>$$<br>:star: 三种情况：</p>
<ul>
<li>若其中一个问题有最优解，另一个问题也有最优解，且最有可行解值相同</li>
<li>若其中一个问题的目标函数无界，则另一个问题不存在可行解。</li>
<li>若其中一个问题没有可行解，另一个问题不存在最优解，但可能有可行解也可能没有。</li>
</ul>
<p><strong>互补松弛条件</strong><code>P269</code></p>
<p>$x$ 和 $\lambda$ 分别是原问题和对偶问题的可行解，则它们分别是各自问题的最优解的充分必要条件是：</p>
<ul>
<li>$(\pmb{c}^T - \pmb{\lambda}^T\pmb{A})\pmb{x} = 0$ </li>
<li>$\pmb{\lambda}(\pmb{Ax - b})=0$</li>
</ul>
<p>这俩式子是等价的，看你有的是c还是b</p>
<h1 id="约束、非线性"><a href="#约束、非线性" class="headerlink" title="约束、非线性"></a>约束、非线性</h1><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007150352909.png" alt="image-20211007150352909"></p>
<h2 id="20、仅含等式约束"><a href="#20、仅含等式约束" class="headerlink" title="20、仅含等式约束"></a>20、仅含等式约束</h2><p>线性规划是这类问题的一个特例。<br>$$<br>minimize\   f(\pmb{x}) \<br>subject\ to\ \pmb{Ax=b}\<br>\pmb{x}\geq0<br>$$<br>对于满足等式约束的$x^*$，若 $\triangledown h_1(x^*),\cdot\cdot\cdot,\triangledown h_m(x^*)$ 线性无关，则称 $x^*$为该约束的一个正则点。</p>
<p>显然，当 $rand\ D\pmb{h(x^*)} = m$ 时，$x^*$为正则点。$D\pmb{h(x^*)} $的每行，是梯度倒数的转置$\triangledown h_i(x)^T$</p>
<p>$S = {\pmb{x} \in R^n : \pmb{h(x) = 0}}$ S是$R^n$空间中的一个<strong>曲面</strong>，这就是高维曲面的一般方程吧。</p>
<p>若S上的<u>所有点都是正则点</u>，则S的维数是 $n-m$。</p>
<hr>
<p>曲面上曲线的定义：<code>理论来自P36多面体</code></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007155733411.png" alt="image-20211007155733411" style="zoom: 67%;" />

<p>顺便定义一下可微和二次可微</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007155906762.png" alt="image-20211007155906762" style="zoom:67%;" />

<p>​    $\pmb{h}\in C^m$ 意思是函数向量h，m阶可微</p>
<p>则曲线S中$x^*$处<strong>切线空间</strong>定义为：$T(\pmb{x^*}) = {\pmb{y:Dh(x^*)y = 0}}$，其实就是矩阵$\pmb{Dh(x^*)}$的零空间，</p>
<p>一般描述为二维切平面，便于直观理解。</p>
<p>$TP(x^*)=x^*+T(x^*)$因为子空间是在原点处的，平移就行。</p>
<p><code>当某个点为正则点时，该点处的切线空间就是该点所有切向量的集合。</code></p>
<p><strong>法线空间</strong>定义为$N(\pmb{x^*})={\pmb{x}\in R^n:\pmb{Dh(x^*)^Tz},z\in R^n}$，其实就是用z把$Dh(x^*)^T$的行线性组合了。</p>
<p>算是一种行空间的高级表示方法，实际上就是值域。</p>
<p>$NP(x^*)=x^*+N(x^*)$描述更为方便。</p>
<p>显然行空间和零空间互为正交补，即 $N(x)^{\bot} = T(x)$，可以用这俩对$R^n$进行直和分解。</p>
<hr>
<p><strong>拉格朗日条件（一阶必要条件）</strong></p>
<p>有约束极值问题的一阶必要条件，著名的拉格朗日定理。</p>
<p>法线空间和切线空间正交 等价于 $\triangledown h(\pmb{x})$与 $h(\pmb{x})$水平集 正交。</p>
<p>定理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211007195010904.png" alt="image-20211007195010904"><br>$$<br>Df(\pmb{x^*})+\pmb{\lambda^{<em>T}}D\pmb{h}\pmb{(x^</em>)}=\pmb{0}^T<br>$$<br>如果$x^*$是极值点，那么目标函数f在该点处的梯度可以表示为关于约束函数在该点处梯度的线性组合。</p>
<p>更紧凑的形式是$\triangledown f(x^*) \in N(x^*)$，$\pmb{\lambda^*}$为拉格朗日乘子向量。</p>
<p>:star:拉格朗日的精髓：</p>
<p><code>正则性</code>是拉格朗日的必需假设，为了便于描述引入拉格朗日函数 $l(\pmb{x,\lambda}  )\triangleq f(\pmb{x})+\pmb{\lambda}^T\pmb{h}(\pmb{x})$</p>
<p>通过求解👇可找出<u>可能的极值点</u>。这是<strong>必要而非充分条件</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008103355619.png" alt="image-20211008103355619" style="zoom:50%;" />

<p>其中：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008103933015.png" alt="image-20211008103933015" style="zoom: 50%;" />



<hr>
<p>但仅仅求出候选解不够，我们需要更强的条件。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059852.png" alt="image-20211203210800835" style="zoom:60%;" />

<p><strong>二阶必要条件</strong><br>$$<br>\pmb{L}(\pmb{x,\lambda}) = \pmb{F}(\pmb{x})+[\pmb{\lambda H}(\pmb{x})]\<br>[\pmb{\lambda H}(\pmb{x})] = \lambda_1\pmb{H}_1(\pmb{x})+…+\lambda_m\pmb{H}_m(\pmb{x})<br>$$<br>对于满足一阶必要条件的正则点、局部极小点 $x^*$ ：</p>
<ol>
<li>存在$\lambda^<em>\in R^m$使得$Df(\pmb{x^</em>})+\pmb{\lambda^{<em>T}}D\pmb{h}\pmb{(x^</em>)}=\pmb{0}^T$</li>
<li>对于所有 $y \in T(\pmb{x^*})$ (切线空间)，有 $y^TL(x^*,\lambda^*)y \geq 0 $ 【区别于无约束，不是在整个 $R^n$上成立】</li>
</ol>
<p><strong>二阶充分条件</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211008110258482.png" alt="image-20211008110258482" style="zoom: 33%;" />

<p>这里是正定而不是半正定，若是负定，就是严格局部极大值点。</p>
<h2 id="21、含不等式约束的优化问题"><a href="#21、含不等式约束的优化问题" class="headerlink" title="21、含不等式约束的优化问题"></a>21、含不等式约束的优化问题</h2><p>$$<br>minimize\ f(\pmb{x})\<br>subject\ to\ h_i(\pmb{x}) = \pmb{0},\ i=1,…,m\<br>g_j(\pmb{x})\leq\pmb{0},\ j = 1,…,p\<br>$$</p>
<p>$f:R^n \rightarrow R\ ，\pmb{h}:R^n \rightarrow R^m\ ，m\leq n\ , \pmb{g}:R^n \rightarrow R^p$</p>
<p>对于不等式约束 $g_j(\pmb{x})\leq0$，在$x^*$处可分成起作用约束$g(x^*)=0$和不起作用约束$g(x^*)&lt;0$。等式约束视为总起作用。</p>
<p>修改了正则点的定义，如果正好处于起作用约束的 $\pmb{g}(x)$上，还得加上所有的$\triangledown h_i(x^*),$和起作用的$\triangledown g_j(x^*)$线性无关。其中切线空间和法线空间的修改完全类似。</p>
<p><strong>Karush-Kuhn-Tucker条件（KKT条件）（一阶必要条件）</strong>:</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010183126851.png" alt="image-20211010183126851" style="zoom:67%;" />

<p>PS：有时候也称 库恩-塔克（KT）条件。</p>
<p><u>由第三个条件推得，不起作用约束对应的KKT乘子 $\mu_j^* = 0$，其他的乘子则是非负的</u></p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010200400492.png" alt="image-20211010200400492" style="zoom:67%;" />

<p>还有很多其他的形式，抓住<strong>本质</strong>：</p>
<p>类似泰勒的拟合思想，通过一些约束得到拟合函数，然后它们有部分相同的性质，便于研究。$g(x)$这是用线性组合确定范围，$h(x)$则用函数那一点的梯度和$f(x)$一样来约束$f(x)$。</p>
<p>:star:👇</p>
<p>个人总结：g(x)小于或大于0，并不受f(x)影响，这是不同的函数，它规定了约束自己的哪一边，然后就能判断$\triangledown g(x)$的方向是指向围成的区域内还是外，然后再用$\triangledown g(x)$把$\triangledown f(x)$表达出来，就可以判断$\triangledown f(x)$ 是朝区域内还是朝区域外。</p>
<p>【<strong>比如条件为$g(x)\geq 0$，那么$f(x)$的方向如果表示为$\triangledown g(x)_i$的正的线性组合，那就是朝区域内，就是极小值。</strong>】</p>
<p>规律为：<u>【符号 * $\mu$ * $g_i(x)$】的符号为正，是极小；反之为极大。</u></p>
<p>注意这是必要条件，只能找出潜在的。</p>
<hr>
<p><strong>二阶必要</strong></p>
<p>二阶的定义如下，其实和等式约束一样，知识多了个$\mu G(x)$，其中$G_k(x)$是$g_k$在$x$处的黑塞矩阵。<br>$$<br>\pmb{L}(\pmb{x,\lambda}) = \pmb{F}(\pmb{x})+[\pmb{\lambda H}(\pmb{x})]+[\pmb{\mu G}(\pmb{x})]\<br>[\pmb{\lambda H}(\pmb{x})] = \lambda_1\pmb{H}_1(\pmb{x})+…+\lambda_m\pmb{H}_m(\pmb{x})\<br>[\pmb{\mu G}(\pmb{x})] =\mu_1 \pmb{G}_1(\pmb{x})+…+\mu_p \pmb{G}_p(\pmb{x})<br>$$<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010202546145.png" alt="image-20211010202546145" style="zoom:67%;" /></p>
<p>可以说和仅含等式约束十分接近了。</p>
<p><strong>二阶充分</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010202659361.png" alt="image-20211010202659361" style="zoom:67%;" />

<p>ps：👆那个子集关系是因为约束条件少了，可表示的范围就大啦！</p>
<p>上面那一坨其实是说，每出现一个 $\mu_i(&gt;0)$，就多出一个限制条件，而原先是满条件。</p>
<p>类似的有，如果$\mu ^* \leq 0$ 和 $L(x^*,\lambda^*)$在范围上负定，则是严格局部极大点。</p>
<h2 id="22、凸优化问题"><a href="#22、凸优化问题" class="headerlink" title="22、凸优化问题"></a>22、凸优化问题</h2><h3 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h3><p>总体而言，前面两章讨论的关于非线性优化问题的求解还是存在一定困难的，或是来自于目标函数，或是来自约束条件，甚至两者兼有，这会导致求解上的困难，但是凸函数这不会带来这些问题。</p>
<p>实值函数上图（epigraph）:</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010213323478.png" alt="image-20211010213323478" style="zoom:67%;" />

<p><strong>定义</strong>：如果函数$f:\rightarrow R，\Omega \subset R^n $的上图是凸集，那么 $f $ 是集合 $\Omega$ 上的凸函数。</p>
<p><strong>定理</strong>：如果函数$f:\rightarrow R，\Omega \subset R^n $是集合 $\Omega$ 上的凸函数。那么 $\Omega$ 是凸集。</p>
 <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010215337043.png" alt="image-20211010215337043" style="zoom:67%;" />

<p>（因为本书一开始说了，以极小值问题为主，极大值可以转换成极小值，所以是默认都用下凸函数）</p>
<p><strong>定理</strong>：假设函数 $f,f_1,f_2$都是凸函数，那么对 $\forall a \geq0$，函数 $af、f_1+f_2$也是凸函数。【线性组合】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010220430622.png" alt="image-20211010220430622" style="zoom:67%;" />

<p>当$-f$是（严格）凸函数时，$f$是（严格）凹函数</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010225954694.png" alt="image-20211010225954694" style="zoom:67%;" />

<p>内点：如果P存在某个邻域 $\sub$ D 则称点P为内点。</p>
<p>开集：若D中的每一个点都是D的内点则称D为开集，显然不包括边界。</p>
<p><strong>凸函数的判定：</strong></p>
<p><em>一阶可微</em></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010230008947.png" alt="image-20211010230008947" style="zoom: 67%;" />

<p>几何理解是因为线性近似总是位于上图$epi(f)$的下方。</p>
<p>该定理关于 $\Omega$是开集的假设不是必须的，只要 $f$定义在某个<strong>包含 $\Omega$的</strong>开集上即可。</p>
<p><em>不可微函数的次梯度</em></p>
<p>函数 $f:\Omega\rightarrow R$定义在开凸集 $\Omega \sub R^n$上，如果对于<em><strong>所有</strong></em> $\pmb{y}\in\Omega$，都有<br>$$<br>f(\pmb{y}) \geq f(\pmb{x})+\pmb{g}^T(\pmb{y-x})<br>$$<br>则称向量 $\pmb{g} \in R^n$为函数 $f$定义在点 $\pmb{x} \in \Omega$处的次梯度。</p>
<p><em>二阶可微</em></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211010231054775.png" alt="image-20211010231054775" style="zoom: 67%;" />

<p>该定理可以拓展到<strong>定义域是非开集</strong>的情况，只需要把条件修改为对任意的 $\pmb{x,y}\in \Omega$，<br>有$(\pmb{y-x})^T\pmb{F}(\pmb{x})(\pmb{y-x}) \geq 0$。</p>
<hr>
<p><strong>凸优化问题</strong></p>
<p>凸优化问题有许多独特之处。比较特别的一点就是对某些问题，局部极小点就是全局极小点。</p>
<p>此外，<strong>极小点的一阶必要条件是凸优化问题的充分条件</strong>！</p>
<p>对于凸集，其范围内包含全局极小点的集合也是凸集。</p>
<p>若目标函数是连续可微的凸函数，那么某个点是极小点所应该满足的一阶必要条件同时也是充分条件。</p>
<p>:star:</p>
<p>第六章提到的 局部最小一阶必要：对某点$x^*$ 所有可行方向$d$，$d^T\triangledown f(x^*)$均&gt;=0</p>
<p>对于一阶连续的凸函数只要在凸集$\Omega$上存在梯度为0的点，就是全局极小点。</p>
<p>对于20章仅含等式的约束问题，只要满足拉格朗日条件，就是全局极小点。</p>
<p>对于21章一般情况下的问题，满足KKT条件就是全局极小点。</p>
<h3 id="半定规划"><a href="#半定规划" class="headerlink" title="半定规划"></a>半定规划</h3><p>作为<u>凸规划</u>问题的一个分支，求解的是<u>线性矩阵不等式约束</u>下的线性目标函数的极小值。线性矩阵不等式定义了一个<u>凸可行集</u></p>
<p>可视为线性规划的拓展，只要把向量不等式约束替换为矩阵不等式约束。</p>
<p>PS：仿射函数，即最高次数为1的多项式函数。常数项为零的仿射函数称为线性函数</p>
<p>$F_i\ ,i=0…n$ 是n+1个实对称矩阵，表达式$F(x)$可称为线性矩阵不等式（LMI），或仿射矩阵不等式</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211014105833873.png" alt="image-20211014105833873" style="zoom: 33%;" />

<p>的点 x 的集合，也就是保证$F(x)$是半正定的【记为$F(x)\geq 0$】</p>
<p><strong>对于形如 $\pmb{F}(\pmb{x})\geq 0 $的线性矩阵不等式而言，容易证明 ${\pmb{x}:\pmb{F}(\pmb{x})\geq 0}$ 是凸集。</strong> </p>
<p>以此类推，对于形如$F(x)&gt;0$线性矩阵不等式而言，其要求为F(x)正定(不仅仅是半正定)</p>
<p>优化、控制系统设计以及信号处理中的许多问题都可以转化为<u>线性矩阵不等式的形式</u>。确定是否存在一个点x使得$F(x)&gt; 0$成立的问题称为<strong>可行性问题</strong>。如果不存在这样一个x，则称线形矩阵不等式问题是不可行的。</p>
<p>而对于这样的问题，MATLAB、Python库等已经实现了高效的求解方式。</p>
<h2 id="23、有约束优化问题的求解方法"><a href="#23、有约束优化问题的求解方法" class="headerlink" title="23、有约束优化问题的求解方法"></a>23、有约束优化问题的求解方法</h2><p>本章将针对特殊约束条件下的优化问题，讨论一些简单的求解算法。之前无约束优化问题的求解算法是这些算法的基础。</p>
<p>有投影法、拉格朗日法、罚函数法，旨在简单介绍有约束优化问题的部分求解算法及原理。</p>
<h3 id="投影法"><a href="#投影法" class="headerlink" title="投影法"></a>投影法</h3><p>第二部分讨论过的优化算法，大都具有通用的迭代公式。$x^{(k+1)} = x^{(k)} + \alpha_kd^{(k)}$</p>
<p>但是在有约束问题中，$x$的取值范围必须在预先设定的约束集内，所以不能直接套用以前的算法。</p>
<p>一种比较简单的改进方式就是<strong>引入投影</strong>。具体方法为：</p>
<ul>
<li>若$x^{(k)} + \alpha_kd^{(k)}$在$\Omega$内，则$x^{(k+1)} = x^{(k)} + \alpha_kd^{(k)}$；</li>
<li>否则，应该将$x^{(k)} + \alpha_kd^{(k)}$投影到$\Omega$中，然后将投影结果作为$x^{(k+1)}$。</li>
</ul>
<p>引入投影算子$\Pi$，$\Pi[x]$称为$x$到$\Omega$上的投影，则之前的算法可以改进为 $x^{(k+1)} = \Pi[x^{(k)} + \alpha_kd^{(k)}]$</p>
<p>对于一般的情况，可定义投影为： $\Pi[x] = \mathop{argmin}\limits_{z\in \Omega}||z-x||$</p>
<p>框式约束时，投影算子定义如下：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059853.png" alt="image-20211204094248769" style="zoom:67%;" />

<p>许多情况下，投影$\Pi[x]$存在明确的计算公式。比如，<em>框式约束</em>👆，当$\Omega$为一个<em>线性簇</em>时，也有明确的公式。</p>
<p>但是很多时候，投影的计算也是个较为复杂的数值优化问题。</p>
<hr>
<p><strong>求解含线性约束优化问题的投影梯度法</strong></p>
<p>将投影算子引入梯度法，可得如下迭代公式$x^{(k+1)} = \Pi[x^{(k)} + \alpha \triangledown f(x^{(k)})]$，称为投影梯度法</p>
<p>形如<br>$$<br>minimize\ f(\pmb{x})\<br>subject\ to\ \pmb{Ax}=\pmb{b}\<br>$$<br>rank A = m， $b \in R^m $ 且假定$f \in C^1$，约束集的这种特定结构决定了可以使用正交投影算子作为$\Pi$，即<br>$$<br>P = I_n - A^T(AA^T)^{-1}A<br>$$<br>引理：P的零空间，是$A$的行空间；A的零空间，是P的列空间。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059854.png" alt="image-20211204100640630" style="zoom:67%;" />

<p>这个拉格朗日条件的新形式就是关键，而投影算子可表示为<br>$$<br>\Pi[x^{(k)} + \alpha \triangledown f(x^{(k)})] =x^{(k)} - \alpha_kP \triangledown f(x^{(k)})<br>$$<br><strong>几何来看，其实是因为向量$\triangledown f(x)$不一定是可行方向，需要将其投影到可行集，也就是矩阵A的零空间（假定$x^{(k)}$已经属于可行集，只有让后面的$A\omega = 0$这样才能继续保证$A(x+\omega)=b$），而A的零空间就是P的列空间，投影过去等价于左乘P。</strong></p>
<p>看看性质：</p>
<ul>
<li>根据红字分析也能看出，只要$x^{(0)}$可行，任意$x^{(k)}$可行。</li>
<li>向量$-P \triangledown f(x)$是函数在 x 处的<u>最速下降可行方向</u></li>
<li>和无约束类似，如果$\alpha$选择一维正方形搜索最小的，称为投影最速下降法，该方法能保证每次迭代目标函数值都减小</li>
<li>当且仅当$P \triangledown f(x^*) = 0$时，满足拉格朗日条件，$x^*$为全局极小点</li>
</ul>
<h3 id="拉格朗日法"><a href="#拉格朗日法" class="headerlink" title="拉格朗日法"></a>拉格朗日法</h3><p>基本思路是利用梯度法，在更新决策变量的同时，也更新拉格朗日乘子向量。</p>
<p><strong>仅含等式约束的情况</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059855.png" alt="image-20211204103711220" style="zoom: 67%;" />

<p>可以看出，$x^{(k)}$的更新方程是一种使得拉格朗日函数关于自变量$x$极小化的梯度算法，$λ^{( k )}$的更新方程也是一种梯度算法，使得拉格朗日函数关于自变量$ λ $极大化。由于仅仅用到了梯度，该方法也称为<u>一阶拉格朗日法</u>。</p>
<p>若收敛，那么<em>迭代点序列的极限</em>必须满足拉格朗日条件；特别的，<em>任意不动点</em>（更新后的新点与其相等）必满足拉格朗日条件。</p>
<p>局部收敛性：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059856.png" alt="image-20211204104417327" style="zoom:70%;" />



<p><strong>含不等式优化的拉格朗日法</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059857.png" alt="image-20211204105344929" style="zoom:67%;" />

<p>$x^{(k)}$的更新方程是一种使得拉格朗日函数关于自变量$x$极小化的梯度法，$\mu ^{( k )}$的更新方程是一种梯度投影法，使得拉格朗日函数关于自变量$ \mu $极大化。采用梯度投影法的原因在于，KKT乘子向量$\pmb{\mu}$必须是非负的。</p>
<p>同样，收敛极限和不动点必须满足KKT条件。</p>
<p>收敛性：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059858.png" alt="image-20211204110647649" style="zoom:67%;" />

<p>第一阶段，不起作用的约束条件对应的乘子在有限时间内减小到0，此后一直为0</p>
<p>第二阶段，起作用的约束条件的乘子以线性速度收敛到各自的解。</p>
<p>对偶问题见《统计学习方法》P447</p>
<h3 id="罚函数法"><a href="#罚函数法" class="headerlink" title="罚函数法"></a>罚函数法</h3><p>考虑将有约束优化问题<strong>近似处理</strong>为如下的无约束优化问题<br>$$<br>minimize\ f(z)\<br>subject\ to\ x\in \Omega\ \downarrow\<br>minimize\ f(x) + \gamma P(x)<br>$$<br>其中<u>惩罚因子</u>$\gamma$是大于0的常数；<u>罚函数</u>$P：R^n \rightarrow R$是给定函数，求解该无约束优化问题，解作为原问题极小点。</p>
<p>为了使得无约束优化问题能够更好地<u>近似有约束问题</u>，必须选择合适的惩罚函数$P$。罚函数可以对<u>可行集外</u>的点进行 “惩罚”。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059859.png" alt="image-20211204124639606" style="zoom:67%;" />

<p>绝对值罚函数👆在满足$g_i(x)=0$的点$x$上可能不是可微的，因此，在这些情况下，不能使用涉及求导的优化方法。</p>
<p>但是另一种版本$P(x) = \sum_{i=1}^{p}(g_i^+(x))^2$能保证罚函数可微。</p>
<p>无约束优化问题的解是否近似于真正的解，<u>取决于惩罚因子$\gamma$和罚函数$P$</u>，理论上当$\gamma \rightarrow \infin$时，得到真正的解，后续讨论。</p>
<hr>
<p>接下来，不假设罚函数的具体形式，仅假设其满足3个条件，分析<em>一般意义下的罚函数法</em>：</p>
<p>先引入一些符号和用法，</p>
<ul>
<li>$x^*$表示优化问题的一个解（全局最小点）。</li>
<li>$\gamma_k \in R，\ k = 1,2,…$是一个给定的正数。</li>
<li><strong>伴随函数</strong> $q(\gamma_k,\pmb{x}) = f(\pmb{x}) + \gamma_kP(\pmb{x})$，对于每个k，都可构造一个伴随的无约束优化问题：$minimize \ q(\gamma_k,\pmb{x})$<br>并用$x^{(k)}$表示该问题的极小点，随后给出以下引理。</li>
</ul>
<p>引理23.4给出了<u>有约束问题与伴随的无约束优化问题的关联关系</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059860.png" alt="image-20211204131635745" style="zoom:67%;" />

<p>利用这一引理可以证明如下<strong>定理</strong>：</p>
<p>目标函数$f$连续，当$k \rightarrow \infin$时，$\gamma_k \rightarrow \infin$。那么序列${\pmb{x}^{(k)}}$的<em>任意收敛子序列</em> 的极限是约束优化问题的一个解。</p>
<p>​    如果进行无限多次极小化计算，随着惩罚因子$\gamma_k \rightarrow \infin$，那么定理能保证任何收敛子序列的极限都是有约束优化问题的极小点.<br>显然，这一定理在实际应用中是受限的。实际上，利用罚函数法求解无约束优化问题的最优解时，期望<strong>只通过一次极小化</strong>计算便可求得最优解，进而得到原问题的最优解。</p>
<p>​    换句话说，在$γ&gt;0$为一个<strong>给定常数</strong>的情况下，通过求解伴随的无约束优化问题$[minimize\ f(x) + \gamma P(x)]$获得原问题的精确解。可以证明，<u>这的确是可以做到的</u>，这种情况下的罚函数称为<strong>精确的罚函数</strong>。但是，精确的罚函数要求是<u>不可微的</u>【必要】，但是得满足存在可行方向 $d$ 使得$\pmb{d}^T\triangledown P(x)&gt;0$。如果存在某点$\triangledown f(x^*) = 0$，虽然P可微，仍然是精确罚函数。</p>
<p>​    接下来的求解工作就是无约束的内容啦！</p>
<p><em>本章仅仅讨论了罚函数的基础知识</em>，关于不可微函数的优化问题的深入讨论要自己查文献。。。</p>
<h2 id="24、多目标优化"><a href="#24、多目标优化" class="headerlink" title="24、多目标优化"></a>24、多目标优化</h2><p>The last one!</p>
<p>如果某个优化问题只包含一个目标函数，称为单目标优化问题；但是，绝大多数工程问题需要设计者同时处理多个目标，而这些目标之间往往存在冲突，即改进一个目标会导致另一个目标恶化。这种<u>存在冲突</u>的多目标问题，也成为<u>多准则、向量优化问题</u>。</p>
<p>这种问题需要找到一个决策变量，个元素就是目标函数。多目标优化问题可以表示为</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059861.png" alt="image-20211204162618132" style="zoom:67%;" />

<p>3种多目标优化问题【后两类可以等价转换为第一类问题，即极小化问题】</p>
<ul>
<li>极小化所有目标函数</li>
<li>极大化所有目标函数</li>
<li>极小化某些目标函数，极大化其余目标函数</li>
</ul>
<p><strong>帕累托解 Pareto</strong></p>
<p>多目标函数给各个决策变量分配一个位于多目标空间中的<u>多目标函数向量函数值</u>。</p>
<p>单目标优化问题的目标是找到一个解，主要关注<strong>决策向量空间</strong>；</p>
<p>而在多目标问题问题中，通常对<strong>目标函数空间</strong>更感兴趣。</p>
<p>正如某位M开头大师所说，多目标问题某种意义上无法进行明确的定义，因为目标函数空间中不存在自然排序，不像一维空间中可以清晰、直观地比较大小关系，但是最终仍然给出了正式定义。</p>
<p>目前，最优解的正式定义，习惯于将多目标优化问题的最优解称为帕累托极小点（帕累托解）定义如下：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059862.png" alt="image-20211204163914597" style="zoom:67%;" />

<p>成立，则$x^*$是一个帕累托极小点。也成为非支配解，它意味着<u>不存在一个可行的决策变量$x$能够使得某些目标函数减少的同时不会导致另一个其他目标函数增加。</u>【知乎大佬：<strong>从此以后，非损人不能利己</strong>。】也可以用于博弈论啊</p>
<p>帕累托极小点（最优解）的集合称为帕累托前沿，绝大多数多目标优化算法用到了“支配”概念，但帕雷托解是非支配的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059863.png" alt="image-20211204165010255" style="zoom: 67%;" />



<p><strong>帕累托前沿的求解</strong></p>
<p>在求解帕累托前沿时，需要对两个解进行比较，从候选的帕累托解集合中移除支配解。因此，帕累托前沿只包含非支配解。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059864.png" alt="image-20211205140953483" style="zoom:67%;" />

<p>对于新的候选解$\pmb{x}^{j}$，可能有三种情况：</p>
<ul>
<li>$\pmb{x}^{j}$至少支配一个当前的帕累托解——用$\pmb{x}^{j}$替代被支配的解</li>
<li>$\pmb{x}^{j}$不支配任何当前的帕累托解——直接将$\pmb{x}^{j}$加入帕累托候选集合</li>
<li>$\pmb{x}^{j}$收到一个当前的帕累托解支配——不操作。</li>
</ul>
<p><strong>帕累托前沿的生成算法</strong></p>
<p>$J$ 表示为得到最优解而必须进行分析的候选解的数目，$R$ 是当前候选的帕累托解数量。$\varrho$ (类似的那个符号)是目标函数向量的维数，$n$是决策空间的维数，即$x$的元素个数。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059865.png" alt="image-20211205143500435" style="zoom:60%;" />



<p><strong>多目标优化到单目标优化的转换</strong></p>
<p>在某些情况下，可以将多目标优化问题转换为单目标优化问题，这样，就可以利用前面讨论过的一些常用方法进行求解了。</p>
<p><strong>Method1</strong>：将目标函数向量中的各元素进行线性组合（组合系数必须为正数），也就是各元素的凸组合。<br>$$<br>f(\pmb{x}) = c^Tf(x)<br>$$<br>向量c的<u>元素全部为正</u>，称为加权求和法，系数成为权值，反映的是目标向量中的<u>各元素相对重要度</u>。不得不提出的是，<em>权值的确定可能相当困难</em>。</p>
<p><strong>Method2</strong>：以目标向量中的最大元素作为单目标函数：</p>
<p>实际上，这就是将多目标极小化问题转换为使目标函数的最大元素极小化的问题，可称之为<u>极小极大法</u>。</p>
<p>使用条件：各元素具有可比性或彼此相容的情况。【彼此相容：它们具有相同的单位】</p>
<p>局限性：产生的单目标函数是不可微的，因此无法使用那些要求目标函数可微的优化求解方法（比如梯度）</p>
<p>而目标函数向量中中各元素为线性函数、约束为线性方程的极小极大问题可简化为线性规划问题。</p>
<p><strong>Method3</strong>：若目标向量的元素全部非负，那么以目标函数向量的$p$范数作为单目标函数，也可转换为单目标优化。</p>
<p>极小极大方法可视为特例，也就是$p = \infin$；当$p$有限时，可以用 p范数的p次方代替范数本身！【突然好算多了】</p>
<p><strong>Method4</strong>：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091059866.png" alt="image-20211205191554118" style="zoom:67%;" />

<hr>
<h3 id="存在不确定性的线性规划"><a href="#存在不确定性的线性规划" class="headerlink" title="存在不确定性的线性规划"></a>存在不确定性的线性规划</h3><p>所谓不确定，指的是约束条件的上下界不能确定，约束条件表现为$(\pmb{Ax})_i \leq b_i + \theta t_i$</p>
<p>其中，$\theta \in [0,1],t_i &gt;0, i = 1,2,…,m$</p>
<p>未完待续。。。等真正理解再来吧</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>GRE教程</title>
    <url>/2022/02/22/GRE%20Note/</url>
    <content><![CDATA[<h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>【最近趋势：考老题，】</p>
<p>雅思托福是保证基本语言能力。GRE考的是学术逻辑能力。</p>
<p>GRE是泛学科的，你可能遇到地理、生物。。一堆专业的东西，但是线索都会在文章给出，不需要专业知识。</p>
<p>1500+一考</p>
<p>GRE有单独的报名网站<a href="https://gre.neea.edu.cn/login.do">https://gre.neea.edu.cn/login.do</a> 每个月3场左右，要提前3-6个月抢考位。</p>
<p>现场考试，不能带文具，要带ID（身份证）和考试确认信。</p>
<p>考完后直接出分，但可以在看到成绩前选择是否保留，写作得7-10天后。可填写4个免费送分的机会。不然送分得通过ETS</p>
<p>搜索写作评分标准：gre+issue/argument+scoring+guide</p>
<p>语文数学都不答都有130分。</p>
<p>第二个section难度由第一个section正确率决定。</p>
<p>==大概数值==：</p>
<ul>
<li>对0-6个，进入easy模式，分数范围130-151</li>
<li>对7-12个，medium，143-161（161对语文已经算高分）</li>
<li>hard，151-170分</li>
</ul>
<p>325是一个节点分数，各种要求基本都能过了：数学考满分。。语文两个section错少于8个。</p>
<p>GRE基于section适应而不是题目，所以我们要放弃难题，保简单中等题</p>
<p>考多少分够用：</p>
<p>GRE不是选拔考试，而是基础水平测试，所以只要过了要求的线就行，所以高分并没有太大优势</p>
<p>备考策略：</p>
<ul>
<li>对英语水平、阅读是有要求的。<strong>雅思阅读7.5</strong>。即使先GRE，也得保证阅读</li>
<li>一个月，理论课+集中背单词 -&gt; 报了2个月后的GRE（开始冲刺到考试间1.5-2个月，而且考试和学习不能有间隔）</li>
<li>这俩月冲刺，每天3-4小时 x 60天 = 200小时。最后要上机模考练手感，<a href="https://gre.vip/home">广告</a></li>
<li>语文部分：多刷题，做正确的题【高高频和新新~其实就是浓缩的300和1300，首考可以不用刷其他的。】刷题、听讲解、看解析、分析、改错、背词、提速。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227057.png" alt="image-20220326132849083" style="zoom:50%;" /></li>
<li>数学部分：逐渐变难，完整学习官方的GRE数学部分，然后就开始刷题就好了。</li>
<li>写作部分：理科目标就是3.5，黑书不错（不需要花太多力气）</li>
</ul>
<hr>
<p><strong>背单词</strong></p>
<p>核心词差不多1w上下，包括小学学过的词，但是每次GRE都会冒出从没见过的词（不影响大局）</p>
<p><u>雅思的词汇也是需要的</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227059.png" alt="image-20220326120028964" style="zoom:50%;" />

<p>:star: 前五遍，只看基本含义，其他都不管，是敲门砖；在做题的过程中补上其他的，理解这个词。</p>
<p>刷词，一个单词5-10s，一天重复一个list 2-3遍</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091233914.png" alt="image-20220326120732517" style="zoom:50%;" />

<p>然后就开始备考的下一步。千万不要在这一刻打断，不然单词很容易直接忘掉（是个好问题。）</p>
<hr>
<h3 id="学科"><a href="#学科" class="headerlink" title="学科"></a>学科</h3><p>分析性写作（AW）、语文推理（verbal）、数学推理（Quant）</p>
<p>六个部分（写作，然后语文数学随机2，3）多了一个叫experimental加试，你不知道哪个是加试。</p>
<p>考试时间4个小时，考验体力。</p>
<h4 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h4><p>两篇（30mins*2）：总分六分，中国平均分3.1，全球3.6，大家不怎么投入写作。</p>
<p>GRE写作的分数不计入总分、很多高校并没有要求。所以只要达到比平均分高一些就行。</p>
<p>【500字】Issue议论文，命题写作，更有学术深度，深度思考。。</p>
<p>【450字】Argument 论证，先给阅读短文（论证某个观点），要求考生找出逻辑漏洞，按要求评价。</p>
<p>资料：</p>
<p>题库：搜索：gre issue/argument topic pool可以直接找到 <strong>官方题库</strong>。，。。</p>
<p>写作提纲：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227061.png" alt="image-20220326125920758" style="zoom:50%;" /></p>
<h4 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h4><p>均分148/170，不占优势，时间特别紧张，得训练速度，做完题目就是高手。</p>
<p>每个section 30分钟，填空题x10，阅读题x10<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227062.png" alt="image-20220326112554438" style="zoom:33%;" /></p>
<p>填空都是选择，不考语法、搭配、时态、词性，只考依据已知推理未知。</p>
<p>阅读（短、中、长）文章：每个verbel👇，题型和之前的类似，但是各种难度高。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227063.png" alt="image-20220326112818211" style="zoom:33%;" align = 'left'/>

<p>先学理论知识，然后开刷题。</p>
<p><strong>真题是唯一需要的备考材料</strong>，非官方风格差异很大，还有所谓的题库，机经。</p>
<p>黑名单：橙色的和蓝色的那两本24套和36套。。。真题已经足够多了，练真题完全够。</p>
<p>白名单：阅读机经300篇，填空机经1300题，这都是2015-2019的真题，【后面又说要那两个高高频】</p>
<p>套题：官方正式发布的GRE官方指南（4套题）、2套模考仿真系统 PP0（2免费，3收费）但题目太老，而且题库不共享</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205062227064.png" alt="image-20220326124353853" style="zoom:50%;" />



<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>均分164.7/170</p>
<p>一个section 20个题目，选择&amp;填空。</p>
<p>比较大小题，计算题，图表题，应用题。</p>
<p>满分不容易拿，题干比较长可能理解错，有部分题虽然仍是高中知识，但是思维特别绕。</p>
<p>资料：Official GRE Quant 这个先用来学习理论，冲刺的话真题里面的数学部分就够了，学习成效通过模考的题来看效果就行。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>DL code笔记</title>
    <url>/2022/01/27/code/</url>
    <content><![CDATA[<h2 id="李沐"><a href="#李沐" class="headerlink" title="李沐"></a>李沐</h2><p>tensorflow的tensor没有reshape，必须<code>tf.reshape(x,(3,4))</code> torch牛</p>
<p>tensorflow.random没有randn，得用normal</p>
<p>torch.tensor  对应  tf.constant + tf.Variable + tf.tensors</p>
<p>torch.arange() == tf.range()</p>
<p>查看变量：torch 比较简洁，但tensorflow可能方便点</p>
<p>torch tensor可直接修改  ；TensorFlow中的<code>constant</code>是不可变的，也不能被赋值。 TensorFlow中的<code>Variables</code>是支持赋值的可变容器。 请记住，<u>TensorFlow中的梯度不会通过<code>Variable</code>反向传播。</u></p>
<p>详细描述：<a href="https://tensorflow.google.cn/guide/autodiff?hl=zh-cn#1_%E4%BD%BF%E7%94%A8%E5%BC%A0%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%8F%98%E9%87%8F%E3%80%90%E7%9B%91%E8%A7%86%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%96%E6%B6%88%E7%9B%91%E8%A7%86%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%97%E5%87%BA%E7%9B%91%E8%A7%86%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%8D%E7%9B%91%E8%A7%86%EF%BC%8C%E3%80%91">https://tensorflow.google.cn/guide/autodiff?hl=zh-cn#1_%E4%BD%BF%E7%94%A8%E5%BC%A0%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%8F%98%E9%87%8F【监视常量，取消监视变量，列出监视变量，不监视，】</a></p>
<p>中间结果即使是tensor，也能打印</p>
<p>为了区分需要计算梯度信息的张量和不需计算梯度信息的张量，TF设置一种专门的数据类型用于支持梯度信息的记录：tf.Variable。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># A trainable variable</span>
x0 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x0'</span><span class="token punctuation">)</span>
<span class="token comment"># Not trainable</span>
x1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x1'</span><span class="token punctuation">,</span> trainable<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token comment"># Not a Variable: A variable + tensor returns a tensor.</span>
x2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x2'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span>
x0<span class="token operator">*</span>x0<span class="token comment">#也不行</span>
<span class="token comment"># Not a variable</span>
x3 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'x3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202203181728409.png" alt="image-20220228090447692" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908937.png" alt="image-20220228090508655" style="zoom:40%;" /></p>
<p>如果不用assign，那就会从variable变成tensor</p>
<p>都提供  ~_like()提供同shape，都有<code>.shape</code>，都能用python的<code>len()</code>查看第0维</p>
<p>torch 切片就是原地操作   tf里assign能存参数，无明显原地操作法   torch的<code>_</code>inplace方法，不占用额外的内存</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908939.png" alt="image-20220228091117871" style="zoom:40%;" />

<p>pytorch的<code>tensor(array)</code>不共享内存，<code>as_tensor</code>和<code>from_numpy</code>共享，就地操作也共享。</p>
<p>tensorflow 转换后的结果不共享内存。 这个小的不便实际上是<strong>非常重要</strong>的：当你在CPU或GPU上执行操作的时候， 如果Python的NumPy包也希望使用相同的内存块执行其他操作，你不希望停下计算来等它。</p>
<hr>
<h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a>Linear</h3><p>torch里var.T == tf里tf.transpose(var)</p>
<p>torch可以.clone，复制内存，tf 不行我擦，tf的成员变量真少，都是tf.xxx</p>
<p><code>torch: x.sum(axis = 0)   tf: tf.reduce_sum(x,axis = 0) </code> ==当然，torch也有torch.sum()这些操作==</p>
<p><code>torch: x.numel()    tf:tf.shape(x).numpy()</code></p>
<p>都用xx.norm(var)</p>
<p>torch.mv ==tf.linalg.matvec(A, x)        torch.mm == tf.matmul   torch.dot == tf.tensordot</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>
Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'figure.figsize'</span><span class="token punctuation">]</span> <span class="token operator">=</span> figsize <span class="token comment">#可以设置相当多的属性</span>
axes<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#网格化</span>
axes <span class="token operator">=</span> axes <span class="token keyword">if</span> axes <span class="token keyword">else</span> d2l<span class="token punctuation">.</span>plt<span class="token punctuation">.</span>gca<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#get current axes</span>
plt<span class="token punctuation">.</span>cla<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法清除当前坐标轴，plt<span class="token punctuation">.</span>clf<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法清除当前图形，plt<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法关闭整个窗口。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>隐式计算图 vs 显式计算图：<a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html">https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html</a></p>
<p><code>u = y.detach    u = tf.stop_gradient(y)</code></p>
<p>torch同一个计算图好像不能连续算两遍。tensorflow用的是磁带<code>tf.GradientTape</code>记录梯度，梯度不累加而是覆盖。</p>
<p>tensorflow也有trainable = true，如果是False，冻结的层在训练期间不会更新（无论是使用 <code>fit()</code> 进行训练，还是使用依赖于 <code>trainable_weights</code> 来应用梯度更新的任何自定义循环进行训练时）</p>
<p>由于tensorflow的梯度得另外存储，如<code>dw, db = g.gradient(l, [w, b])</code>，所以得在训练中存好了，交给优化算法读取并更新。<br>而torch直接在优化算法中用grad就能得到。但是torch在优化算法中要注意设置不进行梯度运算，并清零这一batch的梯度。</p>
<p><strong>读取数据集</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#布尔值is_train表示是否希望数据迭代器对象在每个迭代周期内打乱数据</span>
<span class="token comment">#torch</span>
<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils <span class="token keyword">import</span> data
<span class="token keyword">def</span> <span class="token function">load_array</span><span class="token punctuation">(</span>data_arrays<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> is_train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""构造一个PyTorch数据迭代器"""</span>
    dataset <span class="token operator">=</span> data<span class="token punctuation">.</span>TensorDataset<span class="token punctuation">(</span><span class="token operator">*</span>data_arrays<span class="token punctuation">)</span> <span class="token comment">#这次的数据是tensor格式，数据集用TensorDataset构造</span>
    <span class="token keyword">return</span> data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span>is_train<span class="token punctuation">)</span> <span class="token comment">#这个应该是通用的，改dataset就好。其实是True</span>

batch_size <span class="token operator">=</span> <span class="token number">10</span>
data_iter <span class="token operator">=</span> load_array<span class="token punctuation">(</span><span class="token punctuation">(</span>features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span> <span class="token comment">#迭代器的最终形式是dataloader</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
<span class="token comment">#tensorflow</span>
<span class="token keyword">def</span> <span class="token function">load_array</span><span class="token punctuation">(</span>data_arrays<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> is_train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""构造一个TensorFlow数据迭代器"""</span>
    dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>data_arrays<span class="token punctuation">)</span>
    <span class="token keyword">if</span> is_train<span class="token punctuation">:</span>
        dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span> <span class="token comment">#tensorflow没有loader的设定，都在数据集自定的实现上操作</span>
    <span class="token keyword">return</span> dataset

batch_size <span class="token operator">=</span> <span class="token number">10</span>
data_iter <span class="token operator">=</span> load_array<span class="token punctuation">(</span><span class="token punctuation">(</span>features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token comment">#迭代器的最后形式就是dataset</span>

<span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>data_iter<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pytorch的网络是确定的，没有输入之前，就能直接访问各层的参数，并直接修改；tensorflow能指定每层的初始化方法，但只有在我们<strong>第一次尝试通过网络传递数据时才会进行真正的初始化</strong>。 请注意，因为参数还没有初始化，所以我们不能访问或操作它们。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">initializer <span class="token operator">=</span> tf<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>RandomNormal<span class="token punctuation">(</span>stddev<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>
net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>
net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_initializer<span class="token operator">=</span>initializer<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>loss = nn.MSELoss()</code> vs <code>loss = tf.keras.losses.MeanSquaredError()</code></p>
<p><code>trainer = torch.optim.SGD(net.parameters(), lr=0.03)</code> vs<br><code>trainer = tf.keras.optimizers.SGD(learning_rate=0.03)</code> </p>
<p>在每个epoch打印损失：向损失函数输入初始数据集和labels，而非训练用的shuffle过的数据。</p>
<p><strong>经典训练</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch <span class="token keyword">import</span> nn

net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span>
trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">)</span>
num_epochs <span class="token operator">=</span> <span class="token number">3</span>

<span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>
        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">,</span>y<span class="token punctuation">)</span>
        trainer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>
        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
        trainer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>l<span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>
net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
initializer <span class="token operator">=</span> tf<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>RandomNormal<span class="token punctuation">(</span>stddev<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>
net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_initializer<span class="token operator">=</span>initializer<span class="token punctuation">)</span><span class="token punctuation">)</span>
loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>losses<span class="token punctuation">.</span>MeanSquaredError<span class="token punctuation">(</span><span class="token punctuation">)</span>
trainer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>optimizers<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>learning_rate<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">)</span>
num_epochs <span class="token operator">=</span> <span class="token number">3</span>

<span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>
        <span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>
            l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> training<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
        grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>l<span class="token punctuation">,</span> net<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token comment">#参数传递也挺方便的</span>
        trainer<span class="token punctuation">.</span>apply_gradients<span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>grads<span class="token punctuation">,</span> net<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token punctuation">)</span>
    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>l<span class="token punctuation">:</span><span class="token format-spec">f</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">%</span>matplotlib inline
<span class="token keyword">from</span> IPython <span class="token keyword">import</span> display
display<span class="token punctuation">.</span>set_matplotlib_formats<span class="token punctuation">(</span><span class="token string">'svg'</span><span class="token punctuation">)</span> <span class="token comment">#用更高精度的svg图片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>torchvision</code>包 包含了目前流行的数据集，模型结构和常用的图片转换工具。</p>
<p><code>torchvision.datasets</code>中包含了MNIST等6个？数据集</p>
<p><code>torchvision.transform</code>里有许多处理图片的方法、工具。</p>
<p><code>torchvision.models</code>y偶很多预训练模块。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908940.png" alt="image-20220228125050333" style="zoom:60%;" align = 'left'/>

<p>得到的mnist_train可以直接用来做dataset那个参数，X的shape是（batch，channels，height，width）</p>
<p>num_workers参数用来指定用几个进程读数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908941.png" alt="image-20220228125438225"></p>
<p>测试读入简单的tensor，4进程没问题，果然还是和内存有关。</p>
<p>imshow函数接收的图片格式：<br>    X变量存储图像，可以是浮点型数组、unit8数组以及PIL图像，如果其为数组，则需满足一下形状：<br>    (1) MN      此时数组必须为浮点型，其中值为该坐标的灰度；<br>    (2) MN*3  RGB（浮点型或者unit8类型）<br>    (3) MN*4  RGBA（浮点型或者unit8类型）</p>
<p><strong>可视化样本</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_fashion_mnist_labels</span><span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""返回Fashion-MNIST数据集的文本标签"""</span>
    text_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'t-shirt'</span><span class="token punctuation">,</span> <span class="token string">'trouser'</span><span class="token punctuation">,</span> <span class="token string">'pullover'</span><span class="token punctuation">,</span> <span class="token string">'dress'</span><span class="token punctuation">,</span> <span class="token string">'coat'</span><span class="token punctuation">,</span>
                   <span class="token string">'sandal'</span><span class="token punctuation">,</span> <span class="token string">'shirt'</span><span class="token punctuation">,</span> <span class="token string">'sneaker'</span><span class="token punctuation">,</span> <span class="token string">'bag'</span><span class="token punctuation">,</span> <span class="token string">'ankle boot'</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>text_labels<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> labels<span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">show_images</span><span class="token punctuation">(</span>imgs<span class="token punctuation">,</span> num_rows<span class="token punctuation">,</span> num_cols<span class="token punctuation">,</span> titles<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""绘制图像列表"""</span>
    figsize <span class="token operator">=</span> <span class="token punctuation">(</span>num_cols <span class="token operator">*</span> scale<span class="token punctuation">,</span> num_rows <span class="token operator">*</span> scale<span class="token punctuation">)</span>
    _<span class="token punctuation">,</span> axes <span class="token operator">=</span> d2l<span class="token punctuation">.</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>num_rows<span class="token punctuation">,</span> num_cols<span class="token punctuation">,</span> figsize<span class="token operator">=</span>figsize<span class="token punctuation">)</span> <span class="token comment">#这个'_'就很离谱</span>
    axes <span class="token operator">=</span> axes<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>ax<span class="token punctuation">,</span> img<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>axes<span class="token punctuation">,</span> imgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#沐神常用操作了。</span>
        <span class="token keyword">if</span> torch<span class="token punctuation">.</span>is_tensor<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 图片张量</span>
            ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># PIL图片</span>
            ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
        ax<span class="token punctuation">.</span>axes<span class="token punctuation">.</span>get_xaxis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
        ax<span class="token punctuation">.</span>axes<span class="token punctuation">.</span>get_yaxis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> titles<span class="token punctuation">:</span>
            ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> axes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>读取数据集</strong></p>
<p>果然，不同的框架内置的数据集，组织方式也不一样啊。还有这俩框架的处理数据策略果然差挺远。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_data_fashion_mnist</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span>
    trans <span class="token operator">=</span> <span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> resize<span class="token punctuation">:</span>
        trans<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>resize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#先resize，再tosensor！！！！:star</span>
    trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span>trans<span class="token punctuation">)</span> <span class="token comment">#torch对数据集的处理主要用transform实现</span>
    mnist_train <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>
        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    mnist_test <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>
        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_train<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
                            num_workers<span class="token operator">=</span>get_dataloader_workers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_test<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                            num_workers<span class="token operator">=</span>get_dataloader_workers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
train_iter<span class="token punctuation">,</span> test_iter <span class="token operator">=</span> load_data_fashion_mnist<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> X<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch<span class="token punctuation">.</span>float32 torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch<span class="token punctuation">.</span>int64
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
<span class="token keyword">def</span> <span class="token function">load_data_fashion_mnist</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span>
    mnist_train<span class="token punctuation">,</span> mnist_test <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>fashion_mnist<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 将所有数字除以255，使所有像素值介于0和1之间，在最后添加一个批处理维度，</span>
    <span class="token comment"># 并将标签转换为int32。</span>
    process <span class="token operator">=</span> <span class="token keyword">lambda</span> X<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">(</span>tf<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">,</span>
                            tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>y<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'int32'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    resize_fn <span class="token operator">=</span> <span class="token keyword">lambda</span> X<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">(</span>
        tf<span class="token punctuation">.</span>image<span class="token punctuation">.</span>resize_with_pad<span class="token punctuation">(</span>X<span class="token punctuation">,</span> resize<span class="token punctuation">,</span> resize<span class="token punctuation">)</span> <span class="token keyword">if</span> resize <span class="token keyword">else</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">#函数里要同时处理所有吗</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>process<span class="token punctuation">(</span><span class="token operator">*</span>mnist_train<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>
            batch_size<span class="token punctuation">)</span><span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>mnist_train<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>resize_fn<span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span>process<span class="token punctuation">(</span><span class="token operator">*</span>mnist_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>
            batch_size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>resize_fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#标签不用shuffle</span>

train_iter<span class="token punctuation">,</span> test_iter <span class="token operator">=</span> load_data_fashion_mnist<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> X<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>dtype<span class="token punctuation">:</span> <span class="token string">'float32'</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>dtype<span class="token punctuation">:</span> <span class="token string">'int32'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pytorch  model.train() model.eval()【适用dev set和test】主要区别在BN和dropout</p>
<p><code>y_hat.type(y.dtype)</code>   vs   <code>tf.cast(y_hat, y.dtype)</code></p>
<p>交叉熵<code>nn.CrossEntropyLoss(reduction=&#39;none&#39;)</code> vs <code>tf.losses.sparse_categorical_crossentropy()</code></p>
<p>nn的损失函数有reduction参数共有三种选项’elementwise_mean’，’sum’和’none’。<br>‘elementwise_mean’为默认情况，表明对N个样本的loss进行求平均之后返回;<br>‘sum’指对n个样本的loss求和;<br>‘none’表示直接返回n分样本的loss，是一个<strong>向量</strong></p>
<blockquote>
<p>3.6里，有很牛的Animator和Accumulator，实现了很多nb代码。</p>
<p>还是直接去看吧<a href="https://zh-v2.d2l.ai/chapter_linear-networks/softmax-regression-scratch.html">https://zh-v2.d2l.ai/chapter_linear-networks/softmax-regression-scratch.html</a></p>
<p>求准确率：float（布尔代数）类的行为，👇实现列表每项更新，但是其实可以用向量化来处理。</p>
<p>不要把numpy的多维和dataframe的行列弄混了。。。</p>
<p><code>X_train = torch.cat([X_train, X_part], 0)</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>a <span class="token operator">+</span> <span class="token builtin">float</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>花哨索引：传入多个列表，每个列表代表相应维度的坐标，想想都方便欸。</p>
</blockquote>
<h3 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h3><p><code>torch.relu(x)/sigmoid/tan  vs  tf.nn.relu(x)/sigmoid/tan</code></p>
<p>torch的backward函数：如果参数retain_graph=true,就会每次运行时重新生成图。也就是说，每次 backward() 时，默认会把整个计算图free掉。一般情况下是每次迭代，只需一次 forward() 和一次 backward() , 前向运算forward() 和反向传播backward()是成对存在的，一般一次backward()也是够用的。</p>
<p>但是不排除，由于自定义loss等的复杂性，需要一次forward()，多个不同loss的backward()来累积同一个网络的grad来更新参数。</p>
<p>还有一个<code>grad_tensor</code>参数（第一个默认），一般和要求梯度的tensor大小一致，用来指定权重，暂时没用上。</p>
<p>Relu的简单实现：<code>lambda x:torch.max(x,torch.zeros_like(x))</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#关于维度，W是（input，output），计算时是matmul（X,W） input是X的特征维数，X的第0维是batch</span>
<span class="token comment">#这里有个处理，就是reshape来适配一下维度。即`torch.matmul(X.reshape((-1, W.shape[0])), W) + b`</span>
num_inputs<span class="token punctuation">,</span> num_outputs<span class="token punctuation">,</span> num_hiddens <span class="token operator">=</span> <span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">256</span>
W1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>
    num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span>
b1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
W2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>
    num_hiddens<span class="token punctuation">,</span> num_outputs<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span>
b2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_outputs<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
params <span class="token operator">=</span> <span class="token punctuation">[</span>W1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> W2<span class="token punctuation">,</span> b2<span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">net</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>
    X <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>
    H <span class="token operator">=</span> relu<span class="token punctuation">(</span>X@W1 <span class="token operator">+</span> b1<span class="token punctuation">)</span>  <span class="token comment"># 这里“@”代表矩阵乘法</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>H@W2 <span class="token operator">+</span> b2<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#tensorflow只用改输出，比torch赢一筹。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>当它们被分配为模块属性时，它们会自动添加到其参数列表中，并将出现在例如<code>parameters()</code>迭代器中。分配张量没有这样的效果。这是因为人们可能想要在模型中缓存一些临时状态，例如 RNN 的最后一个隐藏状态。</p>
<p>如果没有这样的类<a href="https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html#torch.nn.parameter.Parameter"><code>Parameter</code></a>，这些临时人员也会被注册。</p>
<p>torch.tensor([1,2,3],requires_grad=True)的区别，这个只是将参数变成可训练的，并没有绑定在module的parameter列表中。</p>
<p>用在自定义块里。nn自带的网络的w，b都是parameter</p>
</blockquote>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#权重衰减</span>
。。。。
    <span class="token comment"># 偏置参数没有衰减</span>
    trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">[</span>
        <span class="token punctuation">&#123;</span><span class="token string">"params"</span><span class="token punctuation">:</span>net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span><span class="token string">'weight_decay'</span><span class="token punctuation">:</span> wd<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">#这是给第一层weight指定</span>
        <span class="token punctuation">&#123;</span><span class="token string">"params"</span><span class="token punctuation">:</span>net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>bias<span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>lr<span class="token punctuation">)</span>
    trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr <span class="token operator">=</span> lr<span class="token punctuation">,</span>weight_decay <span class="token operator">=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment">#多层</span>
。。。。
    
<span class="token keyword">def</span> <span class="token function">train_concise</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">:</span>
。。。。
    net<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>
        <span class="token number">1</span><span class="token punctuation">,</span> kernel_regularizer<span class="token operator">=</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>regularizers<span class="token punctuation">.</span>l2<span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#L2正则化放在这</span>
    net<span class="token punctuation">.</span>build<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#这算是指定输入参数吗。</span>
。。。。
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
<span class="token comment">#dropout</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment"># 在第一个全连接层之后添加一个dropout层</span>
        nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout1<span class="token punctuation">)</span><span class="token punctuation">,</span>

<span class="token keyword">def</span> <span class="token function">init_weights</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">==</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">:</span>
        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>
net<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>init_weights<span class="token punctuation">)</span><span class="token punctuation">;</span>

net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment"># 在第一个全连接层之后添加一个dropout层</span>
    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout1<span class="token punctuation">)</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>torch.clamp()</code> vs <code>tf.clip_by_value()</code></p>
<p><a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/kaggle-house-price.html">Kaggle示例</a> 里好多可学的例子</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">numeric_features <span class="token operator">=</span> all_features<span class="token punctuation">.</span>dtypes<span class="token punctuation">[</span>all_features<span class="token punctuation">.</span>dtypes <span class="token operator">!=</span> <span class="token string">'object'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index
all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>
    <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> x<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span> <span class="token operator">=</span> all_features<span class="token punctuation">[</span>numeric_features<span class="token punctuation">]</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">#DataFrame.dtypes 是 每一列的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tf里还有个``tf.Constant<code> tf好像把会降维的加了个</code>reduce_`前缀，便于区分，其实还是挺不错的。</p>
<p>使用tf.constant函数创建的随机权重参数在训练期间不会更新（即为常量参数）</p>
<h3 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h3><p>tensorflow如果不命名层/块的名字，那命名是按深度遍历的。</p>
<p><a href="https://zh-v2.d2l.ai/chapter_deep-learning-computation/model-construction.html">自定义块</a>其实就是自定义很多layer，然后调用__call__，在forward/call函数编写传播过程</p>
<p>还是看看原文吧，比如<code>net.add_models(&#39;name&#39;,block)</code>这些东西</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 我们需要给共享层一个名称，以便可以引用它的参数</span>
<span class="token comment"># tf.keras的表现有点不同。它会自动删除重复层。</span>
shared <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    shared<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    shared<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
net<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token comment">#确保相同</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>net<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> net<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>net<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> param<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#列出不重复的的</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> param<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#列出所有的（这是个OrdictedDict）</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Sequential<span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'0.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'0.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'2.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'4.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'4.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.weight'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'6.bias'</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#share的层中，named_parameters不会count repeated的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与Variable不同，parameter默认require_grad=True，当我们创建一个model时，<u>parameter会自动累加到Parameter 列表</u>中。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">torch里用net<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>，以Ordicted<span class="token operator">-</span><span class="token builtin">dict</span>组织  参数叫weight 和 bias
因为是字典，可以用   net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'2.bias'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data来组织
也可以net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>，与<span class="token builtin">dict</span><span class="token punctuation">.</span>item结构类似。
<span class="token keyword">print</span>（net）可以展示所有递归的结构
PyTorch的nn<span class="token punctuation">.</span>init模块提供了多种预置初始化方法。用net<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>initializer<span class="token punctuation">)</span>
<span class="token comment">#内置初始化</span>
<span class="token keyword">def</span> <span class="token function">xavier</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">==</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">:</span>
        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">)</span>
        <span class="token comment">#nn.init.normal_(m.weight, mean=0, std=0.01)</span>
        <span class="token comment">#nn.init.zeros_(m.bias)</span>
        <span class="token comment">#nn.init.constant_(m.weight, 42)</span>
        <span class="token comment">#加上一些别的就是自定义了。比如m.weight.data *= m.weight.data.abs() >= 5</span>
net<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>xavier<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
tf里用<span class="token punctuation">.</span>layers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span>索引，参数叫kernel和bias  列表组织
参数类型不是tensor，用 tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span><span class="token punctuation">)</span>可以转换成tensor
也可以net<span class="token punctuation">.</span>get_weights<span class="token punctuation">(</span><span class="token punctuation">)</span> 得到参数列表，但没有名字
net<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>只会展示最上层的，不会显示内部结构。
TensorFlow在根模块和keras<span class="token punctuation">.</span>initializers模块中提供了各种初始化方法。通过各层的kernel_initializer和bias_initializer指定
<span class="token comment">#自定义初始化</span>
<span class="token keyword">class</span> <span class="token class-name">MyInit</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>Initializer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        data<span class="token operator">=</span>tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>dtype<span class="token punctuation">)</span>
        factor<span class="token operator">=</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span>
        factor<span class="token operator">=</span>tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>factor<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token comment">#tensorflow不同数据类型不能直接做计算</span>
        <span class="token keyword">return</span> data <span class="token operator">*</span> factor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#自定义层，那就要定义参数，实现前向传播</span>
<span class="token comment">#该层需要输入参数：in_units和units，分别表示输入数和输出数。</span>
<span class="token keyword">class</span> <span class="token class-name">MyLinear</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_units<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>in_units<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>units<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>
        linear <span class="token operator">=</span> torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data
        <span class="token keyword">return</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>linear<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
<span class="token comment">#tensorflow仅仅接收输出参数</span>
<span class="token keyword">class</span> <span class="token class-name">MyDense</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> units<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>units <span class="token operator">=</span> units

    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X_shape<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#需要单独用build函数设定参数</span>
        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> self<span class="token punctuation">.</span>add_weight<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'weight'</span><span class="token punctuation">,</span>
            shape<span class="token operator">=</span><span class="token punctuation">[</span>X_shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>units<span class="token punctuation">]</span><span class="token punctuation">,</span>
            initializer<span class="token operator">=</span>tf<span class="token punctuation">.</span>random_normal_initializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> self<span class="token punctuation">.</span>add_weight<span class="token punctuation">(</span>
            name<span class="token operator">=</span><span class="token string">'bias'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>units<span class="token punctuation">]</span><span class="token punctuation">,</span>
            initializer<span class="token operator">=</span>tf<span class="token punctuation">.</span>zeros_initializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>
        linear <span class="token operator">=</span> tf<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias
        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>linear<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于一般数据结构：torch自带load和save，tf得用np的，还要指定.npy后缀。但是模型存储都类似：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'mlp.params'</span><span class="token punctuation">)</span>
clone <span class="token operator">=</span> MLP<span class="token punctuation">(</span><span class="token punctuation">)</span>
clone<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#这个两步，先load再加载。也有写model.pt的</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
net<span class="token punctuation">.</span>save_weights<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span>
clone <span class="token operator">=</span> MLP<span class="token punctuation">(</span><span class="token punctuation">)</span>
clone<span class="token punctuation">.</span>load_weights<span class="token punctuation">(</span><span class="token string">'mlp.params'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tensorflow什么都用层次封装，太麻烦了</p>
<h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">x<span class="token punctuation">.</span>device 查看在哪个设备上，通用

<span class="token keyword">def</span> <span class="token function">try_gpu</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""如果存在，则返回gpu(i)，否则返回cpu()"""</span>
    <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'cuda:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">try_all_gpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""返回所有可用的GPU，如果没有GPU，则返回[cpu(),]"""</span>
    devices <span class="token operator">=</span> <span class="token punctuation">[</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'cuda:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
             <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> devices <span class="token keyword">if</span> devices <span class="token keyword">else</span> <span class="token punctuation">[</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

X <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>device <span class="token operator">=</span> try_gpu<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Y <span class="token operator">=</span> X<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#copy副本到第三个GPU上，如果调用1，则不会复制新内存，返回本身。</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">#为神经网络指定设备</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
net <span class="token operator">=</span> net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#单GPU</span>

<span class="token comment">#多GPU</span>
<span class="token comment">#train_batch的那个函数，计算损失的时候是串行的代码结构，此处依赖框架本身看能否在背后之行为并行操作。</span>
<span class="token comment">#GPU不变快有很多的原因，可能是data读起来就贼慢（可以用for loop遍历一遍数据看看时间）</span>
<span class="token comment">#还有可能没有打满GPU，通常做法是batch size到n倍（n个GPU），但是这样精度会变低，可以调大一点learning rate</span>

<span class="token comment"># 在多个GPU上设置模型</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>DataParallel<span class="token punctuation">(</span>net<span class="token punctuation">,</span> device_ids<span class="token operator">=</span>devices<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#网络放到0号上</span>
<span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>
    trainer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>
    X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
    l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
    trainer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#pytorch中，网络被Dataparallel“包装”后，在前向过程会把输入tensor自动分配到每个显卡上。</span>
<span class="token comment">#而Dataparallel使用的是master-slave的数据并行模式，主卡默认为0号GPU，所以在进网络之前，只要移到GPU[0]就可以了。</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
<span class="token keyword">def</span> <span class="token function">try_gpu</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""如果存在，则返回gpu(i)，否则返回cpu()"""</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>config<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>list_physical_devices<span class="token punctuation">(</span><span class="token string">'GPU'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'/GPU:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'/CPU:0'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">try_all_gpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""返回所有可用的GPU，如果没有GPU，则返回[cpu(),]"""</span>
    num_gpus <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>config<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>list_physical_devices<span class="token punctuation">(</span><span class="token string">'GPU'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    devices <span class="token operator">=</span> <span class="token punctuation">[</span>tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'/GPU:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_gpus<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> devices <span class="token keyword">if</span> devices <span class="token keyword">else</span> <span class="token punctuation">[</span>tf<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">'/CPU:0'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword">with</span> try_gpu<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    X <span class="token operator">=</span> tf<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    Y <span class="token operator">=</span> X <span class="token comment">#相当于设置一个环境来操作，此处把X copy到0号GPU</span>
    
<span class="token comment">#为神经网络指定设备</span>
strategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>MirroredStrategy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#多GPU</span>
device_name <span class="token operator">=</span> device<span class="token punctuation">.</span>_device_name<span class="token comment">#单GPU</span>
strategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>OneDeviceStrategy<span class="token punctuation">(</span>device_name<span class="token punctuation">)</span>
<span class="token keyword">with</span> strategy<span class="token punctuation">.</span>scope<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    net <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Conv"><a href="#Conv" class="headerlink" title="Conv"></a>Conv</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span>
conv2d <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
    nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>AvgPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>AvgPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
28x28输进去在flatten会变成<span class="token number">16</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span>，这个输入要计算就非常离谱。

<span class="token comment">#技巧——用单位输入确定输出</span>
X <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> layer <span class="token keyword">in</span> net<span class="token punctuation">:</span>
    X<span class="token operator">=</span>layer<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>layer<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span><span class="token string">'output shape:\t'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
    
X <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> layer <span class="token keyword">in</span> net<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>layers<span class="token punctuation">:</span>
    X <span class="token operator">=</span> layer<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>layer<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> <span class="token string">'output shape:\t'</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>


<span class="token comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span>
conv2d <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> use_bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">net</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">,</span>
                               padding<span class="token operator">=</span><span class="token string">'same'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>AvgPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>
                               activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>AvgPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#tensorflow就很舒服</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>$(\frac{n+2p-f}{s}+1)\times (\frac{n+2p-f}{s}+1)$ 不是整数就向下取整</p>
<p>pytorch训练结构和animator使用</p>
<p>不过tensorflow的训练是用自定义的<u>回调函数</u>配合<code>net.fit()</code>指定在每个epoch开始和结束时发生的事。</p>
<p>两个train结构，十分有==参考价值==：<a href="https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/lenet.html">https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/lenet.html</a></p>
<p>tensorflow<a href="https://blog.csdn.net/jpc20144055069/article/details/105383836">一般流程</a>，定义-&gt;net.build-&gt;net.compile-&gt;net.fit-&gt;net.evaluate</p>
<blockquote>
<p>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</p>
</blockquote>
<h4 id="Modern"><a href="#Modern" class="headerlink" title="Modern"></a>Modern</h4><p><strong>VGG</strong>块中，每个卷积层（数量是超参数）的输出都是一样的，而且(n-3+2)/1+1 = n，所以不改变大小，只在池化层减半然后通道翻倍。组织结构值得借鉴：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">vgg_block</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span>
                                kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        in_channels <span class="token operator">=</span> out_channels
    layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>layers<span class="token punctuation">)</span>

<span class="token comment">#tensorflow不需要in_channels,padding可以使用预设的same</span>
<span class="token keyword">def</span> <span class="token function">vgg_block</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> num_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    blk <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_convs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        blk<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
                                    padding<span class="token operator">=</span><span class="token string">'same'</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    blk<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>MaxPool2D<span class="token punctuation">(</span>pool_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> blk
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
conv_arch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#五个块</span>
<span class="token keyword">def</span> <span class="token function">vgg</span><span class="token punctuation">(</span>conv_arch<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conv_blks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    in_channels <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment"># 卷积层部分</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span> <span class="token keyword">in</span> conv_arch<span class="token punctuation">:</span>
        conv_blks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>vgg_block<span class="token punctuation">(</span>num_convs<span class="token punctuation">,</span> in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">)</span><span class="token punctuation">)</span>
        in_channels <span class="token operator">=</span> out_channels<span class="token comment">#这一步:star</span>

    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
        <span class="token operator">*</span>conv_blks<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment"># 全连接层部分</span>
        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>out_channels <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

net <span class="token operator">=</span> vgg<span class="token punctuation">(</span>conv_arch<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>NiN</strong>——设计上借鉴了Alex_Net</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nin_block</span><span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> strides<span class="token punctuation">,</span> padding<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> strides<span class="token punctuation">,</span> padding<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#这个有默认顺序的。</span>
        nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
    nin_block<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nin_block<span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nin_block<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#这有个Dropout</span>
    <span class="token comment"># 标签类别数是10</span>
    nin_block<span class="token punctuation">(</span><span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#输出通道数10为类别数。</span>
    nn<span class="token punctuation">.</span>AdaptiveAvgPool2d<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#（1，1）是高宽消到1</span>
    <span class="token comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span>
    nn<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#Output：</span>
Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
MaxPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Dropout output shape<span class="token punctuation">:</span>        torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Sequential output shape<span class="token punctuation">:</span>     torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
AdaptiveAvgPool2d output shape<span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Flatten output shape<span class="token punctuation">:</span>        torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>GoogLeNet 抄参数：<a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html">https://zh-v2.d2l.ai/chapter_convolutional-modern/googlenet.html</a></p>
<p>批量规范化层在”训练模式“（通过小批量统计数据规范化）和“预测模式”（通过数据集统计规范化）中的功能不同。 在训练过程中，我们无法得知使用整个数据集来估计平均值和方差，所以只能根据每个小批次的平均值和方差不断训练模型。 而在预测模式下，可以根据整个数据集精确计算批量规范化所需的平均值和方差。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">batch_norm</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> moving_mean<span class="token punctuation">,</span> moving_var<span class="token punctuation">,</span> eps<span class="token punctuation">,</span> momentum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 通过is_grad_enabled来判断当前模式是训练模式还是预测模式</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>is_grad_enabled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差</span>
        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> moving_mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>moving_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。</span>
            <span class="token comment"># 这里我们需要保持X的形状以便后面可以做广播运算</span>
            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        <span class="token comment"># 训练模式下，用当前的均值和方差做标准化</span>
        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span>
        <span class="token comment"># 更新移动平均的均值和方差</span>
        moving_mean <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_mean <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> mean
        moving_var <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_var <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> var
    Y <span class="token operator">=</span> gamma <span class="token operator">*</span> X_hat <span class="token operator">+</span> beta  <span class="token comment"># 缩放和移位</span>
    <span class="token keyword">return</span> Y<span class="token punctuation">,</span> moving_mean<span class="token punctuation">.</span>data<span class="token punctuation">,</span> moving_var<span class="token punctuation">.</span>data

<span class="token keyword">class</span> <span class="token class-name">BatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># num_features：完全连接层的输出数量或卷积层的输出通道数。</span>
    <span class="token comment"># num_dims：2表示完全连接层，4表示卷积层</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> num_dims<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> num_dims <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span>
        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>beta <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment"># 非模型参数的变量初始化为0和1</span>
        self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果X不在内存上，将moving_mean和moving_var,因为不是parameters，得手动弄。</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>device <span class="token operator">!=</span> X<span class="token punctuation">.</span>device<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_var<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>
        <span class="token comment"># 保存更新过的moving_mean和moving_var</span>
        Y<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> batch_norm<span class="token punctuation">(</span>
            X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>gamma<span class="token punctuation">,</span> self<span class="token punctuation">.</span>beta<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span>
            self<span class="token punctuation">.</span>moving_var<span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>          <span class="token comment">#得注意eps的值，可能会造成影响，不同框架也不一样。</span>
        <span class="token keyword">return</span> Y
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>BatchNorm1d<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>BatchNormalization<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Activation<span class="token punctuation">(</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Residual</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>
                 use_1x1conv<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>
                               kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>
                               kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> use_1x1conv<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>
                                   kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>bn1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bn2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>
        Y <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>bn1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        Y <span class="token operator">=</span> self<span class="token punctuation">.</span>bn2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">:</span>
            X <span class="token operator">=</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
        Y <span class="token operator">+=</span> X
        <span class="token keyword">return</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>Y<span class="token punctuation">)</span>
    
<span class="token comment">#结构    </span>
b1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">resnet_block</span><span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> num_residuals<span class="token punctuation">,</span>
                 first_block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    blk <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_residuals<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token keyword">not</span> first_block<span class="token punctuation">:</span>
            blk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Residual<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span>
                                use_1x1conv<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            blk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Residual<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> blk
b2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> first_block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#b1减半了两次，这里就不减半</span>
b3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b4 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b5 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span>resnet_block<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><p><strong>目标检测</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#Augmentation</span>
d2l<span class="token punctuation">.</span>set_figsize<span class="token punctuation">(</span><span class="token punctuation">)</span>
img <span class="token operator">=</span> pil<span class="token punctuation">.</span>Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'../img/cat1.jpg'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>
transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment">#水平翻转</span>
transforms<span class="token punctuation">.</span>RandomVerticalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#垂直</span>
transforms<span class="token punctuation">.</span>RandomRotation<span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>
transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ratio<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#最终大小，像素范围，宽高比</span>
transforms<span class="token punctuation">.</span>ColorJitter<span class="token punctuation">(</span>brightness<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> contrast<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> saturation<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment">#亮度、对比度、饱和度、色调</span>
transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#随机裁剪</span>
transforms<span class="token punctuation">.</span>CenterCrop<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#中心裁剪</span>
transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#更多的https://blog.csdn.net/comway_Li/article/details/96138551</span>

train_augs <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>
     transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

test_augs <span class="token operator">=</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>
     transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
dataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span>is_train<span class="token punctuation">,</span>transform<span class="token operator">=</span>augs<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
dataloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span>
                    shuffle<span class="token operator">=</span>is_train<span class="token punctuation">,</span> num_workers<span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>

<span class="token comment">#模仿👇就能在线生成多张啦</span>
<span class="token keyword">def</span> <span class="token function">apply</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> aug<span class="token punctuation">,</span> num_rows<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> num_cols<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> scale<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    Y <span class="token operator">=</span> <span class="token punctuation">[</span>aug<span class="token punctuation">(</span>img<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_rows <span class="token operator">*</span> num_cols<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Fine tuning</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用RGB通道的均值和标准差，以标准化每个通道</span>
normalize <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token number">0.485</span><span class="token punctuation">,</span> <span class="token number">0.456</span><span class="token punctuation">,</span> <span class="token number">0.406</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0.229</span><span class="token punctuation">,</span> <span class="token number">0.224</span><span class="token punctuation">,</span> <span class="token number">0.225</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#如果选择的模型里有BatchNormalization，就不用这个</span>

train_augs <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">#随机裁剪成224，</span>
<span class="token comment">#👆默认值scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333)</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    normalize<span class="token punctuation">]</span><span class="token punctuation">)</span>

test_augs <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#测试时大小标准化。</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>CenterCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    normalize<span class="token punctuation">]</span><span class="token punctuation">)</span>
finetune_net <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>resnet18<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
finetune_net<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>finetune_net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>in_features<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#还能直接拿到输入输出shape,直接print改结构</span>
nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>finetune_net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">#注意最后的fc层在optim中设置10倍的学习率。</span>
<span class="token keyword">def</span> <span class="token function">train_fine_tuning</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> num_epochs<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>
                      param_group<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    train_iter <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>
        os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>train_augs<span class="token punctuation">)</span><span class="token punctuation">,</span>
        batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    test_iter <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>
        os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>test_augs<span class="token punctuation">)</span><span class="token punctuation">,</span>
        batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span>
    devices <span class="token operator">=</span> d2l<span class="token punctuation">.</span>try_all_gpus<span class="token punctuation">(</span><span class="token punctuation">)</span>
    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span>reduction<span class="token operator">=</span><span class="token string">"none"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> param_group<span class="token punctuation">:</span> <span class="token comment">#单独改learning_rate</span>
        params_1x <span class="token operator">=</span> <span class="token punctuation">[</span>param <span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>
             <span class="token keyword">if</span> name <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"fc.weight"</span><span class="token punctuation">,</span> <span class="token string">"fc.bias"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'params'</span><span class="token punctuation">:</span> params_1x<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                                   <span class="token punctuation">&#123;</span><span class="token string">'params'</span><span class="token punctuation">:</span> net<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    <span class="token string">'lr'</span><span class="token punctuation">:</span> learning_rate <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                                lr<span class="token operator">=</span>learning_rate<span class="token punctuation">,</span> weight_decay<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">,</span>
                                  weight_decay<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>
    d2l<span class="token punctuation">.</span>train_ch13<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> test_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> trainer<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span>
                   devices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>这一块基本都是用C++、cuda实现，不然效率太低，而且会有大量的tricks，小细节太多</strong></p>
<p>所以尽量用别人<u>已经成熟</u>的包。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入参数boxes可以是长度为4的张量，也可以是形状为（，4）的二维张量，其中是边界框的数量。</span>
set_index方法，可以使用现有列设置单索引和复合索引 https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>cnblogs<span class="token punctuation">.</span>com<span class="token operator">/</span>cgmcoding<span class="token operator">/</span>p<span class="token operator">/</span><span class="token number">13691142.</span>html
reset_index，重置DataFrame的索引，并使用默认索引。如果DataFrame具有MultiIndex，则此方法可以删除一个或多个级别
遍历 https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>delftstack<span class="token punctuation">.</span>com<span class="token operator">/</span>zh<span class="token operator">/</span>howto<span class="token operator">/</span>python<span class="token operator">-</span>pandas<span class="token operator">/</span>how<span class="token operator">-</span>to<span class="token operator">-</span>iterate<span class="token operator">-</span>through<span class="token operator">-</span>rows<span class="token operator">-</span>of<span class="token operator">-</span>a<span class="token operator">-</span>dataframe<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>pandas<span class="token operator">/</span>
tensor<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token comment">#插入维度</span>

<span class="token comment">#一次next返回一个batch[0]==图像，batch[1]==labels</span>
labels的shape<span class="token operator">==</span><span class="token punctuation">[</span>batch_size<span class="token punctuation">,</span>num_box<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token comment">#5是[种类,左上x,y,右下x,y]/也有可能是左上+高宽</span>
imgs <span class="token operator">=</span> <span class="token punctuation">(</span>batch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#把通道维挪到最后，牛啊</span>

<span class="token comment">#返回的锚框变量Y的形状是（批量大小，锚框的数量，4) 很丧心病狂，但是大家都用这个方法。（我没看懂它的生成）</span>
torch<span class="token operator">/</span>np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span><span class="token punctuation">)</span>函数常用于生成二维网格，比如图像的坐标点。
torch<span class="token punctuation">.</span>stack是在新维度堆叠
torch<span class="token punctuation">.</span>repeat是复制后拼接，torch<span class="token punctuation">.</span>repeat_interleave是直接复制 https<span class="token punctuation">:</span><span class="token operator">//</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>weixin_42516475<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">117199456</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>把我看傻了：<a href="https://zh-v2.d2l.ai/chapter_computer-vision/anchor.html">https://zh-v2.d2l.ai/chapter_computer-vision/anchor.html</a> 太难理解了这数据。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061908942.png" alt="image-20220320165125841" style="zoom: 50%;" />

<p><strong>SSD</strong></p>
<p>设目标类别的数量为q。这样一来，锚框有q+1个类别，其中0类是背景。 </p>
<p>特征图的高和宽是h和w，每个单元生成a个锚框，共需对hwa个锚框进行分类。</p>
<p>使用全连接层作为输出，很容易导致模型参数过多。 回忆 <a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/nin.html#sec-nin">7.3节</a>一节介绍的使用卷积层的通道来输出类别预测的方法， 单发多框检测采用同样的方法来降低模型复杂度。输出通道数为$a(q+1)$，其中索引为$i(q+1)+j（0≤j≤q）$的通道代表了索引为$i$的锚框有关类别索引为$j$的预测</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#类别预测层</span>
<span class="token keyword">def</span> <span class="token function">cls_predictor</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors<span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors <span class="token operator">*</span> <span class="token punctuation">(</span>num_classes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                     kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">#边界框预测层</span>
<span class="token keyword">def</span> <span class="token function">bbox_predictor</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_anchors <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>把通道、高和宽全部合并，就可以不用为每个分辨率单独配置loss啥的，计算十分方便高效。</p>
<p>损失函数用L1，因为可能偏差特别大</p>
<hr>
<p><strong>语义分割</strong></p>
<p>要实现RGB和VOC的相互map其实用python实现是比较慢的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#@save</span>
<span class="token keyword">def</span> <span class="token function">voc_rand_crop</span><span class="token punctuation">(</span>feature<span class="token punctuation">,</span> label<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""随机裁剪特征和标签图像"""</span>一定得同步
    rect <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">.</span>get_params<span class="token punctuation">(</span>
        feature<span class="token punctuation">,</span> <span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#返回bounding box</span>
    feature <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>crop<span class="token punctuation">(</span>feature<span class="token punctuation">,</span> <span class="token operator">*</span>rect<span class="token punctuation">)</span><span class="token comment">#按照框去crop</span>
    label <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>crop<span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token operator">*</span>rect<span class="token punctuation">)</span><span class="token comment">#同样的操作得对label执行</span>
    <span class="token keyword">return</span> feature<span class="token punctuation">,</span> label

imgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    imgs <span class="token operator">+=</span> voc_rand_crop<span class="token punctuation">(</span>train_features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> train_labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>

imgs <span class="token operator">=</span> <span class="token punctuation">[</span>img<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> img <span class="token keyword">in</span> imgs<span class="token punctuation">]</span><span class="token comment">#一般画的时候得把channel放到最后。</span>
d2l<span class="token punctuation">.</span>show_images<span class="token punctuation">(</span>imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> imgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
VOCS数据集的图片大小很多不一致的。
<span class="token comment">#resize是个问题，很多像素是由插值得到的，但是label不能插值</span>
<span class="token comment">#所以图片分割都用crop size，然后移除掉尺寸小于随机裁剪所指定的输出尺寸的图像</span>
<span class="token comment"># 打印第一个小批量的形状会发现：与图像分类或目标检测不同，这里的标签是一个三维数组。</span>
feature<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
label<span class="token punctuation">:</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">]</span><span class="token punctuation">)</span>，loss的时候要连续两次<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>











<h3 id="Recurrent"><a href="#Recurrent" class="headerlink" title="Recurrent"></a>Recurrent</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">read_time_machine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""将时间机器数据集加载到文本行的列表中"""</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>d2l<span class="token punctuation">.</span>download<span class="token punctuation">(</span><span class="token string">'time_machine'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        lines <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'[^A-Za-z]+'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>
lines <span class="token operator">=</span> read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">#token词元是文本的基本单位 如果字符串是token，还得学词是怎么构成的</span>
<span class="token keyword">def</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> token<span class="token operator">=</span><span class="token string">'word'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""将文本行拆分为单词或字符词元"""</span>
    <span class="token keyword">if</span> token <span class="token operator">==</span> <span class="token string">'word'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>
    <span class="token keyword">elif</span> token <span class="token operator">==</span> <span class="token string">'char'</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">list</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'错误：未知词元类型：'</span> <span class="token operator">+</span> token<span class="token punctuation">)</span>
        
        
<span class="token comment">#将训练集中的所有文档合并在一起，对它们的唯一词元进行统计， 得到的统计结果称之为语料（corpus）。 然后根据每个唯一词元的出现频率，为其分配一个数字索引。</span>
<span class="token keyword">class</span> <span class="token class-name">Vocab</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""文本词表"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> min_freq<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> reserved_tokens<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> tokens <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> reserved_tokens <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            reserved_tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment"># 按出现频率排序</span>
        counter <span class="token operator">=</span> count_corpus<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token comment">#预处理一下，能输入多种结构</span>
        self<span class="token punctuation">.</span>_token_freqs <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                                   reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        <span class="token comment"># 未知词元的索引为0</span>
        self<span class="token punctuation">.</span>idx_to_token <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'&lt;unk>'</span><span class="token punctuation">]</span> <span class="token operator">+</span> reserved_tokens
        self<span class="token punctuation">.</span>token_to_idx <span class="token operator">=</span> <span class="token punctuation">&#123;</span>token<span class="token punctuation">:</span> idx
                             <span class="token keyword">for</span> idx<span class="token punctuation">,</span> token <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">#字典解析！！！？？？</span>
        <span class="token comment">#把读到的加进去，太cool了这代码。</span>
        <span class="token keyword">for</span> token<span class="token punctuation">,</span> freq <span class="token keyword">in</span> self<span class="token punctuation">.</span>_token_freqs<span class="token punctuation">:</span>
            <span class="token keyword">if</span> freq <span class="token operator">&lt;</span> min_freq<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token keyword">if</span> token <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">.</span>append<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">[</span>token<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tokens<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#定义后能用索引来变换</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>tokens<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#单个token</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>token_to_idx<span class="token punctuation">.</span>get<span class="token punctuation">(</span>tokens<span class="token punctuation">,</span> self<span class="token punctuation">.</span>unk<span class="token punctuation">)</span><span class="token comment">#如果没找到就返回未知——‘0’</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">to_tokens</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>indices<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">[</span>indices<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">for</span> index <span class="token keyword">in</span> indices<span class="token punctuation">]</span>

    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">unk</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 未知词元的索引为0</span>
        <span class="token keyword">return</span> <span class="token number">0</span>

    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">token_freqs</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_token_freqs

<span class="token keyword">def</span> <span class="token function">count_corpus</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""统计词元的频率"""</span>
    <span class="token comment"># 这里的tokens是1D列表或2D列表，如果是元组就不展平，比如zip弄出的二元组列表</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 将词元列表展平成一个列表</span>
        tokens <span class="token operator">=</span> <span class="token punctuation">[</span>token <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span><span class="token comment">#神马神奇操作！！！</span>
    <span class="token keyword">return</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span>

<span class="token comment">#整合</span>
<span class="token keyword">def</span> <span class="token function">load_corpus_time_machine</span><span class="token punctuation">(</span>max_tokens<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""返回时光机器数据集的词元索引列表和词表"""</span>
    lines <span class="token operator">=</span> read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span>
    tokens <span class="token operator">=</span> tokenize<span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">)</span>
    vocab <span class="token operator">=</span> Vocab<span class="token punctuation">(</span>tokens<span class="token punctuation">)</span>
    <span class="token comment"># 因为时光机器数据集中的每个文本行不一定是一个句子或一个段落，</span>
    <span class="token comment"># 所以将所有文本行展平到一个列表中</span>
    corpus <span class="token operator">=</span> <span class="token punctuation">[</span>vocab<span class="token punctuation">[</span>token<span class="token punctuation">]</span> <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span>
    <span class="token keyword">if</span> max_tokens <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        corpus <span class="token operator">=</span> corpus<span class="token punctuation">[</span><span class="token punctuation">:</span>max_tokens<span class="token punctuation">]</span>
    <span class="token keyword">return</span> corpus<span class="token punctuation">,</span> vocab

corpus<span class="token punctuation">,</span> vocab <span class="token operator">=</span> load_corpus_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#n元语法实现</span>
tokens <span class="token operator">=</span> d2l<span class="token punctuation">.</span>tokenize<span class="token punctuation">(</span>d2l<span class="token punctuation">.</span>read_time_machine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 因为每个文本行不一定是一个句子或一个段落，因此我们把所有文本行拼接到一起</span>
corpus <span class="token operator">=</span> <span class="token punctuation">[</span>token <span class="token keyword">for</span> line <span class="token keyword">in</span> tokens <span class="token keyword">for</span> token <span class="token keyword">in</span> line<span class="token punctuation">]</span><span class="token comment">#语料库，为了简便处理成单列表</span>
vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>corpus<span class="token punctuation">)</span>

bigram_tokens <span class="token operator">=</span> <span class="token punctuation">[</span>pair <span class="token keyword">for</span> pair <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>corpus<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
bigram_vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>bigram_tokens<span class="token punctuation">)</span>
bigram_vocab<span class="token punctuation">.</span>token_freqs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>

trigram_tokens <span class="token operator">=</span> <span class="token punctuation">[</span>triple <span class="token keyword">for</span> triple <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>corpus<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> corpus<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
trigram_vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Vocab<span class="token punctuation">(</span>trigram_tokens<span class="token punctuation">)</span>
trigram_vocab<span class="token punctuation">.</span>token_freqs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>


<span class="token comment">#读取长序列数据，不能总像之前一样读取整个进来，当序列变得太长而不能被模型一次性全部处理时， 我们可能希望拆分这样的序列方便模型读取。而且之前那种方式，数据冗余很大，一个数据点可能被用到了好几次。</span>
<span class="token comment">#我们可以从随机偏移量开始划分序列， 以同时获得覆盖性（coverage）和随机性（randomness）。 下面，我们将描述如何实现随机采样（random sampling）和 顺序分区（sequential partitioning）策略。</span>

<span class="token comment">#参数batch_size指定了每个小批量中子序列样本的数目， 参数num_steps是每个子序列中预定义的时间步数。</span>
<span class="token keyword">def</span> <span class="token function">seq_data_iter_random</span><span class="token punctuation">(</span>corpus<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""使用随机抽样生成一个小批量子序列"""</span>
    <span class="token comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span>
    corpus <span class="token operator">=</span> corpus<span class="token punctuation">[</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    <span class="token comment"># 算出子序列的个数（去尾），减去1，是因为我们需要考虑标签（比子序列偏移一个序列）</span>
    num_subseqs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> num_steps
    <span class="token comment"># 长度为num_steps的子序列的起始索引</span>
    initial_indices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_subseqs <span class="token operator">*</span> num_steps<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 在随机抽样的迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span>
    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>initial_indices<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">data</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 返回从pos位置开始的长度为num_steps的序列</span>
        <span class="token keyword">return</span> corpus<span class="token punctuation">[</span>pos<span class="token punctuation">:</span> pos <span class="token operator">+</span> num_steps<span class="token punctuation">]</span>
	<span class="token comment">#每个batch可以读进多少个子序列。没处理好，最后丢掉了几个子序列。。</span>
    num_batches <span class="token operator">=</span> num_subseqs <span class="token operator">//</span> batch_size 
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> batch_size <span class="token operator">*</span> num_batches<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 在这里，initial_indices包含子序列的随机起始索引</span>
        initial_indices_per_batch <span class="token operator">=</span> initial_indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span> i <span class="token operator">+</span> batch_size<span class="token punctuation">]</span>
        X <span class="token operator">=</span> <span class="token punctuation">[</span>data<span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> initial_indices_per_batch<span class="token punctuation">]</span>
        Y <span class="token operator">=</span> <span class="token punctuation">[</span>data<span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> initial_indices_per_batch<span class="token punctuation">]</span> <span class="token comment">#最多预测t个长度。</span>
        <span class="token keyword">yield</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>Y<span class="token punctuation">)</span>
 
 <span class="token comment">#如果是连续的可以拿到更多的空间信息，允许我们做出更长的序列出来，这代码太强了</span>
<span class="token keyword">def</span> <span class="token function">seq_data_iter_sequential</span><span class="token punctuation">(</span>corpus<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""使用顺序分区生成一个小批量子序列"""</span>
    <span class="token comment"># 从随机偏移量开始划分序列</span>
    offset <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span>
    <span class="token comment">#划分直接以batch_size为单位，batch里的子序列逻辑相连。算出最终取多少个tokens</span>
    num_tokens <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>corpus<span class="token punctuation">)</span> <span class="token operator">-</span> offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> batch_size<span class="token punctuation">)</span> <span class="token operator">*</span> batch_size
    Xs <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>corpus<span class="token punctuation">[</span>offset<span class="token punctuation">:</span> offset <span class="token operator">+</span> num_tokens<span class="token punctuation">]</span><span class="token punctuation">)</span>
    Ys <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>corpus<span class="token punctuation">[</span>offset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> offset <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> num_tokens<span class="token punctuation">]</span><span class="token punctuation">)</span>
    Xs<span class="token punctuation">,</span> Ys <span class="token operator">=</span> Xs<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Ys<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    num_batches <span class="token operator">=</span> Xs<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">//</span> num_steps
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_steps <span class="token operator">*</span> num_batches<span class="token punctuation">,</span> num_steps<span class="token punctuation">)</span><span class="token punctuation">:</span>
        X <span class="token operator">=</span> Xs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> i <span class="token operator">+</span> num_steps<span class="token punctuation">]</span>
        Y <span class="token operator">=</span> Ys<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> i <span class="token operator">+</span> num_steps<span class="token punctuation">]</span>
        <span class="token keyword">yield</span> X<span class="token punctuation">,</span> Y
        
<span class="token keyword">class</span> <span class="token class-name">SeqDataLoader</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""加载序列数据的迭代器"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">,</span> max_tokens<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> use_random_iter<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>data_iter_fn <span class="token operator">=</span> d2l<span class="token punctuation">.</span>seq_data_iter_random
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>data_iter_fn <span class="token operator">=</span> d2l<span class="token punctuation">.</span>seq_data_iter_sequential
        self<span class="token punctuation">.</span>corpus<span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab <span class="token operator">=</span> d2l<span class="token punctuation">.</span>load_corpus_time_machine<span class="token punctuation">(</span>max_tokens<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_steps <span class="token operator">=</span> batch_size<span class="token punctuation">,</span> num_steps

    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data_iter_fn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>corpus<span class="token punctuation">,</span> self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_steps<span class="token punctuation">)</span>
    
<span class="token keyword">def</span> <span class="token function">load_data_time_machine</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span>  <span class="token comment">#@save</span>
                           use_random_iter<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> max_tokens<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回时光机器数据集的迭代器和词表"""</span>
    data_iter <span class="token operator">=</span> SeqDataLoader<span class="token punctuation">(</span>
        batch_size<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">,</span> max_tokens<span class="token punctuation">)</span>
    <span class="token keyword">return</span> data_iter<span class="token punctuation">,</span> data_iter<span class="token punctuation">.</span>vocab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>深层：<code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</code>其实就是加了个num_layer</p>
<p>双向：<code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=True)</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#我们每次采样的小批量数据形状是二维张量： （批量大小，时间步数）。 </span>
<span class="token comment">#one_hot函数将这样一个小批量数据转换成三维张量， 张量的最后一个维度等于词表大小（len(vocab)）。 </span>
X <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
F<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>X<span class="token punctuation">.</span>T<span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape —— torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#我们经常转换输入的维度，以便获得形状为 （时间步数，批量大小，词表大小）的输出。 这将使我们能够更方便地通过最外层的维度， 一步一步地更新小批量数据的隐状态。</span>

<span class="token keyword">def</span> <span class="token function">grad_clipping</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>
    <span class="token triple-quoted-string string">"""裁剪梯度"""</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
        params <span class="token operator">=</span> <span class="token punctuation">[</span>p <span class="token keyword">for</span> p <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> p<span class="token punctuation">.</span>requires_grad<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        params <span class="token operator">=</span> net<span class="token punctuation">.</span>params
    norm <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>grad <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> params<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> norm <span class="token operator">></span> theta<span class="token punctuation">:</span>
        <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>
            param<span class="token punctuation">.</span>grad<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*=</span> theta <span class="token operator">/</span> norm


<span class="token comment">#简洁实现</span>
num_hiddens <span class="token operator">=</span> <span class="token number">256</span>
rnn_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span>
state <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#隐藏层数，批量大小，隐藏单元数</span>
X <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>num_steps<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Y<span class="token punctuation">,</span> state_new <span class="token operator">=</span> rnn_layer<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token comment">#Y的shape和X是一样的;state_new和state是一样的</span>
<span class="token comment">#RNN的输入输出https://blog.csdn.net/Fantine_Deng/article/details/111356280</span>

<span class="token comment">#@save</span>
<span class="token comment">#rnn_layer只包含隐藏的循环层，我们还需要创建一个单独的输出层。</span>
<span class="token keyword">class</span> <span class="token class-name">RNNModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""循环神经网络模型"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rnn_layer<span class="token punctuation">,</span> vocab_size<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>RNNModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> rnn_layer
        self<span class="token punctuation">.</span>vocab_size <span class="token operator">=</span> vocab_size
        self<span class="token punctuation">.</span>num_hiddens <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>hidden_size
        <span class="token comment"># 如果RNN是双向的（之后将介绍），num_directions应该是2，否则应该是1</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>bidirectional<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>num_directions <span class="token operator">=</span> <span class="token number">1</span>
            self<span class="token punctuation">.</span>linear <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>num_directions <span class="token operator">=</span> <span class="token number">2</span>
            self<span class="token punctuation">.</span>linear <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_hiddens <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        X <span class="token operator">=</span> F<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>T<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>vocab_size<span class="token punctuation">)</span><span class="token comment">#input的shape：(num_steps, batch_size, len(vocab))</span>
        X <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>
        Y<span class="token punctuation">,</span> state <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token comment">#y的shape：(时间步数，批量大小,隐藏单元数)</span>
        <span class="token comment"># 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数)</span>
        <span class="token comment"># output形状是(时间步数*批量大小,词表大小)。</span>
        output <span class="token operator">=</span> self<span class="token punctuation">.</span>linear<span class="token punctuation">(</span>Y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Y<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> output<span class="token punctuation">,</span> state

    <span class="token keyword">def</span> <span class="token function">begin_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> device<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rnn<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># nn.GRU以张量作为隐状态</span>
            <span class="token keyword">return</span>  torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>
                                 batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                device<span class="token operator">=</span>device<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># nn.LSTM以元组作为隐状态</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>
                self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>
                batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span>
                    torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>
                        self<span class="token punctuation">.</span>num_directions <span class="token operator">*</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span>
                        batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_hiddens<span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>


num_inputs <span class="token operator">=</span> vocab_size
gru_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>GRU<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span><span class="token operator">//</span>lstm_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span>
lstm_layer <span class="token operator">=</span> nn<span class="token punctuation">.</span>LSTM<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> num_layers<span class="token punctuation">)</span><span class="token comment">#最后一个是隐藏层数</span>
model <span class="token operator">=</span> d2l<span class="token punctuation">.</span>RNNModel<span class="token punctuation">(</span>gru_layer<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span>
model <span class="token operator">=</span> model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>
d2l<span class="token punctuation">.</span>train_ch8<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> device<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
gru_cell <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>GRUCell<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span>
    kernel_initializer<span class="token operator">=</span><span class="token string">'glorot_uniform'</span><span class="token punctuation">)</span>
gru_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>gru_cell<span class="token punctuation">,</span> time_major<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    return_sequences<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_state<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

device_name <span class="token operator">=</span> d2l<span class="token punctuation">.</span>try_gpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_device_name
strategy <span class="token operator">=</span> tf<span class="token punctuation">.</span>distribute<span class="token punctuation">.</span>OneDeviceStrategy<span class="token punctuation">(</span>device_name<span class="token punctuation">)</span>
<span class="token keyword">with</span> strategy<span class="token punctuation">.</span>scope<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    model <span class="token operator">=</span> d2l<span class="token punctuation">.</span>RNNModel<span class="token punctuation">(</span>gru_layer<span class="token punctuation">,</span> vocab_size<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>vocab<span class="token punctuation">)</span><span class="token punctuation">)</span>

d2l<span class="token punctuation">.</span>train_ch8<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> strategy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#RNN的训练</span>
<span class="token comment">#当使用顺序分区时， 我们只在每个迭代周期的开始位置初始化隐状态。 由于下一个小批量数据中的第个子序列样本 与当前第个子序列样本相邻， 因此当前小批量数据最后一个样本的隐状态， 将用于初始化下一个小批量数据第一个样本的隐状态。 这样，存储在隐状态中的序列的历史信息 可以在一个迭代周期内流经相邻的子序列。 然而，在任何一点隐状态的计算， 都依赖于同一迭代周期中前面所有的小批量数据， 这使得梯度计算变得复杂。 为了降低计算量，在处理任何一个小批量数据之前， 我们先分离梯度，使得隐状态的梯度计算总是限制在一个小批量数据的时间步内。</span>
<span class="token comment">#当使用随机抽样时，因为每个样本都是在一个随机位置抽样的， 因此需要为每个迭代周期重新初始化隐状态</span>
<span class="token comment">#@save</span>
<span class="token keyword">def</span> <span class="token function">train_epoch_ch8</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">,</span> device<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""训练网络一个迭代周期（定义见第8章）"""</span>
    state<span class="token punctuation">,</span> timer <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> d2l<span class="token punctuation">.</span>Timer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    metric <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Accumulator<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 训练损失之和,词元数量</span>
    <span class="token keyword">for</span> X<span class="token punctuation">,</span> Y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>
        <span class="token keyword">if</span> state <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> use_random_iter<span class="token punctuation">:</span>
            <span class="token comment"># 在第一次迭代或使用随机抽样时初始化state</span>
            state <span class="token operator">=</span> net<span class="token punctuation">.</span>begin_state<span class="token punctuation">(</span>batch_size<span class="token operator">=</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># state对于nn.GRU是个张量（即不参与更新）</span>
                state<span class="token punctuation">.</span>detach_<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># state对于nn.LSTM或对于我们从零开始实现的模型是个张量</span>
                <span class="token keyword">for</span> s <span class="token keyword">in</span> state<span class="token punctuation">:</span>
                    s<span class="token punctuation">.</span>detach_<span class="token punctuation">(</span><span class="token punctuation">)</span>
        y <span class="token operator">=</span> Y<span class="token punctuation">.</span>T<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>
        y_hat<span class="token punctuation">,</span> state <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>updater<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Optimizer<span class="token punctuation">)</span><span class="token punctuation">:</span>
            updater<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>
            l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
            grad_clipping<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
            updater<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
            grad_clipping<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token comment"># 因为已经调用了mean函数</span>
            updater<span class="token punctuation">(</span>batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
        metric<span class="token punctuation">.</span>add<span class="token punctuation">(</span>l <span class="token operator">*</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>metric<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> timer<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">#@save</span>
<span class="token keyword">def</span> <span class="token function">train_ch8</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> device<span class="token punctuation">,</span>
              use_random_iter<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""训练模型（定义见第8章）"""</span>
    loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>
    animator <span class="token operator">=</span> d2l<span class="token punctuation">.</span>Animator<span class="token punctuation">(</span>xlabel<span class="token operator">=</span><span class="token string">'epoch'</span><span class="token punctuation">,</span> ylabel<span class="token operator">=</span><span class="token string">'perplexity'</span><span class="token punctuation">,</span>
                            legend<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'train'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xlim<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> num_epochs<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment"># 初始化</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
        updater <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        updater <span class="token operator">=</span> <span class="token keyword">lambda</span> batch_size<span class="token punctuation">:</span> d2l<span class="token punctuation">.</span>sgd<span class="token punctuation">(</span>net<span class="token punctuation">.</span>params<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>
    predict <span class="token operator">=</span> <span class="token keyword">lambda</span> prefix<span class="token punctuation">:</span> predict_ch8<span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> net<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> device<span class="token punctuation">)</span>
    <span class="token comment"># 训练和预测</span>
    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        ppl<span class="token punctuation">,</span> speed <span class="token operator">=</span> train_epoch_ch8<span class="token punctuation">(</span>
            net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">,</span> device<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'time traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            animator<span class="token punctuation">.</span>add<span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ppl<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'困惑度 </span><span class="token interpolation"><span class="token punctuation">&#123;</span>ppl<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>speed<span class="token punctuation">:</span><span class="token format-spec">.1f</span><span class="token punctuation">&#125;</span></span><span class="token string"> 词元/秒 </span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">str</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'time traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>predict<span class="token punctuation">(</span><span class="token string">'traveller'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>机器翻译和</p>
<h4 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器-解码器"></a>编码器-解码器</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#机器翻译的数据集是由源语言和目标语言的文本序列对组成的。 因此，我们需要一种完全不同的方法来预处理机器翻译数据集， 而不是复用语言模型的预处理程序。</span>
<span class="token keyword">def</span> <span class="token function">preprocess_nmt</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""预处理“英语－法语”数据集"""</span>
    <span class="token keyword">def</span> <span class="token function">no_space</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> prev_char<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#空格的好处是切词的时候能把标点切成一个词</span>
        <span class="token keyword">return</span> char <span class="token keyword">in</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">',.!?'</span><span class="token punctuation">)</span> <span class="token keyword">and</span> prev_char <span class="token operator">!=</span> <span class="token string">' '</span>

    <span class="token comment"># 使用空格替换不间断空格，对utf-8的半角空格什么的都换成空格。</span>
    <span class="token comment"># 使用小写字母替换大写字母</span>
    text <span class="token operator">=</span> text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\u202f'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\xa0'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 在单词和标点符号之间插入空格</span>
    out <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">' '</span> <span class="token operator">+</span> char <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> no_space<span class="token punctuation">(</span>char<span class="token punctuation">,</span> text<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> char
           <span class="token keyword">for</span> i<span class="token punctuation">,</span> char <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>out<span class="token punctuation">)</span>

<span class="token comment">#机器翻译中，我们更喜欢单词级词元化 （最先进的模型可能使用更高级的词元化技术）每个词元要么是一个词，要么是一个标点符号。</span>
<span class="token keyword">def</span> <span class="token function">tokenize_nmt</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> num_examples<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""词元化“英语－法语”数据数据集"""</span>
    source<span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#换行符分样本</span>
        <span class="token keyword">if</span> num_examples <span class="token keyword">and</span> i <span class="token operator">></span> num_examples<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        parts <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span><span class="token comment">#制表符分语言</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parts<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            source<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            target<span class="token punctuation">.</span>append<span class="token punctuation">(</span>parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> source<span class="token punctuation">,</span> target

还是看原文吧：https<span class="token punctuation">:</span><span class="token operator">//</span>zh<span class="token operator">-</span>v2<span class="token punctuation">.</span>d2l<span class="token punctuation">.</span>ai<span class="token operator">/</span>chapter_recurrent<span class="token operator">-</span>modern<span class="token operator">/</span>machine<span class="token operator">-</span>translation<span class="token operator">-</span><span class="token keyword">and</span><span class="token operator">-</span>dataset<span class="token punctuation">.</span>html

<span class="token comment">#编码器和解码器，NotImplementedError有点cool，shi'pe</span>
<span class="token keyword">class</span> <span class="token class-name">Encoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""编码器-解码器架构的基本编码器接口"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>Encoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError
        
<span class="token keyword">class</span> <span class="token class-name">Decoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""编码器-解码器架构的基本解码器接口"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>Decoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">init_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#用于将编码器的输出（enc_outputs）转换为编码后的状态。</span>
        <span class="token keyword">raise</span> NotImplementedError

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#X是额外的输入</span>
        <span class="token keyword">raise</span> NotImplementedError
        
<span class="token keyword">class</span> <span class="token class-name">EncoderDecoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""编码器-解码器架构的基类"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> encoder<span class="token punctuation">,</span> decoder<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>EncoderDecoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>encoder <span class="token operator">=</span> encoder
        self<span class="token punctuation">.</span>decoder <span class="token operator">=</span> decoder
	<span class="token comment">#在前向传播中，编码器的输出用于生成编码状态， 这个状态又被解码器作为其输入的一部分。</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_X<span class="token punctuation">,</span> dec_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
        enc_outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>enc_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
        dec_state <span class="token operator">=</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>init_state<span class="token punctuation">(</span>enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>dec_X<span class="token punctuation">,</span> dec_state<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>seq to seq太难了，看原文吧：<a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html">https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#decoder最后</span>
 <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 输出'X'的形状：(batch_size,num_steps,embed_size)</span>
        X <span class="token operator">=</span> self<span class="token punctuation">.</span>embedding<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token comment"># 广播context，使其具有与X相同的num_steps</span>
        context <span class="token operator">=</span> state<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#相当于对每个时间步，都加了一个c初始化</span>
        X_and_context <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        output<span class="token punctuation">,</span> state <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>X_and_context<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
        output <span class="token operator">=</span> self<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token comment"># output的形状:(batch_size,num_steps,vocab_size)</span>
        <span class="token comment"># state[0]的形状:(num_layers,batch_size,num_hiddens)</span>
        <span class="token keyword">return</span> output<span class="token punctuation">,</span> state
    
<span class="token keyword">class</span> <span class="token class-name">MaskedSoftmaxCELoss</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""带遮蔽的softmax交叉熵损失函数"""</span>
    <span class="token comment"># pred的形状：(batch_size,num_steps,vocab_size)</span>
    <span class="token comment"># label的形状：(batch_size,num_steps)</span>
    <span class="token comment"># valid_len的形状：(batch_size,)</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pred<span class="token punctuation">,</span> label<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
        weights <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>label<span class="token punctuation">)</span>
        weights <span class="token operator">=</span> sequence_mask<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>reduction<span class="token operator">=</span><span class="token string">'none'</span>
        unweighted_loss <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>
            pred<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token comment">#pytorch要求把那个softmax处理的那个维度放中间，可能for 效率</span>
        weighted_loss <span class="token operator">=</span> <span class="token punctuation">(</span>unweighted_loss <span class="token operator">*</span> weights<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> weighted_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#带批量矩阵乘法</span>
X <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Y <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
torch<span class="token punctuation">.</span>bmm<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">.</span>shape <span class="token operator">==</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">#torch的rand函数和sort函数</span>
n_train <span class="token operator">=</span> <span class="token number">50</span>  <span class="token comment"># 训练样本数</span>
x_train<span class="token punctuation">,</span> origin_seq <span class="token operator">=</span> torch<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n_train<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>   <span class="token comment"># 排序后的训练样本</span>

x_train
tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0840</span><span class="token punctuation">,</span> <span class="token number">0.1345</span><span class="token punctuation">,</span> <span class="token number">0.3510</span><span class="token punctuation">,</span> <span class="token number">0.5656</span><span class="token punctuation">,</span> <span class="token number">0.8183</span><span class="token punctuation">,</span> <span class="token number">0.9208</span><span class="token punctuation">,</span> <span class="token number">1.1907</span><span class="token punctuation">,</span> <span class="token number">1.3527</span><span class="token punctuation">,</span> <span class="token number">1.4449</span><span class="token punctuation">,</span>
        <span class="token number">1.5247</span><span class="token punctuation">,</span> <span class="token number">1.5696</span><span class="token punctuation">,</span> <span class="token number">1.7349</span><span class="token punctuation">,</span> <span class="token number">1.8324</span><span class="token punctuation">,</span> <span class="token number">1.8558</span><span class="token punctuation">,</span> <span class="token number">1.8864</span><span class="token punctuation">,</span> <span class="token number">1.9879</span><span class="token punctuation">,</span> <span class="token number">2.0112</span><span class="token punctuation">,</span> <span class="token number">2.0115</span><span class="token punctuation">,</span>
        <span class="token number">2.0157</span><span class="token punctuation">,</span> <span class="token number">2.1903</span><span class="token punctuation">,</span> <span class="token number">2.2141</span><span class="token punctuation">,</span> <span class="token number">2.2400</span><span class="token punctuation">,</span> <span class="token number">2.3800</span><span class="token punctuation">,</span> <span class="token number">2.4314</span><span class="token punctuation">,</span> <span class="token number">2.5796</span><span class="token punctuation">,</span> <span class="token number">2.6966</span><span class="token punctuation">,</span> <span class="token number">2.7665</span><span class="token punctuation">,</span>
        <span class="token number">2.8231</span><span class="token punctuation">,</span> <span class="token number">2.9374</span><span class="token punctuation">,</span> <span class="token number">3.0170</span><span class="token punctuation">,</span> <span class="token number">3.0468</span><span class="token punctuation">,</span> <span class="token number">3.1662</span><span class="token punctuation">,</span> <span class="token number">3.2001</span><span class="token punctuation">,</span> <span class="token number">3.2120</span><span class="token punctuation">,</span> <span class="token number">3.2182</span><span class="token punctuation">,</span> <span class="token number">3.2420</span><span class="token punctuation">,</span>
        <span class="token number">3.5141</span><span class="token punctuation">,</span> <span class="token number">3.5614</span><span class="token punctuation">,</span> <span class="token number">3.5880</span><span class="token punctuation">,</span> <span class="token number">3.6311</span><span class="token punctuation">,</span> <span class="token number">3.7026</span><span class="token punctuation">,</span> <span class="token number">3.8288</span><span class="token punctuation">,</span> <span class="token number">4.3208</span><span class="token punctuation">,</span> <span class="token number">4.3390</span><span class="token punctuation">,</span> <span class="token number">4.5670</span><span class="token punctuation">,</span>
        <span class="token number">4.6363</span><span class="token punctuation">,</span> <span class="token number">4.6682</span><span class="token punctuation">,</span> <span class="token number">4.7314</span><span class="token punctuation">,</span> <span class="token number">4.7663</span><span class="token punctuation">,</span> <span class="token number">4.9927</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
origin_seq
tensor<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span>
        <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>形状详见<a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-scoring-functions.html">10.3</a>加性注意力。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#查询、键和值的形状为（批量大小，数量（如n个q），特征大小），经过转换后👇</span>
<span class="token comment">#queries的形状：(batch_size，查询的个数，1，num_hidden)</span>
<span class="token comment">#key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span>
<span class="token comment">#queires和key被处理成scores 形状：(batch_size，查询的个数，“键-值”对的个数)</span>
<span class="token comment">#values的形状：(batch_size，“键－值”对的个数，值的维度)</span>
<span class="token comment">#返回的结果是torch.bmm(scores,values) scores还得经历掩码softmax和dropout，输出的形状为（批量大小，查询的步数，值的维度）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="李宏毅"><a href="#李宏毅" class="headerlink" title="李宏毅"></a>李宏毅</h2><p>HW1</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">device <span class="token operator">=</span> <span class="token string">'cuda'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>
config <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">'seed'</span><span class="token punctuation">:</span> <span class="token number">5201314</span><span class="token punctuation">,</span>      <span class="token comment"># Your seed number, you can pick your lucky number. :)</span>
    <span class="token string">'select_all'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>   <span class="token comment"># Whether to use all features.</span>
    <span class="token string">'valid_ratio'</span><span class="token punctuation">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span>   <span class="token comment"># validation_size = train_size * valid_ratio</span>
    <span class="token string">'n_epochs'</span><span class="token punctuation">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>     <span class="token comment"># Number of epochs.            </span>
    <span class="token string">'batch_size'</span><span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span> 
    <span class="token string">'learning_rate'</span><span class="token punctuation">:</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span>              
    <span class="token string">'early_stop'</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>    <span class="token comment"># If model has not improved for this many consecutive epochs, stop training.     </span>
    <span class="token string">'save_path'</span><span class="token punctuation">:</span> <span class="token string">'./models/model.ckpt'</span>  <span class="token comment"># Your model will be saved here.</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">#tensorboard</span>
<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter
writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"runs2"</span><span class="token punctuation">)</span>
writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span>comment<span class="token operator">=</span><span class="token string">"this_is_ex_version"</span><span class="token punctuation">)</span><span class="token comment">#只能用默认的runs，会在子文件夹名字后面加comment</span>
<span class="token keyword">for</span> n_iter <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Loss/train'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">,</span>new_style<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment">#会分一个Loss区，里面俩张图</span>
    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Loss/test'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">,</span>new_style<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Accuracy/train'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">'Accuracy/test'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_iter<span class="token punctuation">)</span>
writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#默认runs/</span>
r <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#会生成ab_sinx/xcosx/tanx三个文件夹,会划到ab区的一张图里</span>
    writer<span class="token punctuation">.</span>add_scalars<span class="token punctuation">(</span><span class="token string">'ab'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'xsinx'</span><span class="token punctuation">:</span>i<span class="token operator">*</span>np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    <span class="token string">'xcosx'</span><span class="token punctuation">:</span>i<span class="token operator">*</span>np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    <span class="token string">'tanx'</span><span class="token punctuation">:</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>i<span class="token operator">/</span>r<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token operator">%</span>load_ext tensorboard
<span class="token operator">%</span>tensorboard <span class="token operator">-</span><span class="token operator">-</span>logdir<span class="token operator">=</span>路径，如果打开了没有子文件夹的文件夹，event名字是'<span class="token punctuation">.</span>

<span class="token comment">#直方图、等例子直接查文档吧：https://pytorch.org/docs/stable/tensorboard.html</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">#生成1000个随机数</span>
    writer<span class="token punctuation">.</span>add_histogram<span class="token punctuation">(</span><span class="token string">'distribution centers'</span><span class="token punctuation">,</span> x <span class="token operator">+</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    

    <span class="token keyword">import</span> csv
<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm
<span class="token keyword">def</span> <span class="token function">save_pred</span><span class="token punctuation">(</span>preds<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">''' Save predictions to specified file '''</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
        writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>
        writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'tested_positive'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i<span class="token punctuation">,</span> p <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">:</span>
            writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> p<span class="token punctuation">]</span><span class="token punctuation">)</span>

model <span class="token operator">=</span> My_Model<span class="token punctuation">(</span>input_dim<span class="token operator">=</span>x_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>
model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>config<span class="token punctuation">[</span><span class="token string">'save_path'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
preds <span class="token operator">=</span> predict<span class="token punctuation">(</span>test_loader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> device<span class="token punctuation">)</span> 
save_pred<span class="token punctuation">(</span>preds<span class="token punctuation">,</span> <span class="token string">'pred.csv'</span><span class="token punctuation">)</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

]]></content>
      <categories>
        <category>DL</category>
      </categories>
  </entry>
  <entry>
    <title>数学感悟</title>
    <url>/2021/12/10/%E6%95%B0%E5%AD%A6%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>数学是一门计算的学问，不断组合现有结论达到 ”巧妙计算“，但当技巧穷尽，还有一门研究如何暴力计算的数值分析，这需要借助计算机，而机器学习依靠的就是这些。</p>
<p><strong>许多内容是个人直觉感悟，可能有错</strong></p>
<p>纯粹数学：不顾与现实的几何，单单研究数学本身，以数论为主体。</p>
<p>计算数学 研究的是如何在找不到公式解的情况下（比如超越方程）找到近似解，而数值分析就是研究如何用计算机来完成这一过程，是计算数学的主体部分。</p>
<p>包括矩阵计算【数值线性代数】</p>
<p>线代是研究【线性】的学科，因为人类在线性领域研究颇深。而矩阵是线代的一种表示工具。</p>
<p>矩阵经过发展，形成了独立的数学分支——矩阵论。</p>
<p>具体数学是教你如何把一个实际问题一步步演化为<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/1376909">数学模型</a>，然后通过计算机解决它，特别着重于算法分析方面。算法偏向于将理论转变为高效的程序。【我才懒得搞这个。。卷死了】</p>
<p>微积分：解决了无穷小的定义问题，严谨的用极限来分析计算问题。</p>
<p>数学分析是分析学的基础，包括了微积分，又拓展了级数、复数和更多的函数域。</p>
<p>泛函分析：研究对象是函数构成的空间，看作无限维向量空间的解析几何和数学分析。</p>
<p>拓扑 是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的<strong>位置关系而不考虑它们的形状和大小</strong>。</p>
<p>统计学是通过搜索、整理、分析、描述数据等手段，以达到推断所测对象的本质，甚至预测对象未来的一门综合性科学。分为描述统计和推断统计，代表了完成统计的两个过程。这也是类似心理学的，结合了大量的领域知识。有几分估算，有些玄幻。。。变魔术。</p>
<p>数理统计以概率论为基础，研究大量随机现象变化规律的一种方法。精准</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>reflection = 2projection - I</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002323702.png" alt="image-20210923002323702" style="zoom:67%;" />分解怎么分的</p>
</li>
<li><p>连续求偏导，af/ax * af/ay</p>
</li>
</ol>
<p>理论可以分学派，但是这只是由基本假设不同而探索的不同路径，对于理论家们，只是选择了一个方向继续研究而已，而不是什么党派斗争。</p>
<h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><ol>
<li><p>所谓极限，强调的是存在性，只要极限存在，那么不论你需要多高的收敛精度，总能做到。</p>
</li>
<li><p>导数只能研究一维，微分可以研究更高维度的</p>
</li>
<li><p>泰勒是对函数更高层导数的拟合。</p>
</li>
<li><p>反常和级数收敛是找到“无限中的有限”</p>
</li>
<li><p>对二元函数来讲，z=f(x,y)三维空间中的一个曲面，<strong>在某点可微意味着在该点有唯一切平面</strong>，也就是说平面上通过该点的所有曲线有切线，且所有切线共面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-4d7351677207685ef8751c9ac200e4e3_720w.jpg" alt="v2-4d7351677207685ef8751c9ac200e4e3_720w"></p>
<p>因此有可微-&gt;偏导存在 + 函数连续</p>
<p>而可微的充分条件：每个正交方向上的偏导数都在小邻域内存在连续，则是因为<strong>正交基线性组合</strong>可以铺满整个空间（二元方程就是二维空间），确保能完成超平面的效果。</p>
</li>
<li><p>输入参数（几元）每多一个，反向传播就提高几倍效率，因为节省了重复计算。</p>
</li>
<li><p>导数除了理解为”趋势“，还可以理解为”权重“，在F（x,y,z）的求隐函数例子中，x，y，z相互之间的导数与对整体F偏导有关，这里就反映了权重的关系，谁的权重大，对整体的影响就大。</p>
<p>比如：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-6fd72844899de59141cede582df9aa9b_720w.jpg" alt="v2-6fd72844899de59141cede582df9aa9b_720w"></p>
<p>假如，Fx/Fy比较大，证明x影响大，所以dy/dx大，代表x能替换更多的dy。负号是因为那一点是固定的，每多一点x，就要减少那么多y才能维持不变。</p>
</li>
<li><p>【人们好像默认选用<strong>正交</strong>的参数或基底】，而方向导数就是线性组合正交基来表示任意方向。</p>
</li>
<li><p>我是这样理解高阶泰勒的，这其实就是多了个链式法则，从低纬度一步一步组合到最高的维度，根据链式法则来穷尽所有的组合，因为每一步都要考虑不同正交基间的相互影响。而这种线性组合的穷尽，当然用线性代数里面的矩阵比较好表示一些，也就是黑塞矩阵</p>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li><p>曲线求的是切线和法平面，用的是导数，</p>
<p>曲面求的是切平面和法线，用的是偏导数。</p>
</li>
<li></li>
</ol>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ol>
<li><p>分布列对于随机变量的每个取值给出对应的概率。它对应的是X的值也就是值域而不是x的定义域</p>
<p>卧槽，我发现诡异的地方了。。。x在这里是X的取值，而不是基本事件的定义域。。。tmd</p>
<p>在概率论里面，“随机变量”好像才是第一层。。。而它本身就是一个映射规则很奇怪的函数、、</p>
</li>
<li><p>各种定律乱七八糟的，其实还不就那几个思想：</p>
<p>分组（全概率），序贯（乘法定理），条件就是选取更小的样本空间然后继续分组，贝叶斯就是部分/整体。独立性要区分。。玄学。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-37387c56c6d1740aedab256f1081fced_1440w.jpg" alt="img"></p>
<p>独立性和条件独立性并没联系。</p>
<p>两两独立和相互独立也没关系。这个独立非常玄学。它根本没用普通的数学关系表示出来，<code>因为数学不能刻画现实的所有逻辑</code>，哪怕是离散数学，也只能刻画部分而已。</p>
<ol>
<li>全期望 P92，【无条件平均（期望）可由条件平均（条件下的期望）再求平均得到】</li>
<li>连续和离散贝叶斯 P160</li>
<li>重期望法则 P195 条件期望的期望 = 无条件期望（全期望的另一版本）</li>
<li>全方差法则 P199 总方差可分为 组内方差平均数 + 各组间的方差（有物竞那味了）【这俩可用来化简】<br>理论依据：估计$E[X|Y]$ 与 估计误差$E[X|Y]-X$ 相互独立</li>
<li>矩母函数（变换）是对概率（分布律/概率密度函数）的另一种表述，不太直观，单解决某些类型的数学计算很方便<br>$M_X(s) = E(e^{sX})$ 矩母函数是参数为s的函数。即矩母函数作用于一个函数得到一个新的函数。<br>$M_Y(s) = E(e^{s(aX+b)}) =e^{sb}E(e^{saX}) = e^{sb}M_X(sa)$   标准正态分布$M_Y(s) = e^{s^2/2}$   一般$M_X(s) = e^{(\sigma^2s^2/2)+\mu s}$<br>$M_X(0) = 1$          $\displaystyle \lim_{s\rightarrow -\infin}M_X(s) = P(X=0)$</li>
<li>独立随机变量和与矩母  和的矩母为随机变量矩母之积 P207  常见分布矩母函数表 P208-209</li>
<li><u>随机数个</u> 相互独立随机变量之和的 均值、方差、矩母</li>
</ol>
<p><strong>随机过程</strong><br>是处理包含时间以及数据序列的概率模型。<br>序列中的每个数据都视为一个随机变量，简单地说，随机过程就是遗传（有限或无限）随机变量序列。<br>特征：强调过程中产生的数据序列之间的相关关系、对整个过程的长期均值感兴趣、刻画边界事件的似然或概率<br>种类繁多，本书仅讨论：到达过程、马尔可夫过程</p>
<ul>
<li>到达过程：“到达”特性是否发生，研究<u>相邻到达时间是相互独立的随机变量</u>的模型，根据服从几何、指数分为伯努利、泊松过程。</li>
<li>马尔可夫过程：未来数据演化与历史数据有概率相关结构，但假设未来数据只依赖当前数据，与过去数据无关，技术十分成熟。</li>
</ul>
<p>与伯努利相比，泊松是连续时间轴上的到达过程。其性质见269         </p>
<table>
<thead>
<tr>
<th></th>
<th>泊松</th>
<th>伯努利</th>
</tr>
</thead>
<tbody><tr>
<td>到达时间</td>
<td>连续</td>
<td>离散</td>
</tr>
<tr>
<td>到达次数分布(<em>可加</em>)</td>
<td>泊松(参数为$\lambda \tau$)</td>
<td>二项</td>
</tr>
<tr>
<td>相邻到达时间分布(<em>独立、无记忆</em>)</td>
<td>指数</td>
<td>几何</td>
</tr>
<tr>
<td>到达率</td>
<td>$\lambda/$单位时间</td>
<td>$p/$每次试验</td>
</tr>
<tr>
<td>第k次到达的时间</td>
<td>埃尔朗\伽玛分布 P272</td>
<td>帕斯卡分布 P261</td>
</tr>
</tbody></table>
<p>到达次数随机变量是相邻到达时间随机变量之和：$Y_k = T_1+…+T_k$</p>
<p>P262 伯努利过程的分裂与合并，仍是伯努利，$pq\ p(1-q)\ (p+q-pq)$    </p>
<p>P274 泊松过程分裂合并类似，$\lambda p$  $\lambda_1+\lambda_2$ </p>
<p>P277 随机数个独立随机变量和的性质。</p>
<p>随机插入悖论，由于插入时，插入不同区间的概率不同，进行修正。泊松过程将区间修正为二阶埃尔朗分布，其他过程也会有影响。</p>
<p>马尔可夫模型中，未来会依赖过去，影响归结为对<em>状态</em>的影响，变量取值有限。<br>马尔可夫模型哪里都有，包含了几乎所有的动力模型，状态随时间变化具有不确定性。同分<em>离散、连续</em></p>
</li>
</ol>
<h2 id="线代和矩阵论"><a href="#线代和矩阵论" class="headerlink" title="线代和矩阵论"></a>线代和矩阵论</h2><p>线性代数最让人陶醉的是，它非常自然的引出了多维空间的概念，即使我们想象不出来。由于科学研究中的非<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/9857200">线性模型</a>通常可以被近似为<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B">线性模型</a>，使得线性代数被广泛地应用于自然科学和社会科学中。<a href="https://baike.baidu.com/item/%E9%9D%9E%E7%BA%BF%E6%80%A7">非线性</a>的问题极为困难，我们并没有足够多的通用的性质和定理用于求解具体问题。如果能够把非线性的问题化为线性的，这是我们一定要走的方向！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-736ecb905966099feac5e943e365aa6f_r.png" alt="v2-736ecb905966099feac5e943e365aa6f_r"></p>
<p>还有什么能比这更牛逼的图？</p>
<ol>
<li><p>Ax = b   A作用于x，x默认是一列，对A的各列进行线性组合得到向量b</p>
<p>也可以理解为，n维的向量，经过空间变化（A），得到m维对应的结果b</p>
<p>这是线代的基石（为什么不用行？因为约定向量是按列的，所以这样更有意义）</p>
</li>
<li><p>矩阵乘法也很好解释，投影到的空间作为下一个变换的输入空间必须同维度</p>
</li>
<li><p>为什么行变换不改变结果？</p>
<p>我觉得是因为一个向量的各个正交维度是等价的，不管怎么调换顺序，正交带来的对称性是不会被打破的。</p>
<p>而不同特征间组合相当于构建新特征？仍不能由原有的单个特征表出，保留了无关，而在现实问题中，如果要这样操作，就要用学长说的标准化，化为同一量纲。</p>
</li>
<li><p>四种方法：</p>
<ul>
<li>硬算，左行*右列，一个一个傻傻的算</li>
<li>左行*右边整个  /   右列*左边整个（我喜欢这个）</li>
<li>左列*右行，用很多相同大小的秩一矩阵求和。</li>
</ul>
</li>
<li><p>线性代数主要以运算为主，比如矩阵的四则运算、行列式的计算、特征值和特征向量的计算等。 而矩阵论主要以变换为主，它利用线性代数知识，描述线性变换，并提出了特殊变换，如正规变换、酉变换等。</p>
</li>
<li><p>A B 可逆，A+B不一定可逆，但是AB可逆，我感觉，如果可逆，代表该变换是同维度变换，充斥整个空间的所有可能，AB相当于连续进行两次这样的变换，因此仍是可逆的。</p>
</li>
<li><p>LU分解，一开始分出的是L逆 + U，把L逆取逆后得到的L中（逆的基本矩阵E操作顺序是反的）是从下层开始操作的，因为不会有从上层操作而带来的”干扰项“。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210920221007667.png" alt="image-20210920221007667"></p>
</li>
<li><p>梳理一下，求Ax = b有高斯消元和LU分解；</p>
<p>求Ax = 0，通过给自由变量挨个设1，找到特解。通过设自由变量均为0找到特解。。</p>
</li>
<li><p>With rank one, Ax  =  0 is easy to understand. That equation u( v T x)  =  0 leads us to v T x = 0. All vectors x in the nullspace must be orthogonal to v in the row space.</p>
</li>
<li><p>U  tells which columns are combinations of earlier columns (pivots are missing). Then R tells us what those combinations are.</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921004243300.png" alt="image-20210921004243300"></p>
<p>今天终于能总结理解了。</p>
<p>r = m &lt; n的时候，肥矮，零空间有除了零向量以外的向量，且列空间 = 整个空间，一定有解且有无穷解。</p>
<p>r = n &lt; m的时候，瘦高，列向量张成的子空间处于更大的空间中，因此b可能落不到子空间里，可能无解，零空间也没别的，最多一个解。</p>
<p>r &lt; n,r &lt; m 的时候，零空间一定有别的，列空间小于整个空间，所以要么无解，要么无穷解。</p>
<p>r = m = n 的时候天选之子，只有唯一解。相当于是在研究的整个空间内进行自己到自己的的变换，输入，输出都在整个空间，因此也具有传递性。</p>
<p>能投影出b的x必定有唯一的一部分来自行空间，配上零空间的任意部分，第五版的图画得好啊</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921095341752.png" alt="image-20210921095341752" style="zoom:10%;" />

<p><strong>顺便提一个结论，空间变换降维的过程是不可逆的，可逆一定是同维。</strong></p>
<p>列秩 = 行秩，用到的结论是基变换（至少在这里）不改变无关的性质。等后面学了基再看吧。</p>
</li>
<li><p>矩阵加减，各个维度相加减，既有新开拓的，又有归零降维的。因此秩应该处于|r1|+|r2|</p>
<p>到 | |r1| - |r2| |之间吧</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921105413893.png" alt="image-20210921105413893"></p>
<p><strong>A T  A (nxn) is invertible if and only if  A  has linearly independent columns.</strong></p>
<p>A 是 rectangular ，一定不可逆，不然哪里需要求近似解，</p>
<p>这不是正规方程吗！A表示输入，后面仨 + y就是正规方程，乘起来就是投影，这就是”最小二乘“的几何学表示，代数学表示就是梯度下降令导数均为0.</p>
<p>When Ax= b has no solution, multiply by A T  and solve (A T  A)x= (A T) b</p>
<p>Ax = b = p+e  其中p落在列空间，e落在左零空间，当无解时，移除e，Ax`  = p必然可解。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921111608466.png" alt="image-20210921111608466" style="zoom: 67%;" />

<p>当列不独立时，零空间有除了零向量以外的向量，这时候投影条件无助于找到最小二乘法的直线，要用到伪逆，这时候x` 有多个解，伪逆会选出x最小的解。。。</p>
<p>最小二乘还可适用于非线性方程和傅里叶级数等。</p>
</li>
<li><p>正交矩阵变换并不会影响长度（IIQx ll  =  ll x ll  for every vector x.）,最标准的基，带来最标准的影响。因此对计算非常有利，计算机尽可能采用正交矩阵。</p>
<p>此时最小二乘：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921142337398.png" alt="image-20210921142337398"></p>
<p>p = Q QT b，若更进一步，Q是方阵，那b = p，直接消干净了。</p>
</li>
<li><p>克拉默法则，给出了我们一个用行列式写出nxn线性方程组解的简便方法，<strong>有重要的理论意义</strong>，但是计算量很大，所以就是用来理论研究推导的嘛。。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921165546210.png" alt="image-20210921165546210"></p>
</li>
<li><p>特征值和特征向量引出了新的领域，当我们不再观察单个状态，引入连续的变化后，我们更关注保持不变的东西——特征，这大大简化了各方面的复杂度（比如A^10000）。</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921171846620.png" alt="image-20210921171846620" style="zoom: 67%;" />

<p>Markov matrix：Each column of P adds to 1 (property)</p>
<p>Its largest eigenvalue is λ  =  1，so others are generally disappearing</p>
</li>
<li><p>当进行行变换时，特征值一般会改变，因为特征值虽然刻画的是不变量，但可能是几个不好的基糅杂在一起，而不是像单个基一样分开来，所以好像有个感觉上的“牵连作用”？(待定)</p>
</li>
<li><p>相似性，说明的是不同基下的同一个变换/图形，而对角矩阵其实是因为变换到了特征向量为基的坐标系下，除去了干扰，彻底把特征值暴露出来。</p>
<p>Cx = λx. Then BCB- 1  has the same eigenvalue λ with the new eigen­vector Bx</p>
<p>因为这转换到了B基的空间，自然也要把原来的特征向量左乘B转过来。</p>
</li>
<li><p>当代数重数 &gt; 几何重数时，可能是巧合导致某几个方向上λ值相等。</p>
<p>也有可能是因为这几个方向重叠了，对应（A-λI矩阵不可逆，所以转换后降维了）而重叠的情况下我们就少了几个特征向量（被压缩），这就是解释。</p>
</li>
<li><p>uk = A^k *u0  求这种问题</p>
<p>思路是把U0表示为特征向量的线性组合，然后分开研究不同向量k次迭代后的值，再组合起来，过程中组合系数不变。</p>
<p>系数为 c  =   X-1 u0 这样就组合成了u0（当然比较少的时候也能直接看出来）</p>
<p>然后左乘对角阵的k次方，这是应用k次迭代的特征值到每一个c上得到新的系数，</p>
<p>最后再组合起来<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210922131057114.png" alt="image-20210922131057114"></p>
<p>就完成了。</p>
</li>
<li><p>也可以运用在将常系数微分方程转化为线性组合。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210922150411993.png" alt="image-20210922150411993" style="zoom: 33%;" />

<p>只适用于常微分方程 就是 dy/du = Cu这种，</p>
</li>
<li><p>对称矩阵时最重要的矩阵，在线代理论和应用上。</p>
<p><code>它具有n个实特征值，而且有n个正交的特征向量，也必然能被对角化，而且对角化的形式是特征向量矩阵归一化夹着特征值矩阵。</code></p>
<p>对称矩阵的列空间和行空间是一样的，因此零空间也同时垂直列空间。</p>
<p>【证明用的是数学里的谱定理和几何、物理里的主轴定理（特征向量指向椭圆的主轴）】</p>
<p>而且那个X矩阵这个时候是一个正交矩阵Q，不过注意要选择合适的长度，使得每个向量length = 1</p>
</li>
<li><p>正定矩阵的性质让它更加特殊！但是这并不意味着稀少，它是许多应用的核心。</p>
<p>有一个结论👇因为：显然xT(S+T)x分解后的和恒&gt;0，而对称矩阵相加仍然对称。</p>
<p>If S and T are symmetric positive definite, so is S  +  T.</p>
<p><strong>可逆和可对角化并没有必然联系。</strong></p>
<p><code>ATA一定是对称、半正定、可对角化的，如果A还是列满秩，那么ATA一定是可逆、正定的。</code></p>
<p>对称矩阵可逆的充要条件是n个实特征值不包含0.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923000916235.png"></p>
<p>strang给出了三种分解方式，我没看懂A1是怎么做到的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002323702.png" alt="image-20210923002323702" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002335728.png" alt="image-20210923002335728" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002405224.png" alt="image-20210923002405224" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923002233967.png" alt="image-20210923002233967" style="zoom:67%;" /></li>
<li><p>主轴定理：</p>
<p>特征向量指向椭圆的主轴，而且大的特征值对应了短轴。因为半轴是取1/根号下λ</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210923004958881.png" alt="image-20210923004958881"></p>
<p>如果有个特征值是负的，那椭圆就变成双曲线了。。。hyperbola，两个特征值均负无实数解。</p>
<p>如果S是nxn的，那么这个就是超椭圆。</p>
</li>
<li><p>正交矩阵 矩阵转置 = 矩阵的逆，先从行空间投向列空间，再投回来。 ATA= I啥都不变</p>
<p>那么普通矩阵可逆呢。必然可逆，因为是从原空间投向原空间，但为啥不等于 I 呢，是因为第一次只投到列空间，没有左零空间的部分（而且零空间的被吞掉了），所以往回投的时候定义域缩窄了。那么正交矩阵是没有零空间和左零空间的，完全可逆。</p>
</li>
<li><p>SVD</p>
<p>图像压缩有两种方案，提前选基【傅里叶等】和适应性选基【SVD等】</p>
<p><strong>图像一般是满秩的，但是有很多特征值非常小的可舍弃</strong>，</p>
<p>但是有几个问题，一般图像的特征向量不是正交；而且要分解成U,V俩矩阵，这就是SVD能做的。</p>
<p>U和V一定是酉矩阵【即正交矩阵】，因为特征值被抽取出来到 Σ 里了，<a href="https://zhuanlan.zhihu.com/p/29846048">简易证明</a></p>
<p>（当A是正定或半正定时特征值分解就相当于是对角化。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924100929032.png" alt="image-20210924100929032">也就是行空间的v投影到列空间的u上，而且系数是σ。</p>
<p>而且σ1 - σr都是正的，因为Ar 满足列满秩，所以ArTAr一定正定，所以特征值都正，开方也正。而紧接着说明了剩下的u和r因为空间的性质，自动正交于列空间和行空间的u 、v，因此Av = uσ 适用于所有的。也说明了对于形状任意，秩情况任意的矩阵，奇异值分解都成立。</p>
<p>相对于对细小变化做出反应的特征值，奇异值对此并不敏感，因为其本质——分解成秩一矩阵。并不会关注细小的变化，而新增的小秩一矩阵自然会分配小奇异值，影响并不大。</p>
<p>类比S = ATA 的对角化</p>
<p>A和S的秩相等，λ = σ2  vi = S的特征值qi。 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924105359042.png" alt="image-20210924105359042" style="zoom: 67%;" />

<p>然后递归的进行这个过程，可以证明这两条式子其实是一样的。</p>
<p>证明用到了瑞利xxx，可见P376页。</p>
<p>那么λ和σ事实上是如何计算的呢？直接暴算多项式（n = 10000+）就太离谱了。。</p>
<ul>
<li><p>首先要尽可能多搞点0出来，还不能改变任意的σ和λ，这通过巧妙的对角化方法实现。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091507660.png" alt="image-20210924110736701" style="zoom:67%;" />

<p>这样既不改变值，又能用不对称的Q1和Q2操纵矩阵。细节在11节。</p>
</li>
<li><p>LAPACK提供的受欢迎的方式使用简单的正交矩阵Q来拟合 QT S Q = 特征值对角阵，近似解。</p>
</li>
</ul>
</li>
<li><p>主成分分析</p>
<p>S = AAT/(n-1)  样本协方差矩阵，其中对角线是方差，其他是协方差，A要进行均值化处理</p>
<p>令 T （trace）= σ1^2 +σ2^2 …………，则σ1^2 / T 就代表了重要比例。当比例足够时就可以舍弃后面的。</p>
<p>在这里也同时解决了正交距离最小化，而不是一般最小二乘法的垂直距离。 </p>
<p>我们将aj分解到组成他的u1，u2上，<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210924150625604.png" alt="image-20210924150625604"></p>
<p>左边的是固定的，当我们在PCA中选择u1作为基，左边第一项最大，则第二项最小，而第二项正是所谓的正交距离，也就是aj落在正交于最优直线的垂线的分量。</p>
<p>当然在处理现实数据时，如果规模是个问题，还要用相关矩阵。统计和线代关系密切。</p>
</li>
<li><p>伪逆真是方便A+ = VΣ+UT</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925164019077.png" alt="image-20210925164019077"></p>
<p>这俩👆是因为投影的时候清除了了垂直的分量。</p>
</li>
<li><p>Are all linear transformations from V  =  R n to W  =  R m  produced by matrices?</p>
<p>The answer is yes! This is an approach to linear algebra that doesn’t start with<br>matrices. We still end up with matrices-after we choose an input basis and output basis.</p>
<p>Transformations have a language of their own. For a matrix, the column space contains all outputs  Av.  The nullspace contains all inputs for which  Av  = 0<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925214411053.png" alt="image-20210925214411053"></p>
<p>我们只要知道了一组基的变换情况，我们就知晓了变换的一切。</p>
</li>
<li><p>达到一种变换T有很多矩阵，我们希望能找到最好的那种（对角）</p>
<p>线性变换中，把输入向量用vj组合，然后对每个组合进行T变换，再组合起来就是核心idea。</p>
<p>当基变换时，T（v） = v的矩阵就不再是 I 了，而是👇，这样相当于用新基W表示完全相同的向量</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925220326553.png" alt="image-20210925220326553"></p>
<p><u>虽然每家教材的形式都不一样，但其实说的都是同一件事啊。</u>感觉这种把V用W表示出来才更直观！</p>
<p>新基下的坐标 = B *原基下的坐标。</p>
<p>变换矩阵A构造如下：</p>
<p>对每个vi，我们用T（vi）将它进行变换，然后用output空间的新基表示出来，</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925222409088.png" alt="image-20210925222409088" style="zoom:67%;" />

<p>然后这些系数就成为空间变换矩阵A的第一列。</p>
<p>当我们选择特征向量作为我们的基时，这个所谓的A就是<strong>特征值矩阵</strong>。</p>
</li>
</ol>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ol>
<li><p>Diagonally dominant matrices are invertible</p>
<p>即aii &gt; Σaij (i ≠ j)</p>
</li>
<li><p>LU分解中，<strong>A行首的0由L继承，列首的0由U继承</strong>，可以省下计算步骤</p>
<p>这样既可以省下计算步骤，又可以直观记录我们高斯消元的过程。关键是这是预处理。</p>
<p>Solve  Le  =  b  and then solve  Ux  =  e</p>
<p>对称矩阵的L和U是对称的（LDU），所以不用存两遍。</p>
<p>一般用PA = LU（提前置换好） 而不是 A = L1P1U1</p>
</li>
<li><p>函数空间F是无限维度的，他的子集P或Pn是幂函数空间</p>
</li>
<li><p>正交矩阵（包括旋转、置换、反射矩阵），逆 = 转置，</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921141238244.png" alt="image-20210921141238244"></p>
<p><strong>把u方向的向量转成 -u</strong></p>
</li>
<li><p>QR分解法是<strong>三种将矩阵分解的方式之一</strong>。这种方式，把矩阵分解成一个正交矩阵与一个上三角矩阵的积。QR分解经常用来解线性最小二乘法问题。QR分解也是特定特征值算法即QR算法的基础。</p>
<p>A T  A = (QR)T QR = R T Q T QR = R T  R</p>
<p>The least squares equation  A T  Ax  =A T  b  simplifies to  R T  Rx  =  R T  Q T  b.<br>Then finally we reach  Rx  =  Q T  b: good.   x = R-1 QT b</p>
<p>这样就不用求解Ax = b，直接回代 👆，非常快，最大的消耗在mn2的乘法（分解QR）。</p>
</li>
<li><p>The determinant is a linear function of each row separately (all other rows stay fixed).</p>
</li>
<li><p>Markov matrix: Each column of P adds to 1, so , 1 is an eigenvalue.</p>
<p>Pis singular, so,   0 is an eigenvalue.(其实0特征值对应的特征向量fills in nullspace)</p>
<p>【别和特征向量fill in A-λI 的零向量空间弄混，而且因为x一定有非零解，所以绝对det = 0】</p>
<p>P  is symmetric, so its eigenvectors ( 1, 1) and ( 1, -1) are perpendicular.</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210921173824970.png" alt="image-20210921173824970" style="zoom:67%;" />

<p>对于相同的特征向量，有 reflection= 2(projection) - I</p>
</li>
<li><p>当2x2矩阵有一个0特征值的时候，每个A-λI的每行都来自一个行向量(a,b)，而对应的特征向量就是(b,-a)</p>
</li>
<li><p>A and B share the same  n  independent eigenvectors if and only if  AB =  BA.</p>
</li>
<li><p>实数特征值让特征向量伸缩，而虚数让其旋转</p>
<p>对称矩阵只有实数特征值，反称矩阵只有虚数特征值。</p>
</li>
<li><p>注意，可逆性和可对角化没有关系。可对角化需要的是独立的n个特征向量，可逆性关注特征值为不为0。</p>
</li>
<li><p>线性变换可以用基 * A来表示。</p>
<p>过渡矩阵一定可逆，<strong>一个线性变换在不同的基下是相似的</strong>，这也暗含了其实是同一个空间的两组基。</p>
<p>我们也可以用奇异值分解来完成这个</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925233750506.png" alt="image-20210925233750506"></p>
<p>这时称作：isometric 等距，而不是相似。</p>
<p>这里的B就是原基到bi基的过度矩阵。👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925234616036.png" alt="image-20210925234616036"></p>
</li>
<li><p>Jordan会构造广义特征向量，而这些特征向量依附于共享特征值的 真特征向量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210925235638367.png" alt="image-20210925235638367"></p>
<p>这是为了尽可能地接近对角化！</p>
<p>同时还有个结论，当矩阵拥有相同的Jordan型时他们相似，没有例外。</p>
</li>
<li><p>好基：离散值是向量，连续值是函数。它们可能不能对角化A，但是对应用数学里的很多重要矩阵，它们能达到接近的效果，更重要的是它们直接选定，无需计算。</p>
<p>傅里叶基，λ^n = 1 ，作用是对角化了n阶置换矩阵。Px = λx，P^2x = λ^2 x。而且适用于P。。P^n 的线性组合的所有矩阵。但是</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210926094412910.png" alt="image-20210926094412910"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210926095326158.png" alt="image-20210926095326158"></p>
<p>其中，傅里叶基因其周期性而特别适用于周期性的</p>
<p>其中6是将幂级数进行正交化的结果，7是将x对应三角函数以便使用快速傅里叶变换。</p>
</li>
<li></li>
</ol>
<p>​    </p>
<h2 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h2><h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>考虑修正计算C=C+AB，这比赋值计算更典型。</p>
<p>这好几种矩阵相乘的形式虽然在数学上等价，但事实证明，由于不同矩阵乘法的内存开销不同，计算表现上会有巨大差异。</p>
<p>点积：行*列</p>
<p>saxpy：<strong>y</strong> = a <strong>x</strong></p>
<p>gaxpy: <strong>y</strong> = <strong>Ax</strong> </p>
<p>外积：列*行</p>
<p>作者从最基础的点积、saxpy、gaxpy，搭建矩阵行列划分、冒号、外积，最终将矩阵乘法分解成点积、saxpy、外积等形式。</p>
<p>i，j，k的六种排列应该<strong>从内向外依次固定其他变量来理解</strong>。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>考虑算法的运算量和存储量。</p>
<p>利用好三角矩阵、对角矩阵、带状矩阵、对称矩阵和置换矩阵的性质，可以节省许多。</p>
<p>引入带状矩阵“思想”。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>李沐-实用机器学习</title>
    <url>/2022/02/13/%E6%9D%8E%E6%B2%902/</url>
    <content><![CDATA[<p>实用机器学习——课程：【20课时】关注DS的方方面面，很实际</p>
<p><strong>Coentents</strong></p>
<p>Machine Learning topics that matter but are often skipped </p>
<p>• Data: collection, preprocessing, features, dataset shift, non-iid. data （非独立同分布）</p>
<p>• Model training: model selection, model tuning, transfer learning, distillation, multimodality, scalability </p>
<p>• Deployment: efficiency, serving, fairness </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251740.png" alt="image-20220413110451857" style="zoom:50%;" />

<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251369.png" alt="image-20220226223318983" style="zoom:50%;" />

<p>可以先训练简单的模型，比如五六十年的线性回归，用来测试数据的好坏！部署不是结束，这是个不断迭代的过程。</p>
<p>算法本身不会不公，但数据会有偏差。蒸馏是指，将模型提炼出易于部署的，较小较快的数据。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251960.png" alt="image-20220226222409869" style="zoom:50%;" />

<p>首先要关注自己公司的核心业务，把他做好，可能运气好会碰到简单问题，但也可能是无人车之类的复杂问题：</p>
<p>我们不缺数据，但是非常缺高质量的数据。最近七八年，模型的复杂度呈指数增长，越来越贵，越需要越来越多的数据。</p>
<p>当前一些行业中ML的应用：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251870.png" alt="image-20220421172359529" style="zoom: 33%;" />

<p>场景分工：沐神说现在行业还很缺data scientists，这门课<u>主要关注的就是Data science</u>         职业规划👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251545.png" alt="image-20220226223531813" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303386.png" alt="image-20220226224149527" style="zoom:50%;" /></p>
<p>领域专家还要提出建议，将机器学习用在合适的地方，因为这是一件很贵的事情。</p>
<p>SDE有很多活要干，包括管理计算资源，能够有序的训练模型整个集群并加以管理（什么定时训练，还有负载均衡），pipeline，还有可能部署很多不同版本的新老模型、实验模型，异常模型上线、下线。</p>
<p>==数据科学家==有一点“全栈的味道”，什么都要干，看上图右边，<u>获取、clean、可视化、选择、训练、部署。</u>【区别大数据开发者】</p>
<p>ML专家根据业务对模型的要求，专门<u>定制化</u>、优化模型，包括很多模型的预训练数据都是学术上的数据集，要做出对应修改，还有比如蒸馏数据模型以使得模型的规模符合要求。 还可能负责领域研究，写论文</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251239.png" alt="image-20220226225522815" style="zoom:60;" />

<p>data的协变量、概念、标签都会发生变化，而且还有许多不是假设中独立同分布的情况。</p>
<p>训练会讲模型怎么做验证，怎么做融合，调超参数。还有最近兴起的：从不同数据源获得type(文本、图片)的数据糅合起来做个大模型</p>
<p>部署，蒸馏       监控，公平性，可解释性（理解模型在干什么）</p>
<h3 id="数据获取-1"><a href="#数据获取-1" class="headerlink" title="数据获取"></a>数据获取</h3><p>当你成功把业务定义为ML问题后，第一步就是看你有没有足够多的数据，这部分是讲没有的：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251994.png" alt="image-20220301221924554" style="zoom:50%;" />

<ul>
<li>如果你有办法找到数据，那就找数据，然后融合你有的数据</li>
<li>否则就看你有没有数据生成的办法来生成数据了</li>
</ul>
<p><strong>Discover</strong></p>
<p>根据不同的用途，你要找的数据也不一样，数据集 $\neq$ 数据，<u>做产品很可能没有数据集用，就需要自己收集</u>，要注意的是收集的数据能够覆盖到场景的方方面面</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251022.png" alt="image-20220421212533126" style="zoom:33%;" />

<p><em>数据集</em></p>
<p>• MNIST: digits written by employees of the US Census Bureau   【有个叫Fashion-Mnist的】<br>• ImageNet: millions of images from image search engines<br>• AudioSet: YouTube sound clips for sound classification<br>• LibriSpeech: 1000 hours of English speech from audiobook<br>• Kinetics: YouTube videos clips for human actions classification<br>• KITTI:  traffic scenarios recorded by cameras and other sensors<br>• Amazon Review: customer reviews and from Amazon online shopping<br>• SQuAD: question-answer pairs derived from Wikipedia<br>More at <a href="https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research">https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research</a></p>
<p><em>Find Datasets</em><br>• <a href="https://paperswithcode.com/datasets">Paperswithcodes Datasets</a>: academic datasets with leaderboard 常用学术界的数据集都有，而且可以看到各论文在DS上精度<br>• <a href="https://www.kaggle.com/datasets">Kaggle Datasets</a>: ML datasets uploaded by data scientists 非常多，层次不齐（用户可上传）<br>• Google Dataset search: search datasets in the Web 搜索引擎<br>• Various toolkits datasets: tensorflow, <a href="https://huggingface.co/">huggingface</a>  工具自带的，比如torch的  hugging face专注文本的transformers<br>• Various conference/company ML competitions  一般竞赛数据集质量高，而且应用比较新。（还有奖金）<br>• <a href="https://registry.opendata.aws/">Open Data on AWS</a>: 100+ large-scale raw data 非常大，P级别<br>• Data lakes in your own organization 公司的数据堆砌</p>
<p><em>三种数据集</em>：<u>学术、竞赛、原始（处理后可能只剩下一丢丢）</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251020.png" alt="image-20220301222959267" style="zoom:80%;" />

<p>Data integration——数据库的tabel join 过程，合并许多表到同一。 缺失数据处理、去掉语义重复值。</p>
<p>Data curation can be a big projection involving multiple teams.——<u>Processing pipeline, storage, legal issue, privacy</u></p>
<p>GAN生成、图像增强、文本来回翻译哈哈</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251880.png" alt="image-20220301224146209" style="zoom:60%;" />

<p>工业上的产品就不要过于看重经典学术数据集的效果，还是得看实际。</p>
<h3 id="网页抓取"><a href="#网页抓取" class="headerlink" title="网页抓取"></a>网页抓取</h3><p>$\neq$ 爬取</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091251778.png" alt="image-20220421220019350" style="zoom: 55%;" />

<p>我们只关心网页里面的某些数据，爬是指感兴趣的网页都整个弄下来存好，抓取是只提取感兴趣的，可能变成table。</p>
<p>尽量假装成真人，整的跟攻防一样。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252742.png" alt="image-20220421220507073" style="zoom: 50%;" />

<p>整下页面，页面解析，例子：</p>
<p>获得id列表后，依次替换url的部分内容，遍历访问一堆房子页面，要自己去看网页结构，找到信息在哪。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252871.png" alt="image-20220421221305792" style="zoom:42%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303819.png" alt="image-20220421221529017" style="zoom:41%;" /></p>
<p>属于是重复劳动力，有一些自动化工具做。</p>
<p><strong>成本</strong></p>
<p>用云主要有点需求的是内存，开几个chrome挺耗内存的（2G差不多够用），CPU和网络带宽最低级就好，基本用不满的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252267.png" alt="image-20220421221943375" style="zoom:50%;" />

<p>被banned了，重启机器可以得到一个新的IP，然后继续爬。</p>
<p>除了文本，图片也是需要的，之前提到的multi-modality，就能利用多维数据【成本翻了很多倍】</p>
<p>基本思路：通过正则表达式获得所有id，然后构建url列表，随后遍历抓取。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252431.png" alt="image-20220421222348354" style="zoom:50%;" />

<p>主要开销在存储（如果存云端），你可以减少图片尺寸或慢慢传回来，后续会介绍其他方法。</p>
<p><em>法律考虑</em></p>
<p>爬取行为本身不犯法，但是要注意版权、敏感隐私信息什么的，把有版权的数据存在本地是违法的。（还有robots）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252987.png" alt="image-20220421222841067" style="zoom:50%;" />

<p>尤其是如果你爬取不是个人做分析，而是用于公司盈利，可以咨询公司的法律部门和律师。</p>
<p>如果按照沐神刚才说的一堆云实例来爬，100G 1个T可能也就几十块钱。</p>
<h3 id="数据标注"><a href="#数据标注" class="headerlink" title="数据标注"></a>数据标注</h3><p>当你有了足够数据后，你有几个选项，提高标注、数据或模型，本节讲标注。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252295.png" alt="image-20220421223410458" style="zoom:50%;" />

<p>又没钱标注又不够，就得用弱监督学习 weak supervision。</p>
<p><em>半监督学习</em></p>
<p>第三个流形假设，可能数据具有内在结构，复杂性只分布在几个维度，远远比你看到的要低。</p>
<p>scenario 设想</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252969.png" alt="image-20220421224045273" style="zoom:50%;" />

<p>自-训练——SSL的一种实现方法</p>
<p>由于不用线上部署，可以在本地选择模型复杂度更高，更贵的模型进行训练【deeper、ensemble】【不计成本、只要精度】。</p>
<p>当然，在右边“keep highly confident predictions”这就能整出各种算法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252510.png" alt="image-20220421224340822" style="zoom:50%;" />

<p><em>众包</em>——有钱人的选择</p>
<p>现在作为愈加广泛的选择，座的人越来越多了，成本也越来越低，【真的有数据标注村这种东西吗】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252595.png" alt="image-20220421224939559" style="zoom:50%;" />

<p>减少任务复杂度，能更容易找到更多的人做，价格也更便宜。</p>
<p>因为是人做的，质量会参差不齐，你得来<u>做质量控制</u>，或者找公司。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252398.png" alt="image-20220421225201094" style="zoom:50%;" />

<p>标注公司会帮你设计好这些，但是得加钱~</p>
<p><em>主动学习</em></p>
<p>结合了半监督学习的假设（少量已标号）和众包，最大化利用人的帮助。训练出模型，吐出不确定的，再训练新的，不断迭代。</p>
<p>同样可以选择比较贵的模型，比如练多个模型投票</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252033.png" alt="image-20220421225918237" style="zoom: 50%;" />

<p><em>混用</em></p>
<p>高级啊</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252521.png" alt="image-20220421230654050" style="zoom:50%;" />

<p>质量控制</p>
<p>挺麻烦的事，因为不是找的真正专家来做，有可能故意，有可能你的任务他没看懂，反正可能性很多。还有标的不好的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252166.png" alt="image-20220422155044880" style="zoom:50%;" />

<p>还有对标注工进行评估，筛掉部分。</p>
<p><em>Weak Supervision</em></p>
<p>半自动生成标号，比人标的差一点，但是还不错，够训练模型。</p>
<p>启发式学习，通过数据编程，把你对数据的认知转换为一些限制，然后</p>
<p>还有使用各大公司AI产品标号，然后聚合</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="探索性数据分析"><a href="#探索性数据分析" class="headerlink" title="探索性数据分析"></a>探索性数据分析</h3><p>只做了一小些分析，类似EDA，一般做完以后有很多块，可以share 给大家</p>
<p>本节slide：<a href="https://c.d2l.ai/stanford-cs329p/_static/notebooks/cs329p_notebook_eda.slides.html#/2">https://c.d2l.ai/stanford-cs329p/_static/notebooks/cs329p_notebook_eda.slides.html#/2</a></p>
<p>notebook:<a href="https://colab.research.google.com/drive/1zzuFXZQ0djOLZOzdQ4GNlZO-dZjdgTsv#scrollTo=ol9CO2GAzZnN">https://colab.research.google.com/drive/1zzuFXZQ0djOLZOzdQ4GNlZO-dZjdgTsv#scrollTo=ol9CO2GAzZnN</a></p>
<p>pandas基本是首选，数据要是几百G可选用别的框架更快，也可采样以后用pandas</p>
<p>matplotlib和十几年前matlab的用法比较像，seaborn在此基础上提供了更多的画法</p>
<p>svg分辨率高一点，不然默认分辨率属实是有点低。</p>
<p>推荐：<u>文本默认存成一个zip压缩文件</u>，现代工具可以直接读取使用：<code>data = pd.read_csv(&#39;house_sales.zip&#39;)</code><br>当然图片这种就没什么用，已经做了很好的压缩。使用<a href="https://arrow.apache.org/docs/python/feather.html"><code>feather</code>格式</a>，它比 CSV 读取速度更快，但使用更多磁盘空间。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'house_sales.zip'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'unicode'</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span>to_feather<span class="token punctuation">(</span><span class="token string">'house_sales.ftr'</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_feather<span class="token punctuation">(</span><span class="token string">'house_sales.ftr'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>data.drop(....,inplace = True)</code> 如果只用跑一次，直接操作内存可以省点内存。（只能跑一次xs）</p>
<p>要check它的数据的types，一般object就是pandas识别不了，或者不能转过去的类型，<u>数据类型转换也是清洗的一部分。</u></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#把代码列在这。</span>
data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'house_sales.zip'</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span>shape
data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#保留缺失值小于30%的列</span>
null_sum <span class="token operator">=</span> data<span class="token punctuation">.</span>isnull<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>columns<span class="token operator">=</span>data<span class="token punctuation">.</span>columns<span class="token punctuation">[</span>null_sum <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span>dtypes
<span class="token comment">#清理金钱列表，转成float类型，pandas的place自带正则表达式实现</span>
currency <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> <span class="token string">'Listed Price'</span><span class="token punctuation">,</span> <span class="token string">'Tax assessed value'</span><span class="token punctuation">,</span> <span class="token string">'Annual tax amount'</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> c <span class="token keyword">in</span> currency<span class="token punctuation">:</span>
    data<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span>
        <span class="token string">r'[$,-]'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span>
        <span class="token string">r'^\s*$'</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">)</span>
<span class="token comment">#清洗占地面积列表，转成同一单位的float</span>
areas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Total interior livable area'</span><span class="token punctuation">,</span> <span class="token string">'Lot size'</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> c <span class="token keyword">in</span> areas<span class="token punctuation">:</span>
    acres <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Acres'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span>  <span class="token comment">#check字符串</span>
    col <span class="token operator">=</span> data<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">r'\b sqft\b|\b Acres\b|\b,\b'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">)</span>
    col<span class="token punctuation">[</span>acres<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">43560</span>
    data<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> col
data<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#基本统计值，从中能看出数据的很多问题，比如看极值，然后看一下这些统计值符不符合正常逻辑。</span>
<span class="token comment">#通过筛选看看你认为异常的有多少。</span>
abnormal <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>areas<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>areas<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1e4</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token operator">~</span>abnormal<span class="token punctuation">]</span>
<span class="token builtin">sum</span><span class="token punctuation">(</span>abnormal<span class="token punctuation">)</span>
<span class="token comment">#画个直方图看看分布，一般对价格取个log，画的图视觉效果好，不会太奇怪，因为钱分布差距很大</span>
<span class="token comment">#插一句，沐神说再几千-几万那有个小峰值，可能是把出租的数据误爬了。</span>
ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>histplot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xlim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'%.0e'</span><span class="token operator">%</span>a <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token number">10</span><span class="token operator">**</span>ax<span class="token punctuation">.</span>get_xticks<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#看一下房子有多少种类，后面的基本都是噪音，要后续清理的，比如同一种但多个名字。</span>
data<span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span>

<span class="token comment">#画一个种类-价格的密度分布图（指定kind为‘kde’），然后可以看到房子的类别显然和价格是挂钩的</span>
types <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isin<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'SingleFamily'</span><span class="token punctuation">,</span> <span class="token string">'Condo'</span><span class="token punctuation">,</span> <span class="token string">'MultiFamily'</span><span class="token punctuation">,</span> <span class="token string">'Townhouse'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
sns<span class="token punctuation">.</span>displot<span class="token punctuation">(</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'Sold Price'</span><span class="token punctuation">:</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          <span class="token string">'Type'</span><span class="token punctuation">:</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Type'</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            x<span class="token operator">=</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">'Type'</span><span class="token punctuation">,</span> kind<span class="token operator">=</span><span class="token string">'kde'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#观察种类-房子均价的箱型图，这种方法能比较好的观察不同分布的对比。</span>
data<span class="token punctuation">[</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">]</span> <span class="token operator">/</span> data<span class="token punctuation">[</span><span class="token string">'Total interior livable area'</span><span class="token punctuation">]</span>
ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Type'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">[</span>types<span class="token punctuation">]</span><span class="token punctuation">,</span> fliersize<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#相当于x = d['Type']</span>
ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#同样，查看地域对房子均价的影响，通过邮政编码划分地域。</span>
d <span class="token operator">=</span> data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">'Zip'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isin<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Zip'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Zip'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>d<span class="token punctuation">,</span> fliersize<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span>ax<span class="token punctuation">.</span>get_xticklabels<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#查看相关系数矩阵！！！</span>
_<span class="token punctuation">,</span> ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Sold Price'</span><span class="token punctuation">,</span> <span class="token string">'Listed Price'</span><span class="token punctuation">,</span> <span class="token string">'Annual tax amount'</span><span class="token punctuation">,</span> <span class="token string">'Price per living sqft'</span><span class="token punctuation">,</span> <span class="token string">'Elementary School Score'</span><span class="token punctuation">,</span> <span class="token string">'High School Score'</span><span class="token punctuation">]</span>
sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>data<span class="token punctuation">[</span>columns<span class="token punctuation">]</span><span class="token punctuation">.</span>corr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>annot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>cmap<span class="token operator">=</span><span class="token string">'RdYlGn'</span><span class="token punctuation">,</span> ax<span class="token operator">=</span>ax<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>亲自实验的小补充：一定要设好图的范围，不然可能一片空白</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252945.png" alt="image-20220423130707454" style="zoom:50%;" />

<p>如果数据不干净，讲座数据清理；如果数据比较干净，但是不是你想要的格式，叫做数据变换；如果都没问题，但是对于模型训练比较困难，那就做特征提取。</p>
<p><strong>数据的错误</strong></p>
<p>无可避免，比如异常值，缺失值，还有语义上错误的数据，一般机器学习模型都对脏数据有一定的抵抗性，但你的模型不可避免地有精度的下降，以及拟合到错误分布的后果：用错误的数据训练出模型，用户使用后给你带了错误的反馈，如此迭代，错误累积。</p>
<p>工业上的问题就是：你没法获得如同学术数据集那样纯净的数据，也就没有一个比较好的性能参照，<u>你不知道你清理了数据以后，到底会不会有很好的提升。</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252605.png" alt="image-20220423131611257" style="zoom:50%;" />

<p>一般的错误有：</p>
<p><u>数值越界，违反规则，违反模式（语法）</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252650.png" alt="image-20220423132036498" style="zoom:50%;" />

<p>不同<em>错误举例</em>：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252318.png" alt="image-20220423133128510" style="zoom:50%;" />

<p>可以设计很多规则，如果不满足，要么编写fix的逻辑，要么直接去掉。</p>
<p>这是个迭代的过程，一边看数据，一边总结规则。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252818.png" alt="image-20220423140116217" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091252538.png" alt="image-20220423140729952" style="zoom:50%;" />

<p>这俩都是比较一般的迭代过程，基本不用手写，<u>有很多工具提供了不错的GUI界面，可以供使用。</u>沐神推荐：</p>
<p>OpenRefine——开源桌面应用程序，用于清除数据并将其转换为其他格式，该活动通常称为数据整理。</p>
<p>Trifacta Wrangler——专为分析师设计，用于探索、转换和丰富原始数据为干净和结构化的格式。</p>
<p>当然每个工具都有局限性，必要时组合多个工具进行清理。</p>
<h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><p>变换指的是，变换成<u>机器学习算法能用</u>的合适的数据类型。</p>
<p>沐神：一般来说广义的数据变形基本可以包括数据预处理的所有步骤，当然我们这里关注狭义的，也就是👇：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253166.png" alt="image-20220424190917121" style="zoom:30%;" />

<p><strong>实数值</strong></p>
<p>机器学习是<u>数值敏感的</u>，如果不经过数值范围的调整，很容易遇上梯度爆炸和消失的问题，而且在没有先验知识的条件下，数值之间的不均衡就好像赋予了一些不公平的权重。</p>
<p>Z-score的效果是很不错的。</p>
<p>Log也很好，而且log上面的加减还能等价原始数值的乘除（这相当于是关注百分比的关系而不是绝对值得关系），当<u>更关注误差的相对值而不是绝对值时</u>尤其有用（比如money，之前那个房价问题），通常用于<u>比较大而且分布较广的正数</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253896.png" alt="image-20220424191805125" style="zoom: 33%;" />

<p><strong>图片数据</strong></p>
<p>机器学习其实对低分辨率的图片做的还是挺好的（毕竟不像人是看个全局，ML都是一个一个像素看的），所以resize成比较小的尺寸，或者把中间的一块抠出来（知道边上是背景）这种既能节省存储空间，又能快速读取的方法是十分可取的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253145.png" alt="image-20220424192340770" style="zoom:33%;" />

<p>前辈们通过教训明白，下采样确实会带来精度的下降（顺便提醒了我们一番debug的艰难），所以得权衡。</p>
<p>image whitening：图片中很多的像素取值没什么用，可以通过降维的方法，减小像素取值</p>
<p>图片放在一个一个文件里读的自然慢，如果都放在一个文件里然后指定特殊的格式那肯定就会快一些</p>
<p><strong>视频</strong></p>
<p>一般都是截取视频中你感兴趣的片段进行存储、训练。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253714.png" alt="image-20220424193234240" style="zoom:33%;" />

<p>权衡：视频提供比图片好很多的压缩，但是代价是读取效率（包括解码以及视频算法常用的采样）就会变得很低。</p>
<p><strong>文本</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253647.png" alt="image-20220424194926716" style="zoom:50%;" />

<p>lemmatization——词形还原，上图中系动词的代换是语法化，后面车那个是词根化。</p>
<p>词元化：词、字符、还有最近新起的子词（subwords）<u>子词可以用来处理很大的数据集</u>，生成一个相对较小的字典处理许多生僻词。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253656.png" alt="image-20220424195537957" style="zoom:50%;" />







<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253534.png" alt="image-20220424205427062" style="zoom:33%;" />

<p>深度学习其实没有改变大的流程，而是用不同结构的神经网络（按照需求设计，比如transformer）来替换掉人工抽取这个过程。</p>
<p>所以特征抽取和最后的线性层（模型）是一起学习的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253996.png" alt="image-20220424210005444" style="zoom:33%;" />

<p>你的特征要让机器知道说有区分度，比如天按照工作日和周末区分就会知道人的表现会很不一样，但要是拿星期几来区分就徒增难度</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253433.png" alt="image-20220424210646289" style="zoom: 33%;" />

<p>图片现在已经基本用不到手动，都用预训练的深度学习模型来整了</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091253646.png" alt="image-20220424210906363" style="zoom:33%;" />



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你获取不了数据，而且生成都困难，那可能说明你这个问题不那么适合机器学习，因此就不要挣扎啦。长期迭代👇：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303755.png" alt="image-20220424211355145" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254431.png" alt="image-20220424211551417" style="zoom:33%;" /></p>
<p>但是这个滚雪球的过程你要随时监控做得够不够好，有没有走弯路。后续会讲</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254589.png" alt="image-20220424212649984" style="zoom:40%;" />

<p>数据也要做版本处理，不仅仅是模型，数据也要做到版本回滚之类的操作。</p>
<p>还有数据的安全、用户的隐私这些东西，都在数据科学家的考虑范畴指内。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>自监督学习，标号是直接从数据里面生成的。比如word2vec、BERT</p>
<p>监督学习中的 Pretrain - Finetune 流程：我们首先从大量的<strong>有标签数据</strong>上进行训练，得到预训练的模型，然后对于新的下游任务（Downstream task），我们将学习到的参数进行迁移，在新的有标签任务上进行「微调」，从而得到一个能适应新任务的网络。</p>
<p>自监督的 Pretrain - Finetune 流程：首先从大量的<strong>无标签数据</strong>中通过 pretext 来训练网络，得到预训练的模型，然后对于新的下游任务，和监督学习一样，迁移学习到的参数后微调即可。所以自监督学习的能力主要由下游任务的性能来体现。</p>
<p>监督学习目前还是<u>工业界最主流的任务</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254700.png" alt="image-20220429210745479" style="zoom: 50%;" />

<p>目前主要的监督学习分类</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254116.png" alt="image-20220429210819491" style="zoom:50%;" />



<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>工业界可能用的最多的，而且结果还不错，不太需要调参，一般是第一选择，给你个对任务的直觉。</p>
<p>由于<strong>可解释</strong>，比较敏感的行业比如保险、银行业大量使用，经常需要解释。</p>
<p>模型非常不稳定，容易收到数据噪声的影响。过拟合（可用剪枝），从上到下判断，难以并行，性能低。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254774.png" alt="image-20220429211026515" style="zoom:50%;" />

<p>提高稳定性👇</p>
<p>随机森林<u>一定要随机</u>，两种随机性：bagging（样本）、特征</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254725.png" alt="image-20220429211416307" style="zoom:50%;" />

<p>boosting，有很多种，这里讲的是gradient的boosting</p>
<p>和recnet思想十分类似，<u>顺序而不是独立的</u>训练新的树来弥补差距。因此随机森林是投票或平均，这里是求和。</p>
<p>之所以叫gradient。。。是因为计算的残差相当于是对均方根误差不断做梯度下降。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254276.png" alt="image-20220429211924053" style="zoom:50%;" />



<p><strong>线性模型</strong></p>
<p>之所以损失函数不用MSE用softmax+交叉熵，是因为MSE还要求你不正确的类的mse缩到够小，增加了额外的学习成本，而不是像softmax一样，只关心概率最大的类是正确的类就行。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>本节指的是<u>衡量最终已经训练好后的模型的好坏</u>，只跟你的超参数和采样的数据有关</p>
<p>我们要选用好一点的数据采样方法和好一点的超参数使模型泛化性更强。</p>
<h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>一个模型的评估往往要通过<u>多个指标</u>来实现，而不是仅仅一个最简单的loss函数来实现。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254991.png" alt="image-20220429213940376" style="zoom:50%;" />

<p>看一个例子：展现广告</p>
<p>虽然这是支持很多互联网公司的一个重要业务，但其实也就是个二分类问题。【愿意/不愿意点击】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254069.png" alt="image-20220429214200538" style="zoom:50%;" />

<p>常见的用于分类问题的指标：accuracy、precision、recall、F1</p>
<p>• Accuracy: # correct predictions / # examples </p>
<p>• Precision: # True positive / # (True positive + False positive) </p>
<p>• Recall: # True positive / # Positive examples • Be careful of division by 0 </p>
<p>• F1: the harmonic mean of precision and recall: 2pr/(p + r）</p>
<p>很多时候广告更关心的是区分度，优化用户体验，什么的，广告领域常用的指标有个叫做AUC、ROC，如下图：</p>
<p>0.5是完全随即预测，0是完全预测反了，1是理论最好的情况。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254011.png" alt="image-20220504125406464" style="zoom: 67%;" />

<p>当然还有很多商业上的指标：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254207.png" alt="image-20220504125851514" style="zoom:50%;" />

<p>权衡：</p>
<p>对于一个模型，我们最关注的就是AUC，但是如果我们一味的提升AUC，就会harm很多商业指标。</p>
<p>没有什么太好的方法，最好还是你训练出一个模型，<u>实际部署到线上</u>关注一下你这些商业指标的变化。达标上线，不行就继续换模型</p>
<p>所以很多时候，不能光看论文、课程里提到的模型的指标，还得去关注商业指标。</p>
<p><strong>模型验证</strong></p>
<p>通常我们会用一个测试数据集上测量的误差近似模型的泛化误差。</p>
<p>我的评价是，不如吴恩达。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254108.png" alt="image-20220504132529912" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303253.png" alt="image-20220504132705858" style="zoom: 47%;" /></p>
<h3 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h3><p><strong>Bagging</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254358.png" alt="image-20220504162802062" style="zoom:67%;" />

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bagging</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base_learner<span class="token punctuation">,</span> n_learners<span class="token punctuation">)</span><span class="token punctuation">:</span>
	 	self<span class="token punctuation">.</span>learners <span class="token operator">=</span> <span class="token punctuation">[</span>clone<span class="token punctuation">(</span>base_learner<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_learners<span class="token punctuation">)</span><span class="token punctuation">]</span>

 	<span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
 		<span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">:</span>
 			examples <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>
 			np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> replace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
 			learner<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>examples<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>examples<span class="token punctuation">]</span><span class="token punctuation">)</span>
 	<span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>
 		preds <span class="token operator">=</span> <span class="token punctuation">[</span>learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">]</span>
 		<span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果用决策树做base-learner，那就是随机森林，里面还有个随机采样特征，此处未实现。</p>
<p>主要降低方差而不是偏差，改善了不稳定性，如果模型比较stable，基本没啥效果。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254392.png" alt="image-20220504164151123" style="zoom: 50%;" />

<p>决策树就很适合bagging</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091254771.png" alt="image-20220504164433511" style="zoom:50%;" />





<p><strong>Boosting</strong></p>
<p>这个是降低偏差用的</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255819.png" alt="image-20220504165045510" style="zoom:67%;" />

<p>就是在当前基础上，把训练不好的地方再拿出来，训练一个新的模型把它做好点，然后一直迭代下去。</p>
<p>AdaBoost是一个十分经典的，理论上也十分透彻的一个算法。 【李航的书上面有】</p>
<p>这里和之前那章讲的一样，还是gradient boosting</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255390.png" alt="image-20220504191402770" style="zoom:50%;" />

<p>学习率如果调成1，非常容易过拟合。其实，学习一个$h_t$就是去拟合当前负梯度的方向，跟梯度下降基本是一样的。</p>
<p>当然此处用的是做回归的时候MSE的loss，其他问题的loss会不一样，理解意思就好。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">GradientBoosting</span><span class="token punctuation">:</span>
	 <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base_learner<span class="token punctuation">,</span> n_learners<span class="token punctuation">,</span> learning_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>
		 self<span class="token punctuation">.</span>learners <span class="token operator">=</span> <span class="token punctuation">[</span>clone<span class="token punctuation">(</span>base_learner<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_learners<span class="token punctuation">)</span><span class="token punctuation">]</span>
		 self<span class="token punctuation">.</span>lr <span class="token operator">=</span> learning_rate
	
	 <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
	 	residual <span class="token operator">=</span> y<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
	 	<span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">:</span>
	 		learner<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> residual<span class="token punctuation">)</span>
	 		residual <span class="token operator">-=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
	
	 <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>
		 preds <span class="token operator">=</span> <span class="token punctuation">[</span>learner<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">for</span> learner <span class="token keyword">in</span> self<span class="token punctuation">.</span>learners<span class="token punctuation">]</span>
		 <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>看起来这代码还挺简单的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255322.png" alt="image-20220504193143230" style="zoom: 67%;" />

<p>决策树算不得一个“弱模型”，但你可以限制最大深度，或者采样一些列来手动削弱它【让过拟合不那么严重】。</p>
<p>可以看到（左图）并没有过拟合（模型比较弱），随着n的增加，偏差在下降。当然学习率也要调好，不能太高。</p>
<p>但是毕竟是顺序训练，比较吃亏。大家都用的是：XGBoost或lightGBM，<u>算的快一点</u>。</p>
<p><strong>Stacking</strong></p>
<p>刷榜利器</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255643.png" alt="image-20220505090253634" style="zoom:33%;" />

<p>bagging采样不同的数据训练同样的模型；stacking用同样的数据训练不同的模型</p>
<p>根据模型的不一样，特征提取可能有不同的选择。</p>
<p>如果某个模型加进来不能提升精度，或者特别贵，那就可能不考虑加咯。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255956.png" alt="image-20220505091117905" style="zoom:33%;" />

<p>本来主要降低方差，引入多层以降低偏差。多层的stacking非常容易过拟合，相当于同一份数据训练多次。</p>
<p>需要很多手段避免过拟合：</p>
<p>如果每层用一部分数据，这样有点亏，也可以k折</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255011.png" alt="image-20220505091352416" style="zoom:33%;" />

<p>由于每个模型都在没有参与训练的$1/k$数据上预测，然后把结果交给下一层，减缓了过拟合。但是还有一定程度。</p>
<p>更昂贵的降低过拟合：重复1，2步骤n次，每次把验证集的输出并成大小一致的数据集，取平均。。。进一步降低偏差。</p>
<p>每个小模型训练$k*n$次</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> autogluon<span class="token punctuation">.</span>tabular <span class="token keyword">import</span> TabularPredictor
predictor <span class="token operator">=</span> TabularPredictor<span class="token punctuation">(</span>label<span class="token operator">=</span>label<span class="token punctuation">)</span><span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train<span class="token punctuation">,</span> num_stack_levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> num_bag_folds<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255396.png" alt="image-20220505092637454" style="zoom:50%;" />





<h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>benchmark选择高质量工具包的初始参数，或者论文里的参数，当然论文里的参数一般绑定了某个数据集，但是有时候通用性不错。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255688.png" alt="image-20220505094121711" style="zoom:33%;" />

<p>记得李宏毅的优化：Adam对超参数不那么敏感，容易调一些；SGD对超参数敏感，难调，但是调好了效果更好。</p>
<p>管理好你的调参日志：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255872.png" alt="image-20220505094723790" style="zoom:33%;" />

<p>TensorBoard   和   weights&amp;bias 比较好的工具</p>
<p>环境：xs，李沐吐槽python很多库只管加兼容性，不考虑旧代码的可维护性，python本身也是如此。</p>
<p>代码、随机种子：如果随机性给你的结果抖动比较大，那可能出了问题，可能是数据、dropout、某些库带来的随机性。【可以ensembling、bagging】</p>
<p>总的来说复现实验也是很麻烦的事情</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255507.png" alt="image-20220505095939754" style="zoom:33%;" />

<p>自动调参，可能比人来调参的成本低。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255654.png" alt="image-20220505100036409" style="zoom:33%;" />

<p>超参数优化(HPO)、神经网络架构搜索(NAS)</p>
<h3 id="HPO"><a href="#HPO" class="headerlink" title="HPO"></a>HPO</h3><p>搜索空间</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255493.png" alt="image-20220505145604934" style="zoom:33%;" />

<p>每加一个参数的几个选项，昂贵程度指数上涨。但也不能太小，不然搜的结果不行。</p>
<p>因此你要<u>根据经验选择比较合适的初始区间。</u></p>
<p>• HPO algorithms: Black-box or Multi-fidelity </p>
<p>​    • Black-box: treats a training job as a black-box in HPO: • Completes the training process for each trial </p>
<p>• Multi-fidelity: modifies the training job to speed up the search </p>
<p>​    • Train on subsampled datasets<br>​    • Reduce model size (e.g less #layers, #channels)<br>​    • Stop bad configuration earlier </p>
<p>关心的是超参数之间的重要程度排序，这个时候并不是在选具体参数数值，只要排序就好了</p>
<p>如果你不知道任务细节，而且任务不太大，也能用黑盒来算。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255301.png" alt="image-20220505150850833" style="zoom:40%;" />

<p>模拟退火和遗传可见《最优化导论》</p>
<p><em>Grid Search</em>：穷举搜索，有可能顺序没选好，训半天提升不大，最后猛涨。</p>
<p><em>Random Search</em>：随机搜索，非常有效，没甚么idea就用这个，一般是用完现有资源，比如有两台机子，能跑一晚上，就先跑完看结果；或者看目前最好的结果，如果一段时间都没有变化，或变化不大就可以停了，因为是随机算法，后续再暴涨概率不大。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
	config <span class="token operator">=</span> random_select<span class="token punctuation">(</span>search_space<span class="token punctuation">)</span> 
    train_and_eval<span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token keyword">return</span> best_result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>贝叶斯优化</em>，目前还在快速发展，暂时用的不多。</p>
<p>如下图例子：横轴是搜索空间，纵轴是目标函数。怎么感觉插值能用在这</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091255809.png" alt="image-20220505152522581" style="zoom:33%;" />

<p>获取函数会选取：不那么置信而且预测效果可能比较好的点作为下个采样点。</p>
<p><u>权衡探索和开发</u>，找新的最优点，或在已有比较好的点附近看一看；其实很多ML算法(特别是迭代式的)都是这两者的权衡。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256902.png" alt="image-20220505154104922" style="zoom:33%;" />

<p>刚开始接近随机搜索，而且这个过程是串行的，随即搜索是并行的。</p>
<p>现实生活中，大家还是用的随即搜索多一点。</p>
<p><em>Successive Halving</em>（连续减半）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256812.png" alt="image-20220507194327650" style="zoom: 67%;" />

<p>通常n取大一点，比如100；m取小一点，比如1或2.</p>
<p>把更多的资源分配给更有潜力的！但是问题是n和m不太好取！</p>
<p><em>Hyperband</em></p>
<p>真正的在实际中<u>用得比较多的算法</u>，可以尝试！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256414.png" alt="image-20220507194623483" style="zoom:67%;" />

<p>这样子，对n和m的取值就不那么敏感。</p>
<p>还有更多的其他思路的Multi-fidelity HPO。</p>
<p><u>总有一些超参数，不管放到哪里结果都不错</u>，可以去kaggle看比赛第一第二、或者论文里的超参数，都是你抄我我抄你。<br>如果你能找到，那超参数其实是一件很简单的事情！</p>
<h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><p>Neural Architecture Search</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256767.png" alt="image-20220507200000893" style="zoom:67%;" />

<p>最开始的work使用RL来整的，RL炼起来虽然强大，但是巨贵。</p>
<p>后面有一些工作来加速，后来有个工作叫做one-shot，是一种方法</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256997.png" alt="image-20220507200430990" style="zoom:50%;" />

<p>通过学习，决定哪条路比较好，有点注意力机制的味道👇，后续还有很多工作进行改进。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256785.png" alt="image-20220507200703733" style="zoom: 67%;" />

<p>Efficient Net的思想是，调结构不要一个一个调，要一起联动着调。比如之前说的，网络变深，通道就变长。</p>
<p>最终只用调整一个参数，也就是下文的$\phi$（与模型复杂度有关）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256012.png" alt="image-20220507201054729" style="zoom:50%;" />

<p>最终结果很棒，这是大家发现的一个<u>简单但是实用</u>的方法！</p>
<p>NAS目前还在快速发展，有几个研究重点：</p>
<p>比如：你搜出来的东西是不是“可解释的”，搜出来效果特别好但是长得很奇怪，大家也不知道咋用</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091256330.png" alt="image-20220507201722136" style="zoom:67%;" />

<p>移动设备上的模型，得权衡精度、延迟、功耗等等。</p>
<h3 id="Deep-Network-Tuning"><a href="#Deep-Network-Tuning" class="headerlink" title="Deep Network Tuning"></a>Deep Network Tuning</h3><p>讲深度神经网络里一些共用的设计模式！</p>
<p>。。。批量和层归一化。残差连接。注意力机制。</p>
<p>(未完待续，等李沐老师继续更新！)</p>
]]></content>
  </entry>
  <entry>
    <title>集表象以求真</title>
    <url>/2021/08/22/%E9%80%86%E6%B0%B4%E8%A1%8C%E8%88%9F/</url>
    <content><![CDATA[<h2 id="集表象以求真"><a href="#集表象以求真" class="headerlink" title="集表象以求真"></a>集表象以求真</h2><p>境界不够，无从辩驳</p>
<ol>
<li><p>大多数人所谓的思考，不过是在重复过去的偏见</p>
</li>
<li><p>寻找初心，清楚所需，分辨主次，是人这一生最重要的事，看似最简单，实则最难。任何一个觉得自己差不多能做到的人，都绝对没做到。我做不到，所以我每过一段时间要思考这个问题，要强化认识。更何况，世界在变化，我也会变化</p>
</li>
<li><p>人只有从高处俯视，才能选对正确的道路</p>
</li>
<li><p>我有种错觉，他在大多数情况下只是个普通人，普通到不能在普通的人。但是，他总能在关键的时候，变得不普通。我感觉，他不是天才，但他总能在特别的领域和特别的时间，无限接近天才。</p>
</li>
<li><p>这种完全符合人类需求和历史趋势的商品，永远不可能赔钱，最多是传播速度快慢而已</p>
</li>
<li><p>适当展示力量，胜过遮遮掩掩</p>
</li>
<li><p>没有必然的成功，只有必然的收获。法斯特将军所谓的幸运，是凭借一步一步的收获，抓住了机会。不幸运的人，不是没有机会，而是没有足够多的收获。成功是外求，收获是内求</p>
</li>
<li><p>你现在可以选择两种思考方式，一种是目标思维，我们只关注有益于目标的事情，不关注其他。遇到阻碍，我们把‘解决障碍’当作目标，一切无益于解决障碍的事情，都不考虑。一种，就像你现在的思考方式，总是去想那些与目标无关的事，本质上，你在逃避.</p>
</li>
<li><p>其实每个人都有更多的选择，只是大多数时候，我们放弃最好的选择。不过，每个选择，都是当下最好的。</p>
</li>
<li><p>雪崩之下，没有一片雪花是无辜的</p>
</li>
<li><p>再睿智的目光，也只能看到前方，再狭隘的视线，也可能看到智者的盲区。</p>
</li>
<li><p>大人们做事最恶毒，而孩子们说话最恶毒</p>
</li>
<li><p>贵族的特权，与生俱来；贵族的责任，自始至终</p>
</li>
<li><p>力量越大，责任越大，这句话不是保护别人，是自己。是为了避免自己失控。责任并不是约束，就像衣服并不是为了阻挡我们，是保护。</p>
</li>
<li><p>将自己举到高处的人，也预留出跌落的距离</p>
<p>  因蒙他人荣耀而获得的特权，也必将因放弃承担责任而失去</p>
</li>
<li><p>确实。金钱的确与罪恶有关，但带来罪恶的不是金钱，而是人。</p>
</li>
<li><p>因为，我们容易被表层目标吸引，忘记探索深层目标，也就永远解决不了问题</p>
</li>
<li><p>我喜欢和聪明人交往，因为我不用考虑他们的自尊</p>
<p>  这句话并不是说不尊重他人，而是在说，真正的聪明人，在做任何事的时候，都明白‘自己要做什么’，而不是把次要的脸面、尊严和情绪等等放在首要位置，凡是把这些元素放在首要位置的人，连最基本的主次都分不清，自然无法成为聪明人。而另一个意义是，一旦我们和分不清主次轻重的人交流，我们为了交流更顺畅，就不得不考虑其他因素，从而让自己付出更多的沟通成本，而世界上大部分的沟通成本，都在阻挠人类进步。当然，另一方面来说，另一种聪明的人，会掌握沟通的方式，降低沟通成本，也就是利用别人的情绪、尊严和虚荣的弱点，掌握主动，获益。</p>
</li>
<li><p>这让我意识到，反对传播知识的人，维护的不是知识本身；反对白化病患者的人，维护的不是人，而是他们的‘旧日的正确“</p>
</li>
<li><p>一个有强大学习能力的人，在小时候可以这么说，但成年之后，不会把核心放在有没有好老师教、有没有好的父母关爱、有没有好的环境熏陶、有没有好的过去，而是把核心回归自身，去追寻自己想要的一切，自己去培养想成为的自己</p>
</li>
<li><p>当一个人相信自己看到的就是真实的时候，那么制作这段真实的人，就已经成了他的主宰</p>
</li>
<li><p>是的，很多人内心邪恶，却没有犯罪，这样的人，你不能说他是好人，但他绝对不是坏人。</p>
<p>很多人内心带着挣扎与忏悔，却做了坏事，他以为自己没得选，只想做个好人，但本质上，却就是一个坏人。</p>
</li>
<li><p>“就是字面意思，我们做出了某些选择，就代表我们也放弃了某些选择。</p>
<p>如果我们要因为放弃的选择而自责，那我们以后永远无法做出选择。”</p>
</li>
<li><p>信息差，不见得就是你知道的比别人多，有时候只要能够改变信息的对错，就能够瞒天过海</p>
</li>
<li><p>人的一生，穷的时候基本都是拿面子换钱，有钱了就拿钱买面子</p>
</li>
<li><p>所以人类啊……其实给予他们一个堕落的环境，他们堕落起来大概比谁都痛快。</p>
</li>
<li><p>对外人包容，对亲近的人刻薄。用百分之四十的谎言来覆盖百分之七十的生活。对一个事物的爱似乎是有极限的，一旦想要去爱着某个新生的事与人，就必须从过往的事与人里抽离出一部分爱。小心翼翼却又狂妄自大。另外……无法互相理解，且脆弱，容易死亡</p>
</li>
<li><p>这个世间有很多的故事，原本很简单明朗，其中曲折与狗血，就是两个字——不说。所以做人有时候……也没有那么麻烦。不过是坦荡，坦诚，坦白罢了。</p>
</li>
<li><p>身在这个环境里，他无力改变，只能融入，但他一直还记得，自己为什么要进入这个环境，所以无论什么时候，他始终没有放弃，自己应该做的事情</p>
</li>
<li><p>人做出每一种行为，都有背后的逻辑与动力在支撑。</p>
<p>  他们看起来只是这简单的行为无法做到，但实际上是行为背后的逻辑与动力出问题了。</p>
<p>  机械零件的缺损与燃料的不足，都会导致运转不灵。</p>
<p>  可怜的是，很多人能够理解机械，却理解不了同类</p>
</li>
<li><p>如果你现在感觉很难过，很累的话，那我们就什么都不要理了。我们现在就回家，好好的吃个饭，洗个澡，再睡上一觉。别的一切，都跟我们没有什么关系。我们不需要一直背负着这些东西啊，能好好的活着就很好了。我们凭什么不能让自己更轻松些呢</p>
<p>我还是有点不甘心,因为，事情不该是这个样子的,既然不对，那就让事情回到他应该有的轨迹吧</p>
</li>
<li><p>受害者不完美，不同获得你完美的同情，加害者也不完美，不能承受你完美的愤怒。这么一个不完美的世界里，又怎么装得下你那份完美的正义感</p>
<p>真要审判，那就按着统一的标准，一视同仁的去审判所有人，这才叫公平，但是当你们只能审判比你们弱小的人时，就默认了会放过所有比你们强大的人，也放过了一批虽然做了错事，但却从来不认为自己错了的人，你们的公平，已经打了折扣，便不再是公平</p>
<p>无法审判所有人的审判，本来就应该是被审判的</p>
</li>
<li><p>你不必自责，即便不是百分之百的善意，做了一些善良的事情，也是值得感谢的。就如即便没有抱着歹意，但对别人造成了伤害的也要受到惩罚。</p>
</li>
<li><p>人生是无需后悔的，就像是复杂的数据经过精密的计算也只会有一个结果，把如今的自己投放到了曾经的过去，在当时的具体数据之下，自己做出来的，也是一样的选择。</p>
<p>感知、情绪、欲望、认识、本能、记忆，才是决定一切的数据。</p>
</li>
<li><p>生与死的真谛，不在于生，也不在于死，不在于它的状态，而是……它转变的那个过程。</p>
</li>
<li><p>你到底爱的是汉德，还是爱的是希望做一个健全儿子的父亲的你自己</p>
</li>
<li><p>大时代下，他的领悟，他的痛苦，一文不值，无人问津</p>
</li>
<li><p>只是踩着父母的肩，见识了父母未曾见过的繁华</p>
</li>
<li><p>天予不取，反受其咎。 时至不迎，反受其殃</p>
</li>
<li><p>只记得坚持，却忘记了为何坚持</p>
</li>
<li><p>受国之垢，是谓社稷主。受国不祥，是为天下王</p>
</li>
<li><p>一朝英雄拔剑起，又是苍生十年劫</p>
</li>
<li><p><a href="https://www.slkj.org/c/28647.html">日出扶桑一丈高，人间万事细如毛</a>。<a href="https://www.slkj.org/c/28648.html">野夫怒见不平处，磨损胸中万古刀</a>。</p>
</li>
<li><p>看见天才失败，堕入尘埃，对于失败者来说，固然会有一时的爽感，但是看见天才不努力，挥霍自己的天赋，才是最让失败者揪心的</p>
</li>
<li><p>追求真理的生物，和追求存在的生物……前者根基于后者之上，它是后者的进化和衍生。</p>
</li>
<li><p>人可以犯错，但不能将错误装饰成‘必要的正确’。</p>
</li>
<li><p>智慧诞生，不是为了遵循规则和宿命，去遵循他人应允的‘未来’，而是为了追寻‘更好的未来’，‘更多可能的改变’。</p>
</li>
<li><p>牺牲，是捷径！</p>
</li>
<li><p>是因为我们选择了这条道路，这条道路才能成为大道，而并非是大道成就了我们，选择了我们</p>
</li>
<li><p>【审判的要素，并不是仇恨，首先是因为爱。因为爱所有良善的人，所以才要去惩戒所有为恶的人。】</p>
</li>
<li><p>沉默。唯有沉默是最高的轻蔑。提出质疑，就是因为认可了对方一部分的道理，所以才会有欲望去询问，纠正，质疑和抬杠。</p>
</li>
<li><p>因为众生一直都在反抗这个世界，一直都在同命运战斗，所以被称为圣皇的男人才会有勇气，一直坚持继续战斗下去。</p>
</li>
<li><p>质疑和反抗本身就比答案还重要，因为答案也只是暂时的，一切都会革新，改变，追求完美的答案本身，就是一个不完美的想法</p>
</li>
<li><p>革新本身是正确的，但是没有任何一种革新是绝对正确的，任何不了解当地客观情况，不与实际相结合的革新，都不是真正的革新，而是一种恶，一种名为傲慢，自以为‘正确’，所以便强行要求其他人‘改变’的恶。</p>
<p>  真正的革新，需要积累经验，观察现实。需要根据每一地，每一群人，每一个社会，文明和世界各不相同的情况，进行各不相同，各具特色的革新。</p>
<p>  所以，革新一开始，就不能是完美无瑕的。它的的确确有着缺漏，错误，和不完善的地方，所以才需要去改正，变革，修复，去见原本错误的地方，修补成正确的。</p>
</li>
<li><p>当最强者确定了自己的理想，整个世界中不存在另外一个人去反驳，质疑，挑衅他，只能任由他施为，做‘正确’的事情之时，那么整个世界就会只剩下一个声音，所有的梦想，欲望，乃至于意志，都会被最强者扭曲。</p>
<p>  这就是扼杀了无数未来和希望，乃至于可能性的‘极度邪恶’！</p>
<p>而保持独立，就是强者的特权</p>
</li>
<li><p>每个人类个体的存在都有意义？？随着技术的进步，这一概念最终将有明确的对错吗？</p>
</li>
<li><p>它就是最大的伤害，最大的欺压，最大的不公和压迫，最强最恶的正义和善良。【永恒秩序】</p>
</li>
<li><p>扎根于已经存在的万事万物之上，承认欢笑，也承认苦难，相较于昨日的‘更完美’。这就是革新的真意，革新从来都不否认错误，而是承认错误，加以改正。</p>
</li>
<li><p>旧文明把人变成神……而新文明，我们想要让神变成人。</p>
</li>
<li><p>生命没有任何意义，存在的理由只能自己去追寻和坚信</p>
</li>
<li><p>如果说，一切的‘美好表象’，反而令人脚步停滞在原地，无法向前探索的话……那么毁灭，反倒是一种赐福</p>
</li>
<li><p>引领而不强制，交流而不命令——所有人心中皆有革新的种，我只需要将其点燃，催发，而不是拔苗助长。</p>
</li>
<li><p>爱并非是单纯的，单方面的付出。爱也是一种攻击，一种强大的力量</p>
</li>
<li><p>思想会破碎，会腐朽，但却是不会畏惧痛苦的</p>
</li>
<li><p>苍天何辜？受此佶问<br>【好人一样是人，凭什么就得一路顺风万事如意？好人就得占尽所有好处，不能受半点苦，也不能遭半点罪？】</p>
<p>  【这才不是天理，这只是一厢情愿，自以为是】</p>
</li>
<li><p>做很多工作，从事很多行业，应聘很多岗位，都需要考证，都需要过关，就像是考驾照一样，你得被确认自己技术过关，交通法规认知熟悉，还得让你上路去开，看看你是否能经得起考验<br>但是当父母，不需要考证。</p>
</li>
<li><p>孤独的人，甚至会对对手报以憧憬。</p>
</li>
<li><p>姜望在心里把这名字默念了几遍，也好像把某种责任，系在了道心上。</p>
</li>
<li><p>为众人抱薪者，不可使其冻毙于风雪！</p>
</li>
<li><p>我从来没有在我们佑国，见到过这么天才的修士。”</p>
<p>  “我在想。”他说：“像这样的天才，若给他机会成长起来。难道不能够成为佑国的擎天之柱吗？难道不足以守护佑国吗？”</p>
<p>  赵苍眼皮微抬，淡淡道：“有比他更天才的，但是都没有机会成长，都战死了。”</p>
<p>  他补充道：“在护国圣兽出现之前。”</p>
</li>
<li><p>在这个世界上，无论什么人，什么事物，哪怕一块焦炭，一张废纸，都有他的用法。可靠有可靠的用法，不可靠有不可靠的用法</p>
</li>
<li><p>每个人一生当中都会在某个阶段拥有至交好友或者闺蜜，可再过一段时间呢？很可能就不是了</p>
</li>
<li><p>女人的一生中，需要亲友爱人。而男人的一生中，亲友爱人可有可无，但惟独不能缺少对手。</p>
</li>
<li><p>人千方百计的学习，来认知世界，知晓规则，就是要利用规则。若是被规则牵绊，反而因为自身所学而束手束脚，这才是真正的悲剧。</p>
</li>
<li><p>所谓的信誉，都是狗屁，不过是利益小，打动不了内心罢了。”</p>
</li>
<li><p>这个世界上，总会有一群“老”人。他们四处兜售着社会的经验，把他人的理想当做幻想，把他人的热情当做轻狂，把他人的坚持当做桀骜。他们常在教训后辈中，寻找自己的存在感和优越感。</p>
</li>
<li><p>爱慕虚荣的人，都会变得愚蠢。他们常常为了虚无的美丽，而默默忍受痛楚，放弃真正应该追求的东西。”</p>
</li>
<li><p>生死是世间最大的公平</p>
</li>
<li><p>生活不易，就如逆水行舟，不进则退。</p>
</li>
<li><p>我平生最看不起那些承受不了困惑和痛苦，就把思考的权力拱手让人的懦夫</p>
</li>
<li><p>没有伞的孩子，必须努力奔跑。</p>
</li>
<li><p>慈不掌兵、义不养财、善不为官、情不立事、仁不从政</p>
</li>
<li><p>有的时候，你的价值，是敌人赋予你的</p>
</li>
<li><p>未经他人苦，莫劝他人善</p>
</li>
<li><p>“敌强我弱，只有先退一步，才有腾挪的空间。”</p>
</li>
<li><blockquote>
<p>“剑是用来杀死敌人的，这是剑最质朴的道理。”</p>
<p>　　“你想说，你杀的都是该杀之人”</p>
<p>　　“不，没有任何人，生来应当死在剑下。”</p>
<p>　　“身为剑客，不必问杀了谁，但问救了谁。”</p>
</blockquote>
</li>
<li><p>当你相信命运的时候，命运就会替你做主。</p>
</li>
<li><blockquote>
<p>“命运没有给他们退路，但给了我，如此而已。”</p>
<p>　　“假若你也没有退路呢？”</p>
<p>　　“那就不退。”</p>
</blockquote>
</li>
<li><p>“在杀人这件事上，任何巧合都是拙劣的布置，只会让老手发笑。</p>
</li>
<li><p>对于一个故事来说，当最引人注目的矛盾消失之时，故事便到了结束的时候。</p>
</li>
<li><p>学成文武艺，货于帝王家</p>
</li>
</ol>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>李宏毅深度学习</title>
    <url>/2022/03/01/%E6%9D%8E%E5%AE%8F%E6%AF%85/</url>
    <content><![CDATA[<h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h3 id="Spatial-Transformer"><a href="#Spatial-Transformer" class="headerlink" title="Spatial Transformer"></a>Spatial Transformer</h3><p>普通的CNN能够显示的学习平移不变性，以及隐式的学习旋转不变性，但attention model 告诉我们，与其让网络隐式的学习到某种能力，不如为网络设计一个显式的处理模块，专门处理以上的各种变换。</p>
<p>李宏毅: CNN其实没有scaling的不变性，rotation的泛化性也不是很强。【not invariant to them】<br>translation的泛化性有一些，可以归功于max-pooling。但没有“完全的平移泛化性”</p>
<p>【<u>不然为啥还要数据增强呢xs</u>】</p>
<p>Spatial transformer 也是一种layer，放在了CNN的前面，用来转换输入的图片数据，其实也可以转换feature map,因为feature map说白了就是浓缩的图片数据，所以Transformer layer也可以放到CNN里面。</p>
<p>旋转和平移其实只用六个参数就能完全表示。</p>
<p>针对输出不是整数的情况，采用的是相邻点加权的方式。【不然没法反向求导】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953076.png" alt="image-20220413190037195" style="zoom:50%;" />

<p>基本架构如下：【可以放在CNN外和CNN内】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953177.png" alt="这里写图片描述" style="zoom: 50%;" />

<p>主要的部分一共有三个，它们的功能和名称如下：</p>
<p>参数预测：Localisation net<br>坐标映射：Grid generator<br>像素的采集：Sampler</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953889.png" alt="image-20220413190310131" style="zoom:50%;" />

<p>直观理解，ST相当于提供一个更稳定的输入。cool啊</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953862.png" alt="image-20220413190529672" style="zoom:50%;" />





<h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><a href="https://www.jiqizhixin.com/articles/2018-12-10-8">从Word Embedding到Bert模型——自然语言处理预训练技术发展史</a></p>
<p>有人提到，图像、语音属于比较自然地低级数据表示形式，在图像和语音领域，最基本的数据是信号数据，我们可以通过一些距离度量，判断信号是否相似，在判断两幅图片是否相似时，只需通过观察图片本身就能给出回答。<br>而语言作为人类在进化了几百万年所产生的一种高层的抽象的思维信息表达的工具，其具有<u>高度抽象</u>的特征，文本是符号数据，两个词只要字面不同，就<u>难以刻画它们之间的联系</u>，即使是“麦克风”和“话筒”这样的同义词，从字面上也难以看出这两者意思相同（语义鸿沟现象），可能并不是简单地一加一那么简单就能表示出来，而判断两个词是否相似时，还需要更多的背景知识才能做出回答。</p>
<p>那么据上是不是可以自信地下一个结论呢：如何有效地表示出语言句子是决定NN能发挥出强大拟合计算能力的关键前提！</p>
<p><strong>语言模型</strong></p>
<p>语言模型包括文法语言模型和统计语言模型，一般我们指的是统计语言模型。</p>
<p>统计语言模型： 统计语言模型把语言（词的序列）看作一个随机事件，并赋予相应的概率来描述其属于某种语言集合的可能性。给定一个词汇集合 V，对于一个由 V 中的词构成的序列S = ⟨w1, · · · , wT ⟩ ∈ Vn，统计语言模型赋予这个序列一个概率P(S)，来衡量S 符合自然语言的语法和语义规则的置信度。一个句子的打分概率越高，越说明他是更合乎人说出来的自然句子。</p>
<p>常见的统计语言模型有N元文法模型（N-gram Model）</p>
<p>理想的语言模型就能够基于模型本身生成自然文本。 与猴子使用打字机完全不同的是，从这样的模型中提取的文本 都将作为自然语言（例如，英语文本）来<u>传递</u>。 只需要基于前面的对话片断中的文本， 就足以生成一个有意义的对话。 显然，我们<u>离设计出这样的系统还很遥远， 因为它需要“理解”文本，而不仅仅是生成语法合理的内容。</u></p>
<p><u><strong>表示方法</strong></u></p>
<ol>
<li>独热表示one-hot representation</li>
</ol>
<p>最直观，也是到目前为止<u>最常用</u>的词表示方法？<br>向量的维度会随着句子的词的数量类型增大而增大<br>任意两个词之间都是孤立的，根本无法表示出在语义层面上词语词之间的相关信息，而这一点是致命的。</p>
<ol start="2">
<li>分布式表示distributed representation</li>
</ol>
<p>分布假说：<u>词的语义由其上下文决定</u>（ a word is characterized by thecompany it keeps）。<br>根据建模的不同，主要可以分为三类：基于矩阵的分布表示、基于聚类的分布表示和基于神经网络的分布表示。【均基于分布假说】</p>
<p>两部分：<u>一、选择一种方式描述上下文；二、选择一种模型刻画目标词与其上下文之间的关系。</u></p>
<p><em>分布式表示</em></p>
<ol>
<li><p>基于矩阵的分布表示 基于矩阵的分布表示通常又称为分布语义模型，在这种表示下，矩阵中的一行，就成为了对应词的表示，这种表示描述了该词的上下文的分布。由于分布假说认为上下文相似的词，其语义也相似，因此在这种表示下，<u>两个词的语义相似度可以直接转化为两个向量的空间距离。</u></p>
<p>常见到的Global Vector 模型（GloVe模型）是一种对“词-词”矩阵进行分解从而得到词表示的方法，属于基于矩阵的分布表示。</p>
</li>
<li><p>基于聚类的分布表示 基于聚类的分布表示作者也还不是太清楚，所以就不做具体描述。</p>
</li>
<li><p>基于神经网络的分布表示，词嵌入（word embedding）</p>
</li>
</ol>
<p><strong>词嵌入/词向量</strong></p>
<p>在前面基于矩阵的分布表示方法中，最常用的上下文是词。如果使用包含词序信息的 n-gram 作为上下文，当 n 增加时， n-gram 的总数会呈<u>指数级增长</u>，此时会遇到维数灾难问题。而神经网络在表示 n-gram 时，可以通过一些组合方式对 n 个词进行组合，参数个数仅以线性速度增长。有了这一优势，神经网络模型可以对更复杂的上下文进行建模，在词向量中包含更丰富的语义信息。</p>
<p>而神经网络在表示 n-gram 时，可以通过一些组合方式对 n 个词进行组合，参数个数仅以线性速度增长。有了这一优势，神经网络模型可以对更复杂的上下文进行建模，在词向量中包含更丰富的语义信息。</p>
<blockquote>
<p>当你的任务的训练集相对较小时，词嵌入的作用最明显，所以它广泛用于<strong>NLP</strong>领域。我只提到一些，不要太担心这些术语（下问列举的一些<strong>NLP</strong>任务），它已经用在命名实体识别，用在文本摘要，用在文本解析、指代消解，这些都是非常标准的<strong>NLP</strong>任务。</p>
<p>词嵌入在语言模型、机器翻译领域用的少一些，尤其是你做语言模型或者机器翻译任务时，这些任务你有大量的数据。</p>
</blockquote>
<p>统计语言模型statistical language model就是给你几个词，在这几个词出现的前提下来计算某个词出现的（事后）概率。</p>
<p>可以参考参考李沐的：<a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html">https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html</a></p>
<p>CBOW也是统计语言模型的一种，顾名思义就是根据某个词前面的C个词或者前后C个连续的词，来计算某个词出现的概率。Skip-Gram Model相反，是根据某个词，然后分别计算它前后出现某几个词的各个概率。</p>
<p>实现CBOW（ Continuous Bagof-Words）和 Skip-gram 语言模型的工具正是word2vec！另外，C&amp;W 模型的实现工具是SENNA。</p>
<p>NNLM 是怎么训练的？是输入一个单词的上文，去预测这个单词。这是有显著差异的。为什么 Word2Vec 这么处理？原因很简单，因为 Word2Vec 和 NNLM 不一样，NNLM 的主要任务是要学习一个解决语言模型任务的网络结构，语言模型就是要看到上文预测下文，而 word embedding 只是无心插柳的一个副产品。但是 Word2Vec 目标不一样，它单纯就是要 word embedding 的，这是主产品，所以它完全可以随性地这么去训练网络。</p>
<p><strong>预训练过程（18年以前）</strong></p>
<p>句子中每个单词以 Onehot 形式作为输入，然后乘以学好的 Word Embedding 矩阵 Q，就直接取出单词对应的 Word Embedding 了。那个 Word Embedding 矩阵 Q 其实就是网络 Onehot 层到 embedding 层映射的网络参数矩阵。</p>
<p>所以你看到了，使用 Word Embedding 等价于什么？等价于把 Onehot 层到 embedding 层的网络用预训练好的参数矩阵 Q 初始化了。这跟前面讲的图像领域的低层预训练过程其实是一样的，区别无非 Word Embedding <u>只能初始化第一层网络参数，再高层的参数就无能为力了。</u>下游 NLP 任务在使用 Word Embedding 的时候也类似图像有两种做法：</p>
<ul>
<li>一种是 Frozen，就是 Word Embedding 那层网络参数固定不动；</li>
<li>另外一种是 Fine-Tuning，就是 Word Embedding 这层参数使用新的训练集合训练也需要跟着训练过程更新掉。</li>
</ul>
<blockquote>
<p><strong>ELMO</strong></p>
<p>word embedding多义词问题。我们知道，多义词是自然语言中经常出现的现象，也是语言灵活性和高效性的一种体现。</p>
<p>在用语言模型训练的时候，不论什么上下文的句子经过 word2vec，都是预测相同的单词 bank，而同一个单词占的是同一行的参数空间，这导致两种不同的上下文信息都会编码到相同的 word embedding 空间里去。所以 word embedding 无法区分多义词的不同语义，这就是它的一个比较严重的问题。</p>
<p><u>ELMO</u> 提供了一种简洁优雅的解决方案。【论文：Deep contextualized word representation】</p>
<p>在此之前的 Word Embedding 本质上是个静态的方式，所谓静态指的是训练好之后每个单词的表达就固定住了<br>ELMO 的本质思想是：我事先用语言模型学好一个单词的 Word Embedding，此时多义词无法区分，在我实际使用 Word Embedding 的时候，单词已经具备了特定的上下文了，这个时候我可以根据上下文单词的语义去调整单词的 Word Embedding 表示，这样经过调整后的 Word Embedding 更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。</p>
<p>所以 ELMO 本身是个根据当前上下文对 Word Embedding 动态调整的思路。</p>
<p>ELMO 的预训练过程不仅仅学会单词的 Word Embedding，<u>还学会了一个双层双向的 LSTM 网络结构</u>，而这两者后面都有用。 </p>
<p>多义词问题解决了吗？解决了，而且比我们期待的解决得还要好。</p>
<p>对于 Glove 训练出的 Word Embedding 来说，多义词比如 play，根据它的 embedding 找出的最接近的其它单词大多数集中在体育领域，这很明显是因为训练数据中包含 play 的句子中体育领域的数量明显占优导致；而使用 ELMO，根据上下文动态调整后的 embedding 不仅能够找出对应的「演出」的相同语义的句子，而且还可以保证找出的句子中的 play 对应的词性也是相同的，这是超出期待之处。之所以会这样，是因为我们上面提到过，第一层 LSTM 编码了很多句法信息，这在这里起到了重要作用。</p>
<p>ELMO 有什么值得改进的缺点呢？首先，一个非常明显的缺点在<u>特征抽取器选择方面</u>，ELMO 使用了 LSTM 而不是新贵 Transformer</p>
<p><strong>GPT</strong></p>
<p>把 ELMO 这种预训练方法和图像领域的预训练方法对比，发现两者模式看上去还是有很大差异的。除了以 ELMO 为代表的这种基于特征融合的预训练方法外，NLP 里还有一种典型做法，这种做法和图像领域的方式就是看上去一致的了，一般将这种方法称为“基于 Fine-tuning 的模式”，而 GPT 就是这一模式的典型开创者。</p>
<p>GPT 也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过 Fine-tuning 的模式解决下游任务。<br>区别于ELMO，预训练使用Transformer作为特征抽取器，并且只用上文，不用下文（很吃亏，这限制了其在更多应用场景的效果）</p>
<p>对于不同的下游任务来说，本来你可以任意设计自己的网络结构，现在不行了，你要向 GPT 的网络结构看齐，把任务的网络结构改造成和 GPT 的网络结构是一样的。然后，在做下游任务的时候，利用第一步预训练好的参数初始化 GPT 的网络结构，这样通过预训练学到的语言学知识就被引入到你手头的任务里来了</p>
<p>GPT 论文给了一个改造施工图。</p>
<p>GPT 的效果是非常令人惊艳的，在 12 个任务里，9 个达到了最好的效果，有些任务性能提升非常明显。</p>
<blockquote>
<p>那么站在现在的时间节点看，GPT 有什么值得改进的地方呢？其实最主要的就是那个单向语言模型，如果改造成双向的语言模型任务估计也没有 Bert 太多事了。当然，即使如此 GPT 也是非常非常好的一个工作，跟 Bert 比，其作者炒作能力亟待提升。</p>
</blockquote>
</blockquote>
<p><strong>BERT</strong></p>
<p>Bert 采用和 GPT <u>完全相同</u>的两阶段模型，首先是语言模型预训练；其次是使用 Fine-Tuning 模式解决下游任务。和 GPT 的最主要不同在于在预训练阶段采用了类似 ELMO 的双向语言模型，当然另外一点是语言模型的数据规模要比 GPT 大。所以这里 Bert 的预训练过程不必多讲了。</p>
<p>在改造任务方面 Bert 和 GPT 有些不同</p>
<blockquote>
<p>先大致说下 NLP 的几类问题，以强调 Bert 的普适性有多强。通常而言，绝大部分 NLP 问题可以归入上图所示的四类任务中：</p>
<ul>
<li>一类是<u>序列标注</u>，这是最典型的 NLP 任务，比如中文分词，词性标注，命名实体识别，语义角色标注等都可以归入这一类问题，它的特点是句子中每个单词要求模型根据上下文都要给出一个分类类别。</li>
<li>第二类是<u>分类任务</u>，比如我们常见的文本分类，情感计算等都可以归入这一类。它的特点是不管文章有多长，总体给出一个分类类别即可。</li>
<li>第三类任务是<u>句子关系判断</u>，比如 Entailment，QA，语义改写，自然语言推理等任务都是这个模式，它的特点是给定两个句子，模型判断出两个句子是否具备某种语义关系。</li>
<li>第四类是<u>生成式任务</u>，比如机器翻译，文本摘要，写诗造句，看图说话等都属于这一类。它的特点是输入文本内容后，需要自主生成另外一段文字。</li>
</ul>
</blockquote>
<blockquote>
<p>作者言：</p>
<p>所以说 Bert 的模型没什么大的创新，更像最近几年 NLP 重要进展的集大成者，这点如果你看懂了上文估计也没有太大异议，如果归纳一下这些进展就是：</p>
<ul>
<li>首先是两阶段模型，第一阶段双向语言模型预训练，这里注意要用双向而不是单向，第二阶段采用具体任务 Fine-tuning 或者做特征集成；</li>
<li>第二是特征抽取要用 Transformer 作为特征提取器而不是 RNN 或者 CNN；</li>
<li>第三，双向语言模型可以采取 CBOW 的方法去做（当然我觉得这个是个细节问题，不算太关键，前两个因素比较关键）。</li>
</ul>
<p><strong>Bert 最大的亮点在于效果好及普适性强，几乎所有 NLP 任务都可以套用 Bert 这种两阶段解决思路，而且效果应该会有明显提升。</strong>可以预见的是，未来一段时间在 NLP 应用领域，Transformer 将占据主导地位，而且这种两阶段预训练方法也会主导各种应用。</p>
</blockquote>
<h3 id="wordembedding"><a href="#wordembedding" class="headerlink" title="wordembedding"></a>wordembedding</h3><p>Count-based方法：比如Glove</p>
<p>Prediction-based：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953357.png" alt="image-20220421091036530" style="zoom:31%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954579.png" alt="image-20220421092013452" style="zoom:33%;" /></p>
<p>可以拓展这个model到n个词汇，比如第二幅图就是词，但是<u>weight要相等</u>【我不能理解，这忽略了部分时序吧】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953960.png" alt="image-20220421091522784" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954011.png" alt="image-20220421092355716" style="zoom:33%;" /></p>
<p>有种种变形，难说哪种比较好，不同的test上互有胜负，包括了CBOW、Skip-gram。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080953932.png" alt="image-20220421092438251" style="zoom:33%;" />













<h2 id="Interpretability"><a href="#Interpretability" class="headerlink" title="Interpretability"></a>Interpretability</h2><h3 id="why-deep"><a href="#why-deep" class="headerlink" title="why deep"></a>why deep</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954074.png" alt="image-20220420114744949" style="zoom:40%;" />

<p>更多的数据可以让你更接近理论上限（上限由你的模型决定，模型越复杂，越有可能包含更高的上限）</p>
<p>理论上一个“够胖的”的hidden layer就能做任何事情。研究发现，参数量相同时👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954913.png" alt="image-20220420123256784" style="zoom:33%;" />

<p>WHY？</p>
<p>因为数学上，要拟合一个复杂function，用高瘦的network，需要参数比较少（毕竟指数增长和线性增长。）</p>
<p>而比较少的参数意味着不容易overfitting，需要更少的训练资料。</p>
<p>直观理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954012.png" alt="image-20220420123959298" style="zoom: 22%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954697.png" alt="image-20220420124351296" style="zoom: 23%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080954663.png" alt="image-20220420124416548" style="zoom:23%;" /></p>
<p>就是线性增长咯。👆</p>
<h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><h3 id="Why-Deep"><a href="#Why-Deep" class="headerlink" title="Why Deep"></a>Why Deep</h3><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>之所以不叫优化算法是因为，略过了数学证明：（即某些优化算法理论的精度上下限之类的），只关注深度学习的应用。</p>
<p>但是其实，由于deep learning的复杂性，<u>不管你理论有多强的gurantee，都是不够用的</u></p>
<p><strong>复习</strong></p>
<p>SGD、SGD with momentum、Adagrad、RMSProp、Adam</p>
<p>基本概念：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955203.png" alt="image-20220413105054745" style="zoom:50%;" />

<p>on-line：每次只能看到当前时间步的数据（x，y）<br>off-line：每次能看到整个数据集（本节假设为off-line），实际过程中会受到内存的限制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955584.png" alt="image-20220413105625708" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955227.png" alt="image-20220418130100646" style="zoom:30%;" /></p>
<p>SGDM在局部最小处，不会卡在那个点，而是继续动，就像多出了动量一样（但是可能会累积而使得learning-rate爆炸）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955171.png" alt="image-20220418130331872" style="zoom:33%;" />

<p>Adsgrad思路是放缓下降太快的方向，增大平缓方向的学习率。但是其分母会无止境地累加，而RMSProp确保不会因为累积过多而卡住，但是它也有卡在局部最小点的问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955757.png" alt="image-20220418130505388" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955835.png" alt="image-20220418131258751" style="zoom:33%;" /></p>
<p>Adam算法则结合了以上两者：（$m_t$一开始比较小，分母调节其大小）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955104.png" alt="image-20220418131424333" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205080955374.png" alt="image-20220418132133948" style="zoom:40%;" /></p>
<p>折几个经典的optimizer都是2014年左右提出来的，到底出了什么问题</p>
<p>BERT  Transformer  Tacotron（语音生成）Big-GAN（生物生成）MEMO演算法（寻找通式，提取共同信息） 【Adam】<br>YOLO  Mask R-CNN  【SGDM】</p>
<p><strong>新的分析</strong></p>
<p>这位助教老师自己分析：因为Adam和SGD直接抢到了两个极端的位置（来自某次实验）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321935.png" alt="image-20220418210601396" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321590.png" alt="image-20220418210621657" style="zoom:33%;" /></p>
<blockquote>
<p>Adam: fast training, large generalization gap, unstable     快</p>
<p>SGDM: stable, little generation gap, better convergence   稳</p>
</blockquote>
<p>SWATS：先做Adam再做SGD</p>
<p>AMSGrad:有意义的方向更新被限制了大小，大的步长被限制成较小的值，无法起到好作用。作者的想法是减少无用而且小的gradient造成的影响。（但是还是有learning-rate变小的问题）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321277.png" alt="image-20220418212945087" style="zoom:33%;" />

<p>还有AdaBound，助教说十分粗鲁，失去了数学的优雅，太工业了。</p>
<p>还有很多种比如SGDR、One-cycle LR一堆堆。总之有许多新奇的思路</p>
<p>Adam最开始的步骤里，即使分母有稳定数值，但是意义上是随机的，也会使其混乱。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091321820.png" alt="image-20220418214320254" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317368.png" alt="image-20220418215343727" style="zoom:50%;" />

<hr>
<p><strong>更新的</strong></p>
<p>Hinton团队的一个work，和MEML演算法（原学习）的Reptile很像。</p>
<p>希望你走到比较平坦的地方，避免走进太崎岖的的地方然后accuracy掉下去</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322131.png" alt="image-20220418215618841" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322438.png" alt="image-20220418215933127" style="zoom:33%;" /></p>
<p>能不能看到未来，避免走到太差的点：NAG（通过数学手段免除两倍内存消耗。）【以后可以回来看】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322293.png" alt="image-20220418220653067" style="zoom: 33%;" />



<hr>
<p><strong>对优化器的一些讨论</strong></p>
<p>L2正则化时，正则化项要不要出现在动量的表达式中呢！</p>
<p>这个东西没有标准答案，但有人提出不加更好，也就是有实际价值的<u>SGDWM和AdamW</u></p>
<p>这两者被用于NLP，BERT系列之类的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322898.png" alt="image-20220418221413513" style="zoom:36%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091322484.png" alt="image-20220418221428662" style="zoom:38%;" /></p>
<p>这几个技术其实都是在做一件事，就是<u>鼓励你的探索，增加随机性</u>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091404260.png" alt="image-20220418221740834" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091404567.png" alt="image-20220418221946621" style="zoom:33%;" /></p>
<p>curriculum的思路是：一开始的训练决定大方向，先找到一个比较好的local minimum，再接着用难数据找比较好的点，这样就不会掉到太狭窄的山谷里。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405443.png" alt="image-20220418222304412" style="zoom:50%;" />



<p>==总结==：优化器</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405174.png" alt="image-20220418222518416" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405510.png" alt="image-20220418222602917" style="zoom:33%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405642.png" alt="image-20220418222730658" style="zoom:33%;" />

<p>有必要指出，优化器的选择只不过是在你其他地方没有问题的基础上improve一些，架构、训练技巧、脏数据都是帮不了你的。</p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h3><p><strong>自注意力</strong></p>
<p>引入：原本的<em>输入</em>都是一个长度已经定义好的向量，那么如何处理 一个<u>长度不一</u>的向量<u>序列</u>（他的顺序和沐神似乎不太一样）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405659.png" alt="image-20220412213425911" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405722.png" alt="image-20220412213557171" style="zoom:30%;" /></p>
<p>独热码并没有关心向量之间的关系和联系，word embedding解决了这个问题。👆还有对声音的处理。</p>
<p>输出大致有三种可能性：</p>
<ol>
<li>每个vector被model赋予一个label（输入和输出数目一样）</li>
<li>一整个seq输入，只得到一个输出，比如情感分析positive和negative</li>
<li>输出是不确定的，由model自己决定【seq2seq】</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405988.png" alt="image-20220412215649787" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423977.png" alt="image-20220412220002350" style="zoom:25%;" /></p>
<p>self-attention考虑到了整个输入，计算单个输出：也就是把对应的输入当作query，其他的当作key和value👆</p>
<p>此处的$b_1 - b_n$是<u>并行，同时被计算出来的</u>。所以说并行性好啊，举个例子：$b_2$，矩阵形式👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091405023.png" alt="image-20220412220456271" style="zoom: 45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423978.png" alt="image-20220412220844435" style="zoom:45%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406984.png" alt="image-20220412221141790" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423979.png" alt="image-20220412221302896" style="zoom:40%;" /></p>
<p>他说这里不一定用softmax，还可以用relu什么的，效果也不会太差；这也太友好了吧，shape都帮你推出来。</p>
<p>不过从原始输入还要经过不同的变换才能得到q、k、v，这里直接是多头注意力了。（原理图给的是内积分数计算）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406030.png" alt="image-20220412221916722" style="zoom:40%;" />

<p><strong>多头自注意力</strong></p>
<p>“相关”这个定义方式有很多种，因此我们需要得到多个q，k，v的组合，计算的时候是组内计算的，（如$b^{i,2}$不用${i,1}$的东西），最后把多头接起来，再通过一个变换得到最终的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406602.png" alt="image-20220412222748022" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406913.png" alt="image-20220412222943926" style="zoom:40%;" /></p>
<p><em>位置信息</em></p>
<p>下图黄绿那一片是最开始论文中采用的位置信息（人为设置的，有诸多问题）。</p>
<p>如今，还有许多人在研究position encoding，也没有人说sin cos就是最好的方法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406839.png" alt="image-20220412223145112" style="zoom: 50%;" />

<p>有个问题，在诸如声音讯号中，长度非常长，计算量相当大，有一招叫做truncated self-attention，只考虑一个范围，这个范围如何选定取决于你对问题的理解。</p>
<p>self-attention也可以用在图像中，也就是换一个角度，不把图像看成很长的向量，而是看成一个vector set，每个vector是一个像素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406269.png" alt="image-20220412223741608" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406163.png" alt="image-20220412223930206" style="zoom:45%;" /></p>
<p>如果比较CNN和self-attention，可以说self-attention是一个复杂化的CNN，考虑全局的信息而不是感受野之内的。也可以这样理解：感受野（receptive field）是自己学出来的，而不是人工设定的！【端到端狂喜！】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406369.png" alt="image-20220412224240774" style="zoom:46%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406377.png" alt="image-20220412224432391" style="zoom:45%;" /></p>
<p>但是，更free的model需要更多的数据才能学的好，self-attention比起CNN也需要更多的model</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406301.png" alt="image-20220412230307671" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406274.png" alt="image-20220412230938301" style="zoom:50%;" /></p>
<p>草，李宏毅说RNN基本都能被self-attention代替，所以不讲了</p>
<p>self-attention也可以用在graph上，只考虑有关联的，👆，这就是GNN</p>
<p>减少self-attention的计算量是非常值得研究的课题。还有各类的self-attention变形，见后文：各式SA</p>
<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>Transformer 是个叠加的“自注意力机制（Self Attention）”构成的深度网络，是目前 NLP 里==最强的特征提取器==，注意力这个机制在此被发扬光大，从任务的配角不断抢戏，直到 Transformer 一跃成为踢开 RNN 和 CNN 传统特征提取器，荣升头牌，大红大紫。</p>
<h4 id="Seq2seq"><a href="#Seq2seq" class="headerlink" title="Seq2seq"></a>Seq2seq</h4><p>和bert很有关系，输入是seq，输出是长度不确定的seq。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406635.png" alt="image-20220413112023113" style="zoom:33%;" />

<p>之所以要弄speech-&gt;translation而不是直接拼合上面的，是因为世界上有许多语言是没有文字的（或者像台语一样没啥人用文字）。</p>
<p><u>很多NLP的任务都可以类比QA任务</u>：给model一个上下文context，问机器一个Q，机器返回一个A</p>
<p>而QA的问题就可以用seq2seq来解决【<em>通用方案？</em>】当然，对不同的任务采用特制的模型，可能得到更好的结果（本节不讨论）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406414.png" alt="image-20220413112921818" style="zoom: 40%;" />

<p>还有很多问题，你不觉得是seq2seq，但也可以用这个方法硬解它！👇【甚至物体识别都行】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091406889.png" alt="image-20220413113250621" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407096.png" alt="image-20220413113507114" style="zoom:33%;" /></p>
<hr>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>架构李沐讲的不错，都没有讲什么直观理解。</p>
<p>BERT其实就是transformer的encoder。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407681.png" alt="image-20220413124035656" style="zoom:33%;" /></p>
<p>当然，这个encoder架构不一定要这样设计，有人提出了别的架构方法。下面的论文探究了为什么batch不如layer normalization</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407431.png" alt="image-20220413123828320" style="zoom:33%;" />

<p>Decoder其实有<u>两种（AT和NAT）</u>，比较常见的是Autoregressive，NAT用的也不少，比如在语音合成里。</p>
<p>Encoder和Decoder其实结构很像，第一个注意力层那里，decoder用的是掩码attention，不考虑后面的输入</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407461.png" alt="image-20220413124810744" style="zoom:33%;" />

<p>为了不让程序永无止境地推到下去，需要准备一个特殊字符“EOS”（end of sentence）对比NT和NAT👇：</p>
<p>NAT在并行性和长度的人为可控性有优势（比如音频倍速，就可以利用这个先验信息更好的辅助）</p>
<p>但是<u>NAT这个decoder的表现往往不如AT</u>，decoder的设计现在也是一个热门主题。【选修课有讲NAT】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407719.png" alt="image-20220413125438287" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091407238.png" alt="image-20220413130053827" style="zoom:33%;" /></p>
<p>注意力机制（李宏毅称cross-attention）</p>
<p>当然，是先有注意力机制，再有self-attention的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409311.png" alt="image-20220413130254120" style="zoom:33%;" />

<p>encoder和decoder之间的联系：</p>
<p>原始论文给出的架构中，是<u>encoder的最后一层输入到decoder的每一层，但是完全可以有不同的联系方式。</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409674.png" alt="image-20220413131122361" style="zoom: 50%;" />

<p>训练的时候是“强制教学[teacher forcing]”。</p>
<p><u>训练时用的损失函数是cross entropy</u>，单独考虑每一个词元与正确答案的误差。因为BLEU计算复杂，无法用来微分求导。</p>
<p>【遇到无法优化的目标，用RL硬train一发，把loss当reward，decoder当agent】</p>
<p>但是这不一定使得BLEU减小，<u>测试时用的是BLEU</u>，所以validation集要用BLEU来做评估。</p>
<p>训练和测试评估不一样导致：<em>exposure bias</em> 。</p>
<p>因为训练的时候decoder只看正确的东西，测试的时候便会一步错，步步错。</p>
<p>一个解决思路是：<em>scheduled sampling</em>，也就是在训练的时候加入一些错的“噪音”。</p>
<p>transformer和RNN的解决思路不一样，有一些reference：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091409612.png" alt="image-20220413152100682" style="zoom: 40%;" />



<p>==TIPs==</p>
<p><strong>Copy mechanism</strong></p>
<p>在比如chat-box、做摘要的场景中，要学从人的输入中copy一些词当作他的输出。</p>
<p>那么如何才能拥有这个能力？最早的工作是<em>pointer network</em></p>
<p><strong>Guided attention</strong></p>
<p>如果你对问题有一定的理解，那么强迫这个attention具有一定的模式，比如语音合成应该由左向右。</p>
<p>like monotonic attention；location-aware attention。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410053.png" alt="image-20220413142924697" style="zoom:33%;" align = 'left' />

<p><strong>Beam Search</strong></p>
<p>xs，不一定分数高的结果就好，有时候你需要model发挥一点“创造力”【神tm自动生成小说】</p>
<p>TTS中你要生成好的，必须在decoder里加入一些杂音，否则生成的像机器声一样。</p>
<h3 id="各式SA"><a href="#各式SA" class="headerlink" title="各式SA"></a>各式SA</h3><p>self-attention其实有各式各样的。大部分叫做xxformer</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410543.png" alt="image-20220412231101454" style="zoom: 40%;" />

<p>主要痛点是，指数增长的计算量，因此有各式各样的方法试图加速。主要计算来自于NxN的矩阵。</p>
<p>当然，self-attention只是整个network的一部分，如果占比不大，加速的效果也蛮有限的。<br>当input长度N非常大时，就有必要加速了，这些技术大部分在影像处理里，因为一张256x256的图的N有多达65536，计算还要平方。</p>
<p><strong>手工</strong></p>
<p><em>Local attention</em></p>
<p>有些问题，只用关注局部信息就能得到答案，无需关注全局信息。（又和CNN没差别了）</p>
<p>因此虽然能加快运算，但不一定能给你很好的结果。</p>
<p><em>Stride Attention</em></p>
<p>跳着看邻居的邻居的咨询，而不是直接看邻居的咨询。空几格也是超参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410283.png" alt="image-20220502094747031" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410283.png" alt="image-20220502094911355" style="zoom:33%;" /></p>
<p><em>Global Attention</em></p>
<p>通过特殊的符号（token）代表这个位置要做global attention</p>
<p>它先attend to所有token来看看全局发生了哪些事情，然后再由全局的来查看它以获得全局的咨询。例子：</p>
<p>【假设序列的前两个token设为global token】感觉这个idea非常nb，有点巧妙，可解释性也高。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410389.png" alt="image-20220502095556582" style="zoom:40%;" />

<p>真实情况是，我全都要，多头注意力的每个头都能用不同种类的attention优化方法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410258.png" alt="image-20220502095743386" style="zoom:50%;" />

<p>但是，刚刚提到的三种方法其实都是<u>人工设定</u>的，用了“先验知识”，但是凡是能用先验知识的地方，那必然有data driven</p>
<p><strong>data driven</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410864.png" alt="image-20220502100503991" style="zoom:33%;" />

<p><em>Clustering</em>能采取很多加速的方法。<u>我个人理解，归一化后向量模长差不多，又因为用内积计算，所以相近的自然算的值大。</u></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410237.png" alt="image-20220502100633482" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410576.png" alt="image-20220502100813023" style="zoom:33%;" /></p>
<p>可学的模式：让另一个network去学，这种思想好常用。</p>
<p><em>sinkhorn sorting network</em>：重点是完成从NN生成的continuous的矩阵到一个二值矩阵的变换，并且需要该过程可微！不过这个过程如果真是老老实实算，其实不便宜多少，作者采用的是多个input共用1个NN生成的output来“取巧”，比如10个共用1个就是百倍加速。<br>那么为什么要分两步骤，不直接计算二值矩阵呢，这是作者下一篇paper干的事。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410729.png" alt="image-20220502101313732" style="zoom: 33%;" />

<p><em>Linformer</em></p>
<p>发现是低秩矩阵，很多资讯重复，很多向量是相关的。</p>
<p>选用代表性的key，而不是有代表性的query，这样output length就不变，如果那种固定输出的，你可能可以用代表性query</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410063.png" alt="image-20220502102019578" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091410305.png" alt="image-20220502102205724" style="zoom:33%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411803.png" alt="image-20220502103531704" style="zoom: 33%;" />

<hr>
<p>除了对K和Q做内积加速以外，整体计算也有优化到空间。</p>
<p>先暂时忽略softmax</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411508.png" alt="image-20220502103923562" style="zoom:33%;" />

<p>矩阵连乘，顺序不同，计算量不同，计算量为两矩阵共三个维度的积。哇哦！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411342.png" alt="image-20220502104212858" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411545.png" alt="image-20220502104604769" style="zoom: 33%;" /></p>
<p>一把softmax加回去，数学就上去了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411244.png" alt="image-20220502104825762" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411422.png" alt="image-20220502105133904" style="zoom:33%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411094.png" alt="image-20220502105238225" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411808.png" alt="image-20220502105401508" style="zoom:33%;" /></p>
<p>然后发现1，分子分母除了$\phi(q^i)$外，都与要算的$b^i$无关，因此<u>一次算好，以后都不用算</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411302.png" alt="image-20220502105616567" style="zoom:33%;" />

<p><em>具体流程</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411683.png" alt="image-20220502110031049" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423980.png" alt="image-20220502110107280" style="zoom:33%;" /></p>
<p>直观上的理解没有原来好，但是快呀。</p>
<p>不同文献给出了不同的$\phi$方法。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091411251.png" alt="image-20220502110309453" style="zoom:33%;" />

<hr>
<p>更多<u>神奇</u>的思考</p>
<p>把这个矩阵直接当成参数，根本不需要算。。。                   以前丢了recurrent，现在想丢掉attention</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412571.png" alt="image-20220502110623059" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412470.png" alt="image-20220502110704375" style="zoom:33%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412098.png" alt="image-20220502110757317" style="zoom:50%;" />









<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Spatial"><a href="#Spatial" class="headerlink" title="Spatial"></a>Spatial</h3><p>why：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412679.png" alt="image-20220418224132613" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412037.png" alt="image-20220418224225620" style="zoom:30%;" /></p>
<p>人际关系图找凶手，人物之间的关系可以帮助我们提高识别凶手的准确率。</p>
<p>图非常大，不可能给所有的data都做labeling，如何利用有限的label和graph本身的structure训练出不错的模型【一般unlabelled更多】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412341.png" alt="image-20220419193943728" style="zoom:40%;" />

<p><strong>很酷的路线图</strong>，其中用的最多的是圈起来的GCN和GAT</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412690.png" alt="image-20220419194236667" style="zoom:50%;" />

<blockquote>
<p>Representation learning is a very important aspect of machine learning which automatically discovers the feature patterns in the data.</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412702.png" alt="image-20220419195000226" style="zoom:40%;" />

<p>NN4G</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412360.png" alt="image-20220419195250478" style="zoom:26%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412809.png" alt="image-20220419195319737" style="zoom:30%;" /></p>
<p>DCNN</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412698.png" alt="image-20220419195706643" style="zoom:29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412043.png" alt="image-20220419195740654" style="zoom:30%;" /></p>
<p>MoNET就是处理了NN4G最后相加这个手法太粗糙的问题。（定义了一个距离的概念充当权重）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412122.png" alt="image-20220419200119029" style="zoom:40%;" />

<p>但是，凡是能自己定的，为什么不让model自己学呢，后面会讲到。</p>
<p>GraphSAGE有好几种aggregate方式，甚至可以把邻居的feature喂到LSTM里，最后输出一个hidden stage用来做aggregate。【当然LSTM在实际测试结果不见得特别好。】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412453.png" alt="image-20220419200511061" style="zoom:50%;" />

<p><strong>GAT</strong>（Graph Attention Networks）</p>
<p>对邻居做attention</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091412973.png" alt="image-20220419200820494" style="zoom: 33%;" />

<p>GIN给出了一些理论证明，结论是要用sum，不用mean或者max pooling【todo】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413531.png" alt="image-20220419201137233" style="zoom: 33%;" />

<hr>
<h3 id="Spectral"><a href="#Spectral" class="headerlink" title="Spectral"></a>Spectral</h3><p>CNN要做的是学出一个filter，这相当于频域里的一个乘法，那么在GNN中该如何实现呢？请看理论解释：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413134.png" alt="image-20220419201917411" style="zoom:37%;" />

<p>一些相关背景知识：A连接矩阵代表哪些节点相连（假设对称），D度数矩阵代表每一个节点有几个邻居，节点向量 f 代表signal</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413145.png" alt="image-20220419220234678" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423981.png" alt="image-20220419223403050" style="zoom:67%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413915.png" alt="image-20220419224211195" style="zoom: 33%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413009.png" alt="image-20220419224420154" style="zoom:28%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423982.png" alt="image-20220419224538421" style="zoom:30%;" /></p>
<p>重要概念：<u>频率越大，相邻两点间信号变化量越大。</u></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413705.png" alt="image-20220419225600209" style="zoom:29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423983.png" alt="image-20220419225858195" style="zoom:33%;" /></p>
<p>理论👇：$f^TLf$代表了这个graph相邻结点的信号能量差，也就是signal有多smooth，以量化graph signal的频率大小，</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423985.png" alt="image-20220419225244564" style="zoom: 29%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413350.png" alt="image-20220419225348587" style="zoom: 28%;" /></p>
<p>也就是说，特征值$\lambda$可以代表特征向量变化频率的大小</p>
<p>那么怎么定义fourier transform，也就是怎么把一个图上的信号转到频域去呢，如下：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413167.png" alt="image-20220419231049875" style="zoom: 33%;" />

<p>逆过程参考时域的积分：Amazing！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413791.png" alt="image-20220419231342360" style="zoom:31%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423986.png" alt="image-20220419231441272" style="zoom:29%;" /></p>
<p>而频域的filter其实就是对角矩阵，与之前转到频域的结果$\hat{x}$相乘（multiplication），最终的得到的新结果$\hat{y}$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413541.png" alt="image-20220420103134457" style="zoom:33%;" />

<p>可见，我们最终要学的就是这个$g_\theta()$，也就是对拉普拉斯矩阵的函数，其中只关心对角（设了A和D对称），参数量为$N$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413193.png" alt="image-20220420103633182" style="zoom: 33%;" />

<p>第一个问题，这个函数的shape与输入有关。</p>
<p>第二个问题，他不是localize的。<br>根据数学上给出的定理，$L^N$每一项都不为零，此时的感受野是全局，但我们希望像CNN的卷积核一样看到局部的信息。</p>
<hr>
<p>ChebNet</p>
<p>很快，解决了上述的两个问题。其实就是限制了多项式的级数到K。然而这带来了计算成本高昂的问题。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413553.png" alt="image-20220420110507865" style="zoom:33%;" />

<p>ChebNet引入了数学上的技巧解决计算成本，把$\lambda$化为新的多项式表示，综合除法👇，此时会很好算。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414527.png" alt="image-20220420110849124" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091413278.png" alt="image-20220420110808506" style="zoom:33%;" /></p>
<p>最终计算方式是递回的。。：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414434.png" alt="image-20220420111338954" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414943.png" alt="image-20220420111645797" style="zoom:30%;" /></p>
<p><strong>GCN</strong></p>
<p>简单直观，有一些数学基础。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414589.png" alt="image-20220420111838916" style="zoom:30%;" />

<p>最终更新的式子就变成，把所有的neighbor经过transform相加取平均，加上bias</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414051.png" alt="image-20220420112126438" style="zoom:33%;" />

<hr>
<p>接下来就是一些图领域的东西了。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414975.png" alt="image-20220420112228534" style="zoom:33%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414372.png" alt="image-20220420112505229" style="zoom:26%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423987.png" alt="image-20220420112523708" style="zoom:25%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414713.png" alt="image-20220420112625514" style="zoom: 33%;" />

<p>但是结果看上去GCN很惨：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414876.png" alt="image-20220420112837020" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414629.png" alt="image-20220420112854189" style="zoom:33%;" /></p>
<p>做了weighted-sum的model一般结果好很多。</p>
<p>有人用理论证明说GCN在层数很多时，同一个子图内的edge会收敛到同一处。【只要Dropout就能解决这个问题】，但事实上，还是比浅一点的model要来的烂，有点离谱。至今还有待解决。<br><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414025.png" alt="image-20220420113135563" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414698.png" alt="image-20220420113308612" style="zoom:31%;" /></p>
<p>最后，GNN还可以用于generation，而且在NLP上有很多应用（比如知识图谱什么的）。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414492.png" alt="image-20220420113832248" style="zoom: 43%;" />





<h2 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091414999.png" alt="image-20220502154208307" style="zoom:33%;" />

<p>why generator？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415850.png" alt="image-20220502154419565" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415122.png" alt="image-20220502154641056" style="zoom:33%;" /></p>
<p>当我们的任务需要一点“<u>创造性</u>”，同一个输入，可能有很多不同的输出，而都是对的。（我笑死，老师太好玩了）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415486.png" alt="image-20220502154850821" style="zoom:33%;" />

<h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><p>GAN实在太多啦！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415281.png" alt="image-20220502155034205" style="zoom:33%;" />

<p>希望效果：从normal-distribution中sample不同的低维向量，都能由generator生成动画人脸（图片其实就是高维向量）</p>
<p>simple distribution的选择没有那么重要，generator负责把简单的distribution对应到复杂度distribution</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415061.png" alt="image-20220502155459705" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415746.png" alt="image-20220502155802970" style="zoom:33%;" /></p>
<p>generator和discriminator都是神经网络，只要能达到你想要的作用，用什么架构完全由你决定（我好像明白为啥那么多version了）</p>
<p><em>Basic idea</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415265.png" alt="image-20220502160011489" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415447.png" alt="image-20220502160219025" style="zoom:33%;" /></p>
<p>轮流固定，训练另一方。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415572.png" alt="image-20220502160632906" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091415081.png" alt="image-20220502160651044" style="zoom:33%;" /></p>
<p>可以看成是一个大network，所谓的内插👇（吸收特征然后组合？！）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416230.png" alt="image-20220502161546788" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423988.png" alt="image-20220502161633843" style="zoom:33%;" /></p>
<h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><p>目标是学到$P_data$的分布，要用到概率论咯。</p>
<p>GAN牛逼的地方在于，解决了不知道怎么计算复杂的Diversion这个问题，只要你能从$P_G$ and $P_{data}$中采样，不需要知道这两个分布的formulation，就能算出divergence的逼近。</p>
<p>如右图，最终理论推导出这个$maxV(D,G)$竟然和divergence有关，【<u>注意不是V这个值本身，而是穷举能得到的最大值！</u>】本来作者选这个目标函数只是为了和分类问题挂钩hh</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416386.png" alt="image-20220502161900696" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416460.png" alt="image-20220502162622871" style="zoom:33%;" /></p>
<p>最终变成了一个极小极大值的优化问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416028.png" alt="image-20220502163058293" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416597.png" alt="image-20220502163343914" style="zoom:33%;" /></p>
<p>这篇文章给出了不同divergence的object function，也告诉大家即使很正确的minimize divergence，结果也没有很好。</p>
<p>GAN以不好train闻名哈哈</p>
<hr>
<p><strong>Tips</strong></p>
<p>GAN有很多很多训练的小技巧。</p>
<p>由于JS divergence的特性，只要没有相交，算出的是定值$log_2$，那在训练中就不能区别好坏。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416438.png" alt="image-20220502163838564" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416715.png" alt="image-20220502164117406" style="zoom:33%;" /></p>
<p>所以训练中accuracy不能提供资讯，以前训练GAN只能画出来人眼看，Wasserstein distance也能衡量分布的差异，但是贼难算，因为当样本很多时，有很多种moving的方式。但是这样确实能拟合分布，能真正优化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416330.png" alt="image-20220502164421311" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416550.png" alt="image-20220502164911438" style="zoom:33%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416131.png" alt="image-20220502165812221" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091416606.png" alt="image-20220502170108059" style="zoom:33%;" /></p>
<p>最终把右图的第一条式子解出来就是衡量divergence的值。</p>
<p>现在最好用的还是$Spectral\ Normalization$</p>
<p>只要某一次一个人开摆，另一个人就玩不下去了。。。所以难train             👇不一定有效</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418387.png" alt="image-20220502171210217" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418924.png" alt="image-20220502171229467" style="zoom:33%;" /></p>
<p>很难用于文字，因为取了个max，你微小的变化根本不改变输出，也就没法传递回去，过去很长时间都没法train</p>
<p>当然有人通过爆改超参数炼起来了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423989.png" alt="image-20220502171725228" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418346.png" alt="image-20220502171946467" style="zoom:33%;" /></p>
<p>还有GAN的更详细的一些理论：<a href="https://www.youtube.com/playlist?list=PLJV_el3uVTsMq6JEFPW35BCiOQTsoqwNw">here</a>的4、5、6</p>
<p>还有其他的generative models，不只是GAN：</p>
<p> <a href="https://youtu.be/8zomhgKrsmQ">VAE</a>           <a href="https://youtu.be/uXY18nzdSsM">FLOW-based Model</a></p>
<p>甚至generation能当作监督学习问题来做。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418923.png" alt="image-20220502174027179" style="zoom: 33%;" /></p>
<hr>
<h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091418309.png" alt="image-20220502174308000" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423990.png" alt="image-20220502174438359" style="zoom:33%;" /></p>
<p>强如google暴搜都没法彻底解决这个问题，只能early stopping了，不过好歹容易侦测。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419980.png" alt="image-20220502174928402" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423991.png" alt="image-20220502175138788" style="zoom:33%;" /></p>
<p>但是inception score对同种多个体的不适用（二次元人脸），作业用的是FID</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419610.png" alt="image-20220502175436052" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419399.png" alt="image-20220502175922001" style="zoom:33%;" /></p>
<p>论文：Pros and cons of GAN evaluation measures 列举了很多方式供参考。</p>
<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>Conditional Genaration</strong></p>
<p>想进一步操纵输出，利用x向量输入模型来实现，以前用RNN，现在用transformer的encoder什么的都行。</p>
<p>x是一个控制，最终生成的效果和随机性取决于你sample的z，对应的discriminator也要更改，你训练的数据集要有pair</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420718.png" alt="image-20220502182143005" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419308.png" alt="image-20220502182454515" style="zoom:33%;" /></p>
<p><u>一般同时使用监督学习和GAN效果最好</u></p>
<p>还有根据声音生成画面的。还有产生会动的图片。</p>
<p><strong>用在unsupervised learning上</strong></p>
<p>你经常可能遇到一种情况，你有一堆x和一堆y，但是他们是不成对的，也就是unlabelled资料，那怎么训练呢？</p>
<p>比如影像风格转换就是这种情况。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420186.png" alt="image-20220502192825044" style="zoom:33%;" />

<p>这个跟原来的GAN训练没什么不同，只是原本是从一个简单的分布中sample，现在是从人脸照片里面sample，后续步骤很接近。</p>
<p>但只是这样的话，输入和输出就没什么关系了，我们要强化他们之间的关系。</p>
<p>之前的conditional generation用的是paired资料，但是对这个场景，我们并没有这样的资料。</p>
<p><em>Cycle GAN</em></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419148.png" alt="image-20220502193422113" style="zoom:33%;" />

<p>你可能会担心学到一些很奇怪的对应关系，也能满足上述条件，但实际work中一般都能比较好的完成。</p>
<p>甚至是你不用cycle GAN直接上也能train出来network比较懒，一般都会输出比较相近的东西，但理论上没有什么较好的解释。</p>
<p>同时训练<u>三个</u>：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419104.png" alt="image-20220502193744297" style="zoom:33%;" />



<p>还有更厉害的work：starGAN可以在多种风格之间转换。</p>
<p>还有很多类似的text之间转换的work和领域。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419405.png" alt="image-20220502194502660" style="zoom:33%;" />







<h2 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h2><p><strong>Self-Supervised Learning</strong></p>
<p>这个领域有许多的内容值得我们探索，见右下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419784.png" alt="image-20220503145400157" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420330.png" alt="image-20220504093737452" style="zoom:33%;" /></p>
<p>哈哈哈BERT有340M个参数。就这竟然还不算大的，xswl</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419263.png" alt="image-20220503145608341" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420978.png" alt="image-20220503145704977" style="zoom:33%;" /></p>
<p>然后还有个Switch Transformer比GPT-3大十倍！ 1.6T参数我日</p>
<p>所以自监督学习可以看作是无监督学习的一种。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420804.png" alt="image-20220503213211826" style="zoom:33%;" />



<h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p>可以处理序列数据，因此不局限于NLP，还可以是语音、影像等等。</p>
<p>自己遮住某些词元（两种方法都可以），然后当作标签，训练来减少误差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421372.png" alt="image-20220503214029359" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091419219.png" alt="image-20220503214544826" style="zoom:33%;" /></p>
<p>现在大家说，这个什么next sentence prediction没什么用，也有很多文献证明这一点，反倒是SOP那种判断句子顺序的方法，在bert的一个进阶版本albert里就很有用了。</p>
<p>现在bert会做填空题，神奇的是，现在bert能被用在其他别的任务上。而这些任务甚至可能跟填空题没有什么关系。<br>这些任务被称为是downstream tasks，也就是我们真正在意的任务。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421606.png" alt="image-20220503214948740" style="zoom:33%;" />

<p>他就像是干细胞，给他一点有标注的资料，他就能学会各式各样的任务，这也叫做Fine-tune</p>
<p><em>GLUE</em></p>
<p>由于bert这种特殊性，一般会测试你训练出的这个bert模型在各式各样的任务上的能力。也就是分别微调到9个任务上，然后看看你的模型表现的平均效果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421250.png" alt="image-20220503215527545" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091420326.png" alt="image-20220503215616415" style="zoom:33%;" /></p>
<p>这个基准线是人类能达到的程度，可以看到bert家族的能力逐年攀升。</p>
<p>可以看到模型已经“超越人类”，但显示的是这个资料集被玩坏了，所以就有人创建了更难的数据集，也就是啥super GLUE</p>
<p><em>使用流程</em>：</p>
<p>把你做填空题训练出的参数填到BERT模型里，这远比随机初始化的效果好很多。</p>
<p>然后用这个模型来“fine tune”，牛啊！然后就可以分化到各类任务了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421967.png" alt="image-20220503220145523" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421054.png" alt="image-20220503220212012" style="zoom:33%;" /></p>
<p>看右边这张表，有了bert初始化的模型，不仅在训练过程中loss下降较快，而且最终的效果也更加好一点。</p>
<p>BERT上游是无监督、下游是有监督，合起来tm叫半监督。。。这着实太敷衍了一点。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421567.png" alt="image-20220503221007271" style="zoom:33%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421876.png" alt="image-20220503221134174" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423992.png" alt="image-20220503221234601" style="zoom:33%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421431.png" alt="image-20220503221524289" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421462.png" alt="image-20220503221741295" style="zoom:33%;" /></p>
<p>但是要注意，这个问答系统是有限制的，也就是答案一定出现在原文里，上右图理解：随机初始化和BERT输出维度一样的橙色向量和蓝色向量，分别和输出做内积然后做softmax，橙色最大的那个输出的位置代表了答案开始的位置，蓝色是结束的位置。</p>
<p>理论上，BERT是transformer的encoder架构，可以接受任意长度的输入向量，但是从计算量考虑，512已经有些让人吃不消了。</p>
<p>训练成本太高了，如下，李老师的学生跑了100w次，用TPU跑了8天。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091421499.png" alt="image-20220503222418423" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422149.png" alt="image-20220503223012887" style="zoom:33%;" /></p>
<p>右边那篇论文，介绍了对这个预训练过程的学习和了解，是李老师团队做的，有兴趣可以参考一下。</p>
<hr>
<p>然而上文并没有提到seq2seq的预训练过程，具体怎么做呢？</p>
<p>先把输入的向量弄坏，然后希望decoder能重建弄坏的结果，弄坏的方法多种多样</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422426.png" alt="image-20220503223954746" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422306.png" alt="image-20220503224109624" style="zoom:33%;" /></p>
<p>用哪种方法好，google已经尝试过了，详情见下图T5 paper：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422919.png" alt="image-20220503224512231" style="zoom:33%;" />

<hr>
<p>至于为什么bert那么有效？可以看上文NLP——预训练的发家史。</p>
<p>相对于以前的词嵌入，bert是会考虑上下文的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422711.png" alt="image-20220503225323069" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422978.png" alt="image-20220503224947088" style="zoom:33%;" /></p>
<p>训练bert的过程（做填空题），可以看作是从上下文抽取资讯。</p>
<p>李宏毅：这是你在文献上查到的，但事实真的如此吗？</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422055.png" alt="image-20220503230230967" style="zoom:33%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422000.png" alt="image-20220503230342292" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422319.png" alt="image-20220503230416919" style="zoom:33%;" /></p>
<p>硬train一发，结果依然相当好，这告诉我们它的效果好可能不仅仅是因为“看得懂文章”，甚至可能bert本身就是比较好的初始化参数，适合做这些研究。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422598.png" alt="image-20220503230603016" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422918.png" alt="image-20220503230652396" style="zoom:33%;" /></p>
<p>👆可以用多种语言来train                              这个work用多语言pretrain，英文微调，直接上中文正确率依然有78.8%。</p>
<p>MRR衡量不同语言 同样意思的词汇接近程度。高代表模型能学到不同语言同样意思的符号。</p>
<p>还有李老师的经历：数据够多才出现了这样的现象，后来加多资料量成功了👇</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422267.png" alt="image-20220503231110098" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422038.png" alt="image-20220503231414394" style="zoom:33%;" /></p>
<p>但是肯定有语言的咨询，不然英文填空蹦几个中文不是逆天？那么，语言的咨询藏在哪？</p>
<p>卧槽，英文输入加上平均距离的差，multi-bert模型以为你输入的是对应的中文！所以语言资讯也藏在multi-bert里面</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091422865.png" alt="image-20220503231706629" style="zoom:33%;" />

<hr>
<p><strong>GPT</strong></p>
<p>BERT做的事填空题，GPT做的是预测题，给他之前出现的，让他预测下一个出现的词是什么。很像transformer的decoder部分。可以把一句话补完，这一个小GPT例子：<a href="https://app.inferkit.com/demo">https://app.inferkit.com/demo</a></p>
<p>怎么use gpt呢，GPT可能太大了，fine-tune都有困难。</p>
<p>这个想法👇太nb了，但是目前看起来并没有做到太好</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423212.png" alt="image-20220504093535457" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091423993.png" alt="image-20220504093559640" style="zoom:33%;" /></p>
<h3 id="语言预训练模型近年进展"><a href="#语言预训练模型近年进展" class="headerlink" title="语言预训练模型近年进展"></a>语言预训练模型近年进展</h3>]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>李沐-动手学深度学习</title>
    <url>/2021/12/20/%E6%9D%8E%E6%B2%901/</url>
    <content><![CDATA[<p><strong>【如今，工程远远走在了理论的前面，但迟早会有一天有人提出新的理论框架来解释它】</strong></p>
<p><a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/index.html">https://zh-v2.d2l.ai/chapter_attention-mechanisms/index.html</a></p>
<p><a href="https://d2l.ai/chapter_natural-language-processing-pretraining/index.html">https://d2l.ai/chapter_natural-language-processing-pretraining/index.html</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Welcome！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505790.jpeg" alt="Snipaste_2022-01-07_18-46-44" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505791.png" alt="image-20220107185027758" style="zoom:50%;" /></p>
<p>机器学习更关心计算，统计学习更关心模型。深度学习比机器学习更加计算。</p>
<p>李沐说大企业主要分这三类:</p>
<p>领域专家了解一些机器学习，但更看重怎么用模型辅助自己的专业知识。</p>
<p>数据科学家关注怎么处理数据成模型可用的数据（特征工程），还有构造模型，把领域专家的认知翻译成机器学习的任务。</p>
<p>数据科学家vsAI：数据科学家俩条路，一个是研究很多领域，研究怎么得到模型；深的走就是成为领域研究很深的人，即AI专家</p>
<p>可解释性略谈：人是不是可理解这个模型；它为什么工作；什么时候不工作；怎样会出现偏差之类的。</p>
<p>深度学习的一个关键优势是它<u>不仅取代了传统学习管道末端的浅层模型，而且还取代了劳动密集型的特征工程过程。</u><br>此外，通过取代大部分特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多界限，为解决各种问题提供了一套统一的工具。</p>
<h3 id="调参术"><a href="#调参术" class="headerlink" title="调参术"></a><em>调参术</em></h3><p><strong>原则</strong>：首先保证你的模型足够大，参数够多，保证了有前途，再通过各种手段降低模型容量避免过拟合。</p>
<p>李沐：实际中调参其实没有那么重要，不建议过度调参，这可能会overfit到目前的数据，实际场景中你可能会有越来越多的数据。（除非竞赛）</p>
<p>较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</p>
<p>当你调到一个比较好的参数点时，可以上下修改一下，如果结果剧烈波动，可能就调在了噪音上，泛化性不好。</p>
<p>少量高质量数据，可能有个百倍的换算。</p>
<p>通常来说准确率还是个比较主观的东西，你也不能知道你收集这个数据能达到多高准确，只要用户用的好。 用户心理可能有个阈值，低于它，体验就会很差，高过它，够用就行了。</p>
<p>选模型可以参考：<a href="https://cv.gluon.ai/model_zoo/detection.html">https://cv.gluon.ai/model_zoo/detection.html</a> 选择性能比较合适的，每个领域都有一些模型。</p>
<hr>
<p>选损失函数：通过研究函数形状、梯度形状，尤其离原点远近对比来分析损失函数特性</p>
<p>交叉熵是一个<strong>衡量两个概率分布之间差异</strong>的很好的度量，它测量给定模型编码数据所需的比特数。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061849327.png" alt="image-20220222193812191" style="zoom: 25%;" />

<p>绿：似然函数  蓝：损失函数  橙：导数</p>
<p>Huber结合了L1和L2范数，既不会在数值较大处使得梯度过大，也不会在较小处产生不稳定的突变。</p>
<p>全连接最好是<u>慢慢的减少每层的大小</u>，压小会损失信息，但有时候先压小一些再扩张可以deal with overfitting【靠手感哈哈】</p>
<p>激活函数的种类相对别的超参数没那么重要。</p>
<p>batch太小不适合并行来最大利用计算资源，太大会导致内存消耗（跑不了），浪费时间。但是batchsize较小时会带来噪音，噪音对神经网络是好事情，<u>有助于其泛化性</u>。</p>
<p>一般在没有足够多数据的时候，都使用K-折交叉验证。【深度学习用的不多，传统的用的多】</p>
<p><u>数据比例要结合真实情况，要是是因为采集而失衡，就要通过修改权重等手段处理。</u></p>
<hr>
<p>模型复杂性由什么构成是一个复杂的问题。 一个模型是否能很好地泛化取决于很多因素。 例如，具有更多参数的模型可能被认为更复杂， 参数有更大取值范围的模型可能更为复杂。 通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂</p>
<p><strong>模型容量</strong>：拟合各种函数的能力，高容量可以记住更多的数据【主要因素：参数个数，参数值的取值范围】</p>
<p><strong>数据复杂度</strong>：也很难衡量，一种直观的感觉和相对的，一些影响因素：</p>
<p>样本个数；每个样本的元素个数；时间、空间结构；多样性</p>
<blockquote>
<p>泛化性和灵活性之间的这种基本权衡被描述为<em>偏差-方差权衡</em>（bias-variance tradeoff）。 线性模型有很高的偏差：它们只能表示一小类函数。 然而，这些模型的方差很低</p>
<p>深度神经网络位于偏差-方差谱的另一端。 与线性模型不同，神经网络并不局限于单独查看每个特征，而是学习<em>特征之间的交互</em></p>
<p>即使我们有比特征多得多的样本，深度神经网络也有可能过拟合。</p>
<p>深度网络的泛化性质令人费解，而<strong>这种泛化性质的数学基础仍然是悬而未决的研究问题。</strong> </p>
</blockquote>
<hr>
<p>随机初始化⽅法，对于中等难度的问题，这种⽅法通常很有效</p>
<p>初始化⽅案的选择在神经⽹络学习中起着举⾜轻重的作⽤，它对保持数值稳定性⾄关重要。此外，这些初始化⽅案的选择可以与⾮线性激活函数的选择有趣的结合在⼀起。我们选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快。糟糕选择可能会导致我们在训练时遇到梯度爆炸或梯度消失。</p>
<p>不必过度迷信初始化，只要一开始不出问题，初始化是不太会影响后面的问题的。</p>
<p>Adam优化器的主要吸引力在于它<u>对初始学习率不那么敏感</u>。</p>
<p>如果预测的值的范围很大，RMSE 会被一些大的值主导。即使你很多小的值预测准了，但是有一个非常大的值预测的不准确，RMSE 就会很大。 先取 log 再求 RMSE（RMLSE），可以稍微解决这个问题。RMSE 一般对于固定的平均分布的预测值才合理。</p>
<hr>
<h4 id="Conv"><a href="#Conv" class="headerlink" title="Conv"></a>Conv</h4><p>核大小比较重要，填充一般取默认的，步幅取决于你的模型复杂度要控制在什么程度</p>
<p>步幅和填充是网络架构的一部分，我们选择某个网络比如“Resnet”，它就告诉了你该如何设置这些</p>
<blockquote>
<p>一般很少手写神经网络，都用经典的，Resnet有个系列，除非你的输入特别不一样</p>
<p>网络结构设计中也有很多因素要平衡，而且，网络结构其实没有想象那么重要。</p>
<p>一般work里都是参考经典的网络做架构。</p>
</blockquote>
<p>汇聚（pooling）层，它具有双重⽬的：降低卷积层对位置的敏感性，同时降低对空间降采样表⽰的敏感性。</p>
<p>【现在池化层用的越来越少了，李沐：以前池化也用来降低计算量，现在需求小，而数据增强和池化层降低敏感性的功能重复了。】</p>
<p>大图片只能用CNN，MLP和CNN都能用就用简单的MLP试试，<em>调的动就用简单的MLP</em>。</p>
<p>加入全局池化层，<u>降低了模型复杂度，提高了泛化性，但是收敛会变慢</u>，原来的全连接层比较复杂，强大了，能很快的收敛拟合。</p>
<p><strong>Batch</strong>归一化含几重噪音，因为标准偏差的缩放和减去均值带来的额外噪音。所以类似于dropout，Batch归一化有轻微的正则化效果，你可以将<u>Batch归一化和dropout一起使用</u>，如果你想得到dropout更强大的正则化效果。</p>
<p>应用了较大的mini-batch，比如说，你用了512而不是64，通过应用较大的mini-batch会减少了噪音，减少正则化效果。</p>
<p>不要把Batch归一化当作正则化。好处是可以加速收敛，学习率可以调大一些，但一般不改变模型精度。</p>
<p>先跟着内存调batch size（增加直到每秒处理样本数不再增大），再调学习率，框架都差不多，epoch调大点，多了就停下。</p>
<p>==验证集准确度波动较大，一般是learning-rate的原因==，batchsize小，你lr就不能太大。<br>【从泛化性考虑，batch-size小，你一次更新的随机噪声多，就不能一次走太远。】</p>
<p>学习率对均值和方差敏感。</p>
<p>batch-norm和不断地调学习率有异曲同工之处，但是学习率不知道哪里调大哪里调小，不如BN方便。</p>
<p><strong>微调</strong></p>
<p>成员变量<code>output</code>的参数是随机初始化的，通常需要更高的学习率才能从头开始训练。 假设<code>Trainer</code>实例中的学习率为η，我们将成员变量<code>output</code>中参数的学习率设置为10η。</p>
<p>找pretrained的model时也得找相应领域的，判断癌症的就找医学领域的sei。</p>
<p>微调对学习率不敏感，可以选一个比较小的就行了，比如沐神用的1e^-5</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p><strong>矩阵计算（求导）</strong></p>
<p>亚导数，将导数拓展到不可微，便于计算机处理</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505793.png" alt="image-20220109191041840" style="zoom:50%;" />

<p>这个是分子布局法，在x是标量时有体现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061850566.png" alt="image-20220221200301199" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205061850084.png" alt="image-20220221200600219" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091302041.png" alt="image-20220221200705937" style="zoom:25%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091302470.png" alt="image-20220221200943848" style="zoom:30%;" />

<p>虽然用不到，但得大概明白<u>形状是咋变化</u>的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309303.png" alt="image-20220221201551897" style="zoom:33%;" />

<p>机器学习不关心p的问题，只关心np问题，所以不必纠结最优解，大部分情况也不是凸函数:joy:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505795.png" alt="image-20220110175306257" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505796.png" alt="image-20220110175318506" style="zoom:25%;" /></p>
<p>上面两个例子是向量、矩阵求导的例子</p>
<hr>
<p>【<strong>计算图</strong>】</p>
<p>在框架中，我们用的是自动求导【<strong>计算图</strong>】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505797.png" alt="image-20220109200357064" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505798.png" alt="image-20220109200610990" style="zoom:25%;" /></p>
<p>显式构造需要自己定义中间变量等。隐式则会根据你的计算流程【包括python控制流】自动生成计算图，不用操心。</p>
<p>Pytorch用的是隐式构造（更慢），tensorflow和数学上都用的是显式构造。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505799.png" alt="image-20220109204358173" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202202131505800.png" alt="image-20220109204643611" style="zoom:25%;" /></p>
<p>反向传播是拿内存换时间，因为需要存储正向的中间结果！果然时空不可兼得。【这也是内存爆炸祸源】</p>
<p>一般深度学习里很少用向量函数求导，都是<strong>标量求导</strong>，所以需要用sum函数处理后，再进行backward（）；如果维数特别多，求导后会变成非常巨大的张量矩阵，因此loss（）函数也常设置为标量。<br>虽然支持高维向量求导，但是很慢，而且一般用不到。</p>
<p><u>需要反向传播的数值要为浮点型,不可以为整数</u></p>
<h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>绝对值和平方损失没太大的区别，一开始用平方是因为方便求导。</p>
<p>损失除以n变成平均是防止样本规模影响学习率的调整，不然又多一个超参数，还不正交。</p>
<p>样本大小不是批量的整数倍：丢弃、从下一个epoch补全、更改除数。</p>
<p>确认你读数据的速度要比模型训练的快，这是个常见的性能瓶颈。</p>
<h4 id="SoftMax"><a href="#SoftMax" class="headerlink" title="SoftMax"></a>SoftMax</h4><blockquote>
<p>通过将softmax和交叉熵结合在一起，可以避免反向传播过程中可能会困扰我们的数值稳定性问题。</p>
<p>因为softmax公式里的exp和交叉熵公式里的log可以相互抵消，避免做log和exp运算时出现inf和Nan</p>
<p>我们没有将softmax概率传递到损失函数中， 而是在交叉熵损失函数中传递未规范化的预测，并同时计算softmax及其对数， 这是一种类似<a href="https://en.wikipedia.org/wiki/LogSumExp">“LogSumExp技巧”</a>的聪明方式。</p>
</blockquote>
<p>Mnist手写数字识别（10类）          ImageNet自然物体分类（1000类）</p>
<p>从回归到多类分类——无校验比例：要求预测的最大可能选择比其他的有显著差距</p>
<p>从回归到多类分类——校验比例：就是多项逻辑斯蒂，也称softmax，输出的是匹配的概率。</p>
<blockquote>
<p>如果把熵$H(P)$想象为“知道真实概率的人所经历的惊异程度”，那么什么是交叉熵？交叉熵<em>从</em>$P$<em>到</em>$Q$，记为$H(P, Q)$。</p>
<p>你可以把交叉熵想象为“主观概率为$Q$的观察者在看到根据概率$P$生成的数据时的预期惊异”。<br>当$P=Q$时，交叉熵达到最低。在这种情况下，从$P$到$Q$的交叉熵是$H(P, P)= H(P)$。</p>
<p>简而言之，我们可以从两方面来考虑交叉熵分类目标：<br>（i）最大化观测数据的似然；（ii）最小化传达标签所需的惊异。</p>
</blockquote>
<p>sofxmax输入是向量，再把图片拉长成向量时会损失许多空间信息，而卷积神经网络则不会。</p>
<p><code>.numel()</code>直接获取tensor中元素个数</p>
<p>定义了展平层（flatten），来调整网络输入的形状<code>nn.Flatten()</code>第零维度保留，其他全部压到第一维。</p>
<p><code>net.apply(f)</code>深度优先遍历并应用这个函数。</p>
<p>默认的误差其实是softlabel，把正确的那一类概率记作0.9，其他的是$\frac{1}{n-1}$，这样就有逼近的可能，而不是要趋于无穷。</p>
<p>可以认为logistic是softmax的二分类特例。</p>
<p>代码中有部分冗余，因为pytorch版本或历史原因！</p>
<p>在<code>net.eval()</code>测评模式下，就不会算梯度相关的东西了，效率更好</p>
<h4 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>感知机其实等价于使用批量大小为1的梯度下降，而损失函数为<br>$$<br>l(y,x,w) = max(0,-y\langle w,x \rangle)<br>$$<br>当年发现感知机不能拟合XOR，是“第一次AI寒冬”，导致很多人转行哈哈，但后来有了多层感知机。【多个线性结合】</p>
<p>【深度学习在2014之前好像都是旧东西重命名哈哈哈】</p>
<blockquote>
<ul>
<li>figsize: 指定figure的宽和高，单位为英寸</li>
<li>dpi: 指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80, 1英寸等于2.5cm, A4 纸是 21*30cm的纸张</li>
</ul>
</blockquote>
<p>最好是慢慢的减少每层的大小，压小会损失信息，但有时候<u>先压小一些再扩张可以deal with overfitting</u>【没有太多科学，靠手感哈哈】</p>
<p><code>torch.relu()/sigmoid()/tanh()</code></p>
<p>沐神：所以不用SVM用mlp，其实是因为效果不好可以很容易换到CNN、RNN，代码结构变动小很多。</p>
<p>SVM对超参数不敏感，而且更容易优化，用起来更简单，有很漂亮的数学理论。现在也好，但是MLP改代码实在方便。<br>SVM在参数较多时，计算麻烦，还有可调性不强</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091303771.png" alt="image-20220222225022487"></p>
<p>这俩效果能近似，但是左边的不好学，容易over fitting，右边的就叫“深层”，而且数量之上是指数倍增的。</p>
<p>激活函数的种类相对别的超参数没那么重要。</p>
<p>要保持鲁棒性，数据受干扰时，结果分类应该不变，这也是个很重要的问题。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>由于泛化是机器学习中的基本问题， 许多数学家和理论家毕生致力于研究描述这一现象的形式理论。<br>在<a href="https://en.wikipedia.org/wiki/Glivenko%E2%80%93Cantelli_theorem">同名定理（eponymous theorem）</a>中， 格里文科和坎特利推导出了训练误差收敛到泛化误差的速率。<br>在一系列开创性的论文中， <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory">Vapnik和Chervonenkis</a> 将这一理论扩展到更一般种类的函数。 这项工作为统计学习理论奠定了基础。</p>
<p>在接下来的章节中，我们将讨论因违背独立同分布假设而引起的问题。</p>
<p><strong>原则</strong>：首先保证你的模型足够大，参数够多，保证了有前途，再通过各种手段降低模型容量避免过拟合。</p>
<p>一般在没有足够多数据的时候，都使用K-折交叉验证。【深度学习用的不多哈哈，传统的用的多】</p>
<p>K折三种做法：选出的超参数在整个数据集全部重算；或者把最好的所有的模型拿下来，以后就用这个算，结果取均值【模型稳定性好】；要么就选其中的一个，比如最好的模型。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304281.png" alt="image-20220223130221812" style="zoom:50%;" />

<p>模型复杂性由什么构成是一个复杂的问题。 一个模型是否能很好地泛化取决于很多因素。 例如，具有更多参数的模型可能被认为更复杂， 参数有更大取值范围的模型可能更为复杂。 通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂</p>
<p><strong>模型容量</strong>：拟合各种函数的能力，高容量可以记住更多的数据【<u>主要因素：参数个数，参数值的取值范围</u>】</p>
<p>VC维：统计学习理论的核心思想</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304368.png" alt="image-20220223131106065" style="zoom:50%;" />



<p><strong>数据复杂度</strong>：也很难衡量，一种直观的感觉和相对的，一些影响因素：</p>
<p>样本个数；每个样本的元素个数；时间、空间结构；多样性</p>
<p>这个总结，揭露了更深的理论。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304195.png" alt="image-20220223131305180" style="zoom:50%;" />

<p>我们很难比较本质上不同大类的模型之间（例如，决策树与神经网络）的复杂性。 就目前而言，一条简单的经验法则相当有用： 统计学家认为，能够轻松解释任意事实的模型是复杂的， 而表达能力有限但仍能很好地解释数据的模型可能更有现实用途。</p>
<blockquote>
<p>沐神：神经网络的最大优点是——它更像一种<strong>语言</strong>。可编程性特别好，能解决的问题也很多<br>CNN、RNN通过更好的结构辅助网络更方便的训练出数据的模式，所以是尽量用神经网络的方法去描述数据的特性！【比如CNN是为了告诉神经网络，我觉得这个数据有空间信息】</p>
<p>很多经典的论文一开始找的理由都是错的。</p>
<p>艺术：我不知道为什么，但这样做好看。神经网络就有50%是艺术xs</p>
</blockquote>
<p>整个工科其实背后逻辑差不多。不如就学现在流行的东西【现在是深度学习】，以不变应万变。</p>
<p>将随机森林结合进深度学习比较少，参数不好传。</p>
<p><u>数据要结合真实情况，如果符合现实情况，那比例如何都没问题，要是是因为采集而失衡，就要通过修改权重等手段处理。</u></p>
<h4 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h4><p>常用的控制过拟合的方法【即缩减每个参数的取值范围以减小模型容量】。L2正则，dropout都是</p>
<p>最离谱就是直接强行约束$||w||^2 \leq \theta$，但不怎么用，用的是等价形式——L2正则。</p>
<p>命名原因，在更新参数时w相当于多乘了个参数$(1-\eta \lambda)$</p>
<p>因为数据中存在噪音，在学习的时候会增加参数的震荡？所以学到的参数可能比实际的偏大，加入罚项拉回来？反正就那个意思</p>
<h4 id="dropout【暂退法】"><a href="#dropout【暂退法】" class="headerlink" title="dropout【暂退法】"></a>dropout【暂退法】</h4><p><u>效果一般比权重衰减更好。但只能用在全连接层</u>【注意每一次丢弃的结果是不一样的，不是永久丢弃，是暂退】</p>
<p>思想来自随机森林，但是从实验上来看，起到的作用和正则很像而非投票。</p>
<p>泛化性和灵活性之间的这种基本权衡被描述为<em>偏差-方差权衡</em>（bias-variance tradeoff）。 线性模型有很高的偏差：它们只能表示一小类函数。 然而，这些模型的方差很低</p>
<p>深度神经网络位于偏差-方差谱的另一端。 与线性模型不同，神经网络并不局限于单独查看每个特征，而是学习<em>特征之间的交互</em></p>
<p>即使我们有比特征多得多的样本，深度神经网络也有可能过拟合。</p>
<p>深度网络的泛化性质令人费解，而<strong>这种泛化性质的数学基础仍然是悬而未决的研究问题。</strong> </p>
<p>经典泛化理论认为，为了缩小训练和测试性能之间的差距，应该以简单的模型为目标。 简单性以较小维度的形式展现</p>
<p>简单性的另一个角度是平滑性，即函数不应该对其输入的微小变化敏感。<br>$$<br>\begin{aligned}<br>h’ =<br>\begin{cases}<br>    0 &amp; \text{ 概率为 } p \<br>    \frac{h}{1-p} &amp; \text{ 其他情况}<br>\end{cases}<br>\end{aligned}<br>$$<br>此模型期望不变。</p>
<p>在代码实现中有个效率技巧：<u>做乘法（用掩码）比用索引（比如布尔）来的快</u>，用一个float把布尔矩阵转成0.0，1.0矩阵。</p>
<p>dropout效果又好又好调，mlp现在用的越来越少了。</p>
<p>learning rate主要对期望、方差敏感。</p>
<h4 id="数值稳定性"><a href="#数值稳定性" class="headerlink" title="数值稳定性"></a>数值稳定性</h4><p>现在<strong>tanh</strong>函数在所有场合都优于<strong>sigmoid</strong>函数，但这俩再绝对值大时梯度消失，除非二分类，就在输出用一个，不然还是relu。</p>
<p>由于计算性能需要，一般GPU用16位浮点数，也就是[6e^-5,6e^4]</p>
<p>爆炸和消失的问题是在反传的过程中发生的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309646.png" alt="image-20220223190716900" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309500.png" alt="image-20220223190922252" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309569.png" alt="image-20220223191357540" style="zoom:30%;" /></p>
<p><strong>权重初始化</strong></p>
<p>随机初始化⽅法，对于中等难度的问题，这种⽅法通常很有效</p>
<p>初始化⽅案的选择在神经⽹络学习中起着举⾜轻重的作⽤，它对保持数值稳定性⾄关重要。此外，这些初始化⽅案的选择可以与⾮线性激活函数的选择有趣的结合在⼀起。我们选择哪个函数以及如何初始化参数可以决定优化算法收敛的速度有多快。糟糕选择可能会导致我们在训练时遇到梯度爆炸或梯度消失。</p>
<p>深度学习框架通常实现十几种不同的启发式⽅法。此外，参数初始化⼀直是深度学习基础研究的热点领域。其中包括专⻔⽤于参数绑定（共享）、超分辨率、序列模型和其他情况的启发式算法。例如，Xiao等⼈演示了通过使⽤精心计的初始化⽅法 [Xiao et al., 2018]，可以⽆须架构上的技巧而训练10000层神经⽹络的可能性。</p>
<p>==Xavier==：沐神从均值和方差不变推导，得出了不可兼得，所以折中。</p>
<p>每层的W初始化<br>$$<br>\left(-\sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}, \sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}\right)<br>$$</p>
<p>模型一炸，准确率就变成50%左右了哈哈</p>
<p>沐神：虽然深度学习对数学要求比较低，但你还是得学，不然很多东西做不了，理解不了，光会写代码也没用。</p>
<p>高维损失的“可视化”，目前虽然有一些工作，但还比较原始。</p>
<p>数值被压缩到某个区间，数学上是不会影响到模型的表达性的，因为是总体的偏移。</p>
<p>不必过度迷信初始化，只要一开始不出问题，初始化是不太会影响后面的问题的。</p>
<p>pytorch<em>默认初始化</em>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> init
<span class="token comment">#define the initial function to init the layer's parameters for the network</span>
<span class="token keyword">def</span> <span class="token function">weigth_init</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span><span class="token punctuation">:</span>
        init<span class="token punctuation">.</span>xavier_uniform_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">)</span><span class="token punctuation">:</span>
        m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fill_<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span><span class="token punctuation">:</span>
        m<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">)</span>
        m<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="分布偏移"><a href="#分布偏移" class="headerlink" title="分布偏移"></a>分布偏移</h4><p>首先，一旦模型开始根据鞋类做出决定，顾客就会理解并改变他们的行为。 不久，所有的申请者都会穿牛津鞋，而信用度却没有相应的提高。 总而言之，机器学习的许多应用中都存在类似的问题： 通过将基于模型的决策引入环境，我们可能会破坏模型。</p>
<p>协变量偏移、标签便宜、概念偏移。</p>
<p>在另一些情况下，标签偏移和协变量偏移假设可以同时成立。 例如，当标签是确定的，即使𝑦导致𝐱，协变量偏移假设也会得到满足。 有趣的是，在这些情况下，<u>使用基于标签偏移假设的方法通常是有利的</u>。 这是因为这些方法倾向于包含看起来像标签（通常是低维）的对象， 而不是像输入（通常是高维的）对象。</p>
<p>当分布变化缓慢并且模型没有得到充分更新时，就会出现更微妙的情况： <em>非平稳分布</em>（nonstationary distribution）</p>
<p><strong>偏移纠正</strong></p>
<p>在相应的假设条件下，可以在测试时检测并纠正协变量偏移和标签偏移。在测试时，不考虑这种偏移可能会成为问题。</p>
<p>概念偏移很难用原则性的方式解决。 例如，在一个问题突然从“区分猫和狗”偏移为“区分白色和黑色动物”的情况下， 除了从零开始收集新标签和训练，别无妙方。 幸运的是，在实践中这种极端的偏移是罕见的。 相反，通常情况下，概念的变化总是缓慢的。 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304391.png" alt="image-20220224222149316" style="zoom: 80%;" />

<p>标签偏移的一个好处是，如果我们在源分布上有一个相当好的模型， 那么我们可以得到对这些权重的一致估计，而不需要处理周边的其他维度。 在深度学习中，输入往往是高维对象（如图像），而标签通常是低维（如类别）。</p>
<p>为了估计目标标签分布，我们首先采用性能相当好的现成的分类器（通常基于训练数据进行训练）， 并使用验证集（也来自训练分布）计算其混淆矩阵。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304004.png" alt="image-20220224223318620" style="zoom:80%;" />





<p><strong>环境</strong></p>
<p>在某些情况下，环境可能会记住自动操作并以令人惊讶的方式做出响应。在构建模型时，我们必须考虑到这种可能性，并继续监控实时系统，并对我们的模型和环境以意想不到的方式纠缠在一起的可能性持开放态度。</p>
<p>环境变化的速度和方式在很大程度上决定了我们可以采用的算法类型。 例如，如果我们知道事情只会缓慢地变化， 就可以迫使任何估计也只能缓慢地发生改变。 如果我们知道环境可能会瞬间发生变化，但这种变化非常罕见， 我们就可以在使用算法时考虑到这一点。 当一个数据科学家试图解决的问题会随着时间的推移而发生变化时， 这些类型的知识至关重要。</p>
<blockquote>
<p><em>伦理</em></p>
<p>最后，重要的是，当你部署机器学习系统时， 你不仅仅是在优化一个预测模型， 而你通常是在提供一个会被用来（部分或完全）进行自动化决策的工具。 这些技术系统可能会通过其进行的决定而影响到每个人的生活。</p>
<p>从考虑预测到决策的飞跃不仅提出了新的技术问题， 而且还提出了一系列必须仔细考虑的伦理问题。 如果我们正在部署一个医疗诊断系统，我们需要知道它可能适用于哪些人群，哪些人群可能无效。 忽视对一个亚群体的幸福的可预见风险可能会导致我们执行劣质的护理水平。 此外，一旦我们规划整个决策系统，我们必须退后一步，重新考虑如何评估我们的技术。 在这个视野变化所导致的结果中，我们会发现精度很少成为合适的衡量标准。 </p>
<p>通常，在建模纠正过程中，模型的预测与训练数据耦合的各种机制都没有得到解释， 研究人员称之为“<strong>失控反馈循环</strong>”的现象。 此外，我们首先要注意我们<u>是否解决了正确的问题</u>。 比如，预测算法现在在信息传播中起着巨大的中介作用， 个人看到的新闻应该由他们喜欢的Facebook页面决定吗？ 这些只是你在机器学习职业生涯中可能遇到的令人感到“压力山大”的道德困境中的一小部分。</p>
</blockquote>
<h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h3><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>事实证明，研究讨论“⽐单个层⼤”但“⽐整个模型小”的<strong>组件</strong>更有价值。例如，在计算机视觉中⼴泛流⾏的ResNet-152架构就有数百层，这些层是由<u>层组（groups of layers）【==块==】的重复模式</u>组成。这个ResNet架构赢得了2015年ImageNet和COCO计算机视觉⽐赛的识别和检测任务 [He et al., 2016a]。⽬前<u>ResNet架构仍然是许多视觉任务的⾸选架构</u>。在其他的领域，如⾃然语⾔处理和语⾳，层组以各种重复模式排列的类似架构现在也是普遍存在。</p>
<p><code>Sequential</code>类使模型构造变得简单， 允许我们组合新的架构，而不必定义自己的类。 然而，并不是所有的架构都是简单的顺序架构。 当需要更强的灵活性时，我们需要定义自己的块，自定义计算。，我们⼀直在通过net(X)调⽤我们的模型来获得模型的输出。这实际上是<code>net.__call__(X)</code>的简写</p>
<p>在实现我们自定义块之前，我们简要总结⼀下每个块必须提供的基本功能：</p>
<ol>
<li>将输⼊数据作为其前向传播函数的参数。</li>
<li>通过前向传播函数来⽣成输出。请注意，输出的形状可能与输⼊的形状不同。例如，我们上⾯模型中的<br>第⼀个全连接的层接收⼀个20维的输⼊，但是返回⼀个维度为256的输出。</li>
<li>计算其输出关于输⼊的梯度，可通过其反向传播函数进⾏访问。通常这是⾃动发⽣的。</li>
<li><em>存储</em>和访问前向传播计算所需的参数。</li>
<li>根据需要<em>初始化</em>模型参数。</li>
</ol>
<p>只要继承<code>nn.Module</code>，我们的实现只需要提供我们⾃⼰的构造函数（Python中的<code>__init__</code>函数）和前向传播函数。不必担⼼反向传播函数或参数初始化.</p>
<p>块的⼀个主要优点是它的<strong>多功能</strong>性。我们可以⼦类化块以创建<em>层</em>（如全连接层的类）、<em>整个模型</em>（如上⾯的MLP类）或具有中等复杂度的<em>各种组件</em>。</p>
<p>每个Module都有⼀个<code>_modules</code>属性？以及为什么我们使⽤它而不是⾃⼰定义⼀个Python列表？简而⾔之，<code>_modules</code>的主要优点是：在模块的参数初始化过程中，系统知道在``_modules`字典中查找需要初始化参数的<u>子块</u>。</p>
<p>【可以嵌套】</p>
<h3 id="Conv-1"><a href="#Conv-1" class="headerlink" title="Conv"></a>Conv</h3><p>在图片里找模式的<strong>原则</strong>（启发了卷积）：</p>
<p>平移不变性，模型在图片任何位置，得到的结果应该一致。</p>
<p>局部性，只需要局部的信息就能判断。</p>
<p>卷积核则满足，参数与位置信息i，j无关；而卷积核只关注周围的几个元素。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304495.png" alt="image-20220227094450729" style="zoom:50%;" align = 'left'/>

<p>卷积核较小，层数较深类似每层参数较少的MLP，也是同样的好处。</p>
<p>很少用偶数的卷积核。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309135.png" alt="image-20220227102952944" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091309017.png" alt="image-20220227103317837" style="zoom:50%;" /></p>
<p><strong>加法重载</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304581.png" alt="image-20220227104454262"></p>
<p>核大小比较重要，填充一般取默认的，步幅取决于你的模型复杂度要控制在什么程度</p>
<p>步幅和填充是网络架构的一部分，我们选择某个网络比如“Resnet”，它就告诉了你该如何设置这些</p>
<blockquote>
<p>一般很少手写神经网络，都用经典的，Resnet有个系列，除非你的输入特别不一样</p>
<p>网络结构设计中也有很多因素要平衡，而且，网络结构其实没有想象那么重要。</p>
<p>一般work里都是参考经典的网络做架构。</p>
</blockquote>
<p>机器学习本质上是个极端的压缩、泛化的过程。</p>
<p>3x3卷积用的多，因为10层3x3差不多等于5、6层5x5，但是因为这个计算量是平方增长，所以3x3快很多。</p>
<p>【简单的，就算效果差一点，才能通用】</p>
<blockquote>
<p>没有深度学习的时候，需要很多人力的成本调参，调出来效果不好还得换数据，又得人清洗。</p>
<p>深度学习用计算为代价替代了这些成本，总体来看其实成本是下降的，所以才得以流行。</p>
</blockquote>
<p>输入通道和输出通道其实没有太多相关性，输出通道数是架构的一部分。</p>
<p>不同通道的卷积核大小一致是<u>为了计算</u>上的好处。</p>
<p>【平时简单调试一下就用notebook就好，大型的采用Pycharm】</p>
<p>3d卷积效果比2d稍好一点点，但是计算复杂度高很多，主要用在视频。</p>
<p>$(\frac{n+2p-f}{s}+1)\times (\frac{n+2p-f}{s}+1)$ 不是整数就向下取整</p>
<p><strong>池化层</strong></p>
<p>我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含⼀只猫呢？”），所以我们最后⼀层的神经元应该对整个输⼊的全局敏感。通过逐渐聚合信息，⽣成越来越粗糙的映射，最终实现学习全局表⽰的⽬标，同时将卷积图层的所有优势保留在中间层。</p>
<p>当检测较底层的特征时（例如 6.2节中所讨论的边缘），我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄⿊⽩之间轮廓清晰的图像X，并将整个图像向右移动⼀个像素，即Z[i, j] =X[i, j + 1]，则新图像Z的输出可能⼤不相同。而在现实中，随着拍摄⻆度的移动，任何物体⼏乎不可能发⽣在同⼀像素上。即使⽤三脚架拍摄⼀个静⽌的物体，由于快⻔的移动而引起的相机振动，可能会使所有物体左右移动⼀个像素（除了⾼端相机配备了特殊功能来解决这个问题）。</p>
<p>汇聚（pooling）层，它具有双重⽬的：降低卷积层对位置的敏感性（比如3x3，那就允许你的局部特征在高宽上移动俩像素，仍能识别到该模式【与<em>感受野</em>有关】），同时降低对空间降采样表⽰的敏感性。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304202.png" alt="image-20220227141658569" style="zoom:50%;" />

<p>从语义上看，池化放在卷积后，降低敏感性。</p>
<p>【现在池化层用的越来越少了，李沐：以前池化也用来降低计算量，现在需求小，而<u>数据增强和池化层降低敏感性的功能重复</u>了。】</p>
<p>【<u>尽量不要调用python本身的函数，慢到怀疑人生</u>，但是自带的数据结构内存有优化，可以列表搞好再转成tensor】</p>
<h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><p><strong>LeNet</strong></p>
<p> 1989</p>
<p>:star: <u>核心思想——不断把（空间信息）长宽压缩到越来越长的通道里，最后MLP训练出输出，未来基本都是这个思想。</u></p>
<p>直观理解：假设输入输出高宽不变，通常不会动通道数。假设输入输出高宽都减半，通道会加一倍。【空间压缩了，把提取的信息在更多的通道存下来】</p>
<p>背模型的参数意义不大，要理解是做压缩操作的思想和模式。</p>
<p>直观理解：本来一个像素识别一个低级特征，压缩到一堆通道后一个像素就能识别一个类别（高级特征）。</p>
<p>大图片只能用CNN，MLP和CNN都能用就用简单的MLP试试，<em>调的动就用简单的MLP</em>。</p>
<blockquote>
<p>通常来说准确率还是个比较主观的东西，你也不能知道你收集这个数据能达到多高准确，只要用户用的好。 用户心理可能有个阈值，低于它，体验就会很差，高过它，够用就行了。</p>
</blockquote>
<p><em>时序领域，没有很好的数据集。</em></p>
<p>迁移学习并不用很大的数据集。</p>
<hr>
<p><strong>AlexNet</strong></p>
<p>2012之前流行的是 kernels 核方法，有优美的理论支撑，SVM不用调参哈哈。</p>
<p>还有几何学，不断做物理假设，研究地球的规律，但是深度学习做的比他们更好，还有特征工程。</p>
<blockquote>
<p>吴恩达是说小规模数据分不出差距，神经网络在大规模数据上有优势，异曲同工吧！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304353.png" alt="image-20220227201740031" style="zoom:60%;" align = 'left'/>

<p>计算能力的增长超过了数据的增长。</p>
<p>90年代，用的还是神经网络，模型比较小，比较便宜；</p>
<p>2000年的时候核方法是主流，简单，有理论支撑，能找到核方法的核；</p>
<p>现在深度学习又是主流，因为计算超过了数据（GPU的兴起），可以构造更深的网络结构，用计算量换取精度。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304808.png" alt="image-20220227202614151" style="zoom:50%;" align = 'left'/>“更深更大的LeNet”：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310913.png" alt="alexnet" style="zoom: 67%;" /></p>
<p>2012年，AlexNet赢了2012ImageNet竞赛。          </p>
<p>创新点：<u>丢弃法，Relu的使用，MaxPooling</u>（取值大，梯度大，更好训练）</p>
<p>【由此开启了CNN学习特征而非人工特征的时代，省力高效，更加普适】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304506.png" alt="image-20220227203023302" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310438.png" alt="image-20220227203654546" style="zoom:50%;" /></p>
<p>卷积对位置敏感，那就数据增强（<strong>非常重要</strong>），让你不能记住所有数据。AlexNet在训练时增加了大量的图像增强数据，如翻转、裁切和变色。 这使得模型更健壮，更大的样本量有效地减少了过拟合</p>
<p>GPU beats CPU：首先，功耗往往会随时钟频率呈二次方增长。 对于一个CPU核心，假设它的运行速度比GPU快4倍，你可以使用16个GPU内核取代，那么GPU的综合性能就是CPU的16×1/4=416×1/4=4倍。 其次，GPU内核要简单得多，这使得它们更节能。 此外，深度学习中的许多操作需要相对较高的内存带宽，而GPU拥有10倍于CPU的带宽。</p>
<p>Fashion-MNIST图像的分辨率（28×2828×28像素）低于ImageNet图像。 为了解决这个问题，我们将它们增加到224×224224×224（通常来讲这不是一个明智的做法，但我们在这里这样做是为了有效使用AlexNet架构）</p>
<blockquote>
<p>Lenet太小以至于难以利用GPU资源，Alexnet相对好一点，所以虽然计算量差了200倍，但速度只差了20倍</p>
</blockquote>
<p>ImageNet仍是当下使用最常用的</p>
<p>现在已经比较成熟，CV新的model难搞，但是落地的demo做的人很多，好做一些。</p>
<p><u>resize要保持高宽比</u>，一般短边为基线，然后拿出中间的；或随机取5、6个短x短的</p>
<hr>
<p><strong>VGG</strong></p>
<p>神经网络更深更大自然更好，但是如何组织才能有效的实现呢，太多全连接层太贵，</p>
<p>AlexNet证明深层神经网络卓有成效，但它没有提供一个通用的模板来指导后续的研究人员设计新的网络。 在下面的几个章节中，我们将介绍一些常用于设计深层神经网络的启发式概念。</p>
<p>与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加抽象。研究人员开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式。</p>
<p>通过使用<u>循环和子程序</u>，可以很容易地在任何现代深度学习框架的代码中实现这些重复的架构。</p>
<p>新思想：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091304409.png" alt="image-20220301170502335"></p>
<p><em>学术界一派对另一派的打压。</em></p>
<hr>
<p><strong>NiN</strong></p>
<p>AlexNet和VGG对LeNet的改进主要在于如何扩大和加深这两个模块。然而，如果使用了全连接层，可能会完全放弃表征的空间结构。 <em>网络中的网络</em>（<em>NiN</em>）提供了一个非常简单的解决方案：在每个像素的通道上分别使用多层感知机。</p>
<p>而且1x1能增加非线性性，因为block里有ReLU函数。</p>
<blockquote>
<p>1x1卷积核，又称为网中网（Network in Network）</p>
</blockquote>
<p>现在已经不怎么流行了。</p>
<p>但是最近那个用MLP代替CNN，以及当年的用CNN代替MLP（参数比较少）的思想其实是类似的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310201.png" alt="image-20220301182209058" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310257.png" alt="image-20220301182551558" style="zoom:67%;" /></p>
<p>NiN和AlexNet之间的一个显著区别是NiN<strong>完全取消了全连接层</strong>。<br>全连接存在的问题：参数量过大，降低了训练的速度，且很容易过拟合<br>相反，NiN使用一个NiN块，其输出通道数等于标签类别的数量。最后放一个<em>全局平均汇聚层</em>（global average pooling layer）（gap），生成一个对数几率 （logits）。NiN设计的一个优点是，它显著减少了模型所需参数的数量。然而，在实践中，这种设计有时会增加训练模型的时间。</p>
<p>大量1x1卷积会拖慢运行速度，这个一般，后来google更好地使用了这个卷积。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310515.png" alt="img"></p>
<p>python做service十分容易，写个for loop就行了。</p>
<p>【深度神经网络结构里都没有softmax，因为那个是<strong>放在train时的loss里的不是放在网络结构</strong>里的。】</p>
<p><u>加入全局池化层，降低了模型复杂度，提高了泛化性，但是收敛会变慢，原来的全连接层太强大了，能很快的收敛。</u></p>
<p>预测函数实现的时候，记得把<u>原始labels copy到GPU上</u>，才能计算并做预测；同时<u>预测结果要拿回CPU</u>，与其他的计算。</p>
<hr>
<p><strong>GoogLeNet</strong></p>
<p>GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。 这篇论文的一个重点是<u>解决了什么样大小的卷积核最合适的问题</u>。 本文的一个观点是，有时使用不同大小的卷积核组合是有利的。我们省略了一些为稳定训练而添加的特殊特性，现在有了更好的训练方法，这些特性不是必要的。</p>
<p>《致敬LeNet》——但是其实一点关系都没有，我感觉他们就是皮了，正好le一样吧。设计灵感参考了NiN</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310648.png" alt="image-20220301193115974" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310903.png" alt="image-20220301193708210" style="zoom:50%;" /></p>
<p>xs，作者从来都没说过这些通道数怎么来的，可能是氪金氪出来的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310427.png" alt="image-20220301193811093" style="zoom:40%;" align = 'left'/>

<blockquote>
<p>ps:</p>
<p>FLOPS：注意全大写，是floating point operations per second的缩写，意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。</p>
<p>FLOPs：注意s小写，是floating point operations的缩写（s表复数），意指浮点运算数，理解为计算量。可以用来衡量算法/模型的复杂度。</p>
<p>注意在深度学习中，我们用的是FLOPs，也就是说计算量，即用来衡量算法/模型的复杂度。</p>
</blockquote>
<p>一个Stage是高宽减半。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310570.png" alt="image-20220301194340374" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091310532.png" alt="image-20220301194400972" style="zoom:60%;" /></p>
<p>都是把高宽先减下去，然后通道数拉上去便于后面计算，不然计算量太大了。<br>【更小的卷积层，高宽保留的比Alex还是多一点，能支持后续更深的Network】</p>
<p>v2使用了batch normalization  v3修改了Inception块， v4使用残差连接。</p>
<p>v3现在还是很常用，精度不差太多，运算速度也还行。</p>
<p>写这个网络真麻烦。。。虽然结构确实挺好理解，以后还是copy吧。 trick is more important</p>
<hr>
<h4 id="Modern"><a href="#Modern" class="headerlink" title="Modern"></a>Modern</h4><p><strong>Batch Norm</strong></p>
<p>对于很深的层，这个应该是不可或缺的，效果很好。</p>
<blockquote>
<p>吴恩达：</p>
<p><strong>Batch</strong>归一化减少了输入值改变的问题，它的确使这些值变得更稳定，神经网络的之后层就会有更坚实的基础。即使使输入分布改变了一些，它会改变得更少。它<strong>减弱了前层参数的作用与后层参数的作用之间的联系</strong>，它使得网络每层都可以自己学习，稍稍独立于其它层，有助于加速整个网络的学习。</p>
<p><strong>Batch</strong>归一化含几重噪音，因为标准偏差的缩放和减去均值带来的额外噪音。这里的均值和标准差的估计值也是有噪音的，所以类似于<strong>dropout</strong>，<strong>Batch</strong>归一化有轻微的正则化效果，因为给隐藏单元添加了噪音，这迫使后部单元不过分依赖任何一个隐藏单元，类似于<strong>dropout</strong>，它给隐藏层增加了噪音，因此有轻微的正则化效果。因为添加的噪音很微小，所以并不是巨大的正则化效果，你可以将<u><strong>Batch</strong>归一化和<strong>dropout</strong>一起使用</u>，如果你想得到<strong>dropout</strong>更强大的正则化效果。</p>
<p>也许另一个轻微非直观的效果是，如果你应用了较大的<strong>mini-batch</strong>，对，比如说，你用了512而不是64，通过应用较大的<strong>min-batch</strong>，你减少了噪音，因此减少了正则化效果，这是<strong>dropout</strong>的一个奇怪的性质，就是应用较大的<strong>mini-batch</strong>可以减少正则化效果。</p>
<p>说到这儿，我会把<strong>Batch</strong>归一化当成一种正则化，这确实不是其目的，但有时它会对你的算法有额外的期望效应或非期望效应。但是==不要==把<strong>Batch</strong>归一化当作正则化，把它当作将你归一化隐藏单元激活值并加速学习的方式，我认为正则化几乎是一个意想不到的副作用。</p>
</blockquote>
<p> <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311879.png" alt="image-20220301211525342" style="zoom: 45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311921.png" alt="image-20220301211832235" style="zoom:63%;" /></p>
<p>请注意，我们在方差估计值中添加一个小的常量ϵ&gt;0，以确保我们永远不会尝试除以零</p>
<p><u>对于卷积和全连接的类比，一个像素是1x通道数，可以看成一个样本，通道数=特征维数，样本数=batch*h*w</u></p>
<p><u>所以1x1全连接类比全连接就很好理解了。</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311028.png" alt="image-20220301212736604" style="zoom:50%;" />

<p>因为你每次是随机取样，当前的均值和方差相当于随机的。</p>
<p>好处是可以<u>加速收敛</u>，学习率可以调大一些，但一般不改变模型精度。</p>
<p>xavier是初始化，是数值一开始不要炸；BN是在模型训练的whole过程，增加==噪音==。</p>
<p>BN仍然难以解释，但已经被证明是一种不可或缺的方法。它<u>适用于几乎所有图像分类器</u>，并在学术界获得了数万引用。</p>
<p><u>先跟着内存调batch size（增加直到每秒处理样本数不再增大），再调学习率，框架之间都差不多，epoch调大点，多了就停下。</u></p>
<hr>
<p><strong>ResNet</strong></p>
<p>只有当较复杂的函数类包含较小的函数类时，我们才能确保提高它们的性能。 对于深度神经网络，如果我们能将新添加的层训练成<em>恒等映射</em>（identity function）f(x)=xf(x)=x，新模型和原模型将同样有效。 同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。【通常不会让模型变坏，如果下降了，那就令g(x)为0，直接映射x】</p>
<p>残差网络的核心思想是：每个附加层都应该更容易地<u>包含原始函数作为其元素之一</u>。 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311526.png" alt="image-20220302090850372" style="zoom:50%;" />

<p>一般用rescnet 34就行了，resnet 152一般用来刷榜。。。实际不怎么用</p>
<p>精度更高的其实都是resnet变种。</p>
<p>乘法变加法，防止梯度出问题。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311458.png" alt="image-20220302101927140" style="zoom: 33%;" />





<h3 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a><em>hardware</em></h3><p>一台服务器可以支持多个GPU，高端服务器最多支持8个GPU。更典型的数字是工程工作站最多4个GPU，这是因为热量、冷却和电源需求会迅速增加，超出办公楼所能支持的范围。对于更大的部署，云计算（例如亚马逊的<a href="https://aws.amazon.com/ec2/instance-types/p3/">P3</a>和<a href="https://aws.amazon.com/blogs/aws/in-the-works-ec2-instances-g4-with-nvidia-t4-gpus/">G4</a>实例）是一个更实用的解决方案。</p>
<p>由于Python中的全局解释器锁（GIL），CPU的<u>单线程性能</u>在我们有4-8个GPU的情况下可能很重要。所有的条件都是一样的，这意味着核数较少但时钟频率较高的CPU可能是更经济的选择。</p>
<p>GPU性能主要是以下三个参数的组合：</p>
<ol>
<li><strong>计算能力</strong>。通常我们追求32位浮点计算能力。16位浮点训练（FP16）也进入主流。如果你只对预测感兴趣，还可以使用8位整数。最新一代图灵GPU提供4-bit加速。不幸的是，目前训练低精度网络的算法还没有普及。</li>
<li><strong>内存大小</strong>。随着你的模型变大或训练期间使用的批量变大，你将需要更多的GPU内存。检查HBM2（高带宽内存）与GDDR6（图形DDR）内存。HBM2速度更快，但成本更高。</li>
<li><strong>内存带宽</strong>。只有当你有足够的内存带宽时，你才能最大限度地利用你的计算能力。如果使用GDDR6，请追求宽内存总线。</li>
</ol>
<p>在每个系列中，价格和性能大致成比例。Titan因拥有大GPU内存而有相当的溢价。然而，较新型号具有更好的成本效益</p>
<p><em>提高CPU利用率</em></p>
<p>V：L1 cache: 3 cycles   L2 cache: 11 cycles  L3 cache: 25 cycles   Main Memory: 100 cycles</p>
<p>cpu达不到理论计算能力，很大可能是内存访问太慢了。<u>行为样本比列块</u>。。因为CPU是按行存储，速度差距蛮大的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311686.png" alt="image-20220302122045303" style="zoom:50%;" />

<p>intelCPU使用了超线程，就是一个物理核变成几个虚拟核，告诉你的是虚拟的。</p>
<p>但是对于计算机密集型，超线程没什么用，因为它们共享寄存器。超线程对于几个不同的任务比较有用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311033.png" alt="image-20220302141025208" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091311658.png" alt="image-20220302141629821" style="zoom:50%;" /></p>
<p><u>向量化</u>（c = a+b）这种写法，非常容易并行，能很好地利用CPU的多核</p>
<p><em>提高GPU利用率</em></p>
<p>GPU如果内存带宽跟不上，很难跑满，你得去内存里面拿数据，然后进行计算。<br>所以GPU在运算和带宽上做的很大，代价是内存大不了。而且<u>显存都是高带宽的，很贵，比CPU的贵多了</u>，所以在这上面扣。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312177.png" alt="image-20220302142457918" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312509.png" alt="image-20220302143021719" style="zoom:50%;" /></p>
<p>神经网络得够大，<u>特征不到几千维</u>，都打不满。<br>控制语句打比方，一个判断，几千个线程得停下来等（现在有改善，只停一组核，但还是很亏）</p>
<p>因为带宽限制，CPU和GPU少点互传；因为<strong>同步的开销</strong>，<u>最好一次传完</u>，别一会传一下【可视化和计算loss占用的很少没事】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312959.png" alt="image-20220302143509772" style="zoom:50%;" />

<p>一般GPU就用来打游戏哈哈，放视频都用不上。<u>要做好高性能，硬件很重要，编译器同等重要</u>，CUDA就投入很多资源。最难的是软件，编译器，和你的生态。</p>
<p>核数和频率与功耗有很大关系。</p>
<p>在深度学习框架内部，对GPU的运算也有很多优化，参数的顺序都是有讲究的，甚至会内部格式化后再参与计算。</p>
<p>计算量发展是指数型的，如果什么东西被发现有效，大家会拼命往上堆。</p>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312336.png" alt="image-20220302150601418" style="zoom:67%;" />

<p>沐神：分久必合，合久必分。硬件增长是线性的，任务确是log增长，在任务超过硬件时，很多人会去做“专用”，比如领域专用，分布式，定制。而任务不是无穷无尽的，ImageNet 100w也够了，等硬件追上来，大家又去做通用的了。</p>
</blockquote>
<p>python的multiprocessing做的很拉跨，不如<a href="https://numba.pydata.org/">numba</a>   go的分布式和这里的分布式理论上有差距，不太适合高性能。<br>每个语言都有自己的特性，用的人群是有特征的，go都是做网页的那些人，不会关注高性能计算。</p>
<p>要复现论文，80%的论文不能复现，而且作者得把细节写出来，得理解每一句话，有时候会放论文，是很细节，很锻炼能力的事情。</p>
<p>硬件和软件不一样，技术细节不能公布和讨论（TPU公布了）</p>
<hr>
<p><strong>More Chips</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319636.png" alt="image-20220302144247435" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312741.png" alt="image-20220302155127372" style="zoom: 50%;" /></p>
<p>但是你要是指令用不到那么多计算，那就浪费掉了。</p>
<p>华为用了大量的FPGA，比如路由器，因为不像专用ASIC一样不可更新，其更新换代可以通过烧录进行。</p>
<p><em>专用</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312527.png" alt="image-20220302155616213" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312901.png" alt="image-20220302160240458" style="zoom: 43%;" /></p>
<p>Nvidia盈利：游戏卡赚不了几个钱，但是你学会怎么开发后，到公司里，公司得买server啥的，贼贵，盈利90%</p>
<p>TPU这样的专用芯片，就能省下很多钱。大家都造ASIC是因为不用实现通用，就能省下很多的精力，造的难度骤降，而且便宜。</p>
<p>但可能会担心2，3年做出来，应用已经不火了。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312868.png" alt="image-20220302161225020" style="zoom:50%;" align = 'left'/>

<p>TPU还是用tensorflow跑比较好，pytorch的<a href="https://github.com/pytorch/xla">xla</a>也支持，但是沐神说毕竟不是原生的。</p>
<blockquote>
<p><u>对于云和数据中心，功耗不是大问题，电费不是一个机房的大头，3年才多少钱，还比不上设备换代。</u></p>
<p>芯片一代用个2，3年就可以啦。</p>
<p>网络设计，首先还是考虑了硬件的能力，所以papers也得fit到硬件上，==软硬是鸡生蛋，蛋生鸡，相互影响==。<br>比如TPU内存特别大，而且算全连接层很好，所以transformer在TPU上能很好run，它的发明也是受到TPU很大的影响。</p>
<p>很多手机厂商号称的ASIC其实是个DSPxs</p>
<p>如果框架：真开源，其实不用担心，只要框架间还在竞争没用垄断，就不用担心，因为付费损失的是开发者。<br>框架相对来说比较简单？？？我感觉沐神在凡尔赛。</p>
</blockquote>
<p><strong>单机多卡并行</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312615.png" alt="image-20220302181533510" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312237.png" alt="image-20220302181601661" style="zoom:40%;" /></p>
<p>模型并行难优化一些，而且可能有些机器空闲。数据并行性能会变差，因为矩阵变小了，能用的进程↓</p>
<p>显存优化是很难的啦，靠的是框架，pytorch做的还行。</p>
<p>==验证集准确度波动较大，一般是learning-rate的原因==，batchsize小，你lr就不能太大。</p>
<p>batch-norm和不断地调学习率有异曲同工之处，但是学习率鬼知道哪里调大哪里调小，不如BN方便。</p>
<p>如果不同GPU性能不一样，最好算好性能差，按倍率分配任务，最好同时算完并行度好一些，涉及同步机制。</p>
<h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><p>所有机器都能读取样本，数据放在分布式文件结构上。</p>
<p>通常有多个worker，每个worker可能有好几个GPU</p>
<p>还有多个参数服务器，<u>每个服务器存了模型的一部分参数，每次worker都是向所有服务器要</u>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091312164.png" alt="image-20220302205418348" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313175.png" alt="image-20220302205725151" style="zoom:50%;" /></p>
<p>尽量少在机器之间通信，尽量本地。</p>
<p>大致流程：</p>
<ul>
<li>每个计算服务器读取小批量的一块。</li>
<li>然后worker进一步将数据切分到每个GPU上</li>
<li>每个worker从参数服务器拿到参数，复制到每个GPU上</li>
<li>将所有GPU上的梯度求和，在本地做all-reduce，然后把加起来的发出去。（减少通讯次数）</li>
<li>每个参数服务器对梯度求和，并更新参数。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313202.png" alt="image-20220302210605348" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313315.png" alt="image-20220302210728489" style="zoom:45%;" /></p>
<p>$t_1$和batch-size正相关，但是$t_2$不会，因为发送的是参数，为了防止被通信阻碍，选择合适的batch使$t_1$直观上比$t_2$大20%~30%好</p>
<p>取max函数是因为通讯和计算是可以并行的，算一个发一个哈哈类似这种。</p>
<p>但是增加了以后会导致收敛变慢，所以需要更多的epoch。。。所以如果过度，反而会浪费时间，涉及到<strong>权衡</strong>的问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313155.png" alt="image-20220302212847324" style="zoom:45%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313800.png" alt="image-20220302213015960" style="zoom: 45%;" /></p>
<p>异步的通讯开销会变低。</p>
<p>单机内部用模型并行，一般跨机器都用数据并行</p>
<p>data parralel是一种并行模式，之前讲的是这种模式怎么用于单机和分布式</p>
<p>【沐神：假设分类的类别数是n，那么batch不要超过10*n、20*n，不过很多时候你没那么多GPU哈哈，一般是：GPU尽量加batch，然后看有多少机器，加到没有增益就算了。剩下的跑别的，也不需要全部用上。】</p>
<h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><p><strong>Augmentationi</strong></p>
<p>不是一件太便宜的事情，多开几个num_workers快（取决于CPU），但是windows有问题。。</p>
<p>训练集尽可能地模拟部署时的实际应用场景是提高模型泛化性的好方法。需要人工判断。</p>
<p>一般是<strong>随机的</strong>增强，<strong>在线生成</strong>，然后利用新的来训练，当然只是在训练的时候用。</p>
<p>上下翻转不比左右翻转，得考虑到现实中，房子、猫什么的就不能上下吧。。。当然躺着的猫也是可以上下转的。</p>
<p>切割：随机高宽比（不能太离谱，比如取值范围[3/4,4/3]）、随机大小(有限制)、随机位置，但是形状大小要一致。</p>
<p>颜色：色调、饱和度、明亮度。一般取值在[0.5,1.5]之间。</p>
<blockquote>
<p><strong>对比度：</strong><br>是画面黑与白的比值，也就是从黑到白的渐变层次。比值越大，从黑到白的渐变层次。比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富。</p>
<p><strong>亮度：</strong><br>亮度指照射在景物或图像上光线的明暗程度。</p>
<p><strong>色调：</strong><br>色调指的是一幅画中画面色彩的总体倾向，是大的色彩效果</p>
<p><strong>饱和度：</strong><br>饱和度是指色彩的鲜艳程度，也称色彩的纯度。取决于该色中含色成分和消色成分（灰色）的比例。含色成分越大，饱和度越大</p>
</blockquote>
<p>imgaug 👈 提供了一堆类似的变化。你觉得他有用，是要从<u>部署的可能性</u>出发的</p>
<p>有时候你数据增强后，测试精度可能比训练精度还高，不过仔细调整后训练精度还是会慢慢上来的。</p>
<p><u>原始图片多 $\neq$ 多样性好</u>，还是得分析实际部署的分布。</p>
<p>图片增广需要大概人工看一下效果，图片增广的均值很多不变的。</p>
<p>马赛克：是一种遮挡，因为神经网络识别的绝大部分是纹理，特征（部位），而不是像人类一样总体识别比如一只猫</p>
<p>沐神也不知道为啥mix-up增广有用，但效果挺好的</p>
<p>图神经网络训练很难，落地挺让人头疼</p>
<h4 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h4><p>CV中对深度学习来讲最important的技术（迁移学习这一大类中的一种算法）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313307.png" alt="image-20220303111214593" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313893.png" alt="image-20220303111342590" style="zoom:40%;" /></p>
<p>初始化最后一个分类层。【只能手动提取，嫌麻烦也可以不用，一般用的不多】</p>
<p>成员变量<code>output</code>的参数是随机初始化的，通常需要更高的学习率才能从头开始训练。 假设<code>Trainer</code>实例中的学习率为η，我们将成员变量<code>output</code>中参数的学习率设置为10η。</p>
<p>找pretrained的model时也得找相应领域的，判断癌症的就找医学领域的sei。</p>
<p>微调对学习率不敏感，可以选一个比较小的就行了，比如沐神用的e^-5</p>
<p>而且，这个pretrained的模型一旦弄出来，并不是只用于单任务，它实际是抽取特征，可以用到各类任务（分类、预测。。）</p>
<p>torchvision比较经典，但是更新不快。</p>
<h4 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h4><p>很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。 在计算机视觉里，我们将这类任务称为<em>目标检测</em>（object detection）或<em>目标识别</em>（object recognition）。</p>
<p>相比于图像分类，其实客户更关心的还是图像识别。</p>
<p>图片分类中一定有个主体，但是目标检测里面可能有多个物体，而且还要找出位置。</p>
<p><strong>数据集格式</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313367.png" alt="image-20220319190238756" style="zoom: 33%;" align = 'left'/>

<p>所以每行可能6个值。</p>
<p> 输入参数<code>boxes</code>可以是长度为4的张量，也可以是形状为（n，4）的二维张量，其中n是边界框的数量。</p>
<p>目标检测领域没有像MNIST和Fashion-MNIST那样的小数据集。 为了快速测试目标检测模型，我们收集并标记了一个小型数据集。</p>
<p>无人车不仅仅是视觉，还有许多3D检测器，精度非常高。</p>
<blockquote>
<p>首先采集一点数据出来，手标个几十几百张，然后用fine tuning训练一个模型。再用它去预测接下来很多图片，把预测不那么置信的（概率比较低的）拿出来重新标一下，重新迭代。可能最后标个几千张。但如果更高的工业需求就找人吧</p>
</blockquote>
<p>几百张数据，如果能找到<u>比较类似的预训练</u>模型，其实已经不错了</p>
<p>一般我们喜欢用 ImageNet 来做网络的预训练，主要有两点，一方面 ImageNet 是图像领域里有超多事先标注好训练数据的数据集合，分量足是个很大的优势，量越大训练出的参数越靠谱；另外一方面因为 ImageNet 有 1000 类，类别多，算是通用的图像数据，跟领域没太大关系，所以通用性好，预训练完后哪哪都能用，是个万金油。分量足的万金油当然老少通吃，人人喜爱。</p>
<hr>
<p>目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边界从而更准确地预测目标的<em>真实边界框</em>（ground-truth bounding box）。 </p>
<p>不同的模型使用的区域采样方法可能不同。 这里我们介绍其中的一种方法：以每个像素为中心，生成多个缩放比和宽高比（aspect ratio）不同的边界框。 这些边界框被称为<strong>锚框</strong>（anchor box）【目前更为主流】</p>
<p>预测每个锚框中是否含有关注的物体，if True，预测从该锚框到真实边缘框的偏移。</p>
<p>每个锚框是个训练样本，每个锚框要么标注成背景（nothing），要么关联一个真实边缘框，可能生产一堆锚框，导致大量的负样本</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313809.png" alt="image-20220319215317086" style="zoom:40%;" />

<p>这种赋予标号的方法👆是一种常用做法。这样每个边缘框都分到一个锚框。其他都是负样本。（具体模型可能有不同方法）</p>
<p>NMS用于预测时去掉冗余。常用的是每一类内部处理，当然也有全部拿到一起处理的</p>
<p>由于锚框的引入，算法复杂度远远大于图像分类。实现起来麻烦的要死。</p>
<hr>
<h5 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h5><p>R-CNN是奠基性工作 SSD YOLO 【都是基于锚框的，非锚框的工作比较新】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313917.png" alt="image-20220320184459559" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313352.png" alt="image-20220323173530928" style="zoom: 50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313884.png" alt="image-20220323173602452" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091313672.png" alt="image-20220323180110311" style="zoom:50%;" /></p>
<p>R-CNN（速度很慢）包括以下四个步骤：</p>
<ol>
<li>对输入图像使用<em>选择性搜索</em>来选取多个高质量的提议区域 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#uijlings-van-de-sande-gevers-ea-2013">Uijlings et al., 2013]</a>。这些提议区域通常是在多个尺度下选取的，并具有不同的形状和大小。每个提议区域都将被标注类别和真实边界框。</li>
<li>选择一个预训练的卷积神经网络，并将其在输出层之前截断。将每个提议区域变形为网络需要的输入尺寸，并通过前向传播输出抽取的提议区域特征。</li>
<li>将每个提议区域的特征连同其标注的类别作为一个样本。训练多个<u>SVM</u>对目标分类，其中每个支持向量机用来判断样本是否属于某一个类别。</li>
<li>将每个提议区域的特征连同其标注的边界框作为一个样本，训练<u>线性回归模型</u>来预测真实边界框。</li>
</ol>
<hr>
<p>R-CNN的主要性能瓶颈在于，对每个提议区域，卷积神经网络的前向传播是独立的，而没有共享计算。 由于这些区域通常有重叠，独立的特征抽取会导致重复的计算。<em>Fast R-CNN</em> [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#girshick-2015">Girshick, 2015]</a>对R-CNN的主要改进之一，是<u>仅在整张图象上</u>执行卷积神经网络的前向传播。</p>
<ol>
<li>与R-CNN相比，Fast R-CNN用来提取特征的卷积神经网络的输入是整个图像，而不是各个提议区域。此外，这个网络通常会参与训练。设输入为一张图像，将卷积神经网络的输出的形状记为$1×c×h_1×w_1$。</li>
<li>假设选择性搜索生成了n个提议区域。这些形状各异的提议区域在卷积神经网络的输出上分别标出了形状各异的兴趣区域。然后，这些感兴趣的区域需要进一步抽取出形状相同的特征（比如指定高度h2和宽度w2），以便于连结后输出。为了实现这一目标，Fast R-CNN引入了<em>兴趣区域汇聚层</em>（RoI pooling）：将卷积神经网络的输出和提议区域作为输入，输出连结后的各个提议区域抽取的特征，形状为n×c×h2×w2。</li>
<li>通过全连接层将输出形状变换为n×d，其中超参数d取决于模型设计。</li>
<li>预测n个提议区域中每个区域的类别和边界框。更具体地说，在预测类别和边界框时，将全连接层的输出分别转换为形状为n×q（q是类别的数量）的输出和形状为n×4的输出。其中预测类别时使用softmax回归。</li>
</ol>
<p>ROI：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314923.png" alt="image-20220323131456293" style="zoom:30%;" />



<p><em>Faster R-CNN</em> [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#ren-he-girshick-ea-2015">Ren et al., 2015]</a>提出将选择性搜索替换为<em>区域提议网络</em>（region proposal network），从而减少提议区域的生成数量，并保证目标检测的精度。模型的其余部分保持不变。【先做个大概的预测，再做精准的预测】</p>
<p>区域提议网络的计算步骤如下：</p>
<ol>
<li>使用填充为1的3×3的卷积层变换卷积神经网络的输出，并将输出通道数记为c。这样，卷积神经网络为图像抽取的特征图中的每个单元均得到一个长度为c的新特征。</li>
<li>以<strong>特征图的每个像素</strong>为中心，生成多个不同大小和宽高比的锚框并标注它们。</li>
<li>使用锚框中心单元长度为c的特征，分别预测该锚框的二元类别（含目标还是背景）和边界框。</li>
<li>使用非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测边界框即是兴趣区域汇聚层所需的提议区域。</li>
</ol>
<p>【但是即使是Faster，也还是挺慢的】</p>
<p>Mask R-CNN用于标注了像素级位置的情况，其他不变，双线性插值。ROI pooling换成ROI align，可以切像素，然后加权算。便于像素级别预测。在无人车领域用的比较多</p>
<p><strong>这一系列，处理速度慢，精度高，内存占用高</strong> 目标检测比图片分类贵很多。</p>
<hr>
<p>现在SSD（Single Shot MultiBox Detector）用的不那么多</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314592.png" alt="image-20220323182032493" style="zoom: 67%;" />

<p>常用ResNet</p>
<p>可以设计基础网络，使它输出的高和宽较大。 这样一来，基于该特征图生成的锚框数量较多，可以用来检测尺寸较小的目标。<br>接下来的每个多尺度特征块将上一层提供的特征图的高和宽缩小（如减半），特征图中每个单元在输入图像上的感受野变得更广阔。</p>
<p>速度比较快，精度比较低。单神经网络，一次过。</p>
<p><u>SSD没有人继续做细节更新，但实现十分简单，启发了后续工作。而且可以用python，之前的R-CNN用python实现都难。</u></p>
<blockquote>
<p>多尺度</p>
<p>更低维度的空间分辨率较高，但是更局部；更高维度的空间分辨率较低，但是看到全局。</p>
<p>在不同的stage都做目标检测，这就是多尺度</p>
</blockquote>
<hr>
<p>You Only Look Once</p>
<p>追求速度</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314997.png" alt="image-20220323183220189" style="zoom: 33%;" align = 'left'/>

<p>为了防止一个框中有多个物体时被漏掉，每个锚框预测B个。。</p>
<p>YOLO v3时，作者跑路了，然后由他的合作者接手了。加入了聚类算法，统计你数据集中检测物体的大小规律，生成针对的锚框</p>
<blockquote>
<p>李沐：YOLO v3算是特别差的论文哈哈</p>
<p>非锚框的技术目前的发展也很迅速，什么基于像素的预测什么的（FCN）</p>
</blockquote>
<p>YOLO 系列相对于RCNN精度差了一些，但是速度提高到了和SSD类似的地步（5、6倍）</p>
<hr>
<p>对于OCR这种识别的物体特别小的，一般选择分辨率很高的图片，用R-CNN（精度较高）处理。</p>
<p>车牌识别已经很成熟了。</p>
<blockquote>
<p>卷积、激活函数、池化组合。。。更像一门计算机语言</p>
<p>Attention更关注全局，CNN关注局部，这些被沐神比作流派:joy: 。。。哎老中医了，也没有好的总结。</p>
</blockquote>
<p>NMS在GPU很难跑，一堆iteration比来比去。</p>
<p>当特征图的长宽比较小时，size一般比较大，反之比较小。</p>
<p>特别大的图片，SSD不那么适合。还是RCNN分开两次比较合适，或者YOLO，不管多大，锚框都不会很多。</p>
<p>多个loss加权相加，可以先画出来看看，然后拉到一个数量级上。</p>
<p>NMS的实现有许多加速的细节，不过那都是cuda干的事情了</p>
<p><u>目标检测的fine tuning一般是用图片分类的CNN模型，而cls_predict 和bbox_predict 都是随机初始化的。</u></p>
<p>pytorch也实现了，不过内部是调用的C++的代码。</p>
<p>嵌入式最好用YOLO。</p>
<p>很难公平的比较两个不一样的架构谁好谁坏，因为里面有很多tricks，最后表现的是整体的精度。最后就变成你喜欢哪个用哪个。</p>
<h4 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h4><p>常见的数据格式是VOC和COCO</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314372.png" alt="image-20220324131324548" style="zoom:50%;" />

<p>历史久远了，比如聚类，把像素聚在一起，给一个label。</p>
<p>语义分割属于有监督学习。应用：背景虚化、路面分割。</p>
<p>还有一个<strong>实例分割</strong>，不仅分割类，还检测每个实例，相当于是目标检测的进阶版。</p>
<p>（数据集很贵，因为很难标，所以相对数据集不大，但是无人车挺多，因为大家都不缺钱。）</p>
<p>更精细的语义分割，比如狗的头、身体什么的，可能存在二义性的问题，有个技术叫<strong>关键点识别</strong>。</p>
<p>假设目标框旋转，可以画一个大框圈出来（图像处理也有提到）</p>
<p>人是个比较简单的物体，做起来的难点是人的光照，形状是很容易做语义分割的。这一块能找到很好pretrained的model</p>
<p>3D做语义分割反而会简单很多？三维卷积</p>
<p>自动驾驶有几十、上百个模型一起作用，语义分割主要做路面分割，目标检测（3d）主要测前车和行人和距离、速度。</p>
<hr>
<p><strong>转置卷据</strong></p>
<p>一般卷积不会增大输入的高宽、太大的padding是不可取的，转置卷积可以。</p>
<p>对于语义分割，如果高宽一直减小，最后就做不了像素级别的输出了。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314195.png" alt="image-20220325104510887" style="zoom:50%;" align = 'left'/>

<p>这里的填充指的是输出结果的外围被视为填充，所以去掉。</p>
<p>卷积是为了识别local的模式，转置有点难以理解哈哈哈，可以说是特征放大？</p>
<p>转置卷积只还原了形状，并没有还原输出的那个值。</p>
<p>再谈形状：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314042.png" alt="image-20220325114326602" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314542.png" alt="image-20220325114427564" style="zoom:50%;" /></p>
<hr>
<p>FCN 全连接卷积神经网络时深度学习做语义分割的奠基性工作。</p>
<p>所以现在用的不多。但是思想比较简单</p>
<p>全卷积网络先使用卷积神经网络抽取图像特征，然后通过1×1卷积层将通道数变换为类别个数，最后在 <a href="https://zh-v2.d2l.ai/chapter_computer-vision/transposed-conv.html#sec-transposed-conv">13.10节</a>中通过转置卷积层将特征图的高和宽变换为输入图像的尺寸。模型输出与输入图像的高和宽相同，且最终输出通道包含了该空间位置像素的类别预测。</p>
<p>最后一层前加一个1x1卷积层把通道个数减一减，方便运算，这个操作<u>舍弃精度追求速度。</u></p>
<p>一般，用来放大的转置卷积层的<u>初始化采用双线性插值</u>，效果上相当于把图片放大了两倍。</p>
<p>UNet用了更多的层，还有许多其他工作。</p>
<hr>
<h4 id="风格迁移"><a href="#风格迁移" class="headerlink" title="风格迁移"></a>风格迁移</h4><p>没有什么商业价值，大家也就玩一玩。GAN的商业价值虽然在提升，但仍然整体不大</p>
<p>滤波器能改变照片的颜色风格，从而使风景照更加锐利或者令人像更加美白。但一个滤波器通常只能改变照片的某个方面。如果要照片达到理想中的风格，你可能需要尝试大量不同的组合。这个过程的复杂程度不亚于模型调参。</p>
<p>同样讲的是奠基性的工作，基于CNN</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314506.png" alt="image-20220325200424010" style="zoom: 67%;" />

<p>越靠近输入层，越容易抽取图像的细节信息；反之，则越容易抽取图像的全局信息。 </p>
<p>为了避免合成图像过多保留内容图像的细节，我们选择VGG较靠近输出的层，即<em>内容层</em>，来输出图像的内容特征。 我们还从VGG中选择不同层的输出来匹配局部和全局的风格，这些图层也称为<em>风格层</em>。</p>
<p><code>style_layers, content_layers = [0, 5, 10, 19, 28], [25]</code></p>
<p>用统计信息来表征风格，那么<u>各阶统计量的差异</u>可用来衡量loss【统计直方图包含高阶信息，Gram和协方差有两阶】</p>
<p>假设该输出的样本数为1，通道数为c，高和宽分别为h和w，我们可以将此输出转换为矩阵X，其有c行和hw列。 这个矩阵可以被看作是由c个长度为hw的向量x1,…,xc组合而成的。其中向量$x_i$代表了通道i上的风格特征。</p>
<p>在这些向量的<em>格拉姆矩阵</em>XX⊤∈Rc×c中，i行j列的元素xij即向量xi和xj的内积。它表达了通道i和通道j上风格特征的相关性。我们用这样的格拉姆矩阵来表达风格层输出的风格。 需要注意的是，当hw的值较大时，格拉姆矩阵中的元素容易出现较大的值。 此外，格拉姆矩阵的高和宽皆为通道数c。 为了让风格损失不受这些值的大小影响，格拉姆矩阵除以矩阵中元素的个数，即chw</p>
<p><em>全变分去噪</em>（total variation denoising） 假设xi,j表示坐标(i,j)处的像素值，降低全变分损失</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314283.png" alt="image-20220325202643645"></p>
<p>能够尽可能使邻近的像素值相似。</p>
<blockquote>
<p>格拉姆矩阵可以看做feature之间的偏心协方差矩阵（即没有减去均值的协方差矩阵），在feature map中，每个数字都来自于一个特定滤波器在特定位置的卷积，因此每个数字代表一个特征的强度，而Gram计算的实际上是两两特征之间的相关性，哪两个特征是同时出现的，哪两个是此消彼长的等等。</p>
</blockquote>
<p>风格转移的损失函数是内容损失、风格损失和总变化损失的加权和。 通过调节这些权重超参数，我们可以权衡合成图像在保留内容、迁移风格以及去噪三方面的相对重要性。</p>
<p>在风格迁移中，合成的图像是训练期间<strong>唯一</strong>需要更新的变量。因此，我们可以定义一个简单的模型<code>SynthesizedImage</code>，并将合成的图像视为模型参数。模型的前向传播只需返回模型参数即可。</p>
<p>可以初始化为风格图片或内容图片。</p>
<p>训练大图片的小技巧：先把原图片缩小，训练一下，再放大继续训练，甚至切割分别训练</p>
<p><strong>后来用GAN来做这个事情，不用每次都训练</strong></p>
<h3 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h3><h4 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h4><p>房价预测：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">https://www.kaggle.com/c/house-prices-advanced-regression-techniques</a></p>
<p>直观地说，我们标准化数据有两个原因： 首先，它方便优化。 其次，因为我们不知道哪些特征是相关的， 所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大。</p>
<p><u>pandas的dataframe，如果索引中不用切片用单个数字，此时选的是列，方便却容易混淆。</u></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> out<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span> → Tensor
      <span class="token operator">|</span> <span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token keyword">if</span> x_i <span class="token operator">&lt;</span> <span class="token builtin">min</span>
y_i <span class="token operator">=</span> <span class="token operator">|</span> x_i<span class="token punctuation">,</span> <span class="token keyword">if</span> <span class="token builtin">min</span> <span class="token operator">&lt;=</span> x_i <span class="token operator">&lt;=</span> <span class="token builtin">max</span>
      <span class="token operator">|</span> <span class="token builtin">max</span><span class="token punctuation">,</span> <span class="token keyword">if</span> x_i <span class="token operator">></span> <span class="token builtin">max</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果预测的值的范围很大，RMSE 会被一些大的值主导。这样即使你很多小的值预测准了，但是有一个非常大的值预测的不准确，RMSE 就会很大。 相应的，如果另外一个比较差的算法对这一个大的值准确一些，但是很多小的值都有偏差，可能 RMSE 会比前一个小。先取 log 再求 RMSE(就是)，可以稍微解决这个问题。RMSE 一般对于固定的平均分布的预测值才合理。</p>
<blockquote>
<p>框架的<em>延后初始化</em>（defers initialization）， 即直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小。</p>
<p>在以后，当使用卷积神经网络时， 由于输入维度（即图像的分辨率）将影响每个后续层的维数， 有了该技术将更加方便。 现在我们在编写代码时无须知道维度是什么就可以设置参数， 这种能力可以大大简化定义和修改模型的任务。 接下来，我们将更深入地研究初始化机制。</p>
</blockquote>
<p>如果【数据区间比较大，且全为正数】，可以用log，再做均值初始化可以压缩到很好的区间。</p>
<p>在设备（CPU、GPU和其他机器）之间传输数据比计算慢得多。 这也使得并行化变得更加困难，因为我们必须等待数据被发送（或者接收）， 然后才能继续进行更多的操作。 这就是为什么拷贝操作要格外小心。</p>
<p>CPU，GPU注意降温，不要超过80</p>
<p><u>把GPU的性能留给前向、反向运算，前面的操作在CPU完成。</u></p>
<p>GPU使用60%都已经不算低了。CNN可能更高，容易dao80-90%</p>
<p>Adam对初始学习率相对不敏感。</p>
<p>𝐾折交叉验证往往对多次测试具有相当的稳定性。 然而，如果我们尝试了不合理的超参数，我们可能会发现验证效果不再代表真正的误差。</p>
<p><u>较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</u></p>
<p>可以用少量的数据找到超参数的大致范围，然后在整个数据集上跑几轮找到精确的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314823.png" alt="img" style="zoom: 33%;" />

<p>automl真的可能取代20%的调参，但是这还是得学习。80%：分析哪些数据对目标有用，搜集数据，清理数据。。。</p>
<p>你的价值体现在automl不能做的，你要做的更好，学习的知识是指数增长的。</p>
<p>世界变得很快，得要学会理论和实践的范式和能力。</p>
<p><u>当你调到一个比较好的参数点时，可以上下修改一下，如果结果剧烈波动，可能就调在了噪音上，泛化性不好。</u></p>
<p>李沐：<u>实际中调参其实没有那么重要（竞赛除外），精度还可以就行，因为数据在不断变化。</u></p>
<p>随时思考，如何成长——李沐的梯度下降</p>
<h4 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h4><p>树叶分类：<a href="https://www.kaggle.com/c/classify-leaves/data">https://www.kaggle.com/c/classify-leaves/data</a></p>
<p>少量高质量数据，可能有个百倍的换算。</p>
<p>所以不建议过度调参，这可能会overfit到目前的数据，实际场景中你可能会有越来越多的数据。（除非竞赛）</p>
<p>w = w-lr*w.grad 这样按照python的，左边是一个新的变量，没有attach gradient，梯度计算出问题。</p>
<p>机器学习老中医，深度学习炼丹哈哈哈哈哈。</p>
<h4 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h4><p>cifar-10图像识别：<a href="https://www.kaggle.com/c/cifar-10">https://www.kaggle.com/c/cifar-10</a></p>
<p>torchvision的更新没那么快，但是也不错。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#读了一个csv文件</span>
<span class="token keyword">def</span> <span class="token function">read_csv_labels</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""读取fname来给标签字典返回一个文件名"""</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        lines <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment"># 跳过文件头行(列名)</span>
    tokens <span class="token operator">=</span> <span class="token punctuation">[</span>l<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token keyword">for</span> l <span class="token keyword">in</span> lines<span class="token punctuation">]</span><span class="token comment">#每行是一个列表</span>
    <span class="token keyword">return</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> label<span class="token punctuation">)</span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> label <span class="token keyword">in</span> tokens<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#转换成一个字典以供方便使用</span>

labels <span class="token operator">=</span> read_csv_labels<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'trainLabels.csv'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#&#123;'1': 'frog', '2': 'truck', '3': 'truck',....&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里使用的是最简单的图片数据集组织格式，也就是imagefolder这个iterator，因此需要我们提前分好数据。</p>
<p><a href="https://www.cnblogs.com/wanghui-garcia/p/10649364.html">组织imagefolder的格式和其索引结构</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">copyfile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> target_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""将文件复制到目标目录"""</span>
    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>target_dir<span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    shutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> target_dir<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">reorg_train_valid</span><span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> valid_ratio<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""将验证集从原始的训练集中拆分出来"""</span>
    <span class="token comment"># 训练数据集中样本最少的类别中的样本数,这个Counter好用</span>
    n <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>labels<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment"># 验证集中每个类别的样本数</span>
    n_valid_per_label <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>n <span class="token operator">*</span> valid_ratio<span class="token punctuation">)</span><span class="token punctuation">)</span>
    label_count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> train_file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        label <span class="token operator">=</span> labels<span class="token punctuation">[</span>train_file<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">#获得文件名对应的标签</span>
        fname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train'</span><span class="token punctuation">,</span> train_file<span class="token punctuation">)</span><span class="token comment">#获得路径</span>
        copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>
                                     <span class="token string">'train_valid'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> label <span class="token keyword">not</span> <span class="token keyword">in</span> label_count <span class="token keyword">or</span> label_count<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n_valid_per_label<span class="token punctuation">:</span>
            copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>
                                         <span class="token string">'valid'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>
            label_count<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">=</span> label_count<span class="token punctuation">.</span>get<span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            copyfile<span class="token punctuation">(</span>fname<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span>
                                         <span class="token string">'train'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> n_valid_per_label

<span class="token keyword">def</span> <span class="token function">reorg_test</span><span class="token punctuation">(</span>data_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""在预测期间整理测试集，以方便读取"""</span>
    <span class="token keyword">for</span> test_file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        copyfile<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">,</span> test_file<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_dir<span class="token punctuation">,</span> <span class="token string">'train_valid_test'</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">,</span>
                              <span class="token string">'unknown'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">#scheduler是对学习率的调整，沐神说比较好的是cos，👇这个用的挺多。</span>
scheduler <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>lr_scheduler<span class="token punctuation">.</span>StepLR<span class="token punctuation">(</span>trainer<span class="token punctuation">,</span> lr_period<span class="token punctuation">,</span> lr_decay<span class="token punctuation">)</span>
在完成一个迭代的训练后要加上 scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">#重新训练，将pred放到cpu上，以及编制索引提交</span>
net<span class="token punctuation">,</span> preds <span class="token operator">=</span> get_net<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
train<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_valid_iter<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> wd<span class="token punctuation">,</span> devices<span class="token punctuation">,</span> lr_period<span class="token punctuation">,</span>
      lr_decay<span class="token punctuation">)</span>

<span class="token keyword">for</span> X<span class="token punctuation">,</span> _ <span class="token keyword">in</span> test_iter<span class="token punctuation">:</span>
    y_hat <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    preds<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sorted_ids <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_ds<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sorted_ids<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'id'</span><span class="token punctuation">:</span> sorted_ids<span class="token punctuation">,</span> <span class="token string">'label'</span><span class="token punctuation">:</span> preds<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'label'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> train_valid_ds<span class="token punctuation">.</span>classes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
df<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'submission.csv'</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>沐神：这其实是一个比较蠢的办法，因为copy了一大坨图片两次，数据如果多一点那就是很大量的复制，浪费空间和时间。在实际中通常自己写个classdata （没听清）iterator，而图片不需要动。</p>
<p>但如果图片数量不大，其实挺推荐，因为简单，而且方便鼠标点进去自己查看，很多框架都支持这样的组织方式。</p>
<p>lr-decay会让你的精度提高一些比如0.7-&gt;0.75，但不会有非常显著的提升</p>
<p>SGD本身就做了很强的正则，有很多噪音在里面，所以很稳定。</p>
<hr>
<h4 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h4><p>ImageNet-Dog分类：<a href="https://www.kaggle.com/c/dog-breed-identification">https://www.kaggle.com/c/dog-breed-identification</a></p>
<p>学术数据集注重的是通用性，业务注重客户关注的实用性。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#冻结参数，以及Sequential的使用特性。</span>
<span class="token keyword">def</span> <span class="token function">get_net</span><span class="token punctuation">(</span>devices<span class="token punctuation">)</span><span class="token punctuation">:</span>
    finetune_net <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#这应该是定义了lei</span>
    finetune_net<span class="token punctuation">.</span>features <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>resnet34<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token comment"># 定义一个新的输出网络，共有120个输出类别</span>
    finetune_net<span class="token punctuation">.</span>output_new <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 将模型参数分配给用于计算的CPU或GPU</span>
    finetune_net <span class="token operator">=</span> finetune_net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment"># 冻结参数</span>
    <span class="token keyword">for</span> param <span class="token keyword">in</span> finetune_net<span class="token punctuation">.</span>features<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        param<span class="token punctuation">.</span>requires_grad <span class="token operator">=</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> finetune_net
<span class="token comment">#train里面也要改</span>
trainer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span><span class="token punctuation">(</span>param <span class="token keyword">for</span> param <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span>
                               <span class="token keyword">if</span> param<span class="token punctuation">.</span>requires_grad<span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>lr<span class="token punctuation">,</span>
                              momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> weight_decay<span class="token operator">=</span>wd<span class="token punctuation">)</span>

<span class="token comment">#经典evaluate</span>
<span class="token keyword">def</span> <span class="token function">evaluate_loss</span><span class="token punctuation">(</span>data_iter<span class="token punctuation">,</span> net<span class="token punctuation">,</span> devices<span class="token punctuation">)</span><span class="token punctuation">:</span>
    l_sum<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token keyword">for</span> features<span class="token punctuation">,</span> labels <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>
        features<span class="token punctuation">,</span> labels <span class="token operator">=</span> features<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>features<span class="token punctuation">)</span>
        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
        l_sum <span class="token operator">+=</span> l<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        n <span class="token operator">+=</span> labels<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>l_sum <span class="token operator">/</span> n<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'cpu'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这次输出用的是softmax（题目要求的输出格式），这样可以研究top-5，即正确样本在不在预测前五里。</p>
<p>一般对于十分复杂，类别非常多的数据集（标号长得一样），大家更关心top-5.</p>
<p>老中医的丹方：先resize到256，再中心剪裁到224.</p>
<p>专家调参是非线性，靠手气哈哈，一般效率比机器调参要高一些。但还是得比较成本。</p>
<blockquote>
<p>从长远趋势来看，最后肯定是机器自动调参的。</p>
</blockquote>
<p>目前你还是可以练练调参，是个手艺活，能加深理解。没有特别好的系统学习方案，慢慢积累</p>
<p>trick不是长久的。</p>
<h3 id="Recurrent"><a href="#Recurrent" class="headerlink" title="Recurrent"></a>Recurrent</h3><p>到目前为止我们默认数据都来自于某种分布， 并且所有样本都是独立同分布的 （independently and identically distributed，i.i.d.）。 然而，大多数的数据并非如此。 例如，文章中的单词是按顺序写的，如果顺序被随机地重排，就很难理解文章原始的意思。</p>
<p>两种方案：</p>
<ol>
<li>通常做马尔可夫假设的自回归，仅关注定长的过去信息，可用之前的技术实现。</li>
<li>潜变量自回归，研究两个模型，如何根据上一个输入$x_{t-1}$和之前的时序信息$h_{t-1}$得到现在的时序信息$h_t$，以及如何用现在的$h_t$加上上一个输入$x_{t-1}$得到最新的预测$x_t$(这里引出了因果推理 casual - inference)</li>
</ol>
<p>第一种方案沐神用MLP做了演示，给定四个输入，看看不同步数的预测：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314579.png" alt="image-20220303180220223" style="zoom:50%;" align = 'left'/>

<p>可以看到，即使是简单的函数（sinx），预测未来也很难。事实是由于<u>错误的累积</u></p>
<p>隐变量是个真实存在的东西，只是没有被观察到。潜变量包括了隐变量，但也可能真的不存在，比如聚类的类信息，是现实不存在的，怎么改进sensor都观察不到。</p>
<p>$\tau$的选择，有一些平滑的衰减方法。因果分析最近在统计界和机器学习界都挺火的。</p>
<p>RNN也能记住所有的序列，而且比MLP更强大，但这不见得是一件很好的事情</p>
<p>可以把时序信息，看作是一维的信息量，1-D卷积也能用，效果不见得比RNN差</p>
<hr>
<p>中文分词是非常不容易的哈哈，曾经NLP里中文分词也是一大块。比较好的开源有jieba</p>
<p><strong>文本预处理</strong></p>
<p>一篇文章可以被简单地看作是一串单词序列，甚至是一串字符序列。 现实中的文档集合可能会包含数十亿个单词。</p>
<ol>
<li>将文本作为字符串加载到内存中。</li>
<li>将字符串拆分为词元（如单词和字符）。<em>词元</em>（token）是文本的基本单位</li>
<li>建立一个词表（vocab），将拆分的词元映射到数字索引。<br>我们先将训练集中的所有文档合并在一起，对它们的唯一词元进行统计， 得到的统计结果称之为<em>语料</em>（corpus）。 然后根据每个唯一词元的出现频率，为其分配一个数字索引。 很少出现的词元通常被移除，这可以降低复杂性。<br>另外，语料库中不存在或已删除的任何词元都将映射到一个特定的未知词元“<unk>”。 我们可以选择增加一个列表，用于保存那些被保留的词元， 例如：填充词元（“<pad>”）； 序列开始词元（“<bos>”）； 序列结束词元（“<eos>”）。</li>
<li>将文本转换为数字索引序列，方便模型操作。</li>
</ol>
<p>训练集和测试时用的vocab必须是同一个。</p>
<p><strong>文本序列</strong></p>
<p><em>语言模型</em>（language model）的目标是估计序列的联合概率  P(x1,x2,…,xT)</p>
<p>例如，只需要一次抽取一个词元xt∼P(xt∣xt−1,…,x1)，一个理想的语言模型就能够基于模型本身生成自然文本。 </p>
<p>从这样的模型中提取的文本 都将作为自然语言（例如，英语文本）来传递。 只需要基于前面的对话片断中的文本， 就足以生成一个有意义的对话。 显然，我们离设计出这样的系统还很遥远， 因为它需要“理解”文本，而不仅仅是<u>生成语法合理</u>的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091314548.png" alt="image-20220328102425591"></p>
<p>尽管如此，语言模型依然是非常有用的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315751.png" alt="image-20220303203413886" style="zoom:50%;" />

<p>训练数据集中，词的概率可以根据<u>给定词的相对词频</u>来计算。一种（稍稍不太精确的）方法是统计单词“deep”在数据集中的出现次数， 然后将其除以整个语料库中的单词总数。 这种方法效果不错，特别是对于频繁出现的单词。</p>
<p>但对于稍长的单词对，以及不常见的单词，情况将会变得很糟，即使 用了拉普拉斯平滑。该模型仅简单统计看到的单词的频率，想根据上下文调整这类模型其实是相当困难的。 最后，长单词序列大部分是没出现过的， 因此一个模型如果只是简单地统计先前“看到”的单词序列频率， 那么模型面对这种问题肯定是表现不佳的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315828.png" alt="image-20220303204705061" style="zoom:50%;" />

<p>比如二元语法，1000个词，那就存1000*1000个可能性。。。这会带来内存的问题，但是计算复杂度直接降为$O(t)$</p>
<p>二元和三元<u>用的还是非常多的</u>！！一般语料库几十G….几百G【因为满足👇，节省了很多内存】</p>
<p>词频特征：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315420.png" alt="image-20220303215942551" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315080.png" alt="image-20220303220408876" style="zoom:50%;" /></p>
<p>词表中n元组的数量并没有那么大，这说明语言中存在相当多的结构， 这些结构给了我们应用模型的希望。</p>
<p>很多n元组很少出现，这使得拉普拉斯平滑非常不适合语言建模。 作为代替，我们将使用基于深度学习的模型 RNN</p>
<p>sequence sample 的时间跨度T取决于对一句话建模还是一段话建模。<strong>16，32，</strong>64，128都有，再长也能到512，我肯定到不了。不是每个模型都能支撑那么大的，取决于模型复杂的，还有一些线上的参数。</p>
<p><u>【一个发现：batch中的数据是并行的，在RNN有了显式体现，顺序分区时，每个batch的第一个序列是连续的，第一个和第二个和其他则没有关系，有点离谱】</u></p>
<h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>输出发生在观察之前。</p>
<p>困惑度👇：一个更好的语言模型应该能让我们更准确地预测下一个词元。 因此，它应该允许我们在压缩序列时花费更少的比特。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315451.png" alt="image-20220303225344681" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315813.png" alt="image-20220303225734197" style="zoom: 25%;" /></p>
<p>这里的g是所有层的梯度放在一起。通过这样做，我们知道梯度范数永远不会超过θ， 并且更新后的梯度<u>完全与g的原始方向对齐</u>。 </p>
<p>它还有一个值得拥有的副作用， 即<u>限制任何给定的小批量数据（以及其中任何给定的样本）对参数向量的影响</u>， 这赋予了模型一定程度的<u>稳定性</u>。 梯度裁剪提供了一个快速修复梯度爆炸的方法， 虽然它并不能完全解决问题，但它是众多有效的技术之一。</p>
<p>困惑度的最好的理解是“下一个词元的实际选择数的调和平均数”。这使得不同长度的文档的性能具有了可比性。 我们看看一些案例：</p>
<ul>
<li>在最好的情况下，模型总是完美地估计标签词元的概率为1。 在这种情况下，模型的困惑度为1。</li>
<li>在最坏的情况下，模型总是预测标签词元的概率为0。 在这种情况下，困惑度是正无穷大。</li>
<li>在基线上，该模型的预测是词表的所有可用词元上的均匀分布。 在这种情况下，困惑度<u>等于词表中唯一词元的数量</u>。 事实上，如果我们在没有任何压缩的情况下存储序列， 这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的下限， 而任何实际模型都必须超越这个下限。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315914.png" alt="image-20220303230115244" style="zoom: 33%;" />

<p>transformer出来以后NLP这块飞速进步，现在各大厂家在刷transomer的pretrained模型。</p>
<p>多模态：发现transfomer既能做image也能做文本，用一个大模型直接一起搞了。</p>
<p>视频tracking是一个非常成熟的领域，做的非常好了，不需要太多RNN的东西，倒是那些小波滤波器用的比较多</p>
<p>一般RNN的序列都是随机取，RNN不足以记住太长的序列，一般100以内。这个样本撑不起来单词</p>
<p>高频字符低采样是？</p>
<p><strong>完全计算</strong></p>
<p>这样的计算非常缓慢，并且可能会发生梯度爆炸， 因为初始条件的微小变化就可能会对结果产生巨大的影响。 也就是说，我们可以观察到类似于蝴蝶效应的现象， 即初始条件的很小变化就会导致结果发生不成比例的变化。 这对于我们想要估计的模型而言是非常不可取的。 毕竟，我们正在寻找的是能够很好地泛化高稳定性模型的估计器。 因此，在实践中，这种方法几乎从未使用过。</p>
<p><strong>截断时间步</strong></p>
<p>这会带来真实梯度的<em>近似</em>， 只需将求和终止为∂ht−τ/∂wh。 在实践中，这种方式工作得很好。 它通常被称为截断的通过时间反向传播 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#jaeger-2002">Jaeger, 2002]</a>。 这样做导致该模型主要侧重于短期影响，而不是长期影响。 这在现实中是可取的，因为它会将估计值偏向更简单和更稳定的模型。</p>
<p>虽然<u>随机截断</u>在理论上具有吸引力， 但很可能是由于多种因素在实践中并不比常规截断更好。 首先，在对过去若干个时间步经过反向传播后， 观测结果足以捕获实际的依赖关系。 其次，增加的方差抵消了时间步数越多梯度越精确的事实。 第三，我们真正想要的是只有短范围交互的模型。 因此，模型需要的正是截断的通过时间反向传播方法所具备的轻度正则化效果。</p>
<p><strong>反向传播</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315874.png" alt="image-20220304214915339" style="zoom: 67%;" />

<p>该例子👇，激活函数实用恒等映射。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315422.png" alt="image-20220304214953302" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315068.png" alt="image-20220304215023669" style="zoom: 50%;" />此处可见一斑，出现了W的$T-i$次幂，容易发生数据不稳定<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315310.png" alt="image-20220304215125426" style="zoom:50%;" /></p>
<h4 id="Modern-1"><a href="#Modern-1" class="headerlink" title="Modern"></a>Modern</h4><p>梯度异常在实践中的意义：</p>
<ul>
<li>我们可能会遇到这样的情况：早期观测值对预测所有未来观测值具有非常重要的意义。 考虑一个极端情况，其中第一个观测值包含一个校验和， 目标是在序列的末尾辨别校验和是否正确。 在这种情况下，第一个词元的影响至关重要。 我们希望有某些机制能够在一个记忆元里存储重要的早期信息。 如果没有这样的机制，我们将不得不给这个观测值指定一个非常大的梯度， 因为它会影响所有后续的观测值。</li>
<li>我们可能会遇到这样的情况：一些词元没有相关的观测值。 例如，在对网页内容进行情感分析时， 可能有一些辅助HTML代码与网页传达的情绪无关。 我们希望有一些机制来<em>跳过</em>隐状态表示中的此类词元。</li>
<li>我们可能会遇到这样的情况：序列的各个部分之间存在逻辑中断。 例如，书的章节之间可能会有过渡存在， 或者证券的熊市和牛市之间可能会有过渡存在。 在这种情况下，最好有一种方法来<em>重置</em>我们的内部状态表示。</li>
</ul>
<p><strong>GRU</strong></p>
<p>门控循环单元与普通的循环神经网络之间的关键区别在于： 后者支持隐状态的门控。 这意味着模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态。</p>
<p>重置门（reset gate）和更新门（update gate）。 我们把它们设计成(0,1)(0,1)区间中的向量， 这样我们就可以进行<u>凸组合</u>。 </p>
<ul>
<li>Reset 是看要不要reset旧状态；有助于捕获序列中的<u>短期</u>依赖关系。允许我们控制“可能还想记住”的过去状态的数量；</li>
<li>Update是看目前的状态要不要用候选的隐状态update，还是不变。有助于捕获序列中的<u>长期</u>依赖关系。更新门将允许我们控制新状态中有多少是旧状态的副本。用tanh作激活函数是当时relu还没出来哈哈</li>
</ul>
<p>虽然矩阵乘法比RNN多三倍，但性能没有降低太多，可以通过大量并行打高GPU</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315696.png" alt="image-20220328154138256" style="zoom:43%;" />
$$
\begin{split}\begin{aligned}
\mathbf{R}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xr} + \mathbf{H}_{t-1} \mathbf{W}_{hr} + \mathbf{b}_r),\\
\mathbf{Z}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xz} + \mathbf{H}_{t-1} \mathbf{W}_{hz} + \mathbf{b}_z),\\
\tilde{\mathbf{H}}_t = \tanh(\mathbf{X}_t \mathbf{W}_{xh} + \left(\mathbf{R}_t \odot \mathbf{H}_{t-1}\right) \mathbf{W}_{hh} + \mathbf{b}_h),\\
\mathbf{H}_t = \mathbf{Z}_t \odot \mathbf{H}_{t-1}  + (1 - \mathbf{Z}_t) \odot \tilde{\mathbf{H}}_t.
\end{aligned}\end{split}\\
$$



<hr>
<p><strong>LSTM</strong></p>
<p>Hinton和LSTM作者一直有矛盾</p>
<p>LSTM的很多设计，其实大家也不知道为什么，那就不纠结了，反正效果挺好的。</p>
<p>深度循环神经网络使用多个隐藏层来获得更多非线性信息。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315698.png" alt="image-20220328180244249" style="zoom:60%;" />

<p>输入门$I_t$控制采用多少来自候选记忆元的新数据， 而遗忘门$F_t$控制保留多少过去的 记忆元</p>
<p>所以LSTM有<u>两个隐变量</u>：记忆元和隐状态<br>$$<br>\begin{split}\begin{aligned}<br>\mathbf{I}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xi} + \mathbf{H}</em>{t-1} \mathbf{W}_{hi} + \mathbf{b}<em>i),\<br>\mathbf{F}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xf} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{hf} + \mathbf{b}<em>f),\<br>\mathbf{O}<em>t &amp;= \sigma(\mathbf{X}<em>t \mathbf{W}</em>{xo} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{ho} + \mathbf{b}<em>o),\<br>\tilde{\mathbf{C}}<em>t = \text{tanh}(\mathbf{X}<em>t \mathbf{W}</em>{xc} + \mathbf{H}</em>{t-1} \mathbf{W}</em>{hc} + \mathbf{b}_c),\<br>\mathbf{C}_t = \mathbf{F}<em>t \odot \mathbf{C}</em>{t-1} + \mathbf{I}_t \odot \tilde{\mathbf{C}}_t\<br>\mathbf{H}_t = \mathbf{O}_t \odot \tanh(\mathbf{C}_t).<br>\end{aligned}\end{split}<br>$$<br>上面$C_t$范围可以做的比较大，没有数值限制，所以再用一次tanh化到正负一间保证H一直在正负一。</p>
<p>RNN GRU LSTM，其实<u>区别就在于怎么更新隐状态H</u></p>
<p>文本远远多于图片，也是目前的主流交互方式，NLP整体找工作很好找，比如文本分类、tag，summarization<br>但是文本翻译已经很成熟了。</p>
<h4 id="RNN-pro"><a href="#RNN-pro" class="headerlink" title="RNN pro"></a>RNN pro</h4><p><strong>深度RNN</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315617.png" alt="image-20220328182237893" style="zoom: 50%;" />

<p><code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</code>加个num_layers就行了</p>
<p><strong>双向RNN</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091315713.png" alt="image-20220328183730393" style="zoom:50%;" />

<p>双向RNN非常不适合做推理，几乎不能预测下一个词，因为要同时看到上下文。</p>
<p>所以主要应用是对句子做特征提取。比如语音等你一句话说完，翻译后来回扫一扫确认语义给你。</p>
<p><code>lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=True)</code></p>
<p>正向和反向没有权重这一说，是用concat连在一起的平级参数。</p>
<hr>
<h4 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h4><p><strong>机器翻译</strong></p>
<p>语言模型是自然语言处理的关键， 而<em>机器翻译</em>是语言模型最成功的基准测试。 因为机器翻译正是将输入序列转换成输出序列的 <em>序列转换模型</em>（sequence transduction）的核心问题。 序列转换模型在各类现代人工智能应用中发挥着至关重要的作用</p>
<p><em>机器翻译</em>（machine translation）指的是 将序列从一种语言自动翻译成另一种语言。在使用神经网络进行端到端学习的兴起之前， 统计学方法在这一领域一直占据主导地位。</p>
<p>神经网络机器翻译方法，强调的是端到端的学习。  </p>
<blockquote>
<p>在机器翻译中，我们更喜欢单词级词元化 （最先进的模型可能使用更高级的词元化技术）其中每个词元要么是一个词，要么是一个标点符号。</p>
<p>机器翻译数据集由语言对组成， 因此我们可以分别为源语言和目标语言构建两个词表。 使用单词级词元化时，词表大小将明显大于使用字符级词元化时的词表大小。<br>为了缓解这一问题，这里我们将出现次数少于2次的低频率词元 视为相同的未知（“<unk>”）词元。<br>除此之外，我们还指定了额外的特定词元， 例如在小批量时用于将序列填充到相同长度的填充词元（“<pad>”）， 以及序列的开始词元（“<bos>”）和结束词元（“<eos>”）。 这些特殊词元在自然语言处理任务中比较常用。</p>
<p>语言模型中的序列样本都有一个固定的长度， 无论这个样本是一个句子的一部分还是跨越了多个句子的一个片断。 这个固定长度是由 <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html#sec-language-model">8.3节</a>中的 <code>num_steps</code>（时间步数或词元数量）参数指定的。<br>为了提高计算效率，我们仍然可以通过<em>截断</em>（truncation）和 <em>填充</em>（padding）方式实现一次只处理一个小批量的文本序列。 假设同一个小批量中的每个序列都应该具有相同的长度<code>num_steps</code>， 那么如果文本序列的词元数目少于<code>num_steps</code>时， 我们将继续在其末尾添加特定的“<pad>”词元， 直到其长度达到<code>num_steps</code>； 反之，我们将截断文本序列时，只取其前<code>num_steps</code> 个词元， 并且丢弃剩余的词元。这样，每个文本序列将具有相同的长度， 以便以相同形状的小批量进行加载。</p>
<p>我们将特定的“<eos>”词元添加到所有序列的末尾， 用于表示序列的结束。 当模型通过一个词元接一个词元地生成序列进行预测时， 生成的“<eos>”词元说明完成了序列输出工作。</p>
<p>此外，我们还记录了每个文本序列的长度， 统计长度时排除了填充词元， 在稍后将要介绍的一些模型会需要这个长度信息。</p>
</blockquote>
<hr>
<p>:star2:</p>
<p>最近几年影响比较深的对模型的抽象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316498.png" alt="image-20220328192320663" style="zoom: 27%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316770.png" alt="image-20220328192352169" style="zoom:27%;" /></p>
<p>设计一个包含两个主要组件的架构： </p>
<p>第一个组件是一个<em>编码器</em>（encoder）： 它接受一个<u>长度可变</u>的序列作为输入， 并将其转换为具有<u>固定形状</u>的编码状态。【注意，实现的时候，encoder的输出enc_ouputs就是RNN的输出，<u>在decoder的初始化中，将这个转成编码后的状态。</u>】    编码器通过选定的<u>函数$q$</u>， 将所有时间步的隐状态转换为==上下文变量$c$==。后文用的上下文变量是<u>最后时间步的最后一层的隐状态。</u></p>
<p> 第二个组件是<em>解码器</em>（decoder）： 它将固定形状的编码状态映射到长度可变的序列。 在每个时间步都会将输入 （例如：在前一时间步生成的词元）和编码后的状态 映射成当前时间步的输出词元。【后文中，在seq2seq里，encoder的output被扔掉，最后的state用来初始化decoder；在attention中，就用上了output】</p>
<p>这被称为<em>编码器-解码器</em>（encoder-decoder）架构。编码器的输出用于生成编码状态， 这个状态又被解码器作为其输入的一部分。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316488.png" alt="image-20220328192511963" style="zoom:50%;" />

<hr>
<p><strong>序列到序列学习（seq2seq）</strong></p>
<p>遵循编码器－解码器架构的设计原则， 循环神经网络编码器使用长度可变的序列作为输入， 将其转换为固定形状的隐状态。 换言之，输入序列的信息被<em>编码</em>到循环神经网络编码器的隐状态中。 </p>
<p>为了连续生成输出序列的词元， 独立的循环神经网络解码器是基于输入序列的编码信息 和输出序列已经看见的或者生成的词元来预测下一个词元。 </p>
<p>训练decoder时，知道真正的输出，所以预测错了某个，还是拿正确的输入到下一个。【<em>强制教学</em>】</p>
<p>预测的时候，得把源句子tokenize后丢进encoder和decoder转一圈，依次取输出的值，state喂到下一个去，区别是decoder阶段，是拿你当前的预测输入到下一个去。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316899.png" alt="image-20220328193657017" style="zoom:67%;" />

<p>两个特定的设计： 首先，特定的“<bos>”表示序列开始词元，它是解码器的输入序列的第一个词元。 其次，使用循环神经网络编码器<strong>最终</strong>的隐状态来初始化解码器的隐状态，因此<u>编码器可以是双向</u>，只关心最终。</p>
<p>在其他一些设计中 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#cho-van-merrienboer-gulcehre-ea-2014">Cho et al., 2014b]</a>， 如 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html#fig-seq2seq">图9.7.1</a>所示， 编码器最终的隐状态在每一个时间步都作为解码器的输入序列的一部分。</p>
<p>最终架构如下：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316534.png" alt="image-20220328194342920" style="zoom:60%;" />

<blockquote>
<p><em>嵌入层</em>（embedding layer） 来获得输入序列中每个词元的特征向量。 嵌入层的权重是一个矩阵， 其行数等于输入词表的大小（<code>vocab_size</code>）， 其列数等于特征向量的维度（<code>embed_size</code>）。 对于任意输入词元的索引i， 嵌入层获取权重矩阵的第i行（从0开始）以返回其特征向量。 </p>
<p>维度保持不变，只是把索引变成了索引对应的特征向量，1维变成embed_size维</p>
<p><a href="https://blog.csdn.net/qq_39540454/article/details/115215056">https://blog.csdn.net/qq_39540454/article/details/115215056</a></p>
</blockquote>
<p><em>评价标准</em></p>
<p>预测的句子可能和实际句子长度不同，如何衡量。</p>
<p>BLEU（bilingual evaluation understudy） 最先是用于评估机器翻译的结果， 但现在它已经被广泛用于测量许多应用的输出序列的质量。 原则上说，对于预测序列中的任意n元语法（n-grams）， BLEU的评估都是这个n元语法是否出现在标签序列中。<br>$$<br>\exp\left(\min\left(0, 1 - \frac{\mathrm{len}<em>{\text{label}}}{\mathrm{len}</em>{\text{pred}}}\right)\right) \prod_{n=1}^k p_n^{1/2^n},<br>$$<br>1-xxx那项是惩罚过短的预测；最后$p_n$的幂是给长匹配更高的权重。</p>
<p>最好的结果是1。</p>
<p>word2vec已经没什么人用了，都用BERT。</p>
<p>seq2seq可以用纯transformer实现，但是潮流而已，说不定到时候RNN又更好了。</p>
<p><strong>束搜索</strong></p>
<p>贪心搜索是效率最高的，但是可能不是最优的。穷举在计算上不可行。beam search是折中。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316499.png" alt="image-20220328212245438" style="zoom:50%;" />

<p>除了第一步，后续还是贪心。 它有一个超参数，名为<em>束宽</em>（beam size）k。 在时间步1，我们选择具有最高条件概率的k个词元。 这k个词元将分别是k个候选输出序列的第一个词元。 在随后的每个时间步，基于上一时间步的k个候选输出序列， 我们将继续从k|Y|个可能的选择中 挑出具有最高条件概率的k个候选输出序列。</p>
<p>我们会得到六个候选输出序列： （1）A；（2）C；（3）A,B；（4）C,E；（5）A,B,D；（6）C,E,D。</p>
<p>我们选择其中条件概率乘积最高的序列作为输出序列,但是得惩罚长序列，取log转成负的，免得只选短的，这也是权衡。<br>$$<br>\frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}\mid \mathbf{c}) = \frac{1}{L^\alpha} \sum_{t’=1}^L \log P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \mathbf{c}),<br>$$</p>
<p>L是最终候选序列的长度， α通常设置为0.75。</p>
<h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>注意⼒机制解决了困扰统计学⼀个多世纪的问题：如何在不增加可学习参数的情况下增加系统的记忆和复杂性。</p>
<p>研究⼈员通过使⽤只能被视为可学习的指针结构，找到了⼀个优雅的解决⽅案。不需要记住整个⽂本序列（例如⽤于固定维度表⽰中的机器翻译），所有需要存储的都是指向翻译过程的<u>中间状态的指针（查询）</u>。这⼤⼤提⾼了⻓序列的准确性，因为模型在开始⽣成新序列之前不再需要记住整个序列。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>意识的聚集和专注使灵长类动物能够在复杂的视觉环境中将注意力引向感兴趣的物体，例如猎物和天敌。 只关注一小部分信息的能力对进化更加有意义</p>
<p><em>双组件</em>（two-component）<strong>框架</strong></p>
<p>非自主性提示（非随意）是基于环境中物体的突出性和易见性。不由自主地引起人们的注意。【卷积、全连接、池化】<br>自主性提示（随意）去辅助选择时，受试者的主观意愿推动，选择的力量也就更强大。</p>
<p>自主性提示称为<em>查询</em>（query）。 给定任何查询，注意力机制通过<em>注意力汇聚</em>（Attention Pooling） 将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。 在注意力机制中，这些感官输入被称为<em>值</em>（value）。 更通俗的解释，<u>每个值都与一个<em>键</em>（key）配对</u>， 这可以想象为感官输入的非自主提示。设计注意力汇聚， 以便给定的查询（自主性提示）可以与键（非自主性提示）进行匹配， 这将引导得出最匹配的值（感官输入）。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316974.png" alt="image-20220325210900151" style="zoom:50%;" />

<p>理解键值对的思想。注意力机制的设计有许多替代方案。 例如，我们可以设计一个不可微的注意力模型， 该模型可以使用强化学习方法 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#mnih-heess-graves-ea-2014">Mnih et al., 2014]</a>进行训练。</p>
<p><strong>注意力汇聚</strong></p>
<p>Nadaraya-Watson 核回归</p>
<p>历史的这个<strong>高斯核回归</strong>是一种不错的注意力汇聚方式。</p>
<p>思想：如果一个键xi越是接近给定的查询x， 那么分配给这个键对应值yi的注意力权重就会越大， 也就“获得了更多的注意力”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316992.png" alt="image-20220325210245930" style="zoom: 28%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316229.png" alt="image-20220325210416156" style="zoom:33%;" /></p>
<p>如果要参数化，就加入w：<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091316022.png" alt="image-20220325210715625" style="zoom:25%;" /></p>
<p>w可以控制你最终的曲线的平滑程度，不那么平滑有利于拟合。</p>
<p>在带参数的注意力汇聚模型中， 任何一个训练样本的输入都会和除自己以外的所有训练样本的“键－值”对进行计算， 从而得到其对应的预测输出。</p>
<p>查询和键之间的交互形成了注意力汇聚， 注意力汇聚<u>有选择地聚合了值（感官输入）以生成最终的输出</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317436.png" alt="image-20220325214835848" style="zoom:60%;" />



<p><strong>评分函数</strong></p>
<p>将高斯核指数里面的部分（$-\frac{1}{2}(x-x_i)^2$）视为<em>注意力评分函数</em>（attention scoring function）， 简称<em>评分函数</em></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317055.png" alt="image-20220325221459365" style="zoom:50%;" />

<p>查询q和键$k_i$的注意力权重（标量） 是通过注意力评分函数a 将两个向量映射成标量， 再经过softmax运算得到的<br>$$<br>\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q}, \mathbf{k}_i)) = \frac{\exp(a(\mathbf{q}, \mathbf{k}<em>i))}{\sum</em>{j=1}^m \exp(a(\mathbf{q}, \mathbf{k}_j))} \in \mathbb{R}.<br>$$<br>拓展到多维，则query、key、value<u>可以有不同的shape</u>，关键是a怎么设计</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317564.png" alt="image-20220325223039120" style="zoom:40%;" />

<p>两种常见分数计算（多维）：</p>
<ul>
<li><p>相同长度，计算效率更高，缩放点积注意力，直接做内积然后除以向量长度的开方【好处是不用学习任何东西，唯一超参数是dropout】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317693.png" alt="image-20220412190141947" style="zoom: 80%;" /></li>
<li><p>任意长度，加性注意力，合并起来进入一个单输出单隐藏层的MLP：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317332.png" alt="image-20220325223335333" style="zoom:70%;" /></li>
</ul>
<p>注意力分数是query和key的相似度，注意力权重是分数的softmax结果，normalize过的</p>
<p>masked_softmax是根据语义来的，比如根据前面的预测，那后面的输入就不考虑。</p>
<p><u>把这套方法用在不同领域其实就是 如何定义、设置query、key、value的过程</u>，不同的领域中形式会大不相同。</p>
<h4 id="例子seq2seq"><a href="#例子seq2seq" class="headerlink" title="例子seq2seq"></a>例子seq2seq</h4><p>seq2seq（序列到序列可<em>不局限于文本</em>）还可用于语音和文字之间的转换，chatbot之类的。</p>
<p>我们经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。</p>
<p>如果不是所有输入词元都相关，模型将仅对齐（或参与）输入序列中与当前预测相关的部分。这是通过将上下文变量视为注意力集中的输出来实现的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317660.png" alt="image-20220329182816505" style="zoom:40%;" />

<p>基于字母的一些语言，（英语、法语）什么的，大概率是词一一对应的。</p>
<p>因此希望在翻译时能更<u>关注对应位置</u>的词，而不是像之前一样只输入一个最后的隐状态。</p>
<p><strong>Bahdanau注意力</strong>的架构（对比）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091317383.png" alt="image-20220412192135684"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318026.png" alt="image-20220329184054820" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318386.png" alt="image-20220329183723549" style="zoom:60%;" /></p>
<ul>
<li>编码器对每个词的输出同时作为Key和Value，本身作为值，而又与查询“比较距离”，参与权重计算。</li>
<li>解码器RNN对上一个词的预测作为query，比方说上个预测的词是Hello，作为query拿到编码器中对key进行匹配，找到Hello附近的那一圈词，分配更高的注意力权重。【用RNN输出而不是embedding输入是因为<u>RNN的输出在一个语义空间里</u>】</li>
<li>注意力的输出替代了上下文c，与embedding的输入合并进入解码器的RNN层</li>
</ul>
<p>其他的和之前的seq2seq没差别。</p>
<h4 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h4><p>【是不是因为query和key长度一样，<u>所以都是用内积而不是加性注意力</u>】</p>
<p>它指的不是Target和Source之间的Attention机制，而是Source<u>内部元素之间或者Target内部元素之间发生的Attention机制</u>，也可以理解为Target=Source这种特殊情况下的注意力计算机制。<strong>Q=K=V</strong>。只需要在Source处进行对应的<u>矩阵操作</u>，用不到Target中的信息。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318498.png" alt="img" style="zoom:67%;" />

<p>attention和self attention 其具体计算过程是一样的，只是计算对象发生了变化而已。</p>
<p>我们经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。 那么怎么用<u>注意力机制对序列进行编码</u>呢</p>
<p>有了注意力机制之后，我们将词元序列输入注意力池化中， 以便同一组词元<u>同时充当查询、键和值</u>。 具体来说，每个查询都会关注<em>所有</em>的键－值对并生成一个注意力输出。</p>
<p>由于查询、键和值来自同一组输入，因此被称为 <em>自注意力</em>（self-attention）</p>
<p>自注意力机制相对注意力机制而言，减少了对外部信息的依赖，更擅长捕捉数据或特征的<u>内部相关性</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318599.png" alt="image-20220329214801078" style="zoom: 45%;" />

<p>其中$f$就是之前讨论过的<u>注意力汇聚（也可称为池化）函数</u></p>
<hr>
<p>序列长度是n，输入和输出的通道数量都是d，CNN里的k是卷积核大小。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318975.png" alt="image-20220329214900057" style="zoom: 40%;" />

<p>并行度是说你的输出可以并行地接着运算，有利于GPU发挥实力。顺序操作会妨碍并行计算，而任意的序列位置组合之间的路径越短，则能更轻松地学习序列中的远距离依赖关系。</p>
<p>RNN路径长，无法并行，有些针对RNN的修改增加了计算量，但也增加了并行度，结果时间可能并没有增加。路径长说明前面的词元要传递信息给最后的词元要跨越很长的距离，这样<u>不便于长期记忆，但是对整个序列的记忆比较好</u>，擅长序列性的。</p>
<p>自注意力，在序列比较长时，计算量是指数增长的，因为每次都要回去看一整个序列。相对的，其并行度就非常好，所以像TPU这种大型矩阵乘法的硬件，支持的就非常好。还有在比较长的序列时，路径永远为1，可以轻松抓取很远的信息。所以抛开计算，自注意力<u>很适合处理长文本</u>。</p>
<p>所以基于注意力的算起来特别贵。比CNN贵多了，可能会达到几千个GPU一起算。</p>
<p><strong>位置编码</strong></p>
<p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的， 而自注意力则因为并行计算而放弃了顺序操作，因此失去了位置信息 。（输入随便打乱位置，最终输出的位置跟随变化，但是内容没有影响。）</p>
<p>解决方法：为了使用序列的顺序信息，我们在<u>输入</u>表示中添加 <em>位置编码</em>（positional encoding）来注入绝对的或相对的位置信息。 </p>
<p>有意思的是，它不是把信息加到模型里，这会有各种问题（比如RNN那种，并行度一下就低了），而是加到了输入里。</p>
<p>行号$i$，列号$j$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318674.png" alt="image-20220330110116125" style="zoom:50%;" />

<p>在位置嵌入矩阵P中， <u>行代表词元在序列中的位置，列代表位置编码的不同维度</u>。 在下面的例子中，我们可以看到位置嵌入矩阵的第6列和第7列的频率高于第8列和第9列。 第6列和第7列之间的偏移量（第8列和第9列相同）是由于正弦函数和余弦函数的交替。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318844.png" alt="image-20220330110716374" style="zoom:50%;" />

<p>所以，相当于对每个样本、维度加上一点不一样的值，让模型去分辨这个细微的东西来学到时序，挺奇怪的。</p>
<p>好处是不改变模型，也不改变数据大小，坏处是你的模型可能认不出来:joy:</p>
<p>沿着编码维度单调降低的频率与绝对位置信息的<u>关系</u>（<em>大致理解</em>）：</p>
<p>通过计算机的二进制编码解释，例子中维度是3维，每个数字、每两个数字和每四个数字上的比特值 在第一个最低位、第二个最低位和第三个最低位上分别交替。    然后<u>前面的维度频率慢，后面的维度频率快</u>（第一维01010101）由于输出是浮点数，因此此类连续表示比二进制表示法更节省空间。 </p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318163.png" alt="image-20220330112128687" style="zoom:50%;" />

<p>之所以使用sin、cos函数，是因为这样编码的是<em>相对位置信息</em>。投影矩阵和你的i也就是样本位置无关，但是和你的维度有关。对于任何确定的<u>位置偏移δ</u>，位置i+δ处 的位置编码可以<u>线性投影位置i处的位置编码</u>来表示。</p>
<p>因为我们学的都是这个w，所以他会学到相对的信息，而不是绝对的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318782.png" alt="image-20220330113233357" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318271.png" alt="image-20220412204409955" style="zoom:60%;" /></p>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层 [<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#vaswani-shazeer-parmar-ea-2017">Vaswani et al., 2017]</a>。尽管transformer最初是应用于在文本数据上的序列到序列学习，但现在已经推广到<u>各种现代的深度学中</u>，例如语言、视觉、语音和强化学习领域。</p>
<p>从transformer开始，取名越来越fancy了，包括bert什么的。</p>
<p>基于编码器-解码器架构来处理序列对。<br>但跟使用注意力的seq2seq不同，transformer是纯基于注意力的。</p>
<blockquote>
<p>Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为sublayer）。第一个子层是<em>多头自注意力</em>（multi-head self-attention）汇聚；第二个子层是<em>基于位置的前馈网络</em>（positionwise feed-forward network）。<br>在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出。每个子层都采用了<em>残差连接</em>（residual connection）。在transformer中，对于序列中任何位置的任何输入x∈Rd，都要求满足sublayer(x)∈Rd，以便残差连接满足x+sublayer(x)∈Rd。在残差连接的加法计算之后，紧接着应用<em>层规范化</em>（layer normalization）。<br>因此，输入序列对应的每个位置，transformer编码器都将输出一个d维表示向量。</p>
<p>Transformer解码器也是由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<em>编码器－解码器注意力</em>（encoder-decoder attention）层。<br>在编码器－解码器注意力中，<u>查询</u>来自前一个解码器层的输出，而<u>键和值</u>来自整个编码器的输出。<br>在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<em>掩蔽</em>（masked）注意力保留了<em>自回归</em>（auto-regressive）属性，确保<u>预测仅依赖于已生成的输出词元</u>。【还有一种decoder是NAT（Non-autoregressive），李宏毅有介绍】</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318141.png" alt="image-20220330125329726" style="zoom:50%;" />

<p>编码器和解码器的第一个蓝块（注意力块）是self-attension，但是解码器上面那个是普通的attention用来接收编码器的输出。</p>
<p><strong>多头注意力</strong></p>
<p>当给定相同的查询、键和值的集合时， 我们希望模型可以基于相同的注意力机制学习到不同的行为， 然后将不同的行为作为知识组合起来， 捕获序列内<u>各种范围的依赖关系</u>。（例如，短距离依赖和长距离依赖关系）<br>因此，允许注意力机制组合使用查询、键和值的不同 <em>子空间表示</em>（representation subspaces）可能是有益的。</p>
<p>我们可以用独立学习得到的h组不同的 <em>线性投影</em>（linear projections）来变换查询、键和值。 然后，这h组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这h个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。 </p>
<p>首先通过全连接层，把你映射到（可能低一点的）dimension，对于输出的n个注意力，在特征维度concat起来，再用一个$W_o$变换</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318837.png" alt="image-20220330123028745" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318388.png" alt="image-20220330123016522" style="zoom:40%;" /></p>
<p>不过，比如在解码器对序列中的一个元素输出时，不应该考虑该元素后面的元素，可以通过掩码来实现。（也就是计算$x_i$输出时，假装当前序列长度为$i$）</p>
<p><em>基于位置的前馈网络</em></p>
<p>说白了还是一个全连接，（batch_size，序列的长度，dimension）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318635.png" alt="image-20220330130650343" style="zoom:50%;" />

<p>模型应该与n（序列长度）无关，可以处理任意长度的，所以不能处理成一个特征。</p>
<p>对序列中的每个元素（$x_i$是长度为dimension的向量）作用两个全连接层（输出了又换回来）。</p>
<p>FFN的作用应该就是提供更多的非线性和学习能力。草，我懂了，其实就是一个跟维度n无关的全连接。</p>
<p><em>Add &amp; norm</em></p>
<p>add就是加上一个残差连接。norm是层归一化，但是不能用之前说的那个batch normalization，因为序列长度n会变。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091318861.png" alt="image-20220412211608697" style="zoom:30%;" />

<p>可见，batch norm是选每个（通道内的）所有batch的元素进行归一化。<br>Layer是一个batch内部，自己把多个特征的元素一起归一化。这样稳定性，<u>不会因为n而发生很大变化</u>。</p>
<p><em>信息传递</em></p>
<p>编码器和解码器的第一个蓝块（注意力块）是self-attension，但是解码器上面那个是普通的attention用来接收编码器的输出。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319646.png" alt="image-20220412212412605" style="zoom:33%;" />

<p>编码器和解码器的输出因此一般都是一样的，一是为了简单，二是为了对称。</p>
<p><em>预测</em></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319897.png" alt="image-20220412212634022" style="zoom:33%;" />

<p>预测的时候就不再像训练的时候并行的了，需要一个个顺序的预测，因为要用到之前的预测值。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319798.png" alt="image-20220412212827629" style="zoom:33%;" />

<p>transformer本身还好，只是bert那些鬼东西难算。</p>
<h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319924.png" alt="image-20220504095017854" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319216.png" alt="image-20220504095327879" style="zoom:29%;" /></p>
<p>原本输入分src和tar，分别进encoder和decoder，现在只剩encoder，就要修改修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319800.png" alt="image-20220504095411426" style="zoom:32%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319725.png" alt="image-20220504100052544" style="zoom: 32%;" /></p>
<p>encoder是双向的，可以看到前和后，抽取比较好的特征。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319527.png" alt="image-20220504104316858" style="zoom:33%;" />









<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319157.png" alt="image-20220413110151727" style="zoom:50%;" />

<p>  <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319171.png" alt="image-20220302104957284" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205091319356.png" alt="image-20220302105027404" style="zoom:33%;" />  机器学习和深度学习提取的特征不太一样，不一定深度学习提取的就是最好的（跟数据量和模型都有关），是<strong>互补</strong>关系。<br> 代码不是都和数学原理有关，还有很多tricks。现实生活中tabula数据比图片用的yao多。</p>
]]></content>
  </entry>
  <entry>
    <title>概率（课内）笔记</title>
    <url>/2021/08/26/%E6%A6%82%E7%8E%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>What is Probability theory and Mathematical Statistics</strong></p>
<p>生活中的现象根据是否可事前预言，分为<u>确定性现象和非确定性现象</u>。<br>在非确定性现象中有一类很重要的现象:随机现象</p>
<p>随机现象的性质：</p>
<ul>
<li>各个结果出现的可能性大小不依人们的主观意志转移</li>
<li>试验的结果不止一个，即每次试验的结果可能不同——结果的不确定性。</li>
<li>进行大量重复观察时，可观察出出现各种结果呈现某种规律——统计规律性</li>
</ul>
<p>概率论与数理统计— <u>研究随机现象的统计规律性</u>的一门数学学科</p>
</blockquote>
<blockquote>
<p>概率统计、随机过程以及概率图模型，三位一体、一脉相承的结合起来，一步步掌握其中的核心思想。概率统计是基础，随机过程和概率图模型作为拓展和深化。</p>
<p>概率统计看《概率导论》</p>
<p>概率思想、随机变量、统计推断、随机过程、采样理论、概率模型。</p>
<p>在机器学习算法的修炼道路中，<a href="https://www.zhihu.com/search?q=%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1790318156%7D">概率图模型</a>和随机过程对很多同学而言是一个巨大的拦路虎。</p>
</blockquote>
<h3 id="一些杂感"><a href="#一些杂感" class="headerlink" title="一些杂感"></a>一些杂感</h3><ol>
<li><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/v2-37387c56c6d1740aedab256f1081fced_1440w.jpg" alt="img" style="zoom:33%;" />

<p>事件关系可用文氏图，概率就不行了。。独立性</p>
</li>
<li><p>伯努利是一次实验，二项是重复多次进行伯努利实验后成功的次数，几何是第一次成功是第几次。</p>
</li>
<li><p>《概率导论》的分布列就是考试的分布律，有$P{X=x_i}=p_i$，概率导论这个形式更好看$p_{X}(x_i)$</p>
<p>$P{X=x_i,Y =y_j}=p_{ij}$以及概率导论的$p_{X,Y}(x_i,y_j)$</p>
</li>
<li><p>独立同分布的随机变量的加权和的均值和方差的公式 是 <code>样本均值作为随机变量的期望的估计</code> 的统计过程的理论基础</p>
</li>
<li><p>一般连续变量相对于离散变量的优势：除了刻画细致和精确外，连续随机变量模型可以利用<strong>有力的分析工具</strong>解决概率的计算问题。更重要的是它可以做到离散随机变量做不到的：<code>刻画某些随机现象的本质。</code></p>
</li>
<li><p>指数变量的核心性质：$X$超过某个值的概率，随着这个值的增加而 <strong>指数递减</strong>$P(X\geq a) = e^{-\lambda a}$</p>
</li>
<li><p>线性变化下，随机变量的正态性保持不变。标准正态分布的 $F$ 写作 $\Phi$</p>
</li>
<li><p>泊松、二项、正态具有<strong>可加性</strong>，加的是$\lambda$和$n$，$\mu、\sigma^2$</p>
</li>
<li><p>注意一些分布信息，还有随机变量的函数，自带定义域信息。。。</p>
</li>
<li><p>所谓简答题，给出简单的例子说明他为什么能这样做,要给出定理的条件，然后说明这个例子具有相应的性质来满足条件</p>
</li>
<li><p>乘法公式，本就是描述在概率论里如何刻画乘法关系，刻画连续的关系，加法公式也是类似，乘法、加法的本质是不变的，<u>变的只是在概率论里的形式</u>。而这要分两种情况，相乘的变量是否独立。不独立就是条件形式。</p>
</li>
<li><p>$P(A_1\cup A_2\cup A_3) = P(A_1\cup \overline{A_1}A_2\cup \overline{A_1}\ \overline{A_2}A_3) = P(A_1) + P(\overline{A_1})P(A_2|\overline{A_1}) + …$ </p>
</li>
</ol>
<hr>
<h3 id="基本概率论"><a href="#基本概率论" class="headerlink" title="基本概率论"></a>基本概率论</h3><p><em>随机试验</em>：对随机现象所进行的观察和实验，可在相同条件下重复进行、事先可明确知道所有可能结果，且不可预言出现何结果。</p>
<p>随机试验的每一个可能发生也可能不发生的事情为<em>随机事件</em>，简称事件.</p>
<p><em>基本事件</em> 在一次试验中必发生一个且仅发生一个的最简单事件.</p>
<p>全体基本事件的对应元素所组成的集合称为试验的样本空间样本空间的元素称为<em>样本点</em>.</p>
<p>$A-B = A\overline{B}$</p>
<p><strong>概率</strong>是对随机事件发生可能性大小的一个客观度量</p>
<p>概率是通过公理化定义的。非负、规范、可列可加、单调。<br>概率公理化单调性：</p>
<p>若$A \subset B$，则$ P(A)\leq P(B)$，且$P(B-A) = P(B) -  P(A)$<br>因此<u>$P(A - B)=P(A-AB) = P(A)  - P(AB)$</u>  并且 $P(A-B) = P(A\cup B)-P(B)$</p>
<p><em>随机变量</em></p>
<p>取值由随机试验的结果来确定；取各数值的可能性大小有确定的统计规律性</p>
<p>它可以完整地描述试验结果，从而可用<u>量化分析方法</u>来研究随机现象的统计规律性。</p>
<p>概率为0的事件不一定是不可能事件，为1不一定是必然事件（因为连续型变量）</p>
<hr>
<p><code>联合分布函数F</code></p>
<p>$F(x,y) = P{X\leq x,Y\leq y}$，包括了右端点</p>
<p>$F_X(x) = \underset{y\rightarrow \infty}{lim}F(x,y)$</p>
<p>单调不降；右连续；非负有界$0\leq F(x,y)\leq 1$；</p>
<p>$F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)=P{x1\leq x\leq x2,y1\leq y\leq y2}$</p>
<p>$P{X = x} = F(x) - F(x-0)$ 其他情况为0</p>
<p>:star: 对称分布的分布函数有：$F(-x) = 1-F(x)$<br>      上侧分位数$u_\alpha$：$F(u_\alpha) = 1-\alpha$</p>
<p> $\displaystyle F_X(x)=\int_{-\infty}^{x}\int_{-\infty}^{y}f(u,v)dudv=\int_{-\infty}^{x}f_X(u)du$</p>
<p><code>联合分布列p——离散</code></p>
<p>$P{X = x_i,Y = y_j} = p_{ij}$</p>
<p>$P{Y = y_j} = \displaystyle\sum_{i=1}^{\infty}p_{ij}$</p>
<p>九宫格划分空间（离散型），分类求F</p>
<p><code>联合分布密度f——连续</code></p>
<p>联合概率密度函数包含了所有关于（$X,Y$）的取值概率的信息，包括相互依赖的信息。</p>
<p>$f(x,y) \geq 0$ 处处成立</p>
<p>$\displaystyle\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(u,v)dudv = 1$</p>
<p>对$G \sub R^2$</p>
<p>$P{(x,y)\in G}=\underset{G}{\iint_{}^{}}f(x,y)d\sigma$</p>
<p>$f_X(x)=\displaystyle\int_{-\infty}^{+\infty}f(x,y)dy$</p>
<p>$f_X(x) = F^{‘}_X(x)$   </p>
<p>二维正态随机变量边缘分布仍为正态。<br>可由二维联合概率密度完全确定边缘概率密度，反之不行。X,Y独立分布的充要条件是$\rho = 0$</p>
<h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a><strong>独立</strong></h4><ul>
<li><p>定义：任意x,y有$P{X\leq x,Y\leq y} = P{X\leq x}P{Y\leq y}$</p>
<p>​            即 $F(x,y)=F_X(x)F_Y(y)$</p>
</li>
<li><p>定理：$P{X= x_i,Y= y_j} = P{X= x_i}P{Y= y_j}$（离散） 是独立的<strong>充要条件</strong></p>
<p>​            连续：$f(x,y)=f_X(x)f_Y(y)$ <u>在平面上除去“面积”为零的集合后成立，而不是平面上均成立。</u></p>
</li>
</ul>
<p>大题就分别得到左右两侧，然后看相等否。</p>
<p><code>条件分布率</code></p>
<p>$P{Y= y_j |X= x_i}=\frac{p_{ij}}{p_{i.}}$</p>
<p><code>条件概率密度</code></p>
<p>$f_{Y|X}{y|x}=F^{‘}_{Y|X}{y|x}=\frac{f(x,y)}{f_X(x)}$</p>
<p>如果是一个具体时间，那么$f_{Y|A}(x)=\frac{f_X(x)}{P(X\in A)}$</p>
<p>$\displaystyle f_{X}(x) = \int_{-\infty}^{+\infty}f_Y(y)f_{X|Y}{x|y}dy$联合、边缘、密度相互关联</p>
<p>在X = c 条件下，随机事件${a&lt;Y\leq b}$的条件概率：</p>
<p>$\displaystyle P{a&lt;Y\leq b |X=c}=\int_{a}^{b}f_{Y|X}(y|c)dy$</p>
<p>求离散随机变量的函数及其分布律P83</p>
<p>列表得出可能的值，填上分布律。</p>
<p>离散卷积公式，二项式和泊松的可加性。</p>
<p>求连续随机变量的函数及其概率密度P85</p>
<p>此时，y相当于未定的常数，要进行讨论。</p>
<ul>
<li><p>分布函数法，先利用原来的fx，求得Fy，再求导得fy、</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20211019111029124.png" alt="image-20211019111029124" style="zoom: 33%;" align = 'left'/></li>
<li><p>公式法，只适用于<u>全局严格单调</u>的函数y = g(x)。</p>
</li>
</ul>
<hr>
<p><em>随机变量的函数的数学期望：</em></p>
<blockquote>
<p>数学期望存在的条件：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027941.png" alt="image-20211231220305870" style="zoom: 33%;" />
</blockquote>
<p>定理4.1.1 设 Y 是随机变量X的函数Y=g(X)，g(x)为连续函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027943.png" alt="image-20211231215343557" style="zoom: 33%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027944.png" alt="image-20211231215442901" style="zoom:33%;"/></p>
<p>:star: 二维时，$E(X) = \displaystyle \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}xf(x,y)dxdy = \int_{-\infty}^{\infty}xf_X(x)dx$</p>
<p>$E(x)$具有线性性、而相互独立时$E(XY)=E(X)E(Y)$</p>
<p>方差定义：$D(X) = E[X-E(X)]^2$；标准差$\sigma(X) = \sqrt{D(X)}$</p>
<p>常用计算公式：$D(X) = E(X^2) - [E(X)]^2$</p>
<p>$D(X\pm Y)=D(X)+D(Y)\pm 2cov(X,Y)$，独立时，$cov(X,Y)=0$</p>
<p>协方差定义：$cov(X,Y) =E{[X-E(X)][Y-E(Y)]}$</p>
<p>对称性、齐性 $cov(aX,aY) = abcov(X,Y)$     $cov(X,c) =0$<br>可加性$cov(X_1+X_2,Y)=cov(X_1,Y)+cov(X_2,Y)$</p>
<p>相关系数$\rho_{xy} = \frac{cov(X,Y)}{\sqrt{D(X)D(Y)}} = \frac{E(X_1X_2)-E(X_1)E(X_2)}{\sqrt{D(X)D(Y)}}$ ，是量纲为1的量，衡量 <em>线性</em> 相关关系。<br>$|\rho_{xy}| = 1 \leftrightarrow$X、Y线性相关，即Y =AX+b</p>
<p><strong>相互独立（更本质）一定不相关$(\rho = 0)$，反之不成立（除了二维正态里的X,Y，但是两个普通的正态分布不算）。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027945.png" alt="image-20220102190758627" style="zoom:50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027946.png" alt="image-20220101105817621" style="zoom:50%;" align = 'left'/><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027948.png" alt="image-20220101105951275" style="zoom:33%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027949.png" alt="img" style="zoom:67%;" align = 'left'/>

<p>矩：更一般的数字特征。【只考统计部分要用得到的】</p>
<p>可以证明，若随机变量的高阶矩存在，则低阶矩一定存在。</p>
<p>多维正态随机变量【不考】</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027950.png" alt="image-20220101103918453" style="zoom: 80%;" align = 'left'/>

<p>希望不考：随机变量$(X_1,X_2,…,X_n)$的线性变换$BX$（B是个mxn矩阵），服从m维正态分布$N(Bu,BCB^T)$</p>
<hr>
<p>大数定律和中心极限定理是<u>独立随机变量序列</u>的部分极限定理。</p>
<p>切比雪夫理解：$P{|X-E(X)|\geq\varepsilon} \leq\frac{D(X)}{\varepsilon^2}$ 和 $$P{|X-E(X)|\leq\varepsilon} \geq1-\frac{D(X)}{\varepsilon^2}$$</p>
<p><u>随机变量的取值偏离均值一定范围的概率上界，正比于方差（方差越大分布越广），反比于给定的范围。</u></p>
<p>可用来证明依概率收敛。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027951.png" alt="image-20220101124820047" style="zoom: 50%;" /></p>
<p><strong>大数</strong>：取一个序列的随机变量平均，以及均值的平均。<br><u>刻画了随机变量序列，分布的中心收敛于均值之和，描述的是【聚散】</u></p>
<ul>
<li><p>切比雪夫：相互独立，期望、方差均存在，方差一致有界。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\sum_{i=1}^nX_i -\frac{1}{n}\sum_{i=1}^nE(X_i)|&lt;\varepsilon} =1$</p>
</li>
<li><p>独立同分布：独立同分布，期望、方差存在。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i -\mu|&lt;\varepsilon} =1$</p>
</li>
<li><p>辛钦：独立同分布，期望存在。$\displaystyle \lim_{ n\to \infin}P{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i -\mu|&lt;\varepsilon} =1$</p>
</li>
<li><p>伯努利：$\displaystyle \lim_{ n\to \infin}P{|\frac{m}{n} -p|&lt;\varepsilon} =1$</p>
</li>
</ul>
<p><strong>中心</strong>：找到一个（独立同分布）的序列，均落在某一范围。<br><u>实质是刻画了相互独立的某些随机变量序列，其和的分布随样本增多而收敛于正态分布。描述的是【形态】</u></p>
<p>（不是所有序列都满足该条件的！！）</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027952.png" alt="image-20220101130110785" style="zoom: 43%;" />

<p>独立同分布中心定理（相互独立同分布，期望、方差存在，用$n\mu$和$\sqrt{n}\sigma$替换式子里的两项。）</p>
<p>D-L中心极限定理：（二项分布时，用$np$和$\sqrt{np(1-p)}$替换式子里的两项）</p>
<h3 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h3><p>研究如何以有效的方式<u>收集和整理</u>随机数据</p>
<p>研究如何合理地<u>分析随机数据从而作出科学的推断</u> (称为统计推断).</p>
<blockquote>
<p><strong>弄清楚样本量和总体的统计量的符号和定义！不然老是混淆。</strong></p>
<p><em>总体参数</em>（ML里的期望分布）</p>
<p>数学期望：$\mu$ = $E(X)$</p>
<p>方差：$\sigma^2 = D(X) =\mu_2 =\gamma_2 - \gamma_1^2 $</p>
<p>$k$ 阶原点矩：$\gamma_k = E(X^k)\ (k = 1,2,…)$</p>
<p>$k$ 阶中心矩：$\mu_k = E{[X-E(X)]^k}\ (k = 1,2,…)$</p>
<p><em>样本统计量</em>（ML里的经验分布）</p>
<p>样本均值：$\overline{X}=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i$</p>
<p>样本方差：$S^2=\frac{1}{n-1}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2 = \frac{n}{n-1}M_2$    其中有$M_2 =A_2 - A_1^2$</p>
<p>样本k阶原点矩：$A_k=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i^k$</p>
<p>样本k阶中心矩：$M_k=\frac{1}{n}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^k$</p>
</blockquote>
<p><strong>总体</strong>是具有相应概率分布的随机变量。 比如总体$X$，则随机变量X的概率分布就是总体分布。</p>
<p><strong>样本</strong>是在保证每个个体有同等机会被抽出时，抽出的一部分个体。是<u>一组随机变量</u>，如$X_1,X_2…X_n$。</p>
<p><em>样本值不是确定的！只确定了样本容量</em></p>
<p><strong>简单随机样本</strong>：每个$X_i$均与$X$<u>同分布</u>，每个$X_i$均<u>相互独立</u>。这是简化的情况，便于研究和考试。</p>
<p><strong>统计量</strong>是样本的函数【<u>因此研究的是该样本组的性质</u>】，是<u>随机变量</u>且<em>不含未知参数</em>。</p>
<p><strong>抽样分布</strong>——统计量的分布，虽然难求，但是正态总体中常用的统计量分布已经有了较完整的结果。</p>
<p>我们从总体抽取样本，对这组样本算我们关心的样本的统计量，然后研究这个统计量满足怎样的分布。</p>
<p><em>卡方分布</em>$\chi^2(n)$</p>
<p>$E = n,D = 2n$；可加性；n&gt;45时，$\chi^2_\alpha(n) \approx n+u_\alpha\sqrt{2n}$</p>
<p>当样本量为1时，$X^2 = \chi^2(1)$</p>
<p><em>T分布</em>$T \sim t(n)$</p>
<p>对称性 $t_{1-\alpha}(n) = -t_\alpha(n)$ n&gt;45 近似服从$N(0,1)$分布</p>
<p><em>F分布</em>$F\sim F(n_1,n_2)$</p>
<p>$\frac{1}{F}\sim F(n_2,n_1)$       $F_{1-\alpha}(n_1,n_2) = \frac{1}{F_\alpha(n_2,n_1)}$</p>
<p><strong>抽样分布定理</strong>，（虽然只有正态），告诉了我们一些结论，即<u>正态分布抽样后部分统计量的分布是怎样的</u>，我们可以在此基础上加以组合，得到符合三大分布的分布。【给了样本均值、方差的分布，给了一个“样本方差联合分布”、给了两组正态样本的分布、】</p>
<p>这些结论，都来自<strong>正态分布</strong>的样本，右边俩还要求<em>相互独立</em>。不然一般分布的很难求出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027953.png" alt="image-20220101143237485" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027954.png" alt="image-20220101144340867" style="zoom:30%;" /></p>
<p>推导过程在P151</p>
<p>理解上侧分位数：$P(x&gt;,u_\alpha) = \alpha$      $F(\mu_\alpha) = 1-\alpha$<br>那些带下标的下标，比如$t_\alpha$都指的是令右边的面积为$\alpha$的点。<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027955.png" alt="image-20220101151559917" style="zoom:33%;" /></p>
<hr>
<p>参数估计是统计推断的基本问题之一。有了样本分布定理，就可以进行统计推断了。</p>
<p><strong>点估计</strong></p>
<p>利用样本，对每一个未知参数 $\theta_i$，按一定的优化原则<strong>构造一个统计量</strong> $\hat{\theta}_i(X_1,…,X_n)$ ！作为对参数 $\theta_i$ 的估计，<strong>称为估计量</strong></p>
<p>当样本值确定后，带入统计量，就能得到具体数值 $\hat{\theta}_i(x_1,…,x_n)$即估计值。</p>
<p><em>矩估计</em>：</p>
<p><strong>以样本矩直接作为相应总体矩的估计，样本矩的函数作为相应总体矩同一函数的估计</strong></p>
<p>（由辛钦大数定理知样本矩依概率收敛于总体矩，这也是李航那本书的经验收敛于期望吧。）。</p>
<p>基本假设：总体X分布为$f(x;\theta_1,…,\theta_m)$，<u>各阶矩均存在</u>。</p>
<p><em>如果题目没给矩，那就先算总体的各阶矩 = xxx，然后再反过来表示。</em>【也可以用$\overline{X}$】</p>
<p>对总体方差的矩估计$M_2$ = $\frac{n-1}{n}\cdot S^2$并不是无偏估计。$\mu = \gamma_1\ 、\sigma^2 =\gamma_2-\gamma_1^2$ 可以分别直接用$\overline{X}$和$M_2$替换。</p>
<p>有如泊松分布的情况，一个参数$\lambda$有两个不同矩估计，原则：<u>估计量的优良性标准，一般选用低阶矩</u></p>
<p><em>最大似然估计法——MLE</em></p>
<p>有些分布不存在的数学期望，自然不存在高阶矩，而最大似然是重要而普适的。</p>
<p><strong>按照最大可能性的准则进行推断，把<u>已经发生的事件，看成最可能出现的事件，认为有最大的概率</u>。</strong><br>如果是求某个分布的参数估计，就按照分布律/概率密度来求似然函数。【样本不会出现在概率为0的地方，无需讨论。】</p>
<blockquote>
<p>给定输出x时，关于参数θ的似然函数L(θ|x)（在数值上）等于给定参数θ后变量X的概率：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/1e572150cc607eb32fd3fa77c8865919.svg" alt="img">=$\displaystyle\prod_{i=1}^n f(x_i;\theta_1,\theta_2,…,\theta_m)$</p>
<p>他们其实都表示“<strong>可能性</strong>”的大小，但是一个是已知结果，研究参数的情况，表示对参数的估计；一个是已知参数，研究结果随机变量的情况，研究概率。就像一个二元函数一样，只不过要对输入的参数分两类。</p>
<p>似然函数的主要用法在于<u>比较它相对取值</u>，虽然这个数值本身不具备任何含义。</p>
<p>一般形式上是样本组的联合概率密度函数。</p>
</blockquote>
<p>写出似然函数<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027956.png" alt="image-20220101155125680" style="zoom:33%;" />，取对数，然后对每个参数求偏导，求解似然方程组。</p>
<ul>
<li>似然方程组的解不唯一，要进一步判定哪个是最大值点</li>
<li>似然函数关于参数导数不存在时，无法得到似然方程组，要用<strong>定义</strong>【找到使得L最大的一组参数】来求解。</li>
</ul>
<p>最终将参数<u>用估计值</u>$x_1,x_2…x_n$（有时需假设）来表示，然后再<u>替换成用相应的估计量</u>$X_1,…,X_n$表示。</p>
<ul>
<li>矩法估计参数比较简单,但有信息量损失；极大似然估计法精确度高，但运算较复杂</li>
<li>运用两种方法得出的结果不一定相同，哪怕只用一种方法也可能得出多个结果</li>
</ul>
<p><strong>无偏性：$E(\hat{\theta}) = \theta$ 对θ的所有取值成立，实际意义是无系统误差。</strong>(考的概率大)</p>
<p>有效性：$D(\hat{\theta})$对θ的所有取值尽可能小</p>
<p>相合性：设$\hat{\theta}_n =\hat{\theta}_n(X_1,X_2,…,X_n)$，对θ的所有取值，依概率收敛于θ<br>可以证明，在较为一般的情况下，矩估计、MLE得到的估计量都是相合估计量。</p>
<h4 id="枢轴"><a href="#枢轴" class="headerlink" title="枢轴"></a>枢轴</h4><p>首先满足置信度$1-\alpha$，然后尽量缩小区间长度，也就是提高精度。</p>
<p>不光是记住对应的枢轴变量，更要理解推导出置信区间的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027957.png" alt="image-20220101170041958" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027958.png" alt="image-20220101170123565" style="zoom:50%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027959.png" alt="image-20211202090349096" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027960.png" alt="image-20211202091529763" style="zoom:33%;" />

<p>结合抽样分布定理理解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027961.png" alt="image-20211202091549607" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027962.png" alt="image-20220101185539648" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027963.png" alt="image-20220101185658773" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027964.png" alt="image-20211208202236252" style="zoom: 67%;" /></p>
<p>格式里不要忘了写查表得，在置信度为xxx下，置信区间为，，，，<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027965.png" alt="image-20220103202615404" style="zoom:50%;" /></p>
<p>对于单侧，将一个端点换位无穷，另一个端点的$\frac{\alpha}{2}$换成$\alpha$</p>
<p>而在<strong>假设检验</strong>，我们从另一个角度分类，从各类参数出发构造检验。</p>
<p>对均值估计，已知方差，则都是标准正态。</p>
<p>对均值估计，未知方差，则都是$t$分布【均值差估计时，假设若是$\mu_1-\mu_2=0$记得带入消掉】</p>
<p>对方差估计，都是卡方分布</p>
<p>对方差之比检验，是$F$分布</p>
<p><strong>步骤</strong>：作出假设（由题意需假设检验）、构造检验统计量（要写，当$H_0$成立时）、确定拒绝域（原假设的拒绝域为）、对$H_0$判断。（已知，，，，，查表得。。判断。。因此拒绝/结束$H_0$，即认为）</p>
<p>工艺题，<strong>保守原则</strong>，总是讲$H_0$设为想证明的结论的反面，然后否定$H_0$，比如猜测$\mu_1&gt;\mu_2$<br>就假设$H_0:\mu_1 \leq \mu_2,H_1:\mu_1 &gt; \mu_2$，再等价成$H_0:\mu_1 = \mu_2$，再否定它。<br>拒绝域是$t&gt;t_{\alpha}$，这样记：与$H_1$条件中同号      反之同理，关键是$H_1$</p>
<p>$\mu_1 - \mu_2$未知$\sigma_1\ \sigma_2$，需要先检验$H_0:\sigma_1 = \sigma_2$如果方差不相等，不在考虑范围内。相等则两样本t检验法</p>
<hr>
<p>回归分析和方差分析是数理统计中应用价值很大的两类方法，共同点是研究变量之间的关系。</p>
<p>回归分析着重寻求变量值近似的函数关系。研究相关关系（存在联系，但没达到可以相互确定的程度）</p>
<p>$Y = \mu(x_1,x_2,…,x_k)+\xi$</p>
<p>通常要求随机误差满足：$E(\xi) = 0,D(\xi) = \sigma^2 = E(\xi^2) = E[Y - \mu(x_1,x_2,…,x_k)]^2$<br>即均值为0，方差存在。方差实际是回归函数近似因变量Y的均方误差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027966.png" alt="image-20220102130707096" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027967.png" alt="image-20220102130717305" style="zoom:35%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027968.png" alt="image-20220102130951882" style="zoom:40%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027969.png" alt="image-20220102131215823" style="zoom:40%;" /></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong>课本</strong></p>
<p>​        记得先假设事件，如 A = {}。公式也有分，比如<u>全概率公式、贝叶斯</u>得写出来（由xxx得：列公式=代数字）</p>
<p>P11 古典概型是全概率和贝叶斯的基础。 例1.2.3 到1.2.5</p>
<p>P18 条件概率例题 例1.3.4</p>
<p>P19 例1.3.5  1.3.6 连续乘法 1.3.7</p>
<p>P21 全概率解题结构，要强调xxx构成样本空间得划分。 P23 例1.3.12/13贝叶斯公式。</p>
<p>P46 2.2.8 9 10 泊松分布（因为n较大，p较小，可认为X近似服从参数为$\lambda = np = ?$得泊松分布，于是 <u>先列出二项分布的式子，再约等于泊松的式子</u>） </p>
<p>P56 2.3.9 正态分布</p>
<p>P70 例3.1.6 概念题【注意第四问，<u>设了一个u和v</u>，而不是用原来的x，y】 3.1.7 在求边缘概率密度时要分区间</p>
<p>​        证明相互不独立时，找一个区间就好，一般找那个二维的非零区间。</p>
<p>P78 3.3.1条件分布率 3.3.2</p>
<p>P80 <strong>例3.3.3</strong> 注意边缘概率密度范围是一维的，条件概率是二维的。第二问：<u>求条件概率要先求出条件概率密度再积分。</u></p>
<p>​        例3.3.4 算联合概率时范围确定。（<u>条件分布率的范围表示时把后面那个变量视为常数</u>，有积分那味道了）</p>
<p>P83-84 离散型随机变量的函数、分布律  先列出函数的可能取值，再列式求和。【二项、泊松、正态】有可加性</p>
<p>P86 求连续随机变量的函数及其概率密度（此时，要对y的范围进行讨论，但最终y要取满R）但最终进行求导时不变（除了合并）</p>
<p>P88-93 例3.4.8利用公式法，注意x，y范围是一一对应的。</p>
<p>​         三大特殊分布。和分布，如果X，Y是相互独立的，可以拆成边缘分布律乘积。<br>​            例3.4.12 转到x，z平面，确定积分限。    例3.4.13 转到y，z平面，确定积分限。（这个独立的话也可以拆）<br>​            通过这俩例子也能看到题给条件是联合概率/边缘概率时分别如何处理。</p>
<p>P107 例 4.1.7 4.1.8   二维随机变量的联合函数的方差</p>
<p>P131 切比雪夫例子</p>
<p>P136-138 中心极限定理例子</p>
<p>P151 推导$S_w$的过程，好好掌握，免得暴雷。</p>
<p>P158 矩估计，一般是利用E和D的式子来连接。还有$E(X^2)$</p>
<p>P160-161 对于某种分布的情况，似然函数借助分布律/概率密度进行构造。</p>
<p>很有可能考无偏性，其实是考察对E、D性质的掌握，看学解历年真题</p>
<p>P169-173 几种枢轴变量</p>
<p>P175 单侧置信区间，一定要写 **若$H_0$立，检验统计量…..          故在显著性水平0.05下接受$H_ 0$ **</p>
<hr>
<p><strong>课件</strong></p>
<p>1.3 例9 10 11 12(解法2) 14 15</p>
<p>1.4  全概率、贝叶斯 例5 例6 例8 9贝叶斯要算出全部的再比较</p>
<p>2.1 最后 例3 例4（右连续）</p>
<p>2.3 例6 指数分布，最后一题正态</p>
<p>3.1 例3.1.5 </p>
<p>3.3 条件分布率 例1 <u>例3</u> <strong>例4</strong> 根据边缘概率的区间，对条件概率分段（因为条件概率也是二维的，需要二维约束）。</p>
<p><strong>3.4</strong> 例3.4.7，一个自定义的分段随机变量的函数，<u>画图来讨论范围</u>。第二问用定义来做。3.4.8-最后，多练练。</p>
<p>4.1 下面练习$X,Y \sim N(0,\frac{1}{2})$，则$E(|X-Y|)=\sqrt{\frac{2}{\pi}}$<br>        例4.1.7 4.1.8 利用数学期望的性质（主要是可加性）进行问题求解。【尤其是4.1.8的分解方式，保持独立、一致】</p>
<p>​        例4.2.3 进一步求$|X-Y|$的方差。</p>
<p>4.3 例4.3.4 求cov，转了一层  4.3.6（算一堆均值）</p>
<p>​        例4.3.7 利用了E D Cov的性质，挺不错</p>
<p>5.1 例5.1.2 5.1.3 将题给的数转化成$E(X)$的形式，凑出切比雪夫形式。</p>
<p>5.2 例5.2.2-5.2.4  5.2.3的设变量方式值得学习</p>
<p>6.2 6.2.4 6.2.5 类似的推导，用U,V来描述过程。</p>
<p><u>7.1 例7.1.2（最后超牛） 7.1.3 7.1.4 最后那个均匀的处理。【极大似然格式，掌握好】</u></p>
<p>8.1 最后一题，二项分布结合假设检验</p>
<p>8-2 研究正常男、女红细胞X2，要假设随机变量，</p>
<p>4-5习题课</p>
<p>11 停车次数</p>
<p>8 求类似的<u>一般不用切比雪夫，用中心极限定理</u>。还有后面的车间机床</p>
<p>求 X  和Y 的联合分布指的是求联合分布律或密度</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027970.png" alt="image-20220102194707428" style="zoom:33%;" />设新变量$e^{X_k}$，算出均值为2，用辛钦大数定律。</p>
<p>6-9习题课</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101027971.png" alt="image-20220102193744173" style="zoom:33%;" />

<p>最后5道选择挺有意思。</p>
<p><strong>历年真题</strong></p>
<p>第一套：第三题、<u>似然估计题</u>（如果似然函数的分布律/分布函数是一个常数，那就要分析取值范围，一般取x的俩极值）</p>
<p>第二套：还是狗日的<strong>第三题</strong>，第四题这种处理，先变成大正态，同乘同除处理。最后回归，如果题目没给均值，同乘n</p>
<p><strong>作业册</strong></p>
<p>P11、13、15最下面 </p>
<p>P22_11、13、15、16、19、23（离散结合连续）题</p>
<p>P32_10、11</p>
<p>P37_6、7、8</p>
<p>P40_3、5、6 先确定统计量的分布，或处理后确定分布</p>
<p>P44_4、6</p>
<p>P59_12</p>
]]></content>
  </entry>
  <entry>
    <title>软工概念</title>
    <url>/2021/07/03/%E8%BD%AF%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="软件工程（2）"><a href="#软件工程（2）" class="headerlink" title="软件工程（2）"></a>软件工程（2）</h2><p><strong>软件的概念</strong></p>
<p><u>软件= 程序+ 数据+ 文档</u><br>(1) 程序：按事先设计的功能和性能需求执行的指令序列<br>(2) 数据：是程序能正常操纵信息的数据结构<br>(3) 文档：与程序开发、维护和使用有关的图文材料</p>
<p><u>双重作用：软件一方面是一种产品，另一方面是开发其他软件产品的工具。</u></p>
<p> <strong>软件分类</strong><br>（1）功能分类：系统软件、支撑软件、应用软件<br>（2）服务对象：项目软件、产品软件</p>
<p><em>软件的特征</em><br>1、软件是开发的或者是工程化的，并不是制造的<br>2、软件开发环境对产品影响较大<br>3、软件开发时间和工作量难以估计<br>4、软件会多次修改<br>5、软件的开发进度几乎没有客观衡量标准<br>6、软件测试非常困难<br>7、软件不会磨损和老化<br>8、软件维护易产生新的问题<br>9、软件生产是简单的拷贝    </p>
<p><strong>软件危机</strong></p>
<p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p>
<p>项目超出预算、项目超过计划完成时间、软件运行效率很低、软件质量差、软件通常不符合要求、项目难以管理并且代码难以维护、软件不能交付。</p>
<p><strong>原因</strong></p>
<p>客观：软件本身特点——（逻辑部件，规模庞大）<br>主观：不正确的开发方法——（忽视需求分析，错误认为：软件开发=程序编写，轻视软件维护）</p>
<p><strong>软件工程定义</strong></p>
<p>（1）应用<u>系统化的、学科化的、定量</u>的方法，来开发、运行和维护软件，即将工程化方法应用到软件。<br>（2）对（1）中各种方法的研究。</p>
<p><strong>软工三要素</strong>【后面章节以此为纲吗】</p>
<p><u>工具</u>：为软件工程的过程和方法提供自动化或半自动化的工具支持 。</p>
<p><u>方法</u>：软件工程方法是完成软件工程项目的技术手段。分两类: 结构化方法和面向对象方法</p>
<p><u>过程</u>：过程贯穿软件开发的各个环节，在各环节之间建立里程碑;管理者在软件工程过程中对软件开发的质量、进度、成本进行评估、管理和控制； 技术人员采用相应的方法和工具生成软件工程产品（模型、文档、数据、报告、表格等）</p>
<p>根基：质量焦点</p>
<p><em>发展过程</em></p>
<p>传统软件工程、对象工程、过程工程、构件工程。</p>
<h2 id="软件过程（2）"><a href="#软件过程（2）" class="headerlink" title="软件过程（2）"></a>软件过程（2）</h2><p><u>软件工程是一种层次化技术</u></p>
<p><em>软件生命周期</em>（龙说关注各个阶段产出，不过这图确实是有用。）</p>
<p>指软件产品或软件系统从定义、设计、投入使用到被淘汰的全过程。</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215101731360.png" alt="image-20211215101731360" style="zoom:67%;" />

<p><strong>软件过程概念</strong></p>
<p>软件过程是在工作产品构建过程中，所需完成的工作<u>活动、动作和任务的集合</u>。</p>
<p>活动主要实现宽泛的目标</p>
<p>动作包含了主要工作产品生产过程中的一系列任务</p>
<p>任务关注小而明确的目标，能够产生实际产品</p>
<p><strong>软件过程模型</strong> </p>
<p>是软件开发全部过程、活动和任务的<u>结构框架</u>。<br>直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。</p>
<p><strong>软件过程评估</strong></p>
<blockquote>
<p>能力成熟度模型<strong>CMM</strong>（Capability Maturity Model）是迄今为止学术界和工业界公认的有关软件工程和管理实践的最好的软件过程评估模型。</p>
</blockquote>
<p>分级：【感觉非常有道理！有借鉴意义】</p>
<p>（1）初始级           有能力的人和个人英雄主义</p>
<p>（2）可重复级        基本项目管理</p>
<p>（3）已定义级        过程标准化</p>
<p>（4）量化管理级     量化管理</p>
<p>（5）优化级           持续的过程改进</p>
<hr>
<p><strong>瀑布模型</strong></p>
<p><u>软件开发过程与软件生命周期是一致</u>的，也称经典的生命周期模型。</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215103712171.png" alt="image-20211215103712171" style="zoom:80%;" />

<p>特点：<br>阶段间具有<u>顺序性和依赖性。</u><br><u>推迟实现</u>的观点。<br>每个阶段必须完成规定的文档; 每个阶段结束前完成文档审查,及早改正错误。<u>以文档为驱动。</u></p>
<p>缺点<br>增加工作量<br>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；</p>
<p>开发风险大<br>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；</p>
<p>早期错误发现晚<br>早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。</p>
<p>不适用于需求变化的场合<br>适用于：<u>系统需求明确、技术成熟、工程管理较严格</u>的场合，如军工、航天、医疗。</p>
<p><strong>V模型（瀑布变种）</strong></p>
<p>龙老师说记住对应关系。</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215103954519.png" alt="image-20211215103954519" style="zoom:80%;" />





<p><strong>原型模型</strong>——思想是首先实现软件的最核心的、最重要的功能</p>
<p>原型（prototype）：<br>一个部分开发的产品，使客户和开发人员能够对计划开发的系统的相关方面进行检查。</p>
<p>结果：<u>抛弃原型、把原型发展</u>成最终产品。</p>
<p>优点：减少需求不明带来的风险。</p>
<p>缺点：</p>
<ul>
<li>构造原型采用的工具和技术不一定主流；</li>
<li>设计者在质量和原型中进行折中；</li>
<li>客户意识不到一些质量问题。</li>
</ul>
<p>适用场合：客户定义一个总体目标集，但是他们<u>并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式</u>。</p>
<p><strong>增量模型</strong></p>
<p>增量：满足用户需求的一个子集，能够完成一定功能、小而可用的软件。</p>
<p>增量方式分为：增量方式（增加新功能）和迭代方式（改进）</p>
<p>特点：<br>• 增量模型从部分需求出发，先建立一个不完整的系统，通过测试运行这个系统，取得经验和反馈，进一步使系统扩充和完善<br>• 增量模型结合了原型模型的基本要素和迭代的特征，采用了基于时间的线性序列，每个线性序列都会输出该软件的一个“增量”<br>• <u>每个增量的开发可用瀑布或快速原型模型</u>。</p>
<p>优点：</p>
<ul>
<li>不需要提供完整的需求， 只要有一个增量包出现，开发就可以进行。</li>
<li>在项目的 初始阶段不需要投入太多的人力资源。增量可以 有效地管理技术风险。 </li>
<li>产品逐步交付，能较好的适应需求变化。 </li>
<li>开放式体系结构 ，便于维护。 </li>
<li>软件能够更早的投入市场。</li>
</ul>
<p>缺点：每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小适合的增量。软件必须具备开放式体系结构（困难）。易退化成边做边改的方式，使软件过程控制失去整体性</p>
<p>适用场合：开发中<u>需求可能变化、具有较大风险、或希望尽早进入市场</u>的项目。</p>
<p><strong>螺旋模型</strong></p>
<p>把开发活动和风险管理结合起来控制风险，强调风险管理，因此该模型适用于<u>大型系统</u>的开发。<br>模型结合了<u>瀑布模型和原型模型</u>的特点。</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215105238453.png" alt="image-20211215105238453" style="zoom:67%;" />

<p>优点：</p>
<ul>
<li>特别强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力。支持<u>用户需求的动态变化</u>。</li>
<li>易于为用户和开发人员共同理解，还可作为<u>继续开发的基础</u>，并为用户参与所有关键决策提供了方便。</li>
<li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可<u>降低开发风险。</u></li>
</ul>
<p>缺点：</p>
<ul>
<li>如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟提交时间；</li>
<li>使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高。</li>
</ul>
<p>适用场合：</p>
<p>适用于需求不明确或者<strong>需求可能发生变化的大型复杂</strong>的软件系统。</p>
<p><em>喷泉模型</em></p>
<p>是一种以用户需求为动力，以对象为驱动的模型，主要用于<u>描述面向对象</u>的软件开发过程</p>
<p>优点：各个阶段没有明显的界限，开发人员可以同步进行开发。其提高软件项目开发效率，节省开发时间。<br>缺点：由于喷泉模型在各个开发阶段是重叠的，在 开发过程中需要大量的开发人员，不利于项目的管理。此外这种模型 要求严格管理文档 ，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。</p>
<p><strong>敏捷开发</strong></p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215110616835.png" alt="image-20211215110616835" style="zoom:80%;" />

<p>敏捷软件过程是<u>基本原理和开发准则</u>的结合</p>
<p>优点： 对变化和不确定性有更快更敏捷的反应。在 快速的同时<u>保持可持</u><u>续的开发速度</u>。能较好地适应商业竞争环境下对<u>小项目</u>提出的 有限资源和有限开发时间的约束<br>缺点：极限编程中的测试驱动开发可能会导致 系统<u>通过了测试但不是用</u><u>户期望的</u>。 重构而不降低体系结构的质量是困难的。用于 大型项目有很多问题</p>
<p><strong>选择模型</strong>【在不同的条件下选择相应的思路，对我有启发】</p>
<p>1.前期<u>需求明确</u>的情况下，尽量采用瀑布模型<br>2.<u>用户无系统使用经验，需求分析人员技能不足的情况下</u>，尽量借助原型模型<br>3.<u>不确定因素很多</u>，很多东西无法提前计划的情况下，尽量采用增量模型或螺旋模型<br>4.需求不稳定或资金和成本无法一次到位的，尽量采用增量模型</p>
<p>6.对于完成多个独立功能开发的情况，可在需求分析阶段就进行<u>功能并行</u>，每个功能内部都尽量遵循瀑布模型<br>7.全新系统的开发必须在总体设计完成后再开始增量或并行<br>8.编码人员<u>经验较少的情况下，尽量不要采用敏捷或迭代模型</u><br>9.增量、迭代和原型可以综合使用，但每一次增量或迭代都必须有<u>明确的交付和出口原则</u></p>
<p>瀑布模型、增量模型、原型模型和螺旋模型的<strong>联系和区别</strong></p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>瀑布模型</th>
<th>原型模型</th>
<th>增量模型</th>
<th>螺旋模型</th>
</tr>
</thead>
<tbody><tr>
<td>是否事先定义大部分需求</td>
<td>是</td>
<td>无</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td>每次迭代输出是否为产品</td>
<td>是</td>
<td>无</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td>驱动方式</td>
<td>文档</td>
<td>用户</td>
<td>用户</td>
<td>风险</td>
</tr>
<tr>
<td>迭代周期内的过程模型</td>
<td>瀑布模型</td>
<td>瀑布模型</td>
<td>原型模型</td>
<td>可选</td>
</tr>
</tbody></table>
<p>举例说明：若一个软件包含A、B、C、D四个功能，那么</p>
<p>瀑布模型输出结果为ABCD</p>
<p>原型模型输出结果为A’B’C’D’-&gt;ABCD</p>
<p>增量模型输出结果为A-&gt;AB-&gt;ABC-&gt;ABCD</p>
<p>螺旋模型输出结果为A1B1C1D1-&gt;A2B2C2D2-&gt;……-&gt;ABCD</p>
<h2 id="需求分析（1）"><a href="#需求分析（1）" class="headerlink" title="需求分析（1）"></a>需求分析（1）</h2><p><strong>需求分析的定义</strong>：</p>
<p>确定系统必须具有的<u>功能和性能，系统要求的运行环境</u>，并且<u>预测</u>系统发展的前景。<br>换句话说需求就是以一种 <u>清晰 、简洁 、一致且无二义性</u>的方式，对一个待开发系统中<u>各个有意义方面的陈述</u>的一个集合。</p>
<blockquote>
<p>需求获取</p>
<p>用户目标、领域知识、投资者、运行环境、组织环境</p>
<p>采访、设定情景、原型、会议、观察商业工程和工作流。</p>
<p>十原则：倾听、有准备的沟通、有地位足够的人推动、最好当面沟通、记录决定、保持通力合作</p>
</blockquote>
<p>需求分析的过程：<u>需求确认与需求变更</u></p>
<p><strong>需求确认</strong>：<u>需求获取-&gt;需求提炼-&gt;需求描述-&gt;需求验证</u>：</p>
<ul>
<li>需求获取：软件需求的 来源以及软件工程师收集这些软件需求的方法。</li>
<li>需求提炼（需求分析）：将用户需求 精确化、完全化，最终形成下一步的 需求规格说明书。<u>核心在于建立分析模型</u>。</li>
<li>需求描述：软件需求规格说明书（SRS）——软件系统的需求规格说明，是对待开发系统的行为的 <u>完整描述</u>。为了使用户和软件开发者双方对该软件的初始规定有一个<u>共同的理解</u>，使之成为整个开发工作的基础。</li>
<li>需求验证：重要性：如果在后续的开发或当系统投入使用时才发现需求文档中的错误，就会导致更大代价的返工。<br>需对文档进行：<ul>
<li>有效性检查：检查不同用户使用不同功能的有效性</li>
<li>一致性检查：在文档中，<u>需求之间不应该冲突。</u></li>
<li>完备性检查：需求文档应该包括<u>所有</u>用户想要的功能和约束。</li>
<li>可行性检查：检查保证<u>能利用现有技术</u>实现需求。</li>
</ul>
</li>
</ul>
<p><strong>需求类型/需求分析的分类</strong></p>
<p>(1) 功能性需求：描述<u>系统应该做什么</u>，即<u>为用户和其它系统完成的功能、提供的服务</u>。<br>(2) 非功能性需求：必须遵循的标准，外部界面的细节，实现的<u>约束条件</u>，质量属性等等<br>(3) 非功能需求限定了选择解决问题方案的范围，如运行平台、实现技术、编程语言和工具等</p>
<hr>
<p><strong>分析模型描述工具</strong></p>
<p>一个典型的软件系统使用数据结构（数据模型），执行操作（行为模型），并且完成数据值的变化（功能模型）</p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215115345970.png" alt="image-20211215115345970"></p>
<p><em>面向过程分析模型</em>：基本思想 是用系统工程的思想和工程化的方法，根据用户至上的原则，自始自终按照 <u>结构化、模块化，自顶向下</u> 地对系统进行分析与设计。</p>
<p>结构化分析（Structured Analysis，简称SA），是<u>面向数据流</u>进行需求分析的方法。 结构化分析的主要思想是采取<u>自顶向下逐层分解</u>的分析策略，即面对一个复杂的问题，分析人员不可能一开始就考虑到问题的所有方面以及全部细节，采取的策略往往是分解，把一个复杂的问题划分成若干小问题，然后再分别解决，将问题的复杂性降低到人可以掌握的程度。</p>
<p><em>面向对象分析模型</em>：由5个层次（主题层、对象类层、结构层、属性层和服务层）和5个活动（标识对象类、标识结构、定义主题、定义属性和定义服务）组成。</p>
<p>面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法。 面向对象方法的解决问题的思路是<u>从现实世界中的客观对象（如人和事物）入手，尽量运用人类的自然思维方式来构造软件系统</u>，这与传统的结构化方法从功能入手和信息工程化方法从信息入手是不一样的。</p>
<hr>
<p><strong>面向过程</strong>—结构化分析方法</p>
<p><strong>数据流图DFD</strong></p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120035900.png" alt="image-20211215120035900" style="zoom: 50%;" /><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120514343.png" alt="image-20211215120514343" style="zoom:50%;" /></p>
<p>数据流图层次结构</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20211215120610055.png" alt="image-20211215120610055" style="zoom: 60%;" align = 'left' />

<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20211215141325037.png" alt="image-20211215141325037" style="zoom:67%;" align = 'left'/>与、或、异或。</p>
<p><em>加工</em> 的命名注意事项</p>
<p> 1）顶层的加工名就是整个系统项目的名字</p>
<p> 2）尽量最好使用<u>动宾词组</u>，也可用<u>主谓词组</u></p>
<p> 3）不要使用空洞的动词</p>
<p><em>外部实体</em>（数据源点/ /终点）<br>起到更好的理解作用，但不是系统中的事物</p>
<p><em>数据流</em></p>
<p> 数据流可从加工流向加工，也可在加工与数据存储或外部项之间流动；两个加工之间可有多股数据流</p>
<p>1） 不要把控制流作为数据流。 2) 不要标出激发条件</p>
<p><u>每个加工至少有一个输入数据流和一个输出数据流。</u></p>
<p><u>数据流必须有一端是加工，而不能两端都是 外部项/数据存储。</u></p>
<hr>
<p><strong>面向对象</strong></p>
<p><strong>功能模型-用例图</strong></p>
<p>用例建模用于描述系统需求，把系统当作黑盒，<u>从用户的角度，描述系统的场景</u>。</p>
<p>主要图形元素有以下几个：</p>
<p><em>参与者</em>：是指外部用户或外部实体在系统中扮演的角色。可以是 <u>人、其他系统、设备</u> 或者时间等角色。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034754.png" alt="image-20220102214007908" style="zoom:50%;" />

<blockquote>
<p>确定参与者：</p>
<p>开发人员可以通过回答以下的问题来寻找系统的参与者。<br>（1）谁将使用该系统的主要功能？<br>（2）谁将需要该系统的支持以完成其工作？<br>（3）谁将需要维护、管理该系统，以及保持该系统处于工作状态？<br>（4）系统需要处理哪些硬件设备？<br>（5）与该系统交互的是什么系统？<br>（6）谁或什么系统对本系统产生的结果感兴趣？</p>
</blockquote>
<p><em>用例</em>：对<u>一组动作序列</u>的描述，系统通过执行这一组动作序列为参与者<u>产生一个可观察的结果</u>。用例名往往用<u>动宾结构</u>命名</p>
<p>​            用椭圆形表述</p>
<blockquote>
<p>• 说明了系统具有的一种<u>行为模式</u><br>• 说明了一个参与者与系统执行的一个相关的事件序列<br>• 提供了一种获取系统需求的方法<br>• 提供了一种与最终的用户和领域专家进行沟通的方法<br>• 提供了一种测试系统的方法</p>
</blockquote>
<p><em>执行关联</em>： 参与者（Actor ）执行用例（Use Case）之间的关系</p>
<ol>
<li>关联： <u>参与者与用例之间的关系（其他都是用例之间的关系）</u>。表示 参与者与用例之间的通信，任何一方都可发送或接受消息。<br> 【箭头指向】：指向消息接收方，<u>也可以不加箭头</u></li>
<li>泛化： 就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关<br>系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。<br>【箭头指向】：指向父用例</li>
<li>包含：包含（include）关系指的是两个用例之间的关系，其中一个用例（称为基本用例）的行为包含另一个用例（称为包含用例，inclusion use case）的行为。<br> 【箭头方向】由基本用例指向分解出的用例。 <u>执行基本用例的时候，每次都应该调用被包含用例</u>， 被包含用例也<u>可单独执行</u>。</li>
<li>扩展：扩展关系是指用例功能的延伸，相当于为基础用例提供一个 附加功能。 <u>扩展用例依赖于被扩展用例，不是完整的独立用例， 无法单独执行</u>。在扩展关系中，一个基本用例执行时，<u>可以执行、也可以不执行</u><br> 【箭头方向】由扩展用例指向基本用例。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034755.png" alt="image-20211215145904906" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034756.png" alt="image-20220102214202201" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034757.png" alt="image-20220104222122993" style="zoom:67%;" />

<hr>
<p><strong>行为模型-活动图（泳道图）</strong></p>
<p><u>是对用例的图形化！</u></p>
<p>• 每一步都是做某事的一个<u>状态</u><br>• 执行步骤称为<u>动作</u><br>• 描述哪些步骤被顺序执行、哪些可被并发地执行<br>• 控制流 – 控制从一个动作到下一个动作的流</p>
<p>在用例流中发现动作。</p>
<p>活动图别忘了开始和结束的标记，注意分叉的类型</p>
<p>开始：实心圆  结束：牛眼</p>
<p>转换可以分支及合并（钻石框） – （可选）计算线程【如果需要判断，也得在菱形外面加说明，如果有条件，要附上说明】</p>
<p>转换可以分叉及汇合（短横线）– 并发（并行）计算线程</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034758.png" alt="image-20211215150956912" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034759.png" alt="image-20211215151013131" style="zoom:57%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034760.png" alt="image-20220102215033431" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034761.png" alt="image-20220102215052674" style="zoom:50%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034762.png" alt="img" style="zoom:67%;" />

<p>这俩图还是建议好好看完PPT。</p>
<h2 id="软件设计（1）"><a href="#软件设计（1）" class="headerlink" title="软件设计（1）"></a>软件设计（1）</h2><p><strong>软件设计</strong>：软件系统或组件的架构、构件、接口和其他特性的<u>定义过程及该过程的结果。</u><br>软件工程生命周期中的一个活动。进行软件编码的基础。<br>软件需求分析被转化为软件的内部结构。是连接用户需求和软件技术的桥梁。设计是<u>软件工程技术的核心</u>。</p>
<blockquote>
<p><strong>指导原则</strong>：<br>1 设计应该是一种<strong>架构</strong><br>2 设计应该是<strong>模块化</strong>的<br>3 设计应该包含 <u>数据、体系结构、接口和组件</u>各个方面</p>
<p>应该设计出系统所用的数据结构<br>应该设计出展现独立功能特性的各组件<br>应该设计出各组件与外部环境连接的各接口</p>
<p>4 设计由软件需求分析过程中获得信息驱动，采用可重复使用的方法导出<br>5 设计应该采用正确清楚的表示法</p>
</blockquote>
<p>概要设计：实现目标产品的总体框架，包括<strong>体系结构设计、数据设计、接口和组件</strong>设计。<br>                    其中体系结构是设计师概要设计的主要内容。<br>详细设计：对概要设计划分出来的模块分别去描述设计，以便能够编码实现</p>
<p>系统设计从<strong>数据、体系结构、接口和组件</strong>四方面进行设计。【自底向上】</p>
<p><strong>八大概念</strong>【知道即可，不会让详细解释】</p>
<p>抽象、体系结构、设计模式、模块化、信息隐藏、功能独立、细化、重构。<br>其中，着重考察 <u>体系结构、模块化、信息隐藏、功能独立</u>。</p>
<ol>
<li><p>抽象</p>
<p>忽略具体的信息将不同事物看成相同事物的过程， <u>参数化、规范化</u>。</p>
</li>
<li><p><strong>体系结构</strong></p>
<p>含义：软件的整体结构 和 这种结构为系统提供 概念上完整性 的方式<br>表达方式：结构模型、框架模型、动态模型、过程模型、功能模型</p>
</li>
<li><p>设计模式</p>
<p> 在给定上下文环境中一类共同问题的共同解决方案，如抽象工厂</p>
</li>
<li><p><strong>模块化</strong></p>
<p>软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求</p>
<p>软件的模块性：程序可被智能管理的单一属性</p>
<p>理论依据：基于人类解决问题的观测数据</p>
<p>模块化基本问题 如何分解软件系统以达最佳的模块划分</p>
<blockquote>
<p>设计标准：</p>
<ol>
<li>分解性：可分解为子问题</li>
<li>组合性：组装可重用的组件</li>
<li>可理解性：可作为独立单元理解</li>
<li>连续性：需求小变化只影响单个模块</li>
<li>保护： 模块内异常只影响自身</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034763.png" alt="image-20211215153317948"  align = 'left'/></blockquote>
</li>
<li><p><strong>信息隐藏</strong></p>
<p> 模块应该具有彼此相互隐藏的特性，模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问</p>
</li>
<li><p><strong>功能独立</strong></p>
<p>每个模块只负责<u>需求中特定的子功能</u>，并且从程序结构的其他部分看，该模块具有简单的接口</p>
<p>• 易于开发：功能被划分，接口被简化。<br>• 易于维护（和测试）：次生影响有限，错误传递减少，模块重用。</p>
<p>定性衡量标准：</p>
<p>• 内聚性：模块的功能相对强度<br>• 耦合性：模块之间的相互依赖程度<br>• 模块独立性强 = 高内聚低耦合</p>
</li>
<li><p>精化</p>
<p> 逐步求精的过程</p>
<p> 与抽象的关系：</p>
<p> • 抽象使设计师确定过程和数据，但不局限于底层细节<br> • 精化有助于设计者在设计过程中揭示底层细节</p>
</li>
<li><p>重构</p>
<p> 不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术</p>
<p> 检查现有<u>设计的冗余情况、未使用的设计元素、无效或不必要的算法、较差的构建方式或不恰当的数据结构</u>，或任何其他可被更改从而优化设计的问题</p>
</li>
</ol>
<blockquote>
<p><strong>面向过程设计技术概要</strong></p>
<p>系统设计从体系结构、数据、接口和组件四方面进行设计。</p>
<p><u>数据设计</u><br>（有时也被称为数据架构）构建高层抽象（客户/用户的数据视图）的数据模型、信息模型</p>
<ol>
<li>数据建模： 数据字典、E-R 图 、类图。</li>
<li>数据结构：计算机存储组织数据的方式。</li>
<li>数据库：按照数据结构来组织、存储和管理数据的仓库</li>
</ol>
<p><u>体系结构设计</u> </p>
<p>风格和模式简要分类：<strong>数据中心结构、数据流体系结构、调用和返回结构、层次结构、面向对象结构</strong>【图要认得出】</p>
<p>组织和细化两个基本问题：</p>
<ul>
<li>控制结构：在架构内部如何实现管理控制？是否有不同的控制架构存在</li>
<li>数据传递：组件之间如何进行数据传递？数据流是否连续，或者传递给系统的数据对象是否零散</li>
</ul>
<p><u>接口设计</u>（含界面设计）</p>
<p>• 允许用户操作控制（用户为中心）<br>• 减少用户记忆负担<br>• 保持界面一致</p>
<p><u>组件设计</u>：面向过程（函数、模块）、面向对象（类与操作）<br>在过程设计、详细设计，位于数据设计、体系结构设计和接口设计完成之后</p>
<p><em>面向过程的总体设计</em></p>
<p>1 首先研究、分析和审查数据流图。 从软件的需求规格说明中弄清数据流加工的过程，对于发现的问题及时解决。<br>2 然后根据数据流图决定问题的类型。数据处理问题典型的类型有两种：<u>变换型和事务型</u>。针对两种不同的类型分别进行分析处理。<br>3 由数据流图推导出系统的初始结构图。<br>4 利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。（系统结构图）<br>5 修改和补充数据词典。</p>
</blockquote>
<p>软件体系结构是系统的一个或多个结构，它包括<u>软件构件、构件的外部可见属性、以及它们之间的相互关系</u>。</p>
<p>风格和模式简要分类：<strong>数据中心结构、数据流体系结构、调用和返回结构、面向对象结构、层次结构</strong>【图要认得出】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034764.png" alt="image-20220102221017990" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034765.png" alt="image-20220102221030497" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034766.png" alt="image-20220102221041211" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034767.png" alt="image-20220102221058679" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034769.png" alt="image-20220102221111954" style="zoom:67%;" /></p>
<p><strong>流程图</strong>(flow chart)</p>
<p>利用各种方块图形、线条及箭头等符号来表达解决问题的步骤及进行的顺序；是算法的一种表示方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034770.png" alt="image-20211215162409417" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034771.png" alt="image-20211215162425931" style="zoom:67%;" /></p>
<p><em>基本结构</em></p>
<p>顺序结构、选择结构（二元、多重）、循环结构（while-do\do-while）【可以看看陈安龙出的题】</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034772.png" alt="image-20220102220751495" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034773.png" alt="image-20211223210208725" style="zoom:50%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034774.png" alt="image-20220105211743862" style="zoom: 33%;" />

<p>其他面向过程组件设计方法：盒图（N-S图）、PDL(程序设计语言)、判定表、判定图</p>
<hr>
<p><strong>面向对象的设计</strong></p>
<p>分为系统架构设计、用例设计、类设计、数据库设计、用户界面设计。</p>
<p><strong>架构设计</strong><br>架构设计的目的是要勾画出系统的总体结构，这项工作由经验丰富的架构设计师主持完成。</p>
<p>输入：用例模型、分析模型。     输出：物理结构、子系统及其接口、概要的设计类。</p>
<p><strong>用例设计</strong></p>
<p>进一步细化用例</p>
<p>根据分析阶段产生的高层类图和交互图，由用例设计师<u>研究已有的类，将它们分配到相应的用例中</u>。</p>
<p>检查每个用例功能，依靠当前的类能否实现，同时检查每个用例的特殊需求是否有合适的类来实现。</p>
<p>细化每个用例的类图，<u>描述实现用例的类及其类之间的相互关系</u>，其中的通用类和关键类可用粗线框区分，这些类将作为项目经理检查项目时的重点。</p>
<p><strong>类设计</strong></p>
<p>类是包含信息和影响信息行为的逻辑元素。类的符号是由三个格子的长方形组成，有时下面两个格子可以省略。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034775.png" alt="image-20211215163820307" style="zoom:80%;" />

<p> <em>类间关系</em></p>
<p>(1) 关联关系:关联是一种结构化的关系，指一种对象和另一种对象有联系。<br>(2) 聚合关系:指的是整体与部分的关系。<br>(3) 泛化关系：泛化也就是继承关系<br>(4) 组合关系：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。<br>(5) 依赖关系：是一种使用关系，特定事物的改变有可能会影响到使用该事物的事物</p>
<p><u>组合是一种较为紧密的关系，从生命周期上看，部分和整体是共存亡的关系。 聚合则是一种较为松散的关系，部分和整体的生命周期未必一致。</u></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034776.png" alt="image-20211215151848878" style="zoom: 50%;" />



<p><em>不同的类</em></p>
<p>实体类用于对必须存储的<u>信息</u>和<u>相关行为</u>进行建模。源于业务模型中的业务实体</p>
<p>边界类用于参与者与用例之间、有交互的用例间、用例与系统边界之外交互时，</p>
<p>控制类来源于对用例场景中动词的分析和定义，主要起到协调对象的作用，例如从<u>边界类通过控制类访问实体类</u>，或者<u>实体类通过控制类访问另一个实体类</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034777.png" alt="image-20211215164219626" style="zoom:80%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034778.png" alt="image-20220101201405506"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034779.png" alt="image-20220101201422808"></p>
<p><em>类设计三步</em></p>
<ol>
<li><p>定义类的属性，类的属性反映类的特性，通常属性是被封装在类的内部，不允许外部对象访问。</p>
<p>原则：尽量使用已有的类型，一个类不要太复杂，坚持简单的原则。</p>
</li>
<li><p>定义类的操作</p>
<p>一个类可能被应用在多个用例中，由于它在不同用例中担当的角色不同，所以设计时要求详细周到。<br>检查<u>类在每个用例中实现是否合适</u>，补充必要操作；考虑特殊情况。</p>
</li>
<li><p>定义类之间的关系</p>
</li>
</ol>
<p><strong>UML顺序图</strong></p>
<p>用例常常被细化为一个或多个顺序图。它还能用来记录一个存在于系统的对象现在如何交互。<br>当强调按时间展开信息的传送时，一般使用顺序图建模技术。</p>
<ol>
<li>顺序图是强调消息<u>时间顺序</u>的交互图。</li>
<li>顺序图描述了对象之间传送消息的时间顺序，用来表示用例中的<u>行为顺序</u>。</li>
<li>顺序图将交互关系表示为一个二维图。即在图形上，顺序图是一张表，其中显示的对象沿横轴排列，从左到右分布在图的顶部；而消息则<u>沿纵轴按时间顺序排序</u>。创建顺序图时，以能够使图尽量简洁为依据布局。</li>
</ol>
<p><em>四个元素</em></p>
<p><u>对象（符号和对象图中对象所用的符号一样）、生命线、消息、激活。</u></p>
<p>对象置于顺序图的顶部意味着在交互开始的时候对象就已经存在了，否则表示对象是在交互的过程中被创建的。<br>一般最多两个参与者，他们分列两端。启动这个用例的参与者往往排在最左边；接收消息的参与者则排在最右端；<br>对象从左到右按照<u>重要性排列或按照消息先后顺序</u>排列</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034780.png" alt="image-20220102224513467" style="zoom:67%;" />

<p>每个对象都有自己的生命线（垂直的虚线），用来表示在该用例中一个对象在一段时间内的存在，生命期结束，则用<u>注销符号</u>表示。</p>
<p>激活表示该对象被占用以完成某个任务，去激活指的则是对象处于空闲状态、在等待消息。</p>
<p>面向对象方法中，消息是对象间交互信息的主要方式。<br>结构化程序设计中，模块间传递信息的方式主要是过程（或函数）调用。</p>
<p><em>消息分类：</em></p>
<p>同步消息：消息名称通常就是被调用的操作名称。【普通箭头】</p>
<p>异步消息表示发送消息的对象不用等待回应的返回消息，即可开始另一个活动。【半箭头】</p>
<p>一个对象也可以将一个消息发送给它自己，这就是反身消息。【指向自己】</p>
<p>返回消息是顺序图的一个可选择部分，它表示控制流从过程调用的返回。【返回的虚线箭头】<br>一般可以缺省，隐含表示每一个调用都有一个配对的调用返回。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034781.png" alt="image-20211215170104945" style="zoom: 80%;" />

<p>要注意创建和销毁<em>临时对象</em>的画法</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034782.png" alt="image-20220102224940022" style="zoom:50%;" />

<p>步骤：Ø确定交互的范围、Ø识别参与交互的对象和活动者、Ø设置对象生命线的开始和结束、Ø设置消息、Ø细化消息</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034783.png" alt="image-20211215170552213" style="zoom: 50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034784.png" alt="image-20220105194213354"></p>
<blockquote>
<p>面向对象设计原则【有用】：</p>
<p>强调定义软件对象，并且使这些软件对象相互协作来满足用户需求。</p>
<p>注意：</p>
<p>• 对接口进行设计<br>• 发现变化并且封装它<br>• 先考虑聚合然后考虑继承</p>
<p>强内聚：一个类的属性和操作全部都是完成某个任务所必须的，其中不包括无用的属性和操作。</p>
<p>弱耦合：耦合主要指不同对象之间相互关联的程度。如果一个对象过多地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。<br>当两个对象必须相互联系时，应该通过<u>类的公共接口实现耦合</u>，不应该依赖于类的具体实现细节。</p>
<p>可重用性：</p>
<p>• 尽量使用已有的类，包括开发环境提供的类库和已有的相似的类；<br>• 如果确实需要创建新类，则在设计这些新类时考虑将来的可重用性</p>
<p>框架：</p>
<p>框架是一组可用于不同应用的类的集合。框架中的类通常是一些抽象类并且相互有联系，可以通过继承的方式使用这些类。</p>
</blockquote>
<h2 id="质量保证（1）"><a href="#质量保证（1）" class="headerlink" title="质量保证（1）"></a>质量保证（1）</h2><p><strong>质量保证（QA）概念</strong></p>
<p>定义：系统地监测和评估一个工程的各个方面，以最大限度地提高由生产过程实现的质量的最低标准。</p>
<p>原则：适合用途：该产品应<u>符合预期的目的</u>          一次成功：<u>错误应该被淘汰</u></p>
<p><strong>软件质量</strong>：明确表示是否符合功能和性能要求，明确地记载开发标准和期望的隐性特点</p>
<ul>
<li>符合明确规定的功能和性能要求（前期约定）</li>
<li>符合明确的开发标准（明确标准）</li>
<li>符合所有软件开发专业的共性、隐性标准，如易用性、可维护性等（共性期望）</li>
</ul>
<p><strong>软件质量保证（SQA）</strong></p>
<p>遵照一定的软件生产标准、过程和步骤对软件质量进行评估的活动</p>
<p><strong>评估指标</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034785.png" alt="image-20211216104448415" style="zoom:67%;" align = 'left'/>

<p><strong>可靠性是</strong>一个持续性的状态，更多地强调系统自身；<br>可用性是一个短暂的状态，更多地强调外部的触发。<br>一个人如果随叫随到，但是时不时偷懒，就是高可用、低可靠；而如果他经常找不到人，但干活很负责，就是低可用、高可靠。</p>
<p><strong>V模型！</strong></p>
<p><u>要注意水平对应关系！</u>(这个和之前瀑布的图差了很多)</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034786.png" alt="image-20211216104609617" style="zoom:67%;" align = 'left'/>

<ol>
<li><strong>单元测试</strong>的主要目的是验证<u>软件模块</u> 是否按详细设计的规格说明<u>正确运行</u>。</li>
</ol>
<p>单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p>
<p><em>测试内容</em>：<u>模块接口 + 局部数据结构 + 边界条件 + 独立路径 + 出错处理</u></p>
<p>主要内容：模块接口测试（数据流、内外存交换）、局部数据结构测试、路径测试、错误处理测试、边界测试（流边界、关键路径）</p>
<p><em>测试环境</em>：模块并非独立程序，进行测试时，要考虑它和外界的联系，需用一些辅助模块去做相应模拟。</p>
<ul>
<li>驱动模块：用来模拟被测试模块的上一级模块，相当于被测模块的主程序。</li>
<li>桩模块：模拟被测试的模块所调用的模块，而不是软件产品的组成的部分。</li>
</ul>
<ol start="2">
<li><strong>集成测试</strong>主要目的是检查<u>多个模块间</u> 是否按概要设计说明的方式<u>协同工作</u>。</li>
</ol>
<p>将软件集成起来后进行测试。检查诸如两个模块单独运行正常，但集成起来运行可能出现问题的情况。</p>
<p><em>自顶向下</em>：将模块按系统程序结构，沿控制层次自顶向下进行集成。<br>可首先实现和验证一个完整的软件功能。桩模块的开发量较大。<br>适用于：控制结构清晰稳定；高层接口变化较小；希望<u>尽早能看到产品的系统功能行为</u>，底层接口未定义或经常可能被修改。</p>
<p><em>自底向上</em>：从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成以进行测试。<br>不需要桩模块；必须编写驱动模块；缺陷的隔离和定位不如自顶向下。<br>适用于：底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。</p>
<p>实际工作中，常综合使用：自底向上、自顶向下</p>
<p><em>SMOKE方法</em>：<br>将已经转换为代码的软件构件集成为构造（build）。一个构造包括所有的数据文件、库、可复用的模块以及实现一个或多个产品功能所需的工程化构件。<br>每天将该构造与其他构造，及整个软件产品集成，进行冒烟测试。</p>
<ol start="3">
<li><strong>系统测试</strong>的主要目的是验证<u>整个系统</u> 是否满足需求规格说明。</li>
</ol>
<p>从用户使用的角度进行测试，将完成了集成测试的系统放在真实的运行环境下进行。</p>
<p>目的：功能确认和验证       测试方法：黑盒测试</p>
<p>系统测试是软件开发过程必不可少的一环，<u>软件质量保证的最重要环节</u></p>
<p><em>测试内容</em>：面向：外部输入层测试，如不做，则<u>外部输入层向接口层转换</u>的代码就没有得到测试。</p>
<p>•    功能性测试：在规定的一段时间内运行软件系统的<u>所有功能</u>，以验证有无严重错误<br>•    性能测试：检查系统是否<u>满足需求规格说明书中的性能</u>，常与压力测试结合<br>•    压力测试：检查在系统<u>运行环境不正常乃至发生故障</u>的情况下，系统可以运行到何种程度的测试。敏感性测试<br>•    恢复测试：克服硬件故障后，系统能否继续正常工作。并不对系统造成任何损害。<br>•    安全测试：检测系统的安全性、保密性措施是否发挥作用，有无漏洞</p>
<ol start="4">
<li><strong>验收测试</strong><u>从最终用户的角度检查系统是否满足合同中定义的需求</u>，以及以确认产品是否能符合<u>业务上的需要</u>。</li>
</ol>
<p>时间：系统的有效性测试及软件配置审查通过之后。人员：以用户为主。软件开发人员和 QA（质量保证）人员也应参加<br>测试数据：实际生产数据。</p>
<p><em>主要形式</em>：<br>根据合同的验收测试——系统测试子集再测试<br>用户验收测试：分为客户和最终用户<br>现场测试：α测试、β测试</p>
<p><em>α测试</em>：是由公司内部的用户在 开发环境下进行的测试，模拟实际操作环境下进行的测试。<br>评价FLURPS特性（功能、本地化、可使用性、可靠性、性能和支持）。尤其界面和特色<br>开始时间：模块（子系统）测试完成后<u>系统测试过程中产品达到一定的稳定和可靠程度后</u>。</p>
<p><em>β测试</em>：多个用户在实际使用环境下进行测试。这些用户返回有关错误信息给开发者。<br>用户记录所有问题（真实的、主观的），定期向开发者报告。<br>评价 产品的FLURPS。着重产品的支持性（文档、客户培训和支持产品生产能力）<br>开始时间：α测试达到一定的可靠程度时开始，<u>测试的最后阶段，所有手册文本此阶段完全定稿</u></p>
<p><strong>回归测试</strong></p>
<p>指有选择地重新测试系统或其组件，以验证<u>对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。</u></p>
<p>Why：<br>测试中，如有<u>缺陷修正、功能增加，变化的部分</u>必须再测试。<u>软件的修改可能会导致新的缺陷及其他问题</u>。为防止，需再测试。</p>
<p>回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中。范围：</p>
<ul>
<li>缺陷再测试：重新运行所有发现故障的测试，而新的软件版本已经修正了这些故障。</li>
<li>功能改变的测试：测试所有修改或修正过的程序部分。</li>
<li>新功能测试：测试所有新集成的程序。</li>
<li>完全回归测试：测试整个系统。</li>
</ul>
<hr>
<p><strong>软件缺陷</strong></p>
<p>至少满足下列一个条件，称发生了一个软件缺陷</p>
<p>(1) 软件<u>未实现</u>产品说明书要求的功能。<br>(2) 软件出现了产品说明书指明不能出现的<u>错误</u>。<br>(3) 软件<u>实现了产品说明书未提到的功能。</u><br>(4) 软件未实现产品说明书<u>虽未明确提及但应该实现的目标。</u>（xswl）<br>(5) 软件难以理解、不易使用、运行缓慢或者——从测试员的角度看——最终用户会认为不好。</p>
<p><strong>验证</strong>（Verification）保证软件特定开发阶段的输出已经正确完整地实现了规格说明<br>（我们正确地构造了产品吗？）</p>
<p><strong>确认</strong>（Validation）对于每个测试级别，都要检查开发活动的输出是否满足具体的需求或与这些特定级别相关的需求<br>（我们构造了正确的产品吗？）</p>
<p><strong>测试</strong>（补救）<br><u>找出软件缺陷</u>，并确保缺陷得以修复</p>
<p><strong>质量保证</strong>（预防）<br>创建和执行改进、软件开发过程并<u>防止软件缺陷发生</u>的标准和方法。</p>
<p><strong>质量与可靠性</strong><br>功能性、可靠性、可维护性、可用性、效率、可移植性。</p>
<p><strong>软件测试</strong>：目标是发现软件缺陷的存在</p>
<p><strong>软件调试</strong>：目标是定位与修复缺陷</p>
<p><strong>测试用例</strong>（test case）：是<u>测试输入、执行条件、以及预期结果</u>的集合<br>是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合。<br>设计格式：【输入的(oldpwd, newpwd, newpwdag)，输出的(提示1,提示2)】</p>
<hr>
<p><strong>白盒测试</strong></p>
<p>考虑系统或组件的内部机制的测试形式（如分支测试、路径测试、语句测试等），也称结构性测试或逻辑驱动测试。</p>
<p><em>逻辑覆盖</em> 是以程序内部的逻辑结构为基础的设计测试用例的技术。</p>
<p><strong>每条边设置个英文字母，每条路径设置个$L_i$</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034787.png" alt="image-20220103094104162" style="zoom: 67%;" />

<ol>
<li><p>语句覆盖：就是设计若干个测试用例，运行被测程序，使得<u>每一可执行语句</u>至少执行一次。</p>
</li>
<li><p>分支覆盖/判定覆盖：使得程序中<u>每个判断的取真分支和取假分支</u>至少经历一次。</p>
</li>
<li><p>条件覆盖：使得程序中每个判断的<u>每个条件的可能取值</u>至少执行一次。只要每个可能都出现过就好，理论上最少2次就行。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034788.png" alt="image-20220105150214533" style="zoom:50%;" /></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034789.png" alt="image-20220103094444920" style="zoom:67%;" />

<ol start="4">
<li>条件组合覆盖：使得每个判断的所有可能的条件取值组合至少执行一次<br>一个判断里，可能有多个条件$T_1,T_2…T_n$,每个条件两种可能，组合起来就是$2^n$种。(还要做标记)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034790.png" alt="image-20220103094510612" style="zoom:67%;" />



<p><em>控制流图覆盖</em> 是将代码转变为控制流图（CFG），基于其进行测试的技术</p>
<p>结点：符号○ ，表示一个或多个无分支的PDL语句或源程序语句。<br>边：箭头，表示控制流的方向。<br>汇聚节点：在选择或多分支结构中，<strong>分支的汇聚处应有一个汇聚结点。这个不能漏，不然算复杂度会错</strong><br>区域：<u>边和结点圈定的区域</u>。对区域计数时，图形外的区域也应记为一个区域。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034791.png" alt="image-20211216144744301" style="zoom:67%;" align = 'left'/>

<ol>
<li><p>节点覆盖</p>
<p>对图中的每个节点，至少要有一条测试路径访问该节点显然，节点覆盖=语句覆盖<br>节点覆盖和<u>语句覆盖是等价的</u>。</p>
</li>
<li><p>边覆盖</p>
<p>对图中每一个可到达的长度小于(无边图)等于1 的路径，中至少存在一条测试路径覆盖。显然，边覆盖包含节点覆盖，且边覆盖也可以<u>实现分支覆盖</u>。</p>
</li>
<li><p>路径覆盖</p>
<p>覆盖程序中所有可能的路径，</p>
</li>
<li><p>基本路径覆盖</p>
<p>独立路径：至少包含有一条在其它独立路径中从未有过的边的路径</p>
<p>找独立路径条数：V(G)（环路复杂度） = e（边数）−n（结点数）+2</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034792.png" alt="image-20220103095027872" style="zoom:67%;" />

<p>开始的点被舍掉，连续的点，比如2，3和4，5被<u>合并到一个节点</u></p>
<p>找基本路径：每次<u>回溯</u>上一个节点，即从最后一个节点倒推，如果能走新的路就走新的路。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034793.png" alt="image-20220103095206100"></p>
</li>
</ol>
<hr>
<p><strong>黑盒技术</strong></p>
<p>黑盒测试：忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式</p>
<p><em>等价类划分</em>：</p>
<p>把所有可能的输入数据，即 程序的输入域划分成若干部分，然后从每一部分中 选取少数有代表性的数据做为测试用例。</p>
<p>等价类：某个输入域的子集合。在该子集合中，各个输入数据对于<u>揭露程序中的错误都是等效</u>的。</p>
<p>有效等价类：对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。</p>
<p>无效等价类：对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。</p>
<p>原则：</p>
<p>(1) 如果输入条件规定了取值<u>范围</u>，或值的个数（范围），则可以确立一个有效等价类和两个无效等价类。<br>(2) 如果输入条件规定了输入值的<u>集合</u>，或者是规定了“必须如何”的条件，这时可确立一个有效等价类和一个无效等价类。<br>(3) 如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。<br>(4) 如果规定了输入数据的一组值，而且程序要<u>对每个输入值分别进行处理</u>（不同于 2 ）。这时可为 每一个输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。<br>(5) 如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从<u>不同角度违反规则</u>）。（比如，输入条件：学生的学院字段数据类型，那有效等价类：字符串型；无效等价类：整数、浮点、布尔型）</p>
<p>【2和5相比，5只是规定了一项规则，2直接规定了整个集合】</p>
<p>步骤：</p>
<p>列出表【输入条件、有效等价类、无效等价类】为每个等价类规定一个唯一编号<br>测试用例尽可能多地覆盖尚未被覆盖的有效等价类，仅覆盖一个尚未被覆盖的无效等价类</p>
<blockquote>
<p>例：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034794.png" alt="image-20211216151109884" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034795.png" alt="image-20211216151123275" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034796.png" alt="image-20211216151144014" style="zoom:67%;" />
</blockquote>
<p><em>边界值分析</em></p>
<p>对等价类划分方法的补充，大量的错误是发生在输入或输出范围边界上</p>
<p>闭区间：选择边界点、边界点加一个步长的点和边界点减一个步长设计测试用例</p>
<p>开区间：选择边界点、边界点范围内方向移动一个步长的点计测试用例。</p>
<p><u>上点</u>，即边界上的点，不管是开区间还是闭区间。<br><u>内点</u>，上点范围内的任意一点。<br><u>离点</u>，离上点最近的点称为离点。<u>开区间为上点范围内</u>加一个步长，闭区间为<u>上点范围外</u>加一个步长。</p>
<p>比如[85,100]，离点就是 84，101      (0,60)，离点就是1，59，  [60,75) 离点 59,74</p>
<p>所以一元函数有5个测试用例。</p>
<p>二元函数：</p>
<p>先列出每一个变量的上点、内点和离点（5*2）。</p>
<p>用第一个变量的上点、离点与第二个变量的内点配对设计4个测试用例<br>用第一个变量的内点与第二个变量的上点、离点配对设计4个测试用例<br>最后两个变量的内点配对形成最后一个测试用例，共设计9个测试用例。</p>
<p>多元函数类似，都是某个变量的上点、离点配上别的元的内点，再加上一个都是内点，共$4n+1$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034797.png" alt="image-20220103102412117" style="zoom: 50%;" />

<p>黑盒还有一种<em>状态测试</em>。</p>
<p>在黑盒测试阶段，通过对状态的测试间接地加以验证功能</p>
<p>建立状态转换图-&gt;根据状态转换图设计测试用例。</p>
<p>灰盒测试：<br>介于白盒测试与黑盒测试之间的一种测试，多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况</p>
<p><strong>静态分析</strong></p>
<p><u>不运行程序</u>，通过检查和阅读等手段来发现错误并评估代码质量的测试技术</p>
<p>主要内容：检查<u>需求、设计、代码</u>（缺陷产生的可能由大到小）</p>
<p>类型：同事审查（初次）、走查（开发组内部进行）、审查（会议形式，开发组、测试组和相关人员联合进行）</p>
<h2 id="项目管理（2）"><a href="#项目管理（2）" class="headerlink" title="项目管理（2）"></a>项目管理（2）</h2><p><em>项目管理</em>：计划、协调、度量、监控、控制及报告等管理方法<u>在软件开发和维护中的具体应用</u><br>以保证整个过程是系统的、有原则的、可量化的</p>
<p><strong>四要素</strong>：人员(People)、产品(Product)、过程(Process)、项目(Project)。</p>
<p>关键业务领域：招聘、选拔、绩效管理、培训、薪酬、职业发展、组织和工作设计、团队/文化的发展。</p>
<p>在策划一个项目以前，应当建立产品的<u>目标和范围</u>，应考虑其他解决办法，以及技术和管理应当被约束。</p>
<p>软件开发的一个全面计划</p>
<p>理解成功项目管理的关键因素，掌握项目计划、监控和控制的一般方法</p>
<p><strong>软件度量</strong>：</p>
<p>一种量化衡量方法,使得人们可以理解和把握软件项目的(生产)效率(或者所需要的劳动量)</p>
<p>目的：软件项目管理的成熟化也需要<u>度量与数字化</u>，目的是<u>持续改进软件过程，并用于项目估算、质量控制、生产率评估</u>等</p>
<p><em>面向规模</em>【直接测量】：</p>
<p>通过<u>对质量和（或）生产率的测量进行规范化</u>而得到的，这些测量是根据开发过的软件的规模得到的。</p>
<ul>
<li> 千行代码（ KLOC ）： 这些代码指的是源代码，通过源代码的行数来直观度量一个软件程序有多大规模</li>
<li>生产率（PM）：PM = L / E, L表示<u>代码总量</u>(单位：KLOC)，E表示<u>软件工作量</u>(单位：人月)</li>
<li> 每千行代码的平均成本（ CKL ）：CKL = S / L，S为软件项目总开销 </li>
<li>代码出错率（EQRl）：EQRl = Ne / L，Ne表示代码出错的行数</li>
<li>文档与代码比（Dl）：Dl = Pd / L，Pd表示文档页数</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034798.png" alt="image-20211217100450012" style="zoom:67%;" />

<p>简单易行，自然直观；但 软件开发初期很难估算出最终软件的代码行数，对短小精悍的程序不利</p>
<p><em>面向功能</em>【间接测量】</p>
<p>功能点（Function Point, FP）法，项目开发<u>初期就可估算出</u></p>
<p>方法：先算未调整功能点总计数 UFC，再算功能点 FP</p>
<p>$FP = UFC×TCF = UFC × (0.65 + 0.01×\sum F_i)$</p>
<p>UFC相关的五类组件：内部逻辑文件ILF、外部接口文件EIF、外部输入EI、外部输出EO、外部查询EQ。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034799.png" alt="image-20211217101343777" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034801.png" alt="image-20211217101407856" style="zoom:50%;" /></p>
<p>至于14个复杂性调节因素 $F_i$从0【没有影响】到5【严重影响】</p>
<p>优点：与程序设计语言无关, 在开发前就可以估算出软件项目的规模</p>
<p>不足：没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统，功能点计算主要靠经验公式，主观因素比较多</p>
<p>FP起到了代码行的作用，但是也可以换算，估计不考👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034802.png" alt="image-20220102162809429" style="zoom:50%;" />



<p><strong>项目估算</strong></p>
<p>分两种</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034803.png" alt="image-20220102162431806" style="zoom:50%;" />

<p><em>基于问题分解的估算</em></p>
<p>就是把问题分解成各个子系统，分别估算，最后合并。</p>
<p>三点期望法：估计期望值=(最大值＋4×最可能值＋最小值) / 6</p>
<p>基于LOC的估算：估算出各个子系统的代码行（直接主观猜）</p>
<p>用LOC或FP算出LOC总代码行或FP功能点数，然后结合历史数据</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034804.png" alt="image-20220102163248576" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034805.png" alt="image-20220102163345120" style="zoom:50%;" />





<p><em>基于回归分析的经验估算模型</em></p>
<p>$E=A+B×(e_v )^ C$ 其中E是工作量（人月），$e_v$是估算变量（LOC或功能点）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034806.png" alt="image-20211217135256729" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034807.png" alt="image-20211217135311450" style="zoom:67%;" /></p>
<p><strong>COCOMO经验估算模型</strong>（COnstructive COst MOdel，构造性成本模型）</p>
<p>是一个综合经验模型，模型中的参数取值来自于<u>经验值，并且综合了诸多的因素、比较全面的估算模型</u></p>
<p><u>用来根据KLOC算工作量和开发时间</u></p>
<p>模型层级</p>
<ul>
<li>基本COCOMO模型：估算整个系统的工作量(包括维护)和软件开发和维护所需的时间</li>
<li>中间COCOMO模型：估算各个子系统的工作量和开发时间</li>
<li>详细COCOMO模型：估算独立的软构件，如各个子系统的各个模块的工作量和开发时间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034808.png" alt="image-20211217135834159" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034809.png" alt="image-20220102163524699" style="zoom:50%;" /></p>
<p>EAF的取值(考虑15个因素) 建议取值范围[0.70-1.66] EAF的计算＝$\prod F_i  ( i=1..15)$</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034810.png" alt="image-20220102163925277" style="zoom:50%;" />





<p><strong>项目计划</strong></p>
<p>对项目进行任务划分，定义任务之间的<u>依赖关系</u>，并进行<u>时间估算和资源分配</u>，确保以最佳的时间与成本输出满足质量要求的产品。</p>
<p>编制项目计划本质是一个<u>优化问题</u>。</p>
<p>项目计划可视化用甘特图</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034811.png" alt="image-20211217140902607" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034812.png" alt="image-20211217140924890" style="zoom:67%;" />

<p>关键路径——在任务网络图中，从项目开始到项目完成有许多条路径，路径上<u>所有弧权重之和最大的路径</u>（路径最长）叫关键路径。</p>
<h2 id="软件维护（2）"><a href="#软件维护（2）" class="headerlink" title="软件维护（2）"></a>软件维护（2）</h2><p>定义：由于软件产品出现问题或需要改进，而对代码及相关文档进行修改，</p>
<p>目的：对现有软件产品进行修改的同时保持其完整性</p>
<p>软件维护阶段一般要消耗软件生命周期中经费开支的大部分</p>
<p><strong>四种基本类型</strong>：</p>
<p>完善性维护【一半以上】扩充软件功能、增强软件性能、 改进加工效率、 提高软件的可维护性<br>纠错性维护<br>适应性维护（环境变化）<br>预防性维护【最少】采用先进的软件工程方法对需要维护的软件或软件中的 某一部分（重新）进行设计、编制和测试</p>
<p>决定软件<u>可维护性</u>的主要因素：可理解性、可测试性、可修改性、可移植性、可重用性</p>
<p>影响软件可维护性的<u>环境因素</u>——软件维护的文档、软件的运行环境、软件的维护组织、软件维护质量。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034813.png" alt="image-20211217141553964" style="zoom:67%;" />

<p><strong>软件维护技术</strong></p>
<p>程序的理解：建立从问题/应用域到程序设计/实现域的映射集</p>
<p>程序理解的具体任务：</p>
<p>通过检查单个的程序设计结构，程序被表示成抽象语法树、符号表或普通源文本<br>尽量做到程序隐含信息的显性表示及程序内部关系的可视化<br>检查程序构造过程中的结构关系，明确表示程序组成部分之间的依赖关系。</p>
<p><em>软件再工程</em>：<br>对现有软件进行仔细审查和改造，对其<u>进行重新构造</u>，使之成为一个新的形式，同时包括随之产生的对新形式的实现。</p>
<p><em>软件逆向工程</em>：<br><u>分析目标系统，识别系统的构件及其交互关系</u>，并且通过高层抽象或其他形式来展现目标系统的过程。</p>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034814.png" alt="image-20211217141846309" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205101034815.png" alt="image-20220103111000545" style="zoom:50%;" />
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>The Book Of Why</title>
    <url>/2022/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<blockquote>
<p>在开始前：</p>
<p>我在大二上学习概率论时，我曾经对事件的独立性的描述感到奇怪，书上仅描述了事件组之间相互独立的性质上的结论，却没有式子来刻画更本质的因果和独立性的传递，还追问了老师很久，最好不了了之，没有发现因果科学。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111037508.png" alt="image-20220511103728428" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111037136.png" alt="image-20220511103754059" style="zoom: 33%;" /></p>
<p>没想到，阴差阳错下有机会学习因果科学，弥补心中的遗憾。笔者认为，这是一门直指世界本质的，值得一学的伟大科学。</p>
</blockquote>
<h1 id="为什么——因果科学"><a href="#为什么——因果科学" class="headerlink" title="为什么——因果科学"></a>为什么——因果科学</h1><h2 id="0-思维胜于数据"><a href="#0-思维胜于数据" class="headerlink" title="0. 思维胜于数据"></a>0. 思维胜于数据</h2><p>对于没有概率统计基础的读者来说，笔者的阅读建议是略过数学细节，着重抓住内容大意；</p>
<p>而对于有一定概率统计基础的读者来说，笔者认为在阅读时<u>一定不能放过正文中的数学精髓</u>，这本书中的数学公式不多不少，刚好自圆其说。</p>
<p><strong>本书目标</strong>：</p>
<p>首先，用非数学的语言阐述因果革命的知识内涵，说明它将怎样影响我们的生活和未来。</p>
<p>其次，分享在解决重要的因果问题时，我们的科学家前辈走过的英勇征程，无论成败，这些故事都值得讲述。</p>
<p>最后，回溯因果革命在人工智能领域的发源地，目的是向你介绍如何开发出用我们的母语——因果语言进行交流的机器人。新一代机器人应该能够向我们解释事情为何发生，为何机器人以它们选择的某种方式做出反应，以及大自然为何以这样而非那样的方式运作。一个更加雄心勃勃的目标是，它们也应该能够让我们进一步认识人类自身：我们的思维为什么以这样的方式运行，以及理性思考原因和结果、信任和遗憾、目的和责任究竟意味着什么。</p>
<p><strong>what is 因果推断</strong>：</p>
<p>它假设人类大脑是大自然有史以来为处理因果知识而设计出的最先进的工具。我们的大脑存储了海量的因果知识，而在数据的辅助下，我们可以利用这些知识解决当代社会所面临的最紧迫的问题。一个更宏伟的目标是，一旦我们真正理解了因果思维背后的逻辑，我们就可以在现代计算机上模拟它，进而创造出一个“人工科学家”。这个智能机器人将会为我们发现未知的现象，解开悬而未决的科学之谜，设计新的实验，并不断从环境中提取更多的因果知识。</p>
<p>这门新科学催生出了<u>一种简单的数学语言，用以表达我们已知和欲知的因果关系</u>。以数学形式表达因果关系的能力让我们得以开发出许多强大的、条理化的方法，将我们的知识与数据结合起来，并最终回答出如上述那5个涉及因果关系的问题。</p>
<p><strong>why too late</strong>：</p>
<p>在我看来，阻碍因果推断这一科学诞生的最大障碍，是我们用以提出因果问题的词汇和我们用以交流科学理论的传统词汇之间的鸿沟。</p>
<p>科学工具的开发是为了满足科学需要。</p>
<p>随着人类求知欲的不断增强，以及社会现实开始要求人们讨论在复杂的法律、商业、医疗等领域的决策情境中出现的因果问题，我们终于发现我们缺少一门成熟的科学所应提供的用于回答这些问题的工具和原理。</p>
<blockquote>
<p>具有讽刺意味的是，对因果关系理论的需求正是在统计学产生的那一刻浮出水面的。事实上，现代统计学的创立正源自因果问题——高尔顿和皮尔逊提出了一个关于遗传的因果问题，并独具匠心地尝试用跨代数据来解答它。遗憾的是，这一努力失败了，他们没有停下来问为什么，反而声称这些问题是禁区，转而去发展另一项刚刚兴起、不涉及因果关系的事业——统计学。</p>
<p>这是科学史上的一个关键时刻。给因果问题配备一套专属语言的机会眼看就要被成功捕捉并转化为现实，却被白白浪费掉了。在接下来的几年里，这些问题被宣布为“非科学”，被迫转入地下。尽管遗传学家休厄尔·赖特（1889—1988）为此做出了艰苦卓绝的努力，但因果词汇仍然被科学界禁用了半个多世纪。我们知道，禁止言论就意味着禁止了思想，同时也扼杀了与此相关的原则、方法和工具。</p>
</blockquote>
<p>统计学盲目迷恋这种常识性的观察结论。它告诉我们，相关关系不等于因果关系，但并没有告诉我们因果关系是什么。在统计学教科书的索引里查找“因果”这个词是徒劳的。统计学不允许学生们说X是Y的原因[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0005.xhtml#note2n">2]</a>，只允许他们说X与Y“相关”或“存在关联”。</p>
<p>这一禁律也潜移默化地让人们认同了处理因果问题的数学工具毫无用武之地这一结论，与此同时，统计学唯一关注的就是如何总结数据，而不关注如何解释数据。</p>
<hr>
<p><strong>【纯粹数据driven的局限】</strong></p>
<p>统计学的其他分支，以及那些依赖统计学工具的学科仍然停留在禁令时代，<u>错误地相信所有科学问题的答案都藏于数据之中，有待巧妙的数据挖掘手段将其揭示出来。</u></p>
<p>今天，这种以数据为中心的观念仍然阴魂不散。我们生活在一个相信大数据能够解决所有问题的时代。大学中“数据科学”方面的课程激增，在涉足“数据经济”的公司中，“数据科学家”享有极高的工作待遇。然而，我希望本书最终能说服你相信这一点：数据远非万能。数据可以告诉你服药的病人比不服药的病人康复得更快，却不能告诉你原因何在。也许，那些服药的人选择吃这种药只是因为他们支付得起，即使不服用这种药，他们照样能恢复得这么快。</p>
<p>在科学和商业领域，仅凭数据不足以解决问题的情况一再发生。尽管或多或少地意识到了其局限所在，但多数热衷于大数据的人仍然选择盲目地继续追捧以数据为中心的问题解决方式，仿佛我们仍活在因果禁令时代。</p>
<blockquote>
<p>在20年前，询问一个统计学家诸如“是阿司匹林治愈了我的头痛吗”这样的问题还会被视为在问他是否相信巫术。引用我的一位备受尊敬的同事的话，讨论这种问题“与其说是科学探索，不如说是鸡尾酒会上的八卦闲谈”。但今天，流行病学家、社会学家、计算机科学家以及一些开明的经济学家和统计学家开始频繁地提出这样的问题，并能够借助具有高度精确性的数学工具作答。对我来说，这种改变就是一场革命。</p>
</blockquote>
<p>（感觉因果科学是对现有相关框架的弥补，而不是对数据驱动的否定）</p>
<hr>
<p><strong>数学工具</strong></p>
<p>它背后有数学工具上的发展作为支撑，这种数学工具最恰当的名称应该是“因果关系演算法”</p>
<p>因果关系演算法由两种语言组成：其一为<strong>因果图（causal diagrams）</strong>，用以表达我们已知的事物，其二为<u>类似代数的符号语言</u>，用以表达我们想知道的事物。因果图是由简单的点和箭头组成的图，它们能被用于概括现有的某些科学知识。点代表了目标量，我们称之为“变量”，箭头代表这些变量之间已知或疑似存在的因果关系，即哪个变量“听从于”哪个变量。</p>
<p>有些科学家（比如计量经济学家）喜欢使用数学方程；另一些研究者（比如纯统计学家）则更倾向于借助一组假设来描述问题，这些假设表象化地概括了因果图的关系结构。不管使用哪种语言，因果模型都应该描述，哪怕是定性地<u>描述数据的生成过程</u>，换句话说，就是那些<u>在环境中控制并塑造数据生成的因果力量。</u></p>
<p>与图表式的“知识语言”并存的还有一种<strong>符号式的“问题语言”</strong>，它被用于表述我们想要回答的问题。do算子表明了我们正在进行主动干预而非被动观察，这一概念是经典统计学不可能涉及的。</p>
<blockquote>
<p><em>An example</em></p>
<p>干预算子do（D）来确保观察到的病人存活期L的变化能完全归因于药物本身，而没有混杂其他影响寿命长短的因素。如果我们不进行干预，而是让病人自己决定是否服用该药物，那么<u>其他因素就可能会影响病人的决定</u>，而服药和未服药的两组病人的存活期差异也将无法再被仅仅归因于药物。</p>
<p>假设只有疾病发展到末期的病人服用了这种药，那么这些人的情况就显然不同于那些不服药的病人，两组的比较结果实际上反映的是其病情的严重程度，而非药物的影响。<br>相比之下，随机地指示一些病人服用药物或不服用药物，而不考虑先决条件如何，则可以去除两组病人之间原有的差异，提供有效的比较结果。</p>
</blockquote>
<p>注意P（L|D）与P（L|do（D））完全不同。观察到（seeing）和进行干预（doing）有本质的区别，它解释了我们不认为气压计读数下降是风暴来临的原因。<br>观察到气压计读数下降意味着风暴来临的概率增加了，但人为迫使气压计读数下降对风暴来临的概率并不会产生影响。</p>
<p><u>对观察和干预的混淆成为悖论之源</u>，对此本书将展开详细的讨论。缺少P（L|do（D）），而完全由P（L|D）统治的世界将是十分荒诞的。在这个世界中，病人不去就诊就能减少人们患重病的概率，城市解雇消防员就能减少火灾的发生</p>
<p><strong>因果革命最重要的成果之一就是解释了如何在不实际实施干预的情况下预测干预的效果。</strong></p>
<p><strong>反事实（counterfactual）</strong></p>
<p>经典统计学只关注总结数据，因此它甚至无法提供一种语言让我们提出上面那个问题。因果推断则不仅提供了一种表达符号，更重要的是，它还提供了一种解决方案。这使得我们在预测干预效果时，在多数情况下能够借助一种算法来模拟人类的反思性思考，通过将我们<u>对观测世界的了解输入算法系统</u>，其将输出有关<u>反事实世界的答案</u>。</p>
<p>反事实并非异想天开之物，而是反映了现实世界运行模式的特有结构。共享同一因果模型的两个人也将共享所有的反事实判断。</p>
<p>反事实是道德行为和科学思想的基石。回溯自己过去的行为以及设想其他可能情景的能力是自由意志和社会责任的基础。反事实的算法化使“思维机器”（thinking machine）习得这种人类特有的能力，并掌握这种目前仍为人类所独有的思考世界的方式成为可能。</p>
<blockquote>
<p>20世纪80年代末，我意识到智能机器缺乏对因果关系的理解，这也许是妨碍它们发展出相当于人类水平的智能的最大障碍。我坚信强人工智能是一个可实现的目标，也是一个完全无须恐惧的目标，因为我们在实现它的过程中纳入了因果关系。因果推理模块将使智能机器有能力反思它们的错误，找到自身软件程序中的弱点，并能像一个道德实体那样思考和行动，自然地与人类交流它们自己的选择和意图。</p>
</blockquote>
<p><strong>因果模型</strong></p>
<p>因果模型将科学、知识、数据这些晦涩的概念纳入了一个具体的、有意义的背景框架，让我们得以看到三者是如何相互协作以解答棘手的科学问题的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111009358.png" alt="image-20220511100924246"></p>
<p>因果推断引擎是一种问题处理机器，它接收三种不同的输入——假设、问题和数据，并能够产生三种输出。能够将数据与因果知识相结合生成目标问题的答案。(虚线框不是引擎的组成部分，但它是构建引擎的<u>必要基础</u>。箭头也可以从方框4和方框9指向方框1，也即是把答案添加到已有的知识中去)</p>
<p>第一种输出是“是/否”判断，用于判定<u>在现有的因果模型下，假设我们拥有完美的、无限的数据</u>，那么给定的问题在理论上是否有解。</p>
<p>如果答案为“是”，则接下来推断引擎会生成一个被估量。这是一个数学公式，可以被理解为一种能<u>从任何假设数据中生成答案的方法</u>，只要这些数据是可获取的。</p>
<p>最后，在推断引擎接收到数据输入后，它将用上述方法生成一个问题答案的实际估计值，并给出对该估计值的不确定性大小的统计估计。这种不确定性反映了样本数据集的代表性以及可能存在的测量误差或数据缺失。</p>
<blockquote>
<p>1.“知识”指的是推理主体（reasoning agent）过去的经验，包括过去的观察、以往的行为、接受过的教育和文化习俗等所有被认为与目标问题有关的内容。“知识”周围的虚线框表示它仍隐藏在推理主体的思想中，<u>尚未在模型中得到正式表达</u>!</p>
<p>2.研究者所拥有的大部分知识都隐藏于他的大脑，只有假设能将其公之于世，也只有假设才能被嵌入模型。</p>
<p>4.以因果模型的路径来表示的变量之间的听从模式通常会导向<u>数据中某种显而易见的<em>模式或相关关系</em></u>。这些模式可被用于测试模型，因此也被称为“<u>可验证的蕴涵”（testable implications）</u>。将“D和L之间没有连接路径”翻译成统计学语言，就是“D和L相互独立”，也就是说，发现D的存在不会改变L发生的可能性。而如果实际数据与这一推断相抵触，那么我们就需要修改模型。此类修改涉及另一个引擎，它从方框4和方框7中获取输入，并计算模型的“拟合度”，即数据与模型假设的匹配程度。为尽可能简化示意图起见，我没有在图0.1中表示出这个引擎。</p>
<blockquote>
<p>在命题逻辑和谓词逻辑中，蕴涵这一概念用于描述两个陈述语句集合之间的联系(离散那个概念)</p>
</blockquote>
<p>5.向推理引擎提交的问题就是我们希望获得解答的科学问题，这一问题必须用因果词汇来表述。例如，我们现在感兴趣的问题是：P（L|do（D））是什么？因果革命的主要成就之一就是确保了这一语言在科学上容易理解，同时在数学上精确严谨。</p>
<p>6.被估量“estimand”来自拉丁语，意思是“需要估计的东西”。它是我们<u>从数据中估算出来的统计量</u>。一旦这个量被估算出来，我们便可以用它来合理地表示问题的答案。虽然被估量的表现形式是一个概率公式，如P（L|D，Z）×P（Z），但<u>实际上它是一种<em>方法</em>，可以让我们根据我们所掌握的数据类型回答因果问题</u>（前提是推断引擎证实了这种数据类型就是我们需要的）</p>
<p>与传统的统计学所提供的估计方法不同，在当前的因果模型下，无论我们收集到多少数据，<u>有些问题可能仍然无法得到解答</u>。例如，如果我们的模型显示D和L都依赖于第三变量Z（比如疾病的发展阶段），并且，如果我们没有任何方法可以测量Z的值，那么问题P（L|do（D））就无法得到解答。在这种情况下，<u>收集数据完全就是浪费时间。相反，我们需要做的是回过头完善模型</u>，具体方式则是<em>输入新的科学知识</em>，使我们可以估计Z的值，或者<em>简化假设</em>（注意，此处存在犯错的风险），例如假设Z对D的影响是可以忽略不计的。</p>
<p>:star: 7.一定要认识到，<u>数据本身不具备表述因果关系的能力。</u>数据告诉我们的只是数量信息，如P（L|D）或P（L|D，Z）的值。<u>而被估量则能够告诉我们如何将这些统计量转化为一个表达式。</u>基于模型假设，该表达式<u>在逻辑上等价于我们所要回答的因果问题</u>，比说P（L|do（D））。【牛】</p>
<p>被估量这个概念以及图0.1顶部的所有概念在统计分析的传统方法中都是不存在的。在传统的统计方法中，被估量就等同于有待解决的问题。</p>
<p>8.你已经得到了一个新鲜出炉的估计值。不过，它只是一个近似值，其原因涉及关于数据的另一个真相：数据永远是从<u>理论上无限的总体中抽取的有限样本。</u>即使这种筛选是随机的，我们也无法避免根据样本测量的概率无法代表整个总体的相应概率的可能性。幸运的是，依靠机器学习领域所提供的先进技术，统计学科为我们提供了很多方法来应对这种不确定性，这些方法包括<u>最大似然估计、倾向评分、置信区间、显著性检验</u>等</p>
</blockquote>
<p>请注意，我们是在完成了以下步骤之后才收集的数据：根据假设确定了因果模型，提出了我们想要解决的科学问题，推导出被估量。这与上面提到的传统统计方法形成了鲜明对比，后者甚至没有用到因果模型。</p>
<p>【许多人工智能领域的研究者仍然想跳过构建因果模型或识别出已有的因果模型这一难度较大的步骤，只依赖数据解决所有的认知难题。他们希望在因果问题出现时，数据本身就能指引他们找到正确的答案】</p>
<p>但对于因果关系方面的知识来说，数据没有任何发言权。例如，有关行动或干预结果的信息根本无法从原始数据中获得，这些信息只能从对照试验操作中收集。</p>
<p>因果模型所具备而数据挖掘和深度学习所缺乏的另一个优势就是<strong>适应性</strong>。注意在图0.1中，被估量是在我们<u>真正检查数据的特性之前仅仅根据因果模型计算出来的</u>，这就使得因果推断引擎适应性极强，因为无论变量之间的数值关系如何，被估量都能适用于与定性模型适配的数据。</p>
<blockquote>
<p>通过观察许多服用药物D的患者的存活期L，某研究者能够预测出某个具有Z特征的病人存活L年的概率。现在，假设她被调职到位于城市另一地区的医院，而那里的人口总体特征（饮食、卫生、工作习惯）与原来的地区有所不同。即使这些新特性仅仅改变了以前她所记录的变量之间的数值关系，她仍不得不重新自我训练，再次从头学习新的预测函数。这就是深度学习程序所能做的：将函数与数据拟合。而如果该研究者掌握了药物的作用机制，并且新地区的因果模型结构仍与原来保持一致，那么她在以往的训练中获得的被估量就依然有效，可被应用于新数据，产生一个新的关于特定总体的预测函数。</p>
</blockquote>
<p>贝叶斯网络是让计算机得以在“灰色地带”进行思考的第一个工具，有段时期，我曾坚信它掌握着开启人工智能大门的钥匙。而到了20世纪80年代末，我终于确信自己错了，本章讲述的正是我从贝叶斯倡导者变身为“叛教者”的整段旅程。不过，<u>贝叶斯网络仍然是人工智能领域的一个非常重要的工具，其涵盖了因果图的大部分数学基础。</u></p>
<p>这些悖论是一种警示，用以提醒科学家们人类的直觉是根植于因果的，而不是根植于统计和逻辑的。</p>
<p>如果能用一句话来概括本书的内容，那就是“<u>你比你的数据更聪明”。数据不了解因果，而人类了解</u>。我希望因果推断这门新科学能让我们更好地理解我们是如何做到这件事的，因为除了自我模拟，我们没有更好的方法来了解人类自身了。与此同时，在计算机时代，这种新的理解也有望被应用于增强人类自身的因果直觉，从而让我们更好地读懂数据，无论是大数据还是小数据。</p>
<h2 id="1-因果关系之梯"><a href="#1-因果关系之梯" class="headerlink" title="1. 因果关系之梯"></a>1. 因果关系之梯</h2><ul>
<li>首先，人类在进化早期就意识到世界并非由枯燥的事实（我们今天可能称之为数据）堆砌而成；相反，这些<u>事实是通过错综复杂的因果关系网络融合在一起</u>的。</li>
<li>其次，<u>因果解释而非枯燥的事实构成了我们大部分的知识，它应该成为机器智能的基石</u>！！</li>
<li>最后，我们从数据处理者向因果解释者的过渡不是渐进的，而是一次“大跃进”，借助的是某种奇异的外部推力。这与我在因果关系之梯上的理论观察完全吻合：没有哪台机器可以从原始数据中获得解释。对数据的解释需要借助外部推力。</li>
</ul>
<p><strong>因果关系的三个层级</strong></p>
<p>可能大家会觉得，我们将关于这个世界的知识组织起来融入因果关系网络的能力是一种一体化的能力，是可以一下子学会或领悟的。</p>
<p>事实上，我在机器学习方面的研究经历告诉我，因果关系的学习者必须熟练掌握至少三种不同层级的认知能力：<br><em>观察能力（seeing）、行动能力（doing）和想象能力（imagining）。</em></p>
<p>第一层级是观察能力，具体而言是指发现环境中的规律的能力。在认知革命发生之前，这种能力为许多动物和早期人类所共有。</p>
<p>第二层级是行动能力，涉及<u>预测对环境进行刻意改变后的结果，并根据预测结果选择行为方案以催生出自己期待的结果</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205111138036.png" alt="image-20220511113834921" style="zoom:67%;" />

<p>处于第一层级的是<strong>关联</strong>，在这个层级中我们通过观察寻找规律。如果观察到某一事件改变了观察到另一事件的可能性，我们便说这一事件与另一事件相关联。因果关系之梯的第一层级要求我们基于被动观察做出预测。其典型问题是：“如果我观察到……会怎样？”<br>统计学本身并不能告诉我们，牙膏或牙线哪个是因，哪个是果。好的预测无须好的解释，</p>
<blockquote>
<p>强人工智能这一目标是制造出拥有类人智能的机器，让它们能与人类交流并指导人类的探索方向。而深度学习只是让机器具备了高超的能力，而非智能。这种差异是巨大的，原因就在于后者缺少现实模型</p>
</blockquote>
<p>当我们开始改变世界的时候，我们就迈上了因果关系之梯的更高一层台阶。这一层级的一个典型问题是：“如果我们把牙膏的价格翻倍，牙线的销售额将会怎么样？”这类问题处于因果关系之梯的第二层级，提出及回答这类问题要求我们掌握一种脱离于数据的新知识，即<strong>干预</strong>。</p>
<blockquote>
<p>无论数据集有多大或者神经网络有多深，只要使用的是被动收集的数据，我们就无法回答有关干预的问题。从统计学中学到的任何方法都不足以让我们明确表述类似“如果价格翻倍将会发生什么”这样简单的问题，更别说回答它们了。</p>
<p>为什么不直接进入存有历史购买信息的庞大数据库，看看在牙膏价格翻倍的情况下实际发生了什么呢？原因在于，在以往的情况中，涨价可能出于完全不同的原因，例如产品供不应求，其他商店也不得不涨价等。但现在，我们<u>并不关注行情如何，只想通过刻意干预为牙膏设定新价格</u>，因而其带来的结果就可能与此前顾客在别处买不到便宜牙膏时的购买行为大相径庭。如果你有历史行情数据，也许你可以做出更好的预测……但是，你知道你需要什么样的数据吗？你准备如何理清数据中的各种关系？这些正是因果推断科学能帮助我们回答的问题。</p>
<p>:star: 一个足够强大的、准确的<em>因果模型</em>可以让我们<u>利用第一层级（关联）的数据来回答第二层级（干预）的问题</u>。没有因果模型，我们就不能从第一层级登上第二层级。这就是深度学习系统（只要它们只使用了第一层级的数据而没有利用因果模型）永远无法回答干预问题的原因，干预行动据其本意就是要打破机器训练的环境规则。</p>
</blockquote>
<p>因果关系之梯第二层级的典型问题就是：“如果我们实施……行动，将会怎样？”也即，如果我们改变环境会发生什么？第二层级中的另一个热门问题是：“怎么做？”</p>
<p><strong>反事实</strong>与数据之间存在着一种特别棘手的关系，因为数据顾名思义就是事实。数据无法告诉我们在反事实或虚构的世界里会发生什么，在反事实世界里，观察到的事实被直截了当地否定了。然而，人类的思维却能可靠地、重复地进行这种寻求背后解释的推断。</p>
<blockquote>
<p>你可能会怀疑，对于“假如”（would haves）这种并不存在的世界和并未发生的事情，科学能否给出有效的陈述。科学确实能这么做，而且一直就是这么做的。举个例子，“在弹性限度内，假如加在这根弹簧上的砝码重量是原来的两倍，弹簧伸长的长度也会加倍”（胡克定律），像这样的<u>物理定律就可以被看作反事实断言</u>。当然，这一断言是从诸多研究者在数千个不同场合对数百根弹簧进行的实验中推导出来的，得到了大量试验性（第二层级）证据的支持。然而，一旦被奉为“定律”，物理学家就把它解释为一种函数关系，自此，这种函数关系就在假设中的砝码重量值下支配着某根特定的弹簧。所有这些不同的世界，其中砝码重量是x磅[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0006.xhtml#note1n">1]</a>，弹簧长度是Lx英寸[<a href="ms-local-stream://13849dognet.myepubreader_7b45413543354545392d433044452d344633462d423232362d4343394538393534344337467d/OEBPS/Text/part0006.xhtml#note2n">2]</a>，都被视为客观可知且同时有效的，哪怕它们之中只有一个是真实存在的世界。</p>
</blockquote>
<p>假如当时发生的事情与实际不同，那会怎样？”对这个问题的回答让我们得以从历史和他人的经验中获取经验教训，这是其他物种无法做到的。</p>
<p>:star: 如果第一层级对应的是观察到的世界，第二层级对应的是一个可被观察的美好新世界，那么第三层级对应的就是一个无法被观察的世界（因为它与我们观察到的世界截然相反）</p>
<p><strong>迷你图灵测试</strong></p>
<p>在创造出具备孩童智能水平的机器人之前，我们可能的确无法成功创造出类人智能，而创造出前者的关键要素就是掌握因果关系。</p>
<p>机器如何才能获得关于因果关系的知识呢？目前，这仍然是一项重大挑战，其中无疑会涉及复杂的输入组合。这些输入来自<u>主动实验、被动观察和（最关键的）程序员输入</u>，这与儿童所接收的信息输入非常相似，他们的输入分别来自进化、父母和他们的同龄人（对应于程序员这个角色）</p>
<p>为“迷你图灵测试”，其主要思路是选择一个简单的故事，用某种方式将其编码并输入机器，测试机器能否正确回答人类能够回答的与之相关的因果问题。之所以称其为“迷你”，原因有二。首先，该测试<u>仅限于考察机器的因果推理能力，而不涉及人类认知能力的其他方面</u>，如视觉和自然语言。其次，我们允许参赛者以任何他们认为便捷的表示方法对故事进行编码，这就免除了机器必须依据其自身经验构造故事的任务。让智能机器通过这个迷你测试是我毕生的事业——在过去的25年里是自觉而为，在那之前则是无意而为。</p>
<p>在让机器进行迷你图灵测试的准备阶段，表示问题必须优先于获取问题。如果缺少表示方法，我们就不知道如何存储信息以供将来使用。人工智能对认知研究的一个主要贡献就是确立“<u>表示第一，获取第二</u>”的范式。通常，在寻求一个好的表示方法的过程中，关于如何获取知识的洞见就会自然产生，无论这种洞见是来自数据，还是来自程序员。</p>
<p>作弊是困难的，假设我们有10个因果变量，每个变量只取两个值（0或1），那么我们可以提出大约3000万个关于这些变量的可能问题<br>人类的大脑肯定拥有某种<u>简洁的信息表示方式</u>，同时还拥有某种<u>十分有效的程序</u>用以正确解释每个问题，并从存储的信息表示中提取正确答案。因此，为了通过迷你图灵测试，我们需要给机器装备同样高效的表示信息和提取答案的算法。</p>
<p>这种表示不仅存在，而且具有孩童思维般的简洁性，它就是<strong>因果图</strong>。如果我们希望计算机能理解因果关系，我们就必须教会它如何打破规则，让它懂得<u>“观察到某事件”和“使某事件发生”</u>之间的区别。“无论何时，如果你想使某事发生，那就删除指向该事的所有箭头，之后继续根据逻辑规则进行分析..(中间)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112002381.png" alt="image-20220511200237236"><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112005792.png" alt="image-20220511200246400" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112005168.png"/></p>
<p>使某事发生就意味着将它从所有其他影响因子中解放出来，并使它受限于唯一的影响因子——能强制其发生的那个因子。</p>
<p>假如A决定不开枪，犯人是否还活着？在虚构世界中，A没有射击，指向A的箭头被去除，这进而又解除了A与C的听命关系。现在，我们将A的值设置为假，并让A行动之前的所有其他变量的水平与现实世界保持一致。（右图）</p>
<hr>
<p>在许多情境中，人类可能需要花费很大的努力才能找到那个正确的因果结论。定量的因果推理通常超出了我们的直觉范畴。此外，为了处理不确定因素，我们就需要掌握有关异常事件发生可能性的信息。【引入概率】</p>
<p>从计算的角度来看，我们设计出的这种让机器通过迷你图灵测试的方案也很出色。在所有三个例子中，我们都使用了相同的程序：<br><u>将故事转化成因果图，解读问题，执行与既定问题（干预问题或反事实问题）相对应的“手术”（如果问题是关联类的，则不需要进行任何“手术”），并使用修改后的因果模型计算答案。</u><br>并且，每次改变故事的时候，我们也不必根据各种新的问题重新训练机器。这一方法具有足够的灵活性，只要我们能绘制出因果图，我们就能解决问题，无论这个问题是关乎长毛象狩猎、行刑队执行枪决还是关乎疫苗接种。这正是我们希望因果推断引擎具备的特性：一种为人类所独享的<strong>灵活性</strong>。</p>
<p>这些变化将对前文提到的例子中的绝大部分变量的概率产生极大的影响；但显然，原有的<u>因果图结构仍将保持不变</u>。这正是构建因果模型的关键秘诀。此外，一旦我们完成了之前的分析工作，我们就不必在条件改变时从头开始重复整个分析过程。如导言所述，同样的被估量（也就是回答相应问题的方法）将一直有效，并且只要因果图不变，该被估量就可以<u>应用于新数据，并为特定问题生成新的估计值</u>。我猜想，正是由于具备这种稳健性，人类的直觉才以因果关系而非统计关系为组织的核心。</p>
<p><strong>论概率与因果关系</strong></p>
<p>哲学家几乎无一例外地使用了条件概率来表示“X提高了Y的概率”，记作P（Y|X）&gt;P（Y）。你肯定注意到了，这种解释是错的，因为“提高”是一个因果概念，意味着X对Y的因果效应，而公式P（Y|X）&gt;P（Y）只涉及观察和手段，表示的是“如果我们观察到了X，那么Y的概率就提高了”。但是，这种概率提高完全可能是由其他因素造成的，比如Y是X的因，或者其他变量（Z）是它们二者的因——这就是症结所在！</p>
<p>一旦用条件概率的语言歪曲“概率提高”，即使再多的概率补丁也无法让你登上更高一层的因果关系阶梯。我知道这听起来很奇怪，但<u>概率提高这个概念确实不能单纯用概率来表示</u>。</p>
<p>拯救概率提高这一概念的正确方法是借助do算子来定义：如果P（Y|do（X））&gt;P（Y），那么我们就可以说X导致了Y。由于干预是第二层级的概念，因此这个定义能够体现概率提高的因果解释，也可以让我们借助因果图进行概率推算。换言之，当研究者询问是否P（Y|do（X））&gt;P（Y）时，如果我们手头有因果图和数据，我们就能够在算法上条理清晰地回答他的问题，从而在概率提高的意义上判断X是否为Y的一个因。</p>
<blockquote>
<p>我并非一直把因果放在第一位，把概率放在第二位。恰恰相反！20世纪80年代初，我开始踏足人工智能方面的研究，并认定不确定性正是人工智能缺失的关键要素。此外，我坚持不确定性应由概率来表示。因此，正如我将在第三章中解释的那样，我创建了一种关于不确定性的推理方法，名为“贝叶斯网络”，用于模拟理想化的、去中心化的人类大脑将概率纳入决策的方法。贝叶斯网络可以根据我们观察到的某些事实迅速推算出某些其他事实为真或为假的概率。不出所料，贝叶斯网络立即在人工智能领域流行开来，甚至直至今天仍被视为人工智能在包含不确定性因素的情况下进行推理的主导范式。</p>
<p>但它并没能弥合人工智能和人类智能之间的差距。我相信你现在也能找出那个缺失的要素了——没错，就是因果论。</p>
<p>当时我认为因果关系只是一个从属概念，最多不过是一种便利的思维工具或心理速记法，用以表达概率的相关性以及区分相关变量和无关变量（好有道理）</p>
<p>贝叶斯网络适用于一个所有问题都被简化为概率或者（用本章的术语来说就是）变量间的关联程度的世界，它无法自动升级到因果关系之梯的第二层级或第三层级。</p>
<p>我想说明的<strong>主要观点</strong>是：概率能将我们对静态世界的信念进行编码，而因果论则告诉我们，当世界被改变时，无论改变是通过干预还是通过想象实现的，<u>概率是否会发生改变以及如何改变</u>。</p>
</blockquote>
<h2 id="2-因果推断的起源"><a href="#2-因果推断的起源" class="headerlink" title="2. 因果推断的起源"></a>2. 因果推断的起源</h2><p>——从海盗（皮尔逊）到豚鼠</p>
<p>对高尔顿来说，梅花机就是一种关于身高遗传的模型，甚至可能也是关于许多其他遗传特征的模型。这是一个因果模型。简单来说，高尔顿相信，就像人类会遗传他们上一代的身高一样，金属小球也会“遗传”它们在梅花机中的位置。</p>
<p>但是，如果我们暂且接受这个模式，就会出现一个难题，这也是高尔顿当晚的主题。钟形曲线的宽度取决于放置在钉板顶部和底部之间钉子的行数。假设我们将行数加倍，我们就构建了一个能够表示两代遗传的模型，其中上半部分代表第一代，下半部分代表第二代。此时你就会发现，第二代比第一代出现了更多的变异情况，而在随后的几代中，钟形曲线会变得越来越宽。</p>
<p>然而，人类身高的真实状况并未出现此种趋势。</p>
<p>高尔顿在此过程中还是有所发现的，特别是当他开始关注类似身高这样的遗传特征的时候。与“卓越”相比，身高特征更易测量，跟遗传的关联也更强。高个子男性的儿子往往身高也比普通人高——但很可能不如他们的父辈高；矮个子男性的儿子往往身高比一般人矮——但很可能不如他们的父辈矮。一开始，高尔顿称这种现象为“复归”（reversion），后又改称为“向均值回归”（regression toward mediocrity）（regression也有退化的意思）。</p>
<p>散点图分析：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112049380.png" alt="image-20220511204930285" style="zoom:80%;" />

<p>分析每一个垂直框，预测总是落在一条直线上，他称这条直线为回归线，它比椭圆的主轴（或对称轴）的斜率小（见图2.3）。事实上，这样的直线有两条，我们选择哪条线作为回归线取决于我们要预测哪个变量而将哪个变量作为证据。</p>
<p>表明，<u>对于向均值回归这一现象，因和果是没有区别的</u>。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112052229.png" alt="image-20220511205232096" style="zoom: 80%;" />

<p>如果你知道父亲的身高，则直线OM将为你提供其儿子身高的最佳预测；如果你知道儿子的身高，则直线ON将为你提供其父亲身高的最佳预测。这两条直线都不同于散点图中的主轴（对称轴）</p>
<blockquote>
<p>相关性概念首次在不依赖于人的判断或解释的前提下以客观度量说明了两个变量是如何关联的。找到这样一种通用的方式来描述随机变量之间的关系，高尔顿和皮尔逊一定曾为此激动不已。尤其是皮尔逊，在他的眼中，与相关系数这种在数学上清晰且精确的概念相比，那些关于因果的模糊而陈旧的概念似乎已经完全过时而丧失科学性了。</p>
<p>高尔顿以寻找因果关系为起点，最终却发现了相关性——一种无视因果的关系。这是一段颇具讽刺意味的历史。</p>
</blockquote>
<p>小球在下一层的位移继承了其沿路撞到的所有钉子带给它的变化的总和。这就与卡尼曼的方程产生了明显的矛盾：</p>
<p>成功=天赋+运气</p>
<p>巨大的成功=更多的天赋+更多的运气</p>
<p>根据卡尼曼的方程，第二代的成功不会继承第一代的运气。按其定义，运气本身是一个只具有短暂影响的事件，因此其对后代没有影响。然而这一具有短暂影响的事件与高尔顿的梅花机是不兼容的。</p>
<p>为将这两个概念放在一起比较，让我们试着画出相应的因果图。</p>
<p>（a）高尔顿板模型，在这种模型下，运气世代相传，这就导致成功的分布不断变宽。（b）遗传模型，在这种模型下，运气不会累积，这就导致成功在代际间的稳定分布</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image@main/img/202205112102796.png" alt="image-20220511210237673" style="zoom:80%;" />

<p>在皮尔逊的眼中，高尔顿扩展了科学的词汇。因果关系被简化为仅仅是相关关系的一个特例（在这一特例中，相关系数为1或–1，两个变量x和y之间的关系是确定的）。因果关系对于皮尔逊来说仅仅是一种重复，在确定性的意义上是永不可证的。数据就是科学的全部,因果关系之梯的最底层就是科学家进行科学研究所需的一切。</p>
<p>【皮尔逊带给我的启示：不要迷信权威的论文和观点，并奉为圭臬，比如batch_norm是好的，还是得自己阅读文献，看看作者的发现和对此的解释，独立思考。】</p>
<p>我们现在已经意识到了，在某些情况下，正确的分析结果只能来自聚合数据，而非来自分组数据。</p>
<p><strong>莱特的分析方法</strong></p>
<p>赖特开创的分析方法在他之后得到了极大的发展，其应用范畴远远超越了最初的豚鼠基因研究。</p>
<p>在寻求某个未知量的值时，你可以先赋予该量一个符号，然后用数学方程的形式描述你对该量和其他相关量的认识，最后，如果你有足够多的耐心和足够多的方程，你就可以解出方程式，并算出目标量的值。</p>
<p>许多人仍然会犯尼尔斯的错误，认为因果分析的目的只是证明X是Y的因或从头开始找到Y的因。这的确是<u>因果关系研究中的因果发现难题</u>，也是我第一次投身于图形化建模时雄心勃勃地试图解决的问题，直到现在，这依然是一个充满活力的研究领域。相比之下，赖特的研究重点，以及本书的讨论重点，则是用数学语言表达看似合理的因果知识，将其与经验数据相结合，回答具有实际价值的因果问题。</p>
<p>赖特的方法告诉我们如何用路径系数来表示每个<u>需要测量的相关性</u>。在对每组变量间的相关性（P，X）、（L，X）和（L，P）执行此操作之后，我们就会得到3个方程，并可以据此用代数方法求解未知路径系数p、l’以及l×q。然后问题就解决了，因为我们想要的路径系数p的值现在已经可以计算出来了。</p>
<p>第一个经验是：因果分析允许我们量化在现实世界中实际存在的某个过程，而非只能分析数据中的模式。</p>
<p>第二个经验是：无论是否采用数学处理，在路径分析中，你都能通过检查整个路径图得出关于单个因果关系的结论。而如果你想测算某个具体的路径系数，你可能就需要进一步分析路径图的整体结构了</p>
<p>因果分析绝不只是针对数据的分析；在因果分析中，我们必须将<u>我们对数据生成过程的理解</u>体现出来，并<u>据此得出初始数据不包含的内容</u>。但有一点费舍尔说得没错：<u>一旦你从统计学中删除因果关系，那么剩下的就只有数据约简了</u>。</p>
<p><strong>贝叶斯连接——从客观性到主观性</strong></p>
<p>赖特认为：“路径分析这种灵活的方法与为尽可能避免偏离客观性而设计的刻板的描述统计方法有很大的区别。”</p>
<p>这句话是什么意思？首先，赖特想说的是，路径分析的应用应该以研究者对因果过程的个人理解为基础，这种理解就反映在其所绘制的因果图或路径图中。它不能被简化为一个机械性的程序，就像统计手册里列出的那些操作方法一样。</p>
<p>1834年3月15日伦敦统计学会成立伊始，<u>客观性就是统计学家的圣杯</u>。学会的创始章程规定，在所有的情况下，数据都优先于观点和解释。数据是客观的，而观点是主观的。这个规则的提出远远早于皮尔逊时代。为客观性而奋斗，完全根据数据和实验进行推理的思想，自伽利略以来一直是科学定义自身存在方式的一部分。</p>
<p>与相关性分析和大多数主流统计学不同，<u>因果分析要求研究者做出主观判断</u>。研究者必须绘制出一个因果图，其反映的是他对于某个研究课题所涉及的因果过程拓扑结构的定性判断，或者更理想的是，他所属的专业领域的研究者对于该研究课题的共识。为了确保客观性，他反而必须放弃传统的客观性教条。在因果关系方面，睿智的主观性比任何客观性都更能阐明我们所处的这个真实世界。</p>
<p><em>【一时也有点难以接受，统计学家们希望寻找到一种通法、真理吗，再看看，保留一些疑惑】</em></p>
<p>在今天的统计学会议上，你已经不会再见到“贝叶斯学派”和“频率派”（frequentists）之间发生激烈辩论的情形，而在20世纪60年代和70年代，此类争论曾频繁爆发</p>
<blockquote>
<p>贝叶斯分析的原型是这样的：<u>先验判断+新的证据→经过修正的判断</u>。例如，假设你抛掷10次硬币，发现其中有9次结果是正面朝上。那么此时你认为硬币抛掷是一个公平的游戏这一判断就可能会发生动摇，但你具体在多大程度上动摇了呢？一位正统的统计学家会说：“在没有任何额外证据的情况下，我倾向于认为这枚硬币掺有杂质，所以我敢打赌，下一次抛掷硬币时，硬币正面朝向的概率为9∶1。”</p>
<p>而一位贝叶斯统计学家会说：“等一下，我们还需要考虑一下我们对于这枚硬币的<u>先验知识</u>。”这枚硬币是从附近的杂货店买的，还是从一个名声不怎么样的赌徒那儿得来的？如果这只是一枚普通的硬币，那么大多数人是不会因为9次结果为正面朝上的巧合就发生动摇的。相反，如果我们可以合理怀疑这枚硬币被做了手脚，那我们会更愿意得出这一结论，即9次正面朝上的结果充分证明了偏倚的存在。</p>
<p>贝叶斯统计为我们提供了一种将观察到的证据与我们已有的相关知识（或主观判断）结合起来以获得修正后的判断的客观方法，借由这种方法，我们就可以对下一次硬币抛掷结果的预测进行修正。而频率派无法忍受的正是贝叶斯学派允许观念<u>以主观概率的形式“入侵”“纯洁”的统计学王国</u>的做法。在贝叶斯分析被证明是一种优秀的工具，且适用于各种应用场景，包括天气预报和追踪敌方潜艇之后，主流的统计学家也只能勉强地承认对手的成功。此外，许多例子已经证明，<u>随着数据量的增加，先验判断的影响会越来越小，乃至彻底消失，这就让我们最终得到的那个结论仍然是客观的</u>。</p>
</blockquote>
<p>遗憾的是，主流统计学界对贝叶斯学派的主观性的接受并<u>没能</u>促进其对因果主观性的接受。答案在于<u>表述语言上的巨大障碍</u>。为了阐明主观假设，贝叶斯统计学家沿用了高尔顿和皮尔逊的“母语”——概率语言。而阐述因果推断的假设需要的是一种内涵更丰富的语言（如因果图）。</p>
<p>此外，<u>即使数据量增加，因果信息中的主观成分也不一定会随着时间的推移而减少</u>。绘制出两个不同的因果图的两个人可以分析相同的数据，但很可能永远不会得出相同的结论，无论数据有多“大”。这对于科学客观性的倡导者来说是一个可怕的前景，也说明了他们拒绝依赖主观因果信息的确有其必然性。</p>
<p>从积极的一面说，<em>因果推断在一个极其重要的意义上是客观的</em>：一旦两个人就假设达成了一致，因果推断就为他们提供了一种百分之百客观的方法用以解释任何新出现的证据（或数据）。</p>
<h2 id="3-从证据到因"><a href="#3-从证据到因" class="headerlink" title="3. 从证据到因"></a>3. 从证据到因</h2><p>——当贝叶斯牧师遇见福尔摩斯先生</p>
<blockquote>
<p>福尔摩斯所做的并非只是从假设推出结论的演绎，他的拿手本领是归纳。与演绎正好相反，<u>归纳是从证据推出假设</u>。</p>
</blockquote>
<p>近年来，人工智能专家在<u>从证据到假设</u>以及<u>从结果到原因</u>的自动化推理方面取得了相当大的进展。我有幸借助开发了实现该功能所必需的一项基本工具（贝叶斯网络）参与了这一发展进程的最初阶段。在本章中，我将简略地对贝叶斯网络做一下介绍，考察当前该工具的一些应用实例，并向大家讲述我在最终进入因果关系研究领域之前所走过的曲折道路。</p>
<p>如果你有一部手机，那么从成千上万个电话中筛选出打给你的电话就是通过<u>信念传播算法（belief propagation）</u>来解码的，而信念传播是专为贝叶斯网络设计的一种算法。作为“互联网之父”之一的温顿·瑟夫曾说：“我们所有人都是贝叶斯方法的超级用户。</p>
<p>:star: <u>贝叶斯网络与因果图之间的关系</u>很简单：因果图就是一个贝叶斯网络，其中每个箭头都表示一个直接的因果关系，或者至少表明了存在某个因果关系的可能性。反过来，并非所有的贝叶斯网络都是因果关系网络，而在很多实际应用中这一点并不重要。但是，一旦你想问关于贝叶斯网络的第二层级或第三层级的问题，你就必须认真对待因果论，一丝不苟地画出因果图。</p>
<blockquote>
<p>贝叶斯留给后世的资料很少，他生前发表过的两篇文章都与概率论无关，但他的遗作《论有关机遇问题的求解》（1763）给他带来了无尽的荣耀。在这篇论文中，他推导出了逆概率公式，即著名的贝叶斯法则。很难评述贝叶斯本人对概率的哲学认识，他的学说被后继者们赋予了更广泛、更深刻的内涵，以致发展成为贝叶斯学派，甚至贝叶斯主义。</p>
<p>频率派和贝叶斯学派<u>对贝叶斯法则的理解是不同的</u>，因而两派借助它来进行推断的手法也不相同。贝叶斯法则是贝叶斯推断的核心，拉普拉斯称之为“<strong>最基本原理</strong>”</p>
</blockquote>
<p>对于贝叶斯来说，休谟的观点很自然地引发了一个问题，有人可能会称其为福尔摩斯式的问题：需要<u>多少</u>证据才能让我们相信，我们原本认为不可能发生的事情真的发生了？在何种情况下，某个假设才会越过绝不可能的界限抵达不大可能，甚至变为可能或确凿无疑呢？虽然这个问题是用概率语言表述的，其含义却带有明显的神学色彩。</p>
<p>贝叶斯法则它表明了我们可以从一个果推断某个因的概率。如果我们知道因，那我们很容易就能估计出果的概率，这是一个前向概率（forward probability）。而它的反面，也就是贝叶斯时代的“逆概率”推理，则难度要大得多。贝叶斯没有解释为什么它很困难，他认为这一点不言而喻，但他向我们证明了逆概率推理是可行的，并展示了如何操作。</p>
<p>这也许是贝叶斯法则在统计学中最重要的应用：我们可以<u>在我们的判断较为可靠的一个方向上直接估算出条件概率，并利用数学工具推导出在我们的判断较为模糊的另一方向上的条件概率</u>。在贝叶斯网络中，该方程也扮演了同样的角色：我们告诉计算机前向概率，在需要时，计算机告诉我们逆概率。</p>
<p>我们还可以将贝叶斯法则看作一种方法，用以更新我们对某一特定假设的信念。理解这一点非常重要，因为人类对未来事件的信念大多取决于该事件或类似事件在过去发生的频率。</p>
<hr>
]]></content>
      <categories>
        <category>Causality</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
</search>
