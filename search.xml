<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git</title>
    <url>/2021/03/06/git/</url>
    <content><![CDATA[<p>git init</p>
<p>git status</p>
<p>git add file</p>
<p>git commit -m “”</p>
<p>git log –oneline</p>
<p>git reflog</p>
<p>git reset –hard HEAD^(版本号)</p>
<p>HEAD^^  HEAD~100</p>
<p>git diff HEAD – file</p>
<p>查看工作区和版本库不同</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>checkout  -&gt; restore</p>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>
<p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage）</p>
<p> `git reset HEAD -&gt; git restore –staged</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<p>远程</p>
<p>git remote -v</p>
<p>git remote remove origin</p>
<p>git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;</a>:git_username/repository_name.git</p>
<p>git pull origin main –allow-unrelated-histories</p>
<pre class="line-numbers language-none"><code class="language-none">git push -u origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>git push origin master</p>
<p>git push -u origin main -f 强制push！！</p>
<p>git clone url</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;创建 &lt;name&gt; 的分支并切换
git switch -c &lt;name&gt;

&#x2F;&#x2F;创建
git branch &lt;name&gt;

&#x2F;&#x2F;切换到&lt;name&gt;分支
git checkout &lt;name&gt;
git switch &lt;name&gt;

&#x2F;&#x2F;查看分支树
git branch 

&#x2F;&#x2F;删除分支
git branch -d &lt;name&gt;

&#x2F;&#x2F;合并分支 假设这里存在 master ， dev 分支
  &#x2F;&#x2F; 1 切换到要保留的分支——这里是master
  git checkout master
  &#x2F;&#x2F; 2 合并掉分支dev
  git merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><code>git log --graph</code>命令可以看到分支合并图</p>
]]></content>
      <categories>
        <category>basic</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow-note</title>
    <url>/2021/04/26/tensorflow-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本课程结构：</p>
<ol>
<li>神经网络计算：搭建第一个神经网络模型</li>
<li>神经网络优化：学习率、激活函数、损失函数、正则化、自写优化器</li>
<li>神经网络八股：搭建八股“六步法”</li>
<li>网络八股扩展：八股拓展：自制数据集、数据增强、断点续训、参数提取、可视化、给图识物</li>
<li>卷积神经网络：用CNN和一些工具实现图像识别</li>
<li>循环神经网络：用RNN和一些工具实现股票预测</li>
</ol>
<hr>
<p>每一章的思维框架借鉴了<a href="https://blog.csdn.net/weixin_42186072/article/details/106669979">大佬的博客</a>，学完一章可以看这里</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155209.png" alt="课程概览" style="zoom: 67%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155220.png" alt="引入"></p>
<h2 id="鸢尾花"><a href="#鸢尾花" class="headerlink" title="鸢尾花"></a>鸢尾花</h2><p>专家系统是理性的。（if case。）</p>
<p>但是有些花农直接可以看出种类，因为他们见了太多，而且经验越丰富，识别准确率越高</p>
<p>这是一种感性的直觉，是这门课介绍的神经网络方法</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/20210426223114.png" style="zoom:33%;" />

<hr>
<p>具体实现</p>
<p>MP模型，每个输入特征乘以线上的权重，再通过一个非线性函数输出，简化是去掉非线性函数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426224043.png" style="zoom:33%;" />

<p>每个输出节点都链接了所有的输入关系，称为全连接网络</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426224129.png" style="zoom:33%;" />

<h2 id="TF2"><a href="#TF2" class="headerlink" title="TF2"></a>TF2</h2><p>把numpy格式转换为tensor格式</p>
<p>创建形式和numpy非常类似！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155247.png" alt="创建"></p>
<hr>
<p>tensorflow中一切皆为张量，包括输出的常数结果也是一个shape = ()的tensor类型张量</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155255.png" alt="函数"></p>
<p>其中tf.argmax可以直接接受numpy数组类型的参数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426234353.png" style="zoom:33%;" />

<h2 id="鸢尾花2"><a href="#鸢尾花2" class="headerlink" title="鸢尾花2"></a>鸢尾花2</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210426235530.png" style="zoom: 33%;" />



<p>class1 P45 <strong>非常重要</strong>，建议全文背诵hhh</p>
<h1 id="参数知识"><a href="#参数知识" class="headerlink" title="参数知识"></a>参数知识</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155310.png" alt="第二章" style="zoom:50%;" />

<p>先介绍一些函数：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095155.png" style="zoom:25%;" />

<p>记住这个是逐个比较</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095313.png" style="zoom:25%;" />



<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427095925.png" style="zoom: 25%;" />

<hr>
<p><strong>复杂度</strong></p>
<p>输入层不算层数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427132521.png" style="zoom:25%;" />

<p><strong>学习率</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427132837.png" style="zoom:25%;" />

<p>只是增加了一些代码</p>
<hr>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a><strong>激活函数</strong></h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191332.png" style="zoom:25%;" />





<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191556.png" style="zoom:25%;" />

<p>因为反向传播从输出层向输入层逐层求导，每一层的导数都落在0-0.25，多了以后趋于0，称为<strong>梯度消失</strong>，无法更新参数。所以sigmoid函数如今用的很少了</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427191737.png" style="zoom:25%;" />

<p>通过调整初始化来避免“神经元死亡（一直是0）”，可以设置更小的学习率，减少参数分布的巨大变化，来👆</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427192342.png" style="zoom:25%;" />

<p>初学者的建议：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427192420.png" style="zoom:25%;" />

<p>对零均值化的解释：</p>
<p><a href="https://blog.csdn.net/wtrnash/article/details/87893725">https://blog.csdn.net/wtrnash/article/details/87893725</a></p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427194702.png" style="zoom:25%;" />

<p>loss_mse = tf.reduce.mean(tf.square(y_-y))</p>
<p>P19随机数使用很秀。</p>
<p>有时候也要根据实际情况自定义损失函数。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427200949.png" style="zoom:25%;" />

<p>交叉熵计算概率分布间的距离</p>
<p>tf.losses.categorical_crossentropy(y,y_)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427201314.png"></p>
<p>这个虽然可以配合softmax使用，但是还有集成的👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427201845.png" style="zoom:25%;" />

<p>如图，一换二不亏</p>
<h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>欠拟合是对现有数据集学习的不太彻底，拟合效果不好</p>
<p>过拟合是对现有数据拟合的太好，却对新数据难以处理</p>
<p>ps：</p>
<p>在机器学习的<a href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>中，超参数是在开始学习过程之前设置值的参数。 相反，其他参数的值通过训练得出。</p>
<p>超参数：</p>
<ul>
<li>定义关于模型的更高层次的概念，如复杂性或学习能力。</li>
<li>不能直接从标准模型培训过程中的数据中学习，需要预先定义。</li>
<li>可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427202855.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427203023.png"></p>
<p>P29有最优化代码</p>
<p>把区分0和1的分界线0.5标出颜色</p>
<h2 id="优化器（跳）"><a href="#优化器（跳）" class="headerlink" title="优化器（跳）"></a>优化器（跳）</h2><p>神经网络参数优化器</p>
<p><strong>不同的优化器，实质上只是定义了一阶动量和二阶动量的公式。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212011.png" style="zoom:25%;" />

<p>？？？？这个公式是什么鬼</p>
<p>gt是梯度，梯度下降优化器👇P32</p>
<p>我跑出来6.5s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212319.png" style="zoom:25%;" />

<p>我跑出来7.7s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212651.png" style="zoom:25%;" />

<p>这个公式,加了一个二阶动量，python实现如下👇P34</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212820.png" style="zoom:25%;" />

<hr>
<p>P36 7.3s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427212903.png" style="zoom:25%;" />

<p>移动平均-&gt;指数滑动平均：</p>
<p>指数平滑法是在<a href="https://baike.baidu.com/item/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E6%B3%95/10785547">移动平均法</a>基础上发展起来的，它具有移动平均法的优点，又可以减少运算过程中的数据储存量，同时还考虑了不同时期的数据所起的不同作用。采用指数平滑法的关键是确定α值。一般情况下，α值的大小，既和反映近期数据的能力有关，也和数据波动状况有关。通常不直接利用一次指数平滑法来预测，而是利用二次指数平滑法，求出平滑系数，建立起预测模型，再进行预测</p>
<p>P38 8.3s</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213327.png" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213358.png" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213417.png" style="zoom:25%;" />

<p>请注意：<strong>pycharm开的控制台越多越卡</strong>，所以之前的数据应该作废呜呜。。。还有以后跑之前记得把控制台全部关上。</p>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155317.png" alt="第三章" style="zoom: 67%;" />

<p>使用keras搭建</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210427213648.png" style="zoom:25%;" />

<p>MNIST是著名的手写数字识别</p>
<p>Fashion是著名的着装图片识别。</p>
<h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p>六步：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155521.png" style="zoom: 50%;" />

<p><strong>导入</strong></p>
<p><strong>设定训练、测试集</strong></p>
<p><strong>逐层搭建神经网络、前向传播</strong></p>
<p><strong>配置训练方法（优化器、损失函数、评测指标）</strong></p>
<p><strong>执行训练过程</strong></p>
<p><strong>打印网络结构和参数统计</strong></p>
<p>Sequential可以认为是个容器，封装了神经网络的结构</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155749.png" style="zoom: 33%;" />

<p>卷积神经网络和循环神经网络，在第五讲和第六讲的时候再讲。</p>
<p>compile里的参数既可以填默认的字符串，亦可以写出具体函数然后细调参数</p>
<p>入门建议<strong>直接写名字</strong>，等掌握了再去官网查看函数的具体用法，调整超参数，细调函数参数</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428155802.png" style="zoom:33%;" />

<p>注意from_logits判断是否经过了概率分布，如果没有进过概率分布，该参数就是true</p>
<p>后面经常使用sparse_categorical_accuracy</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428160240.png" style="zoom: 33%;" />

<p>按照比例，还是按照输入特征分类。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428161322.png" style="zoom: 33%;" />

<p>param = (输入+1)*输出    1是因为bia</p>
<p>鸢尾花复现在class3里的p8</p>
<p>如果需要“跳连”，大概就是可以设置比较深层的神经网络p11</p>
<p>init函数设置各层，call函数调用各层进行前向传播</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428172612.png" style="zoom:25%;" />

<p>其中区别如下👇，</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428172607.png" style="zoom:33%;" />



<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210428170337.png" style="zoom: 33%;" />

<p>在class 3 里 p13 14 15</p>
<h3 id="FASHION"><a href="#FASHION" class="headerlink" title="FASHION"></a>FASHION</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210906154804517.png" alt="image-20210906154804517"></p>
<h1 id="八股功能扩展"><a href="#八股功能扩展" class="headerlink" title="八股功能扩展"></a>八股功能扩展</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20200610164333221.png" alt="第四章" style="zoom: 67%;" />

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>复变函数和积分应用</title>
    <url>/2021/05/12/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言和资源"><a href="#前言和资源" class="headerlink" title="前言和资源"></a>前言和资源</h1><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130415.png"  style="zoom: 67%;" />

<p>推荐一个宝藏up主  “乐乐老师的网络课堂”，是个狼灭</p>
<p>华中科技大学的慕课</p>
<h1 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h1><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130633.png"  style="zoom: 33%;" />

<p><strong>实数域是复数域的一个真子集，实数是有序数，复数不是，因此复数不可比较</strong></p>
<p>*四则运算</p>
<p>z*z共轭 = z模长的平方</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131813.png"  style="zoom:33%;" />

<h3 id="极坐标形式"><a href="#极坐标形式" class="headerlink" title="极坐标形式"></a>极坐标形式</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514131923.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132008.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132027.png"  style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514132647.png"  style="zoom:33%;" />

<p><strong>结合arctany/x的图会比较好理解，起到一个调整范围的作用。</strong></p>
<p>两个复数相等≠模和辐角分别相等，前不能推后，后可以推前，可能差了2npi，<strong>模和辐角主值相等则复数相等</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514143939.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144025.png"  style="zoom:33%;" />



<h3 id="乘幂与方根"><a href="#乘幂与方根" class="headerlink" title="乘幂与方根"></a>乘幂与方根</h3><p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144329.png"></p>
<p>由乘法直接看出</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144805.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514144826.png"  style="zoom: 50%;" />

<p>方根</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145219.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145319.png"  style="zoom:33%;" />

<p><strong>单位根：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145634.png"  style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514130456.png"  style="zoom: 25%;" />

<p>给一个例子：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514145958.png"  style="zoom: 33%;" />



<h3 id="复数域扩充"><a href="#复数域扩充" class="headerlink" title="复数域扩充"></a>复数域扩充</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150150.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150310.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150548.png"  style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150705.png"  style="zoom:33%;" />

<p>复球面</p>
<p>由古老的测地投影法（绘制世界地图），衍生出复球面</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514150941.png"  style="zoom: 33%;" />

<p>这样全体复数都可以被球面的点表示，N点表示无穷远点，这称为黎曼球面</p>
<h3 id="平面点集补充"><a href="#平面点集补充" class="headerlink" title="平面点集补充"></a>平面点集补充</h3><p>复变函数的基础，邻域，去心邻域</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151404.png"  style="zoom: 33%;" />

<p>内点，开集，闭集，边界点以及边界，孤立点（孤立一定是边界），有界集，无界集，连通集</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514151735.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210514152143.png"  style="zoom:50%;" />

]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>复变</tag>
      </tags>
  </entry>
  <entry>
    <title>hot key</title>
    <url>/2021/04/05/%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><p>Fn + 左右箭头快速抵达行头行尾</p>
<p>Fn + shift + 左右箭头快速选中整行</p>
<p>C + f 搜索</p>
<h2 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h2><p>单指：</p>
<p>轻点两下为拖拽，选择</p>
<p>双指：</p>
<p>轻击为右键，反方向为滑动</p>
<p>三指：</p>
<p>左右滑动选择窗口</p>
<p>向下，隐藏所有窗口</p>
<p>向上，依次打开，保留次序</p>
<p>四指：</p>
<p>向上：最近打开的文件</p>
<p>向下：复原</p>
<p>左右：切换桌面</p>
<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>C + g  快速到达某一行</p>
<p>C + A + 上下  为上下行的该位置添加光标，如果为空，则尽量左移</p>
<p>S + A + 拖动鼠标 选中规则同上</p>
<p>C + c  +  C + v 快速复制一行</p>
<p>或者 S + A + 上下</p>
<hr>
<p>C + /  单行注释</p>
<p>C + S + /   多行注释（改的，原来是S + A + a）</p>
<p>C + ~  打开终端</p>
<p>C + d 快速选中相同的</p>
<p>C + f 搜索</p>
<p>C + h 替换（可以全部替换）</p>
<p>C + +/-  放大/缩小布局</p>
<p>Tab 到达下一个光标</p>
<p>自定义快捷键</p>
<p>有些快捷键，我们使用不习惯，其实我们可以自定义快捷键的。</p>
<p>比如js 的多行注释是 shift + alt  + a  ，我们想修改为 ctrl + shfit +  /   </p>
<p>设置方法：   管理按钮  —   键盘快捷方式  —  输入  shift + alt  + a  找到这个快捷键  —– 点击编辑按钮  —- 直接按下  ctrl + shift  +  /     —- 最后按下回车 修改完毕。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/070e4f32b7326196062f020bbc3a91b30c7e470c.gif" alt="img"></p>
<h1 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h1><p>C + R是搜索。。</p>
<p>ipython里终端 C + r是回溯</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>C + S + j   开发者模式（谷歌），在火狐有些不同</p>
<p>C + h   历史记录</p>
<p>C + n  打开新窗口</p>
<p>C + S + n  新无痕窗口</p>
<p>C + 左键:打开新标签方式</p>
<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>C + b 加粗</p>
<p>C + i  斜体</p>
<p>C + k 设为超链接</p>
<h1 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h1><p>A 创建新单元格above当前单元格</p>
<p>B 创建新单元格below当前单元格</p>
<p>在markdown 和 code之间进行转换</p>
<p>markdown -&gt; code Y</p>
<p>code -&gt; markdown M </p>
<p>L 是显示行号d</p>
<p>双击D 可以删除单元格，Z撤销删除</p>
<p>S 保存！</p>
<p>最强的是C + S + P</p>
<p>打开万能的控制栏</p>
]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>hot key</tag>
      </tags>
  </entry>
  <entry>
    <title>跨学科通识课</title>
    <url>/2021/08/09/%E8%B7%A8%E5%AD%A6%E7%A7%91%E9%80%9A%E8%AF%86%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="跨学科通识"><a href="#跨学科通识" class="headerlink" title="跨学科通识"></a>跨学科通识</h1><p><strong><a href="https://www.bilibili.com/cheese/play/ep6902">视频地址</a></strong></p>
<p>所长林超自阅读查理芒格观点后得出的感悟。本课程信奉 <strong>实用主义</strong></p>
<p>现实生活中的挑战并不是按照大学学科划分的，但每种学科，都为我们解决问题提供了重要的思维模型</p>
<p>本课程将介绍约22个学科和120个常见思维模型，以及部分应用：</p>
<p>热力学、函数、工程学、<strong>复杂性科学</strong>、系统论、信息论、会计学、概率论、金融学、生物学、投资学、社会学、管理学、物理学、脑科学、认知心理学、历史学、语言学、逻辑学、经济学、营销学、哲学</p>
<p> <strong>大多数人的一生都喜欢用一个单薄的知识结构解决所有问题，这是专业化带来的狭隘思维</strong></p>
<hr>
<p>像我这样的人才:laughing:（bushi），就应该逐步构建自己的知识体系，哈哈我就是这样做的，我在大一接触了应用数学、博弈论、经济学、投资学、心理学、信息论、运筹学，但是学习方法不对，我需要的不是变成所有领域的专家，而是专精一两门（数据科学+经济学），然后学到其他学科的思考模型，先拿林超大大的课试试水。</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140718.png"  style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809140824.png"  style="zoom: 33%;" />



<p>20-35岁是人生的黄金时间，抓住啊！</p>
<h2 id="一、熵与热力学"><a href="#一、熵与热力学" class="headerlink" title="一、熵与热力学"></a>一、熵与热力学</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>S = k * lnW  也可以说熵正比于微状态数</p>
<p>可能性大 = 熵高 = 混乱程度高</p>
<p>这个世界上混乱才是常态，有序需要<strong>刻意营造</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142123.png"  style="zoom: 25%;" />

<p>熵增定律</p>
<p>封闭系统，与外界隔绝，随时间推移趋于混乱。</p>
<p>趋于有序的方法</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142524.png"  style="zoom: 25%;" />

<p>只要它能正确的做好这两件事，就能使事物变得更加有序。</p>
<hr>
<p><strong>应用：思维决策层</strong></p>
<p>在”脑子里放一个小人“，判断该不该继续思考数量繁多而无序的念头，就能让思维变得有序，这相当于是在正常人的思维输入输出模型里面又加了一个决策层啊！果然方法论决定对外界的反馈，厉害。</p>
<hr>
<p>耗散结构</p>
<p>感知和选择需要信息和能量，封闭系统变成开放系统，吸收外界的能量和信息</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809142944.png"  style="zoom:33%;" />

<p>流水不腐就是一个耗散结构，人体也是，耗散结构是一个动态平衡体，变化又保持一个平衡状态。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143434.png"  style="zoom:33%;" />



<h3 id="运转策略"><a href="#运转策略" class="headerlink" title="运转策略"></a><strong>运转策略</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143513.png"  style="zoom: 33%;" />

<p>ps:虽然很多人都是这么做的，但是却没有总结成结论，没有总结成结论，运用的时候就会无效思考，心生犹豫，但若是作为一条公理、定理，一项判断决策，那就非常有价值了！</p>
<p><strong>人们应该把焦点全部放在蓝色部分的因，接纳红色的因，而不是因为红色的果而感到自责，反而阻止了身体继续排出熵。所以鸡汤里面的依靠决心和自责什么的假大空的，其实就是抓错了重点。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809143954.png"  style="zoom:25%;" />

<p>我们改变不了整体系统，但我们可以改变 <strong>感知+选择</strong> 这件事</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144227.png"  style="zoom: 33%;" />

<p>有些人会困在先天的家庭环境带来的红色的果里，有些人会找到铁饭碗，陷入封闭系统里，这个世界充满辩证法，耗散里的选择才是最关键的，如果落实到具体做法，请看👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210809144756.png"  style="zoom:50%;" />

<p>逐渐的，两种模式都会形成坚固的闭环。B模式总会伴随痛苦，反人性，充满困难。</p>
<p>工程学告诉我们如何拆解困难，化为一件件小事，轻松KO。</p>
<h2 id="二、工程学"><a href="#二、工程学" class="headerlink" title="二、工程学"></a>二、工程学</h2><p>很多人知难而退，其实是知的不够</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809162445785.png"  style="zoom:50%;" />

<p>工程学的细分专业非常多：生物、农业、分子、土木、软件、森林。。。</p>
<p>这节课将提炼共通的重要方法论：<strong>行胜于言、分解结构、量化、列清单、取舍</strong></p>
<h3 id="行胜于言"><a href="#行胜于言" class="headerlink" title="行胜于言"></a><strong>行胜于言</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809163834216.png"  style="zoom: 33%;" />

<p>风口思维找到大方向，高风险，看准下手。</p>
<p>工程思维就喜欢看得见摸得着的，能清楚看清收益回报，也能付出实践的。</p>
<p>我个人还是更喜欢风口思维，因为确实难以忍受搬砖的枯燥，但找对风口后，要见成效确实得搬砖┭┮﹏┭┮</p>
<p><strong>激励</strong>来源：</p>
<p>要联系到后面讲的生理学：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164237881.png"  style="zoom:33%;" />

<p>内啡肽更长更持久，更有益身心健康，显然搬砖是后者。</p>
<p>人们往往习惯了多巴胺型快乐，它让人兴奋，但持续时间短，消散时会带来失落等负面情绪。</p>
<p>曾经物质不丰富，一般是一连串的内啡肽小快乐才等来一次多巴胺型大快乐。</p>
<p>但如今大刺激唾手可得，导致恶性循环👇：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809164639424.png"  style="zoom:33%;" />



<p>真正公式：</p>
<p><strong>日常搬砖获得内啡肽型愉悦感，达到了成功再允许自己激发一些多巴胺型的快乐，彻底放松一次</strong></p>
<p><strong>要是没有达到成果，那就忍着，这才是良性循环</strong></p>
<h3 id="工程分解结构"><a href="#工程分解结构" class="headerlink" title="工程分解结构"></a>工程分解结构</h3><p>把任意问题拆解，是工程学最核心的思维。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165010342.png"  style="zoom:33%;" />

<p>这也有一项孪生能力：focus</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809165516146.png" style="zoom:50%;" />

<p>focus like a laser, not like a flash</p>
<p>无限分解，直到找到抓手，从想-&gt;做就在那一瞬间，在脑科学里就是从一个新脑区的边缘神经元开始激活整个。</p>
<p>既见树木、也见森林</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170229459.png" alt="image-20210809170229459" style="zoom: 67%;" />

<hr>
<p><strong>应用：接触全新学科</strong></p>
<p>找到该领域最权威的教材，读目录，建框架</p>
<ul>
<li>读目录，查清所有不会的术语</li>
<li>推敲概念之间的关系，建立宏观全局框架</li>
</ul>
<p>这是知的部分，全局了解也是非常重要的。</p>
<hr>
<p>这才是知行合一，我就是那种喜欢看全局，然后分解不到位，最后懒得搬砖的人哈哈哈</p>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809170731986.png" alt="image-20210809170731986" style="zoom:50%;" />

<p>一开始只想到房租、售价等几个变量</p>
<p>开始叙事，通过”讲故事“一步步推衍：</p>
<p>从开张开始，需要品牌，装修，开工后要培训，设备，原料。。。。</p>
<p>最后进行数学运算。</p>
<p>有两种厉害的商业思维分析框架，后面会讲：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171033121.png" alt="image-20210809171033121" style="zoom:50%;" />

<p>这件事其实非常简单，更何况我可是数学大佬。</p>
<p><strong>OKR模型</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171243197.png" alt="image-20210809171243197" style="zoom:67%;" />

<p>竖直分解目标，水平量化目标，案例：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809171352398.png" alt="image-20210809171352398" style="zoom: 50%;" />

<p>这也为行动力提高打下了坚实的基础！</p>
<h3 id="清单思维"><a href="#清单思维" class="headerlink" title="清单思维"></a>清单思维</h3><p>对应to do list 和 time schedule</p>
<p>非常简单，但极其有用</p>
<p>列出来有利于</p>
<ul>
<li>确定优先级</li>
<li>让人专注，有利于“聚焦”。</li>
<li>利于推敲，找到不严谨的地方</li>
<li>节省脑资源！！（我就因为这个当年开始列清单的，记得难受死了</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191126647.png" alt="image-20210809191126647" style="zoom:50%;" />

<p>to do表和时间表就像一个事情的两个维度，一个以任务为核心一个以时间为核心，推荐飞书表</p>
<h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><p>对大多数人来说，难度更多在 <strong>舍</strong></p>
<p>一般最多选两样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210809191611562.png" alt="image-20210809191611562"></p>
<p>工程思维：便宜+快  （反完美主义，反本能的</p>
<p>艺术思维：好</p>
<h2 id="三、系统论"><a href="#三、系统论" class="headerlink" title="三、系统论"></a>三、系统论</h2><p>可以用来分析公司？</p>
<p>工程思想是拆分的还原论，那么这里就是整体论</p>
<p>观点：如果不着眼于系统，只改变局部，最终可能总被系统拉回来，比如一个闭环系统👇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812003721985.png" alt="image-20210812003721985" style="zoom:33%;" />

<p> 系统论相当于是呈现这些“飞轮”的机制，让我们从整体把握这个逻辑</p>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a><strong>系统</strong></h3><p>很多实体通过相互 <strong>联系</strong> 形成了一个有运作规律的整体</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005240164.png" alt="image-20210812005240164" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812005306703.png" alt="image-20210812005306703" style="zoom:33%;" /></p>
<p><strong>要素</strong></p>
<p>+ 正信息  正能量  资产</p>
<p>-  负信息  负能量  负债    负信息是让世界变得更加混乱的信息，如谎言、谣言</p>
<p><strong>关系</strong></p>
<p>+ 加强  - 减弱</p>
<p><strong>四种循环</strong></p>
<p>正要素+正关系 = 良性循环</p>
<p>负要素+正关系 = 恶性循环</p>
<p>负要素+负关系 = 贤者时刻（纠错）</p>
<p>正要素+负关系 = 回归平庸（后两个都是均值回归）</p>
<p>滞后效应</p>
<p><strong>负循环</strong></p>
<p>因果分析法，<strong>找到</strong>生活中的负循环</p>
<p>利用杠杆解，主要矛盾</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812010338719.png" alt="image-20210812010338719" style="zoom:33%;" />

<p>复杂的模型（混沌），如果能找到关键变量，便能牵一发动全身，彻底重构整个系统</p>
<hr>
<p><strong>建立仪式！</strong></p>
<p>所谓仪式，一旦开始，剩下的步骤就不需要控制，利用惯性执行</p>
<p>这可以尽可能地减少我们大脑的意识消耗。</p>
<hr>
<p>建立良性循环</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011007405.png" alt="image-20210812011007405" style="zoom:33%;" />

<p>我也要建立对自己的信任！</p>
<p><strong>均值回归</strong>，人是难以突破社会的。。。我跳出了这个圈子，所以我认识的人还是有点少、、、</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011253657.png" alt="image-20210812011253657" style="zoom:33%;" />

<p>我大概会抛弃回报公平吧，回报什么的没啥意思。</p>
<p>草，滞后效应，我现在熬夜会搞得以后难受。。。。哎呀好气</p>
<p>价值投资！也是滞后效应，这就是“确定性啊”</p>
<h3 id="储蓄池"><a href="#储蓄池" class="headerlink" title="储蓄池"></a><strong>储蓄池</strong></h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011807899.png" alt="image-20210812011807899" style="zoom:50%;" />

<p>保护自己的缓冲地带</p>
<p>一个人何以扛过滞后效应，凭借的是</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812011901249.png" alt="image-20210812011901249" style="zoom: 50%;" />

<p>有储蓄机制的系统，也是一个有非常大适应力的系统。</p>
<p>这也引出好系统的三大特性：</p>
<ol>
<li>鲁棒性，可以<strong>建立模拟攻击（跳出舒适圈</strong></li>
<li>自组织，不依靠外部指令，按照某种内在规则自动自发地形成有序结构的一种现象(人体)</li>
<li>层次性，子系统，递归，封装思想（刚才的仪式</li>
</ol>
<h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>函数是这个世界上最美妙的事物之一。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210812012642329.png" alt="image-20210812012642329" style="zoom: 80%;" />

<p>对大部分人来说，二号区是最方便的，实用而且简单直观</p>
<p>教科书为了严谨才把定义搞得那么抽象。函数重要的能力是可视化</p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><h4 id="高特纳曲线"><a href="#高特纳曲线" class="headerlink" title="高特纳曲线"></a><strong>高特纳曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813094417037.png" alt="image-20210813094417037" style="zoom: 50%;" />

<p><strong>不要高估短期能发生的变化</strong></p>
<p><strong>不要低估长期能发生的变化</strong></p>
<p>这是由神经科学的人性曲线和物性曲线（逻辑斯蒂函数（sigmoid））叠加构成的。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095148856.png" alt="image-20210813095148856" style="zoom:33%;" />

<p>而逻辑斯蒂增长就是由指数增长+环境阻力构成的那个物种曲线hhh</p>
<h4 id="倒U曲线"><a href="#倒U曲线" class="headerlink" title="倒U曲线"></a><strong>倒U曲线</strong></h4><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813095346101.png" alt="image-20210813095346101" style="zoom:50%;" />

<p>可以用在生命机能等诸多现象中</p>
<p>正余弦函数——波动，周期</p>
<p>指数函数，跨过某个拐点，就开始起飞。</p>
<p>对数函数，玻璃顶的存在。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101214895.png" alt="image-20210813101214895" style="zoom: 50%;" />

<p>这只是个大概。</p>
<h2 id="五、脑科学"><a href="#五、脑科学" class="headerlink" title="五、脑科学"></a>五、脑科学</h2><p>又称神经科学，作为几乎所有研究人类行为的基础学科</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101722891.png" alt="image-20210813101722891" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813101844649.png" alt="image-20210813101844649" style="zoom:50%;" />

<p>爬行脑是很难主管调节的，比如褪黑素得用化学药物，是生存本能。</p>
<p>所谓的刻意练习，就是利用人类脑对哺乳脑的驯化过程</p>
<p>新皮质四大脑区：</p>
<p>额叶、顶叶、</p>
<h3 id="额叶"><a href="#额叶" class="headerlink" title="额叶"></a>额叶</h3><p>最核心区域，智慧所在</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102929814.png" alt="image-20210813102929814" style="zoom:33%;" />

<p>分好几个区：</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103133065.png" alt="image-20210813103133065" style="zoom:33%;" />

<p>ps: 布洛卡区和威尔尼克区就是语言中枢。</p>
<p>前额叶皮质是非常关键的部分，掌管诸多功能，最重要的是 <strong>社交和自控、专注</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813102334506.png" alt="image-20210813102334506" style="zoom:50%;" />

<p>实际上这个距离就是自控和延迟满足，但如今人们的自控能力发展较慢，取而代之的是高维信息处理能力变强，所以人们自控力要在30岁左右才达到巅峰</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103419281.png" alt="image-20210813103419281" style="zoom:33%;" />

<p>镜像神经元</p>
<p>负则模仿能力和社交能力，还有共情能力，还有音乐。</p>
<p>分布在前运动皮质和初级运动皮层。向下直接连着脑干、脊椎。</p>
<p>还分布在布洛卡区。所以语言和音乐学习的捷径就是浸泡在大环境里面模仿别人，而不是考试。。</p>
<p>顶叶</p>
<p>负则统筹和协调，空间想象力</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813103936139.png" alt="image-20210813103936139" style="zoom:50%;" />

<p>颞叶：语言理解，面部识别，洞察力，观察细节。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104113191.png" alt="image-20210813104113191" style="zoom:33%;" />

<p>枕叶：完全用于视觉</p>
<hr>
<h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>发现人类大脑里处理视觉的区域特别多！可视化yyds</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104345656.png" alt="image-20210813104345656" style="zoom:50%;" />

<p>依次激发更多的脑区！！</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104325285.png" alt="image-20210813104325285" style="zoom: 33%;" />

<p>单纯语言沟通效率是很低的。</p>
<h3 id="哺乳脑"><a href="#哺乳脑" class="headerlink" title="哺乳脑"></a>哺乳脑</h3><p>（女发达）<strong>边缘系统</strong>：长期记忆、情绪管理、<strong>嗅觉</strong>（跟这些有关，所以体香很重要）、性唤醒</p>
<p>（女尤其发达）<strong>扣带回区域</strong>：情感、焦虑、痛苦、自我调节、负面想象</p>
<p><strong>杏仁核</strong>：恐惧、愤怒、兴奋、战或逃</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813104933864.png" alt="image-20210813104933864" style="zoom: 50%;" />

<p>因此恐惧会抑制人类脑，再聪明也得服从本能，战或逃取决于过去的经历和基因。</p>
<p>可以通过训练，用经验告诉杏仁核不必恐惧，选择战而不是逃。</p>
<p>（商家最爱）<strong>基底神经节</strong>：操作技巧、习惯养成、奖赏系统、上瘾系统</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813105502624.png" alt="image-20210813105502624" style="zoom:33%;" />

<p>这个核是消费关键。</p>
<h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><p>刻意选择，不断重复。</p>
<p>就像是不同脑区的神经元链接，多次重复刺激以后形成坚固的道路</p>
<p>但关键步骤要放慢速度，可能调度更多的脑区观察这个过程。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210813110129493.png" alt="image-20210813110129493" style="zoom:33%;" />

<p>所以贴标签是不可取的。</p>
<h2 id="六、复杂性科学"><a href="#六、复杂性科学" class="headerlink" title="六、复杂性科学"></a>六、复杂性科学</h2><p>还原论或还原主义（英语：Reductionism，又译化约论），是一种哲学思想，认为复杂的系统、事物、现象可以将其化解为各部分之组合来加以理解和描述。</p>
<p>在哲学上，还原论是一种观念，它认为某一给定实体是由更为简单或更为基础的实体所构成的集合或组合；或认为这些实体的表述可依据更为基础的实体的表述来定义。” 还原论方法是经典科学方法的内核，将高层的、复杂的对象分解为较低层的、简单的对象来处理；世界的本质在于简单性。</p>
<p>复杂性科学兴起于20世纪80年代的复杂性科学，是系统科学发展的新阶段，也是当代科学发展的前沿领域之一。复杂性科学的发展，不仅引发了自然科学界的变革，而且也日益渗透到哲学、人文社会科学领域。复杂性科学为什么会赢得如此盛誉，并带给科学研究如此巨大的变革呢？主要是因为复杂性科学在<strong>研究方法论上的突破和创新</strong>。在某种意义上，甚至可以说复杂性科学带来的首先是一场方法论或者思维方式的变革。</p>
<ol>
<li>它只能通过研究方法来界定，其度量标尺和框架是<strong>非还原</strong>的研究方法论</li>
<li>它不是一门具体的学科，而是分散在许多学科中，是学科互涉的</li>
<li>它力图打破传统学科之间互不来往的界限，寻找各学科之间的相互联系、相互合作的统一机制</li>
<li>它力图打破从<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E5%8A%9B%E5%AD%A6">牛顿力学</a>以来一直统治和主宰世界的线性理论，抛弃<a href="https://baike.baidu.com/item/%E8%BF%98%E5%8E%9F%E8%AE%BA">还原论</a>适用于所用学科的梦想</li>
<li>它要创立新的理论框架体系或范式，应用新的思维模式来理解自然界带给我们的问题</li>
</ol>
<p>复杂性科学是指以复杂性系统为研究对象，以超越还原论为方法论特征，以揭示和解释复杂系统运行规律为主要任务，以提高人们认识世界、探究世界和改造世界的能力为主要目的的一种“学科互涉”(inter—disciplinary)的新兴科学研究形态。</p>
<p><u>某学者定义：运用跨学科方法，研究不同复杂系统中的<strong>涌现</strong>行为和<strong>统一性规律</strong></u></p>
<p>《复杂》 入门必读</p>
<p>《规模》 研究增长</p>
<p>《系统论》  系统论入门</p>
<hr>
<h3 id="复杂系统"><a href="#复杂系统" class="headerlink" title="复杂系统"></a>复杂系统</h3><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174046214.png" alt="image-20210815174046214" style="zoom:33%;" />

<ol>
<li>大量个体聚集</li>
<li>个体间的运作相对简单，但是叠加后产生群体的复杂行为</li>
<li>能通过不断进化，对环境产生适应性</li>
</ol>
<p>关键词：聚集，进化，适应性，涌现</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174524772.png" alt="image-20210815174524772" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815174958056.png" alt="image-20210815174958056" style="zoom:33%;" />

<p>这样简单的三条原则不断循环后，就能发挥超凡的作用。</p>
<p>这就是单体简单-&gt;群体智慧。</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815190757944.png" alt="image-20210815190757944" style="zoom:33%;" />



<h3 id="聚焦"><a href="#聚焦" class="headerlink" title="*聚焦"></a>*聚焦</h3><p>四段论：</p>
<ol>
<li><p>清理念头</p>
<p>整理、列出思绪，保证自己没有牵挂心无旁骛</p>
</li>
<li><p>忘我聚焦</p>
<p>进入超高效状态持续2个小时，完成大部分任务</p>
</li>
<li><p>刻意休息</p>
<p>只能玩，强迫自己玩，比如半个小时</p>
</li>
<li><p>惯性工作</p>
<p>接着大体完成的脉络继续，由于之前的基础，可以低能耗的工作。</p>
</li>
</ol>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>这里讲的是工程学里的迭代，尤其是软件开发里的敏捷开发。</p>
<p>找到自己的最小内核，一层一层递归、累加、迭代，最终涌现成为传奇</p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192540335.png" alt="image-20210815192540335" style="zoom: 25%;" />

<p>在3.0才找到拐点，我们要抱着正确的心理预期，不是每一次迭代都能升级。</p>
<p><strong>精益创业</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192654391.png" alt="image-20210815192654391" style="zoom:25%;" />



<p><strong>适应性</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/image-20210815192932647.png" alt="image-20210815192932647" style="zoom:33%;" />

<p>过犹不及。。彻底失败</p>
<h2 id="七、认知心理学"><a href="#七、认知心理学" class="headerlink" title="七、认知心理学"></a>七、认知心理学</h2><p>认知心理学（cognitive psychology），20 世纪 50 年代中期在西方兴起的一种心理学思潮和研究方向。广义指研究人类的高级心理过程，主要是认识过程，如注意、知觉、表象、记忆、创造性、问题解决、言语和思维等。狭义相当于当代的信息加工心理学。即采用信息加工观点研究认知过程。</p>
]]></content>
      <categories>
        <category>thought</category>
      </categories>
  </entry>
  <entry>
    <title>黑马dom&amp;bom预习</title>
    <url>/2021/04/02/%E9%BB%91%E9%A9%ACdom&amp;bom/</url>
    <content><![CDATA[<p>为了应付俩招新而学学黑马</p>
<p>结果学着学着忘记原先目的了。。。</p>
<p>既然都记了这么多了</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330093612480.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330093644248.png"  style="zoom:50%;" />



<p><strong>构造函数首字母大写</strong></p>
<p>this！</p>
<p>!(<a href="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330213907799.png">https://gitee.com/darren-greenhand//picture/raw/master/image-20210330213907799.png</a>)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330214012724.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330225348643.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330225823667.png"></p>
<p>其实函数也能遍历到，但是很少用</p>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><p>对象分：自定义，内置，浏览器对象</p>
<p>前俩是ES里的，浏览器对象是JS独有的</p>
<p>内置对象就是JS自带的，提供了最常用的和最基本的功能</p>
<p>可以查询MDN文档</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330231721351.png"></p>
<p>Math.random()返回一个随机小数 0&lt;= x &lt; 1</p>
<p>MDN提供了以此为基础的得到各种随机数的方法</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>元素是标签</p>
<p>节点：所有内容，标签，属性，。。。</p>
<p>DOM把所有内容看作对象</p>
<p>因为文档页面从上往下加载，所以script</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330233811008.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330234121849.png"></p>
<p>如果没有</p>
<p>小心不要把伪数组当初对象哟</p>
<p>document.querySelector 返回指定选择器的第一个元素对象</p>
<p>document.querySelectorAll</p>
<p>获取<strong>body</strong>直接document.body，HTML 是documentElement</p>
<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><p>事件是可以被JS侦测到的行为</p>
<p>是一种触发–响应机制</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235606717.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235841646.png"></p>
<h2 id="改变内容"><a href="#改变内容" class="headerlink" title="改变内容"></a>改变内容</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210330235939513.png"></p>
<p>innerHTML是W3C推荐的</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331000356033.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331001227962.png"></p>
<p>所以标签的属性在DOM中被当作属性</p>
<p>记得表单里显示的内容是value属性</p>
<h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p><strong>行内样式（优先级最高）</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331084125584.png"></p>
<p>循环精灵图</p>
<p>onfocus</p>
<p>onblur</p>
<p>提前准备好另一个类，然后修改类名</p>
<p>element.className = “change”</p>
<p>这会覆盖原先的类名</p>
<p>不想覆盖则 .class<strong>Name</strong> += “ new”</p>
<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>先清除其他所有，再给自己设置</p>
<p>onmouseovr          onmouseout</p>
<h2 id="获得属性"><a href="#获得属性" class="headerlink" title="获得属性"></a>获得属性</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331234557420.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331234830475.png"></p>
<p>.removeAttribute(‘index’)</p>
<p>display none/block</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210331235859797.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401000324162.png"></p>
<p><strong>自定义属性</strong>（在页面而不是服务器存储并使用数据）</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401000808430.png"></p>
<p>ie11以上才有dataset，一般使用getAttribute</p>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="获得节点"><a href="#获得节点" class="headerlink" title="获得节点"></a>获得节点</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401001133305.png"></p>
<p>dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>f1<span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> f2<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// Object &#123;f1: "foo", f2: "bar"&#125;</span>

console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>f1<span class="token operator">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> f2<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// Object</span>
<span class="token comment">//   f1: "foo"</span>
<span class="token comment">//   f2: "bar"</span>
<span class="token comment">//   __proto__: Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富。</p>
<p>该方法对于输出DOM对象非常有用，因为会显示DOM对象的所有属性。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401001628811.png"></p>
<p><strong>父子关系</strong></p>
<p>node.parentNode(离元素最近的父级节点，找不到返回null)</p>
<p>.node.childNodes()集合(包含元素节点和文本节点等等)，用nodetype加以筛选</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401103705538.png"></p>
<p>非官方但是被广泛支持<strong>：.children</strong>(集合)</p>
<p>.firstChild    .lastChild   这个会返回（元素节点或文本节点，超坑的是换行也是一个文本节点！）</p>
<p>兼容性问题👇IE9</p>
<p>.firstElementChild</p>
<p>.lastElementChild</p>
<p>兄弟节点用的很少</p>
<p>实际开发写法还是用ol.children[0]和ol.children[ol.children.length-1]或者自己知道数量</p>
<p>.node.nextSibling </p>
<p>.node.previousSibling</p>
<p>这俩也会看到文本节点</p>
<p>兼容性问题👇IE9</p>
<p>.node.nextElementSibling</p>
<p>node.previousElementSibling</p>
<h3 id="创建添加节点"><a href="#创建添加节点" class="headerlink" title="创建添加节点"></a>创建添加节点</h3><p>document.createElement(‘li’)</p>
<p>node.appendChild(child) node 父级  child子级</p>
<p>这是后面追加元素</p>
<p>node.insertBefore()</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401152243420.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401155757774.png"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.removeChild() 删的必须是子元素，</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401153308442.png"></p>
<h3 id="复制添加节点"><a href="#复制添加节点" class="headerlink" title="复制添加节点"></a>复制添加节点</h3><p>new = node.cloneNode()</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401154336923.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401160340035.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401160426412.png"></p>
<h1 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h1><h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401162928938.png"></p>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401164058073.png"></p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401164303889.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165042532.png"></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165508731.png"></p>
<p>兼容性问题 e = <strong>e||window.event</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401165948856.png"></p>
<p>event有个类似this的属性 currentTarget,没啥鬼用</p>
<p><strong>兼容性问题处理👇</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401170039029.png"></p>
<p><strong>阻止默认行为</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401170434080.png"></p>
<p>或者直接return false; 谁都能用但是return后的代码不执行，而且只用于传统的注册方式</p>
<p>直接preventDefault吧，</p>
<p><strong>阻止冒泡</strong></p>
<p>event.stopPropagation(); 兼容性问题。。</p>
<p>event.cancelBubble;老版本</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172331089.png"></p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172602216.png"></p>
<p>配合e.target就很牛逼</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401172819901.png"></p>
<h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><h3 id="禁止右键和选中文字"><a href="#禁止右键和选中文字" class="headerlink" title="禁止右键和选中文字"></a>禁止右键和选中文字</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401193332860.png"></p>
<p>然而做得好的网站也不知道用什么方法防住了偷取内容。。</p>
<h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p>MouseEvent</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401194638742.png"></p>
<p>mousemove 鼠标移动1px就会触发</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401195727163.png"></p>
<p>记得css修改img为position: absolute</p>
<h3 id="键盘数据对象"><a href="#键盘数据对象" class="headerlink" title="键盘数据对象"></a>键盘数据对象</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401200249491.png"></p>
<p>如果一直按着，down和press会一直输出。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401200749931.png"></p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401202950239.png"   />



<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205111068.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205237508.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205457047.png"></p>
<p>所以不要声明名叫name的全局变量</p>
<h2 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h2><p><strong>窗口加载</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205732846.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401205907695.png"></p>
<p><strong>调整窗口大小</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210145839.png"></p>
<p>只要大小像素变化就会触发resize</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><em><strong>定时器</strong></em></h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210627622.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210647133.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401210753231.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401211057397.png"></p>
<p>拯救男主角  clearTimeout(timerID)</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401211607592.png"></p>
<p><strong>倒计时！</strong></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401212252996.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401212543518.png"></p>
<h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401213938731.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401214513695.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401214628030.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215019237.png"></p>
<p>如定时器3秒，就是3秒后吧事件放到任务队列中</p>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215151934.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401215422449.png"></p>
<p>传递参数</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220658628.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220733210.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401220946122.png"></p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator.userAgent对象存储了用户使用的浏览器的信息</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401221612109.png"></p>
<h1 id="网页特效"><a href="#网页特效" class="headerlink" title="网页特效"></a>网页特效</h1><h2 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401221901011.png"></p>
<p>在用后面俩的时候记得加上 + ‘px’</p>
<p>没有带定位的父亲则以一直网上找直到。。body</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401222324755.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401222559804.png"></p>
<h3 id="拖动模态框"><a href="#拖动模态框" class="headerlink" title="拖动模态框"></a>拖动模态框</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401230220830.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401230651020.png"></p>
<h3 id="电商放大图"><a href="#电商放大图" class="headerlink" title="电商放大图"></a>电商放大图</h3><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231203726.png"></p>
<p>大图片是一个图片，overflow:hidden</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231551677.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401231934835.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401232233398.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401232246907.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401233200379.png"></p>
<h2 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h2><p>可视区</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401233316513.png"></p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>无需调用，立马自己执行的函数，第二个小括号可以看成是调用函数</p>
<p>最大的作用是独立创建了个作用域</p>
<ol>
<li><p>(function () {} )  ()</p>
<p>如 (function (a.b) {console.log(a+b); } )  (1,2)  //传参</p>
</li>
<li><p>(function () {} () )</p>
</li>
</ol>
<p>很多flexble核心源码是有关这个的</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401234824479.png"></p>
<h2 id="Scroll系列"><a href="#Scroll系列" class="headerlink" title="Scroll系列"></a>Scroll系列</h2><p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235104065.png"></p>
<p>onscroll事件，滚动事件</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235720069.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210401235854824.png"></p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210402000122850.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20210402000256076.png"></p>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210402000309513.png"></p>
]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript理论</title>
    <url>/2021/03/18/Javascript/</url>
    <content><![CDATA[<p>[toc]</p>
<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327151203222.png"  style="zoom:50%;" />

<img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327151652147.png"  style="zoom:50%;" />

<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327153158993.png"></p>
<p>第一门课主要学习JS语法，但是最好还是之后看一下JS红宝书</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327153407994.png"></p>
<h2 id="1-简史"><a href="#1-简史" class="headerlink" title="1.简史"></a>1.简史</h2><p>这是我去先看了看红宝书第一章</p>
<p>JS被用于处理表单内容，但让网景公司成为了老大，微软眼红并仿写出了JScript，这是一个基于JS的实现，但由于两者不统一，最后1997年Ecma（欧洲计算机制造商协会）的TC39委员会制定出标准，花费数月时间出台了传说中的ECMA-262,也就是ECMAScript伪语言，<strong>此后，各浏览器以此作为实现的依据，但是他们的实现仍有偏好性</strong></p>
<p>虽然JS和ECMAScript基本是同义词，但是完整的JS实现应包含：</p>
<ol>
<li>核心  ECMAScript</li>
<li>文档对象模型  DOM</li>
<li>浏览器对象模型  BOM</li>
</ol>
<p>ECMAScript连输入输出都没有，他只是一个基准</p>
<p><strong>Web浏览器是其实现的一种宿主环境（node.js也是一种），提供ECMAScript的基准实现和与环境自身交互必须的拓展！</strong></p>
<p>拓展，比如DOM，使用ECMAScript核心类型和语法，提供特定于环境的额外功能，</p>
<p>ESMAScript描述了这门语言的：<strong>语法，类型，语句，关键字，保留字，操作符，全局对象</strong></p>
<p>现在都到ES12了。。。。</p>
<p>ECMAScript的符合性具备极大的自由度，给了实现开发者很大的权限！</p>
<p><strong>好多东西没写，一定要到时候好好看看红宝书，太棒了！</strong></p>
<h2 id="2-Html中的JS"><a href="#2-Html中的JS" class="headerlink" title="2.Html中的JS"></a>2.Html中的JS</h2><p>看不懂。。等以后</p>
<h2 id="3-语言基础"><a href="#3-语言基础" class="headerlink" title="3.语言基础"></a>3.语言基础</h2><p>我还是结合着看吧，红宝书全，但是视频有实战经验。</p>
<h3 id="嵌入HTML"><a href="#嵌入HTML" class="headerlink" title="嵌入HTML"></a>嵌入HTML</h3><p>主要方法是&lt;script&gt;方法，后来被正式加入到HTML规范，他有8个属性，没几个看得懂</p>
<p>但是defer这个属性使得script不用放在body前（兼容性不好，而且有时候可能出现顺序错乱，最好是只有一个这样的脚本，<strong>更好还是放在body的最后。。。</strong>），src允许使用外部js文件，integrity防止你在引用其他网站js文件时接受到恶意内容，async有很多限制，不推荐使用。。。</p>
<p><img src="https://gitee.com/darren-greenhand//picture/raw/master/image-20210327163947742.png" alt="image-20210327163947742"></p>
<p>从上到下解释，浏览器解析行内脚本的方式决定了即使字符串出现&lt;/script&gt;也会结束！</p>
<p>浏览器按照script出现的顺序解释他们，除了defer和async属性。</p>
<p>引用外部时，script标签之间绝对不能写代码</p>
<p>还有一些比如“文档模式”啥的鬼东西，看不懂。。。</p>
<p>&lt;noscript&gt;元素用于优雅降级，先用于那些金庸JS的浏览器，在浏览器不支持脚本或者支持被关闭时，将会渲染在noscript标签中的内容，否则则会被忽视掉，</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>单行注释//   对应快捷键 ctrl + /</p>
<p>多行注释和c语言一样，是/* <em>/ ,对应快捷键*<em>ctrl+shift+/</em></em>  改了以后</p>
<p>左下角设置可以直接更改快捷方式</p>
<p><strong>Js标识符可使用 字母  数字   下划线   美元符号   但是开头不能是数字，惯例是驼峰大小写！</strong></p>
<p>严格模式</p>
<p>所有浏览器都支持严格模式，会在遇到不规范写法时抛出错误</p>
<p>在整个脚本或者某个具体函数开头加上 <code>“use strict”;</code> 来开启</p>
<p>分号不是必须，但是有助于防止很多问题，也有利于压缩代码，提升性能等</p>
<p>和C一样，也用{}标识一个代码块</p>
<p>if类语句和C一样在多条时，必须要代码块，但好习惯是一句也要加代码块</p>
<p>很多关键字都在各个语言见过，没见过的有</p>
<p>catch   delete   extends   finally   instanceof   super   throw </p>
<p>还有一些未来的保留字</p>
<p>enum  implements  interface  let  package  protected  await</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量松散，可以存储任何类型数据，ES6之后才可以用let  const ，var啥时都能用</p>
<p>基本使用无二，不知道为啥说不推荐改变变量存储的类型，但是完全有效</p>
<p>在函数内部var会创建局部变量，但是省略var可以创建一个全局变量！</p>
<p>但是这种做法不被推荐，甚至在严格模式下会抛出ReferenceError</p>
<p>*<strong>var声明提升！</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    语句<span class="token number">1</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
实际上被ECMAScript理解为
<span class="token keyword">var</span> age<span class="token punctuation">;</span>
语句<span class="token number">1</span><span class="token punctuation">;</span>
age <span class="token operator">=</span> <span class="token number">26</span>
这使得变量可以后声明，也使得变量可以重复声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>var的作用域是函数作用域，if块中声明的var可在外面调用</p>
<p>let声明的范围是块作用域，而且<strong>不允许冗余声明</strong>（<strong>SyntaxError</strong>）</p>
<p>但是由于JS引擎会记录变量声明的标识符和所在的块作用域，可以嵌套使用相同的标签</p>
<p><strong>冗余报错会发生在同时使用var和let时，两个关键字声明的变量是相同的，只是指出变量在相关作用域如何存在。</strong></p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  tmp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
  <span class="token keyword">let</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<p>这甚至会导致typeof出错，</p>
<p><strong>与var关键字不同，let在全局作用域中声明的变量不会成为window对象的属性？不懂。。</strong></p>
<p>const声明时必须同时初始化，而且不能修改，限制只适用于它指向的变量的引用，跟python一样</p>
<p>对for-of  for-in循环中的不会修改的变量特别有意义</p>
<h4 id="风格和最佳实践！"><a href="#风格和最佳实践！" class="headerlink" title="风格和最佳实践！"></a>风格和最佳实践！</h4><ol>
<li>不使用var</li>
<li>const优先，let次之</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>对象的转换：<em><strong>如果操作数是对象，则这个对象将先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换；</strong></em></p>
<p>6种原始(简单)数据类型：Undefined Null Boolean Number String Symbol(ES6)</p>
<p>1种复杂数据类型：Object，这是一种无序名值对的集合</p>
<p>ES中不能定义自己的数据类型，但这些类型很灵活，一种能当多种数据类型用</p>
<p>typeof <strong>操作符，它不是函数</strong>，返回数据类型，也可以判断函数（返回’function’）</p>
<p>虽然函数也被ES认为是对象，但它们有特殊的属性，因此被typeof独立区分</p>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>只有一个值undefined, var/let声明对象但未初始化就会赋予undefined</p>
<p>他理论上永远不用与显式赋值，只是为了<em><strong>区别空对象指针null和未初始化指针</strong></em></p>
<p><strong>但由于未声明的变量typeof也会返回undefined，所以最好还是在声明时就初始化</strong></p>
<p>这是一个假值，但是也有很多其他的假值，所以不要依靠真假判断是否是undefined</p>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>只有一个值null，<strong>逻辑上讲，null值表示一个空对象指针，</strong>所以typeof null返回object</p>
<p>null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p>
<p>声明时如果暂时不用赋值，最好赋一个null</p>
<p>undefined是由null值派生的，所以表面相等(null == undifined)</p>
<p>这是一个假值，但是也有很多其他的假值，所以不要依靠真假判断是否是null</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>俩值，true  false，但是此处的布尔值不同于数值，所以不再是等于 1 和 0（哈哈，特意提醒）</p>
<p>所有类型的值都有相应布尔值的等价形式，通过Boolean（）转型函数转换</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>true值</th>
<th>false值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>非零值（<strong>包括无穷</strong>）</td>
<td>0  NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td></td>
<td>undefined</td>
</tr>
</tbody></table>
<p>非常重要，因为if等流控制语句会自动执行该转换</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>整数</p>
<p>八进制和十六进制规则和C一样，但是八进制如果写错了直接忽略0当成十进制，数学操作中都当成十进制</p>
<p><strong>严格模式不能使用八进制前缀0，要用0o</strong></p>
<p>由于JS保存数值的方式，会存在正零，负零，是等价的</p>
<p>浮点数</p>
<p>存储空间是整数两倍，所以JS会尽可能把它们变成整数，如果小数点后为0，<strong>直接给你改成整数</strong>(如21.0)</p>
<p>ES会将小数点后至少6个0的浮点数转换为科学计数法</p>
<p>浮点数精确度高达17位小数，但是也存在如C般很小的偏差问题，因此不要用 == 对待浮点数</p>
<p>这是IEEE 754数值标准导致的。。</p>
<p>最小值Number.MIN_VALUE  5e-324  再小 -Infinity（Number.NEGATIVE_INFINITY）</p>
<p>最大值Number.Max_VALUE 1.79………………e+308, 再大 Infinity（Number.POSITIVE_INFINITY）</p>
<p>0作分子返回NaN（not a number） 作分母返回正负Infinity</p>
<p>NaN有一些诡异的属性：</p>
<ol>
<li>任何涉及NaN的操作始终返回NaN(如NaN/10)</li>
<li>NaN不等于包括自己在内的任何值！</li>
</ol>
<p>数值转换：</p>
<p>Number()   parseInt()   parseFloat()</p>
<p>Number的转换规则和一元加操作符一样，值得注意的是：</p>
<p>null返回0，undefined返回null。空字符串返回0</p>
<p>字符串包含有效的16进制，会转化成对应的<strong>十进制值。</strong></p>
<p>如果字符串包含正常情况外的词，返回NaN。</p>
<p>对于对象：先调用valueof（）方法，再按照正常规则转换，如果结果是NaN，则先调用toString，再按字符串规则转换。</p>
<p>所以必须用于十分标准的字符串才能得到合适输出，所以一般优先采用下面俩方法</p>
<p>parseInt规则：</p>
<p>跳过空白，开始检索，第一个不是数值，加减号，返回NaN,否则开始检索至结束或非法。</p>
<p>未加第二个参数则检索0x开头，0开头，最好加上，可以省略前缀</p>
<p>parseInt(“10100101”, 2),表示按<strong>二进制解析！</strong></p>
<p>parseFloat类似，但忽略开头的0，只用于十进制，若结果为整数，会返回整数</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>可用单，双，没有语法意义。。。pink推荐使用单引号</p>
<p>转义字符（字符字面量）（算一个字符）基本无二，\xnn ASCII   \unnnn  nnnn表示Unicode字符</p>
<p>字符串是不可变的！任何更改都导致原字符串销毁</p>
<p>toString方法可用于数值，布尔值，对象，字符串值（返回副本），</p>
<p><strong>null/undefined没有,调用则返回本身的字符串null-&gt;”null”</strong></p>
<p>在对待数值时可以指定显示的进制 </p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">-</span><span class="token string">"1010"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>模板字面量</strong></p>
<p>通过<strong>反引号定义（但是这里书写用单引号。。不然变成代码块我靠）</strong>，保留内部的空白结构</p>
<p>技术上讲，模板字面量不是字符串而是一种特殊的JS句法表达式，只不过求之后得到的是字符串</p>
<p><strong>字符串插值</strong></p>
<p>模板字面量求值时立刻转换成字符串实例，任何插入的变量也会从它们最接近的作用域中提取</p>
<p>‘${}’来进行调用，可以变量，会将表达式用toString转化成字符串，可以调用函数和方法，可以插入自己以前的值</p>
<p>value = ‘${value}abc’  附加abc</p>
<p><strong>标签函数</strong></p>
<p>用来自定义插值行为，直接把定义的函数放在模板字面量前即可</p>
<p>function xxx(){}</p>
<p>let a = xxx’….’</p>
<p>注意传进去的第一个参量是[“”,”+”,]这种，其中所有的$被换成空字符串，符号保留，经常采用“剩余操作符”收集不确定的参数</p>
<p>原始字符串则调用了默认的String.raw标签函数,也可通过string(某字符串变量).raw来取得原始内容</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ES6新增，符号是原始值，符号实例唯一，不可变</p>
<p>用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
<p>符号需要使用Symbol（）函数初始化，</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>JS对象实质是一组数据和功能的集合，通过new+对象类型的名称来创建</p>
<p>可以通过创建Object实例来创建对象，再添加属性和方法</p>
<p>每个对象内置了一大堆方法，<strong>p56</strong></p>
<p>valueof方法将对象转换为原始值。你很少需要自己调用<code>valueOf</code>方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。如果对象没有原始值，则<code>valueOf</code>将返回对象本身。JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。此外你也可以自己写valueof来覆盖</p>
<table>
<thead>
<tr>
<th align="left"><strong>对象</strong></th>
<th align="left"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回数组对象本身。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符串值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Math 和 Error 对象没有 valueOf 方法。</td>
</tr>
</tbody></table>
<p>你可以在自己的代码中使用<code>valueOf</code>将内置对象转换为原始值。 创建自定义对象时，可以覆盖<code>Object.prototype.valueOf()</code>来调用自定义方法，而不是默认<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>方法。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">MyNumberType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">valueOf</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> customPrimitiveValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>ES中的操作符可用于各种类型的值，在处理对象时会调用valueOf和toString来处理（C++重构吗）</p>
<p>因为数据类型有限，不会出现重构等问题，因此符号的所有规则都可以列出来！</p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>++  – 和C差不多，可用于任意值，应用后均变为数值类型</p>
<p>字符串非法则NaN,false和true变成0和1，对象先调用valueof（）方法，再按照正常规则转换，如果结果是NaN，则先调用toString，再按字符串规则转换。</p>
<p>+ and  - 会对非数值进行Number（）转换，</p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>虽然实际64位，但位操作时仅应用32位，第32位<strong>0正1负</strong>，无符号数就大一倍。</p>
<p>正值前31位正常，负值则是补码。（这里称二补数）</p>
<p><strong>但特殊值NaN和Infinity在位操作中被当成0</strong></p>
<p>C有的这里都有！右移使用符号位来填补空位，无符号右移<code>&gt;&gt;&gt;</code>则用0来填补！</p>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><p>非操作符 ！ 无论对什么数据类型，先转换成布尔值，然后取反</p>
<p>！！ 相当于调用Boolean（）</p>
<p>&amp;&amp;逻辑与可以用于任何类型的操作数，不限于布尔，同样具有短路特性，如果操作数不全为布尔，则逻辑与并不一定返回布尔值：</p>
<ul>
<li>如果第一个操作数是对象，返回第二个操作数</li>
<li>如果两个操作数都是对象，返回第二个操作数</li>
<li>如果第二个操作数为对象，只有第一个操作数为true时才会返回该对象</li>
<li>只要出现null/NaN,undefined,就返回相应的</li>
</ul>
<p>||逻辑或，也会短路，如果操作数不全为布尔，则同样：</p>
<ul>
<li>如果第一个操作数是对象，返回第一个操作数</li>
<li>如果第一个操作数求值为false，则返回第二个操作数</li>
<li>如果第两个操作数是对象，返回第一个操作数</li>
<li>如果俩都为null/NaN,undefined,就返回相应的</li>
</ul>
<h4 id="乘性运算符"><a href="#乘性运算符" class="headerlink" title="乘性运算符"></a>乘性运算符</h4><p>*  也会在处理非数值自动调用Number（）</p>
<p>特性：</p>
<ul>
<li>任意操作数NaN返回NaN</li>
<li>Infinity * 0  -&gt;NaN</li>
<li>Infinity相乘，或乘有限数，返回+-Infinity</li>
</ul>
<p>/   特性:</p>
<ul>
<li>有NaN,返回NaN</li>
<li>无限除无限返回NaN</li>
<li>无限除有限（包括0）返回对应无穷</li>
<li>0 / 0 返回NaN</li>
<li>有限值 / 0 返回正负无穷</li>
</ul>
<p>% ：</p>
<ul>
<li>无限除任何 NaN</li>
<li>有限除 0 NaN</li>
<li>有限除无限  有限</li>
<li>0除 非0  0</li>
</ul>
<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><p>**  和  **==</p>
<h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><p>+   注意：</p>
<ul>
<li>有NaN 返回NaN</li>
<li>无穷+负无穷  返回NaN</li>
<li>0相加，都是-0返回-0，否则返回+0</li>
<li>俩字符串则拼接</li>
<li>不然就转换成字符串，如果有undefined和null，变为”undefined”然后再拼接</li>
</ul>
<p>-  注意：</p>
<ul>
<li>同类无穷相减（其实就是难以判断正负的时候）为NaN</li>
<li>无穷相减，可判断正负则返回对应无穷</li>
<li>0相减，同号得正0，异号得-0</li>
<li>会转化成数值而不是字符串，对象也是和以前一样的处理</li>
</ul>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>还是四个，只返回布尔值</p>
<ul>
<li>出现数值，全转为数值比较</li>
<li>都是字符串则逐个比较（大写字母比小写字母顺序小）</li>
<li>对象先调用valueof（）方法，再按照正常规则转换，如果没有valueof操作符，则调用toString，再按字符串规则转换。</li>
<li>布尔被转化为0和1</li>
<li><strong>只要出现NaN，结果就为false</strong></li>
<li>null和undefined好像也是</li>
</ul>
<p>1、大于运算符</p>
<p>　　　　大于运算符的操作数可能是任意类型，然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换。规则如下：</p>
<p>　　　　如果操作数是对象，则这个对象将先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换；</p>
<p>　　　　 在对象转换为原始值之后，如果两个操作数都是字符串，则按照字母表的顺序对两个字符串进行比较，这里提到的字母表顺序是指组成这个字符串的16位unicode字符的索引顺序；</p>
<p>　　　　 在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换成数字进行比较。</p>
<p>　　　　需要注意的是Javascript字符串是一个由16位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值比较，由unicode定义的字符编码和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。字符串比较是区分大小写的，所以一般首先会将字符串通过String.toLowerCase()或者是String.toUpperCase()做大小写的转换。</p>
<p>　　　　2、大于等于运算符</p>
<p>　　　　大于等于运算符并不依赖于大于或等于运算符的比较规则，而是遵循小于运算符的比较规则，结果取反</p>
<p>　　　　3、小于等于运算符</p>
<p>　　　　小于等于运算符(&lt;=)并不依赖于小于或等于运算符的比较规则，而是遵循大于运算符的比较规则，结果取反。</p>
<p>　　　　4、小于运算符</p>
<p>　　　　小于运算符(&lt;)用于比较两个操作数，如果第一个操作数小于第二个操作数，则小于运算符的计算结果为true，否则为false。</p>
<hr>
<p>所以要考虑到底是不满足条件，还是出现了NaN</p>
<p>大写字母的排序在小写字母前面，所以偏小</p>
<p>按照规则，null和undifined</p>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><p>两组，等于和不等于 == ，  全等和不全等 ===</p>
<p>第一组进行强转再判断：</p>
<ul>
<li>布尔-&gt;数值</li>
<li>字符串比数值，字符串-&gt;数值</li>
<li>对象，用valueof对象再比较</li>
<li>null ==  undefined</li>
<li>null   undefined不能转化为其他类型的值再比较，因此不等于false，因为false-&gt;0</li>
<li>有NaN就返回false，不相等返回true</li>
</ul>
<p>全等不转换！null !== undefined  因为数据类型不同</p>
<p>条件运算符 () ?  :</p>
<p>赋值运算符 &gt;&gt;&gt;=</p>
<p>逗号运算符</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>也称流控制语句</p>
<p>if中自动调用Boolean，也有do-while，while，swtich(break规则一样的)</p>
<p><strong>for - in</strong>是一种严格的迭代语句，用于枚举对象中的<strong>非符号键属性</strong>（如window对象的属性）</p>
<p>for(const property in expression) {statement;}</p>
<p>这里的const不是必须的，但是为了确保局部变量不被修改，推荐使用const</p>
<p>ES中的对象属性是无序的，for-in不能保证返回的顺序，甚至因浏览器而异</p>
<p>如果迭代的变量是null / undefiend 则不执行循环体</p>
<p><strong>for-of</strong> 是一种严格的迭代语句，用于遍历<strong>可迭代对象的元素</strong>(如数组项)</p>
<p>for(const property of expression) {statement;}若尝试迭代的变量不支持迭代则抛出错误</p>
<p><strong>标签语句</strong></p>
<p>在语句前可以通过标签语句加标签，常用于嵌套循环中</p>
<p>break和continue + 标签可以生效后跳到label位置</p>
<p><strong>with语句</strong>将代码作用域设置为特定的变量</p>
<p>严格模式下不允许使用with</p>
<p>with(location){………}</p>
<p>在with语句内部，每个变量首先被认为是局部变量，如果不是，就搜索location对象，看他是否有一个同名属性，使得话，该变量就被求值为location对象的同名属性</p>
<p>swtich特性：</p>
<p>可以用于所有数据类型，case后面不加括号，可以加表达式！</p>
<p>甚至可以swtich(true)然后case里面放一堆判别式，<em><strong>不过case判断是全等！</strong></em></p>
<p>与多if相比，switch效率高，适合情况较多且比较确定，多if适合范围判断，情况较少</p>
<p>函数</p>
<h2 id="4-变量，作用域-内存"><a href="#4-变量，作用域-内存" class="headerlink" title="4.变量，作用域/内存"></a>4.变量，作用域/内存</h2><p>变量可存储两种类型的数据：原始值，引用值（由多个值构成的对象）</p>
<p>分别采用按值访问和按引用访问,<strong>很多语言中字符串是使用对象访问的,因此被认为是引用类型,但是ES不是</strong></p>
<p>引用值可以随意添加,修改和删除属性和方法</p>
<p>原始值不能有属性,但是添加时不会报错,但试图引用会返回undefined.</p>
<p>复制的时候,原始值是复制,引用值是引用原来内存里的变量,而不是创建副本</p>
<p><strong>但是所有函数的参数都是按值传递的</strong>,只不过引用值传进去的时候传的是一个指向（类似指针），所以在里面修改外面也能体现，但仍然是按值传递。</p>
<p>typeof能区分是否是对象,但是它却不能区分对象的具体类型，对引用值意义不大</p>
<p>instanceof对给定引用类型的对象十分有用,比如 person instanceof Object  变量person是Object吗?</p>
<p>所以该操作符检测任何引用值和Object构造函数都会返回true,但是检测原始值则始终返回false</p>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>变量或者函数的上下文决定了可以访问的数据和行为.全局，函数，块级</p>
<p><strong>每个上下文都有一个关联的变量对象</strong>，虽然代码无法访问，但是后台处理数据可能用到</p>
<p>全局上下文是最外层的，根据实现的宿主，可能对象不一样，在<strong>浏览器中全局上下文是window对象</strong></p>
<p><strong>所有通过var方法定义的全局变量和函数都会成为对象的属性和方法</strong></p>
<p>上下文在其所有代码执行完成后会销毁，包括所有定义在它上面的变量和函数，全局上下文则在应用程序退出前才会销毁，比如关闭网页或者退出浏览器，函数参数被视为当前上下文的变量</p>
<p>上下文的代码在执行的时候，会创建变量对象的一个作用域链，从当前上下文往外直到全局上下文</p>
<p>自己理解下吧。。。</p>
<p><a href="https://knightyun.github.io/2019/09/02/js-hoisting#:~:text=%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%20%E6%98%AF%20JavaScript,%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A4%A7%E8%87%B4%E5%B0%B1%E6%98%AF%E5%AD%97%E9%9D%A2%E6%84%8F%E6%80%9D%EF%BC%8C%E5%B0%86%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E6%8F%90%E5%89%8D%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%8C%87%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E6%94%B9%E5%8F%98%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E8%80%8C%E6%98%AF%E5%B0%86%E5%8F%98%E9%87%8F%20%E6%8F%90%E5%89%8D%20%E6%94%BE%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E4%BE%9B%E5%90%8E%E7%BB%AD%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%8B%E9%9D%A2%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%9B">变量提升</a></p>
<p>个人理解，声明被提升到最前面，而赋值仍留在原地</p>
<p><strong>作用域增强？</strong></p>
<p>通常有两种情况：</p>
<ul>
<li>with(location)的location对象会被添加到作用域链的前端。</li>
<li>try/catch 回创建一个新的变量对象，该对象包含即将抛出的错误的声明。</li>
</ul>
<p><strong>执行上下文的生命周期</strong></p>
<p>执行上下文的生命周期包括三个阶段：<strong>创建阶段 → 执行阶段 → 回收阶段</strong>，本文重点介绍创建阶段。</p>
<ol>
<li>创建阶段</li>
</ol>
<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>
<ul>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。下文会详细说明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>
<li>确定 this 指向：包括多种情况，下文会详细说明</li>
</ul>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p>
<ol start="2">
<li>执行阶段</li>
</ol>
<p>执行变量赋值、代码执行</p>
<ol start="3">
<li>回收阶段</li>
</ol>
<p>执行上下文出栈等待虚拟机回收执行上下文</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>和之前一样，赋值为const的对象变量不能被重新赋值为引用值，但对象的键却不受限制</p>
<p>要想对象不能修改，可以 const variable = Object.freeze({})</p>
<p>这样会“静默失败”，即不提示出错，但是调用则返回undefined</p>
<p>应该尽可能使用const，除非确实需要一个将来会重新赋值的变量，以从根本上保证提前发现重新赋值导致的bug，由const声明的实例可被JS运行编译器替换成实际的值，而不会通过查询表进行变量查找，谷歌V8就是这种优化</p>
<p><strong>标识符查找</strong></p>
<p>使用块级作用域不会改变搜索流程，但会添加额外的层次</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>垃圾回收有可能明显拖慢渲染的速度和帧速度</p>
<p>JS使用垃圾回收，即执行环境负责在代码执行时管理内存</p>
<p>周期性执行垃圾回收程序以处理不再使用的变量并释放其内存（<strong>近似且不完美</strong>）</p>
<p>历史上两种主要的标记策略：</p>
<ol>
<li><p>标记清理（常用）</p>
<p>运行时首先标记内存中存储的所有变量，然后将所有上下文中的变量以及被上下文的变量引用的变量的标记清理掉，在此之后再被加上标记或存在标记就会被清理，标记的实现并不重要，关键是打标记的策略</p>
</li>
<li><p>引用标记</p>
<p>记录每个值被引用的次数，当次数为0时清除，但可能导致循环引用，神之间接导致DOM,BOM由JS实现</p>
</li>
</ol>
<p>这对性能影响很大，如今IE7以后更新了回收的策略，极大提升了浏览器中JS性能</p>
<p>某些浏览器可以（不推荐）主动触发垃圾回收</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>由于系统给浏览器分配内存远少于桌面应用（移动浏览器更少）所以有必要限制内存</p>
<p>这会影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量</p>
<p>最佳策略是只保存必要的数据再运行期间，如果数据不在必要，把它设置为null，解除引用，在垃圾回收时清理</p>
<p>局部变量在离开上下文时会自动解除引用，<strong>全局变量和对象要手动解除，设为null</strong></p>
<ol>
<li><p>尽量使用let和const</p>
</li>
<li><p>利用隐藏类</p>
<p>V8在将代码编译为实际的机器码时会利用“隐藏类”，共享隐藏类效果会更好</p>
<p><strong>最好的方法是在构造函数中一次性声明所有属性，把不再需要的属性设置为null</strong></p>
<p><strong>避免先创建再单独给实例创建或删除属性</strong></p>
</li>
<li><p>内存泄漏</p>
<p>可能有函数内部全局变量，定时器调用，闭包。。</p>
</li>
<li><p>静态分配和对象池（优化的极端形式，不太常见）</p>
<p>压榨浏览器，一个关键问题是如何减少浏览器回收垃圾的次数，可以间接触发回收条件。浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度，如果有很多对象一下被初始化，马上又超出作用域，那么就会被浏览器用更激进的方式回收。</p>
<p><strong>如果函数会初始化变量，而马上又失去引用，则会被“盯上”，一个方案是函数调用已存在的对象，给他赋值</strong></p>
<p>那在哪里新建第一个已存在的对象才不会被盯上呢？一个策略是对象池：</p>
<p>在初始化的某一刻创建一个对象池，用来管理一组可回收的对象，其他代码可以向这里请求对象，更改或使用，然后返还它。这样垃圾回收检测就不会发现有对象更替，也就不会那么频繁地运行。</p>
</li>
</ol>
<h2 id="5-基本引用类型"><a href="#5-基本引用类型" class="headerlink" title="5.基本引用类型"></a>5.基本引用类型</h2><p>JS没有类，虽然是面向对象，但缺少某些基本结构比如类和接口，<strong>引用类型是把数据和功能组织到一起的结构</strong>，也被称<strong>对象定义</strong>，它们描述了自己的对象应有的属性和方法。</p>
<p>引用值（或对象）是某个特定引用类型的实例，新对象通过new操作符后+一个构造函数来创建。</p>
<p><em>构造函数是用来创建新对象的函数，负责创建一个只有默认属性和方法的简单对象</em></p>
<p>函数也是一种引用，但是内容好多，放在第十章</p>
<h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="2-3文档模式"><a href="#2-3文档模式" class="headerlink" title="2.3文档模式"></a>2.3文档模式</h3><h3 id="3-32-条件-amp-for声明"><a href="#3-32-条件-amp-for声明" class="headerlink" title="3.32 条件&amp;for声明"></a>3.32 条件&amp;for声明</h3><h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>web-front-end</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python进行数据分析(暂废)</title>
    <url>/2021/05/01/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h3><p>Ctrl-D退出</p>
<p>tab自动补全神器</p>
<p>但是ipython默认隐藏了下划线开始的方法和属性，比如魔术方法，“私有”方法和属性，要先输入下划线才看得到</p>
<p>内省：变量名前后使用 ? 显示关于对象的概要信息（包括docstring）</p>
<p>??来显示函数的源代码</p>
<p>？的终极用途：搜索命名空间，比如np.*load*?</p>
<p>% file.py 运行文件中的代码，如果需要参数就加参数<strong>如果想让待运行的脚本使用ipython空间中有的变量，用%run -i filename.py</strong></p>
<p>%paste 和 %cpaste (–终止)黏贴代码</p>
<p>一些终端指令：ctrl-L清屏  C+U删除当前行  ….</p>
<h4 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h4><p>没有内建到python中去，调用示例:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token operator">%</span>timeit np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>大部分魔术指令可以用?看到额外的选项</p>
<p>魔术函数在不冲突时可以不加百分号调用，%automagic 可以启用、禁用</p>
<p>一些魔术函数像python函数一样，输出可以赋给一个变量</p>
<p>a = %pwd</p>
<pre class="line-numbers language-pytho" data-language="pytho"><code class="language-pytho">%quickref  快速参考卡
%magic 探索所有魔术命令
%debug从最后发生报错的底部进入交互式调试器  %pdb出现任意报错自动进入调试器
%hist
%paste   %cpaste
%reset 清空所有变量&#x2F;名称  %xdel variable 删除变量和相关引用
%page OBJECT  通过分页器更美观的打印一个对象
%run   %prun statement  使用CProfile执行语句，报告输出
%time 报告单个语句执行时间   %timeit 多次运行单语句，计算平均执行时间，用于估算代码最短执行时间
%who  %who_ls  %whos  依次更加详细的展示变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://developer.51cto.com/art/202007/620863.htm">这个厉害</a></p>
<h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>核心组件是 notebook 交互式的文档类型</p>
<p>python的jupyter内核使用ipython系统进行内部活动</p>
<p>集成matplotlib:</p>
<ul>
<li>在ipython命令行中 %matplotlib</li>
<li>在jupyter中 %matplotlib inline</li>
</ul>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>一切皆为对象，对象模型的一致性！！！</p>
<p>几乎所有的python对象都有内部函数，称为方法</p>
<p>python虽然没有显示声明类型，但却是<strong>强类型语言</strong>，比如’5’+5会报错，而不是像很多语言一样发生隐式转换</p>
<p>只有在特定，明显的情况下才会发生隐式转换比如float + int</p>
<p>tips: isinstance(a,(int,float))检查对象类型是否在右边的元组中</p>
<p>python。。。鸭子类型，不管具体类型，只要它拥有某个特殊的方法，就一定有某种属性</p>
<p>iter(x)检查可否迭代</p>
<p>if not isinstance(x,list) and isiterable(x):</p>
<p>​    x = list(x) 不是列表就转换为列表</p>
<p>None 是NoneType类型的唯一实例，如果函数没有显式返回值，那就返回None</p>
<p><strong>三元表达式</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">5</span>
<span class="token string">'a'</span> <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">5</span> <span class="token keyword">else</span> <span class="token string">'b'</span>
<span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span>date<span class="token punctuation">,</span>time
dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token string">'2021,5,1,21,8,30'</span><span class="token punctuation">)</span>
dt<span class="token punctuation">.</span>year<span class="token punctuation">,</span>month<span class="token punctuation">,</span>day<span class="token punctuation">,</span>hour<span class="token punctuation">,</span>minute<span class="token punctuation">,</span>second
dt<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token punctuation">)</span>输出前三个
dt<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>输出后三个

dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%x%x%x'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">'202151'</span><span class="token punctuation">,</span><span class="token string">"%Y%m%d"</span><span class="token punctuation">)</span><span class="token comment">#转换为datetime对象</span>
datetime相减会产生datetime<span class="token punctuation">.</span>delta对象
delta <span class="token operator">=</span> datetime2 <span class="token operator">-</span> datetime1
delta <span class="token operator">==</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">7179</span><span class="token punctuation">)</span> <span class="token comment">#间隔99天,7179秒</span>
timedelta和datetime可以做加减得到新的datetime
<span class="token operator">%</span>y     两位数的年份表示（<span class="token number">00</span><span class="token operator">-</span><span class="token number">99</span>）
<span class="token operator">*</span><span class="token operator">%</span>Y     四位数的年份表示（<span class="token number">000</span><span class="token operator">-</span><span class="token number">9999</span>）
<span class="token operator">*</span><span class="token operator">%</span>m     月份（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>d     月内中的一天（<span class="token number">0</span><span class="token operator">-</span><span class="token number">31</span>）
<span class="token operator">*</span><span class="token operator">%</span>H     <span class="token number">24</span>小时制小时数（<span class="token number">0</span><span class="token operator">-</span><span class="token number">23</span>）
<span class="token operator">*</span><span class="token operator">%</span>I     <span class="token number">12</span>小时制小时数（<span class="token number">01</span><span class="token operator">-</span><span class="token number">12</span>）
<span class="token operator">*</span><span class="token operator">%</span>M     分钟数（<span class="token number">00</span><span class="token operator">=</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>S     秒（<span class="token number">00</span><span class="token operator">-</span><span class="token number">59</span>）
<span class="token operator">*</span><span class="token operator">%</span>a     本地简化星期名称
<span class="token operator">*</span><span class="token operator">%</span>A     本地完整星期名称
<span class="token operator">%</span>b     本地简化的月份名称
<span class="token operator">%</span>B     本地完整的月份名称
<span class="token operator">%</span>c     本地相应的日期表示和时间表示
<span class="token operator">%</span>j     年内的一天（<span class="token number">001</span><span class="token operator">-</span><span class="token number">366</span>）
<span class="token operator">%</span>p     本地A<span class="token punctuation">.</span>M<span class="token punctuation">.</span>或P<span class="token punctuation">.</span>M<span class="token punctuation">.</span>的等价符
<span class="token operator">%</span>U     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期天为星期的开始
<span class="token operator">%</span>w     星期（<span class="token number">0</span><span class="token operator">-</span><span class="token number">6</span>），星期天为星期的开始
<span class="token operator">%</span>W     一年中的星期数（<span class="token number">00</span><span class="token operator">-</span><span class="token number">53</span>）星期一为星期的开始
<span class="token operator">%</span>x     本地相应的日期表示
<span class="token operator">%</span>X     本地相应的时间表示
<span class="token operator">%</span>Z     当前时区的名称
<span class="token operator">%</span><span class="token operator">%</span>     <span class="token operator">%</span>号本身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>tuple</strong></p>
<p>可以用tuple函数将任意序列或迭代器转换为元组，比如tuple(‘ab’)-&gt;(‘a’,’b’)</p>
<p>同样可以使用 + 来连接，可以使用 * 来组成大元组</p>
<p>嵌套元组拆包(为啥python不用临时变量的原因)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tup <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>
a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>collections有很多封装好的数据结构，比如collections.deque</strong></p>
<p>他们适合不同的场景，拥有特定的操作和某些特性下的加速，比如deque是双端数列，头尾插入快</p>
<p>list的remove很方便，但是内存占用比较高，还有insert代价比append更高</p>
<p>与字典，集合相比，对列表使用in时非常缓慢</p>
<p>list.extent(元素)比起创建新列表再使用+来连接节省很多内存</p>
<p>bisect模块可用于排序好的序列(实现了二分搜索，已排序列表的插值)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> bisect
c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
bisect<span class="token punctuation">.</span>bisect<span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#5要插在哪</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token number">6</span>
bisect<span class="token punctuation">.</span>insort<span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
c
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>序列函数enumerate,zip,sorted,reversed</p>
<p>zip取决于最短的那一项，enumerate,zip,reversed都返回生成器</p>
<p>字典的keys values items 返回的是迭代器！</p>
<p>a.update({xxxxxx})可以合并字典，如果冲突，则原来的被覆盖</p>
<p>由于字典本质是2-元组（含有两个元素的元组）的集合，字典可以接受一个2-元组为参数</p>
<p><code>dictionary = dict(zip(range(5),reversed(range(5))))</code></p>
<p>value = dict.get(key,default_value)，不加默认值就返回None，pop也可以，不过默认抛出异常</p>
<p>dict.setdefault(key, default=None)查找key，如果不存在就设置为default，可以用[]</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">by_letter <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
    letter <span class="token operator">=</span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    by_letter<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>letter<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
    <span class="token comment">#设置首字母序列</span>
<span class="token comment">#也可以直接from collections import defaultdict</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a href="https://www.jianshu.com/p/bbd258f99fd3">defaultdict</a></p>
<p>字典的键必须是不可变，它们将被哈希化，用hash(x)检查能否哈希化</p>
<p>为了将列表作为键，可以转换为元组，元组只要内部元素可以哈希化，它自身就可以哈希化</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
d<span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
d
<span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span> <span class="token comment">#...真的有必要把元组作为键吗</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#集合操作</span>
a<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#清空</span>
a<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#移除任意元素，空的则抛出keyerror</span>
a<span class="token operator">|</span>b
a<span class="token operator">&amp;</span>b
a<span class="token operator">-</span>b
a<span class="token operator">^</span>b
<span class="token comment">#这几个都可以 a x= b</span>
a<span class="token punctuation">.</span>issubset<span class="token punctuation">(</span>b<span class="token punctuation">)</span> a包含于b则返回ture
a<span class="token punctuation">.</span>issuperset<span class="token punctuation">(</span>b<span class="token punctuation">)</span> 如果a包含b返回true
a<span class="token punctuation">.</span>isdisjoint<span class="token punctuation">(</span>b<span class="token punctuation">)</span> ab没有交集返回true
a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>用于赋值，免得指向同一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>字典，集合都有推导式！推导式和map功能有些重复</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#字典示范</span>
dictionary <span class="token operator">=</span> <span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span>index <span class="token keyword">for</span> index<span class="token punctuation">,</span>val <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>嵌套列表推导式的for顺序排列,要区别于列表推导式中的列表推导式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">some_tuples <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
flattend <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> <span class="token builtin">tuple</span> <span class="token keyword">in</span> some_tuples <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">tuple</span><span class="token punctuation">]</span>
flattend <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">tuple</span><span class="token punctuation">]</span> <span class="token keyword">for</span> tup <span class="token keyword">in</span> some_tuples<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>global</p>
<p>返回多个值是以元组形式，甚至可以返回一个字典，啥都行</p>
<p>将函数作为参数传递，这种更函数化的编程有更强的复用性和通用性</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">complex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>ops<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> op <span class="token keyword">in</span> ops<span class="token punctuation">:</span>
        op<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
operation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">.</span>strip<span class="token punctuation">]</span>
<span class="token builtin">complex</span><span class="token punctuation">(</span><span class="token string">'wocao'</span><span class="token punctuation">,</span>operation<span class="token punctuation">)</span>
妙啊！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>lambda本身没有显式的__name__属性</p>
<p><strong>柯里化</strong></p>
<p>通过部分参数应用的方式从已有的函数里衍生出新的函数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> partial
add five <span class="token operator">=</span> partial<span class="token punctuation">(</span>add_numbers<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>生成器表达式可以作为函数参数用于替代列表推导式</p>
<p><code>sum(x ** 2 for x in range(100))</code></p>
<p><strong>itertools</strong></p>
<p>适用于大多数数据算法的生成器集合</p>
<p>可以查一下手册，需要的时候</p>
<p>except(xx,xx)来结合多个异常</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">read<span class="token punctuation">(</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
seek<span class="token punctuation">(</span>pos<span class="token punctuation">)</span>
tell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#随机三件套</span>
readlines<span class="token punctuation">(</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>
write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span>
writelines<span class="token punctuation">(</span>strings<span class="token punctuation">)</span>
close
flush <span class="token comment">#将内部I/O缓冲区内容刷新到硬盘</span>
closed

在文本模式下，f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#读取了10个字符所需要的字节并解码</span>
而在二进制模式下<span class="token punctuation">,</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#读取了10个字节，并未解码，显示b'xxxx'</span>
解码如果不完整，则会报错
文本模式配合<span class="token builtin">open</span>的encoding参数读取不同编码类型
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span><span class="token string">'xt'</span><span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>数组和向量化计算</p>
<ul>
<li>高校多维数组，提供数组算术操作和灵活的广播(不同尺寸数组)</li>
<li>线性代数，随机数，傅里叶变换</li>
<li>提供非常易用的C API，使得调用<strong>底层语言</strong>变得极其简单</li>
<li>诸多外部库都基于Numpy，这是数值计算最重要的python库</li>
</ul>
<p>Numpy的方法比python方法快10-100倍，并且使用的内存也更少</p>
<p><strong>核心特征ndarry 快速，灵活的大型数据集容器，允许使用类似标量的操作语法在整块数据上进行数学计算</strong></p>
<p><strong>生成</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">array<span class="token punctuation">(</span>列表，元组，数组<span class="token punctuation">)</span>
asarray<span class="token punctuation">(</span><span class="token punctuation">)</span>将输入转换为ndarray？？
arrange
ones<span class="token operator">/</span>zeros<span class="token operator">/</span>empty<span class="token operator">/</span>full<span class="token operator">+</span><span class="token operator">/</span>_like
eye<span class="token operator">/</span>identity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>dtype</strong></p>
<p>能和吉他系统数据灵活交互的原因</p>
<p>dtype和astype（new type）方法</p>
<p>转换时小数-&gt;整数截断，string转换为合适的，</p>
<p><strong>但在用numpy.string_作数据时，numpy会修正大小或删除输入而不发出警告</strong></p>
<p><strong>数组算术</strong></p>
<p>所谓向量化运算，逐元素操作。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>ndarray可以用”切片”赋值<code>b[1:4] = 5</code>把b的2-4号元素都赋值5</p>
<p><strong>ndarray的切片事原数组的视图，而不是复制！！！不然得多慢</strong>，要想复制得：arr[5:8].copy()</p>
<p>高维索引：可以arr2d[2][1]   也可以arr2d[2,1]</p>
<p>切片配合索引可以很好的进行切片，全选用单独 :</p>
<p><strong>布尔索引</strong></p>
<p>names是一个字符串ndarray</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">names <span class="token operator">==</span> <span class="token string">'Bob'</span>
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dtype <span class="token operator">=</span> <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token comment">#输出一个布尔值数组</span>
可以将布尔数组当作数组的索引，但是其长度必须和数组轴索引长度一致，不一致时不会报错，要小心
date <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
date<span class="token punctuation">[</span>date<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">#好厉害的功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>布尔索引也能配合切片使用</p>
<p>布尔索引总是生成数据的拷贝</p>
<p><code>~()表示对某个通用条件取反</code></p>
<p><strong>神奇索引</strong></p>
<p>真的很神奇。。使用整数数组进行数据索引（Numpy专用）</p>
<p>相当于是一维一维的选择数据，也可以把每个数组的对应位置组合起来看成索引</p>
<p>神奇索引的结果总是一维的，他也总是复制数据到新的数组中</p>
<p>假设arr是二维数组</p>
<p>arr[:,[2,1,0]] 相当于是把前三列倒过来再复制出来，很奇怪的用法</p>
<p>换轴：arr3d.transpose((1,0,2)) 换了轴的次序，有点抽象</p>
<p>arr.swapaxes(1,2)交换俩轴，返回视图而不是复制</p>
<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>快速的逐元素数组函数</p>
<p><strong>一元</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">abs</span><span class="token operator">/</span>fabs  
sqrt
square
exp
log log10 log2 log1p<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回ln(1+x)</span>
sign <span class="token comment">#返回符号值，正数1，0为0，负数-1</span>
ceil floor
rint <span class="token comment">#保留整数，保持dtype</span>
modf <span class="token comment">#分别返回小数部分和整数部分</span>
isnan <span class="token comment">#返回布尔数组</span>
isfinite <span class="token comment">#既非inf又非NaN </span>
isinf
cos<span class="token punctuation">,</span>cosh<span class="token punctuation">,</span>sin<span class="token punctuation">,</span>sinh<span class="token punctuation">,</span>tan<span class="token punctuation">,</span>tanh
arc<span class="token operator">*</span><span class="token number">6</span>
logical_not<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#按位取反</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>二元</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">add subtract multiply divide<span class="token operator">/</span>floor_divide
power<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token comment">#每项依次xi ** yi</span>
maximum<span class="token operator">/</span>minimum<span class="token operator">/</span>fmax<span class="token operator">/</span>fmin <span class="token comment">#后两个忽略NaN</span>
mod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#模</span>
copysign <span class="token comment">#将第一个数组的符号值改为第二个数组的符号值</span>
greater<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>不如直接用操作符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数学和统计"><a href="#数学和统计" class="headerlink" title="数学和统计"></a>数学和统计</h2><p>用数组表达式完成多种数据操作任务，代替显式循环，称为向量化，速度会快很多</p>
<p>np.where(布尔数组，标量/向量，标量/向量)是向量界的三元表达式</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>axis <span class="token operator">=</span> <span class="token punctuation">)</span>
mean
std<span class="token punctuation">,</span>var 标准差<span class="token operator">/</span>方差 ，可以选择自由度调整
<span class="token builtin">min</span> <span class="token builtin">max</span>
argmin argmax 最小值和最大值的位置<span class="token comment">#axis可以省略，直接写维度</span>
cumsum cumprod 累和 和 累积 有中间结果<span class="token comment">#</span>
sort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>布尔数组妙用</strong></p>
<p>arr = np.random.randn(100)</p>
<p>(arr&gt;0).sum()正值的个数</p>
<p>还有bools.any()检查是否至少一个true</p>
<p>bools.all()检查是否每个值都是True，里面可能放轴</p>
<p><strong>唯一值与其他集合逻辑</strong></p>
<p>有一些针对一维ndarray的基础集合操作</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">unique<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token comment">#对唯一值排序</span>
intersect1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>交集
union1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>并集
in1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>x项是否在y中，返回布尔数组
setdiff1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>返回x<span class="token operator">-</span>y
setxor1d<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>返回x<span class="token operator">^</span>y 不共有的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>文件</strong></p>
<p>numpy可以将数据以文本/二进制文件形式存入硬盘或载入，pandas或其他来载入文本/表格更被人们推崇</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#默认后缀是.npy</span>
arr <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
np<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'Iamfile'</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span>
np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'Iamfile.npy'</span><span class="token punctuation">)</span>
<span class="token comment">#多个就是</span>
np<span class="token punctuation">.</span>savez<span class="token punctuation">(</span><span class="token string">'Iammanyfile'</span><span class="token punctuation">,</span>a <span class="token operator">=</span> arr<span class="token punctuation">,</span> b <span class="token operator">=</span> arr<span class="token punctuation">)</span>
<span class="token comment">#load以后变成一个字典对象</span>
arch <span class="token operator">=</span> np<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'Iammanyfile.npy'</span><span class="token punctuation">)</span>
arch<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">==</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">#如果数据已经压缩好了，仍能存入压缩的文件</span>
np<span class="token punctuation">.</span>savez_compressed<span class="token punctuation">(</span><span class="token string">'small.npz'</span><span class="token punctuation">,</span>a <span class="token operator">=</span> arr<span class="token punctuation">,</span> b <span class="token operator">=</span> arr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>点乘</strong></p>
<p>a.dot(b)</p>
<p>np.dot(a,b)</p>
<p>a @ b</p>
<h3 id="linalg"><a href="#linalg" class="headerlink" title="linalg"></a>linalg</h3><p>顾名思义，numpy.linalg 拥有一个矩阵分解的标准函数集，以及其他常用函数比如求逆/行列式</p>
<p>这都是通过在MATLAB和R等其他语言使用的行业标准线性代数库实现的。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> numpy<span class="token punctuation">.</span>linalg <span class="token keyword">import</span> inv<span class="token punctuation">,</span>qr
diag<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回方针的对角元一维数组，一维数组就准换为对角矩阵</span>
dot
trace <span class="token comment">#考考你“迹”</span>
det 
eig <span class="token comment">#方阵特征值和特征向量</span>
inv 逆矩阵
pinv Moore<span class="token operator">-</span>Penrose伪逆
qr QR分解
svd 奇异值分解
solve 求解x的线性系统Ax <span class="token operator">=</span> b，其中A是方阵
lstsq 计算Ax <span class="token operator">=</span> b的最小二乘解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span>这个设置的是全局随机数种子
rng <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
arr <span class="token operator">=</span> rng<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">#这样生成的就是独立的</span>

seed
permutation<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment"># 返回一个序列的随机排列</span>
shuffle <span class="token comment"># 随机排列一个序列,直接更改原来的</span>
rand <span class="token comment">#从均匀分布[0,1)中抽取样本</span>
randint <span class="token comment">#根据给定的从低到高的范围抽取随机一个整数</span>
randn <span class="token comment">#从均值0方差1的正态分布</span>
normal<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#平均值，标准差，shape</span>

binomial <span class="token comment">#从二项分布中抽取样本</span>
beta <span class="token comment">#从beta分布中抽取样本</span>
chisquare <span class="token comment">#从卡方分布中抽取样本</span>
uniform<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#从均匀分布中抽取样本</span>
gamma <span class="token comment">#从伽马分布中抽取样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>随机漫步</strong></p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>numpy像序列化好的矩阵，序列，pandas相当于是字典(有名称的数据)</p>
<p>numpy适合处理同质型的数值类数组数据</p>
<p>pandas用来处理表格型或异质性数据</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>一维的数组型对象，包含一个值序列（类似numpy），和数据标签（索引 index）</p>
<p>默认索引0 - N-1 ，用values和index得到其值和索引</p>
<p>比numpy数组特殊的是可以用标签来索引：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>index
Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>values
Out<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int64<span class="token punctuation">)</span>
    
In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
d    <span class="token number">4</span>
s    <span class="token number">7</span>
dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>可以考虑它是一个长度固定且有序的字典，在可以使用字典的上下文中Series都能用</strong></p>
<p>使用numpy的函数或按numpy风格的操作，比如布尔数组索引，数学函数，都能用，且保存索引值链接</p>
<p>还能把字典变成Series  pd.Series(dict)</p>
<p><code>obj3 = pd.Series(list1,[index = list])</code>如果list里没有，则被舍弃，如果list里有没对上的，就NaN</p>
<p>Pandas用 isnull 和 notnull检查数据，也返回类似布尔值Series的东东</p>
<p><strong>自动对齐索引是非常有用的</strong></p>
<p>Series对象自身和其索引都有name属性</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'population'</span>
In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2<span class="token punctuation">.</span>index<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'state'</span>
In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj2
Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
state
d    <span class="token number">4</span>
s    <span class="token number">7</span>
c   <span class="token operator">-</span><span class="token number">5</span>
a    <span class="token number">3</span>
Name<span class="token punctuation">:</span> population<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>索引可以通过按位置赋值的方式进行改变 obj.index = [new list]</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>表示矩阵的数据表,它包含已排序的列集合，每一列可以是不同的值类型（数值，字符串，布尔值等），DataFrame既有行索引，又有列索引</p>
<p>在DataFrame中数据被存储为一个以上的二维块。</p>
<p>可以利用分层索引在DataFrame中展现更高层次的维度。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>利用包含等长度列表或numpy数组的字典</p>
<p>在jupyter notebook里面dataframe对象会展示一个更好康的HTML表格</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
frame <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
frame2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'first'</span><span class="token punctuation">,</span><span class="token string">'second'</span><span class="token punctuation">,</span><span class="token string">'third'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
colunmns指定列的顺序，索引指定索引。。如果columns里出现data没有的列，则填充缺失值NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>frame2[‘a’] == frame2.a  这是一个Series对象，frame2.a只在a是有效变量名时可用，前者则总可用</p>
<p>也可以用这个更改一列👆，用列表/数组赋值时请确保长度匹配，</p>
<p>将Series付给一列时，索引会尝试匹配，空缺补缺失值，如果a（被赋值的列）不存在，会产生新列（<strong>此时不能用frame2.a的语法！！</strong>），可以用del关键词来删除dataframe的列</p>
<p>返回的Series对象索引继承dataframe的，而且name属性被设置成字典的索引</p>
<p>从DateFrame中选的列同样是数据的视图，拷贝得用.copy()</p>
<p>另一种常用的数据形式是包含字典的嵌套字典:</p>
<p>pandas会将字典的键作为列，将内部字典的键作为行索引，自动补全NaN</p>
<p>可以用Numpy语法转置 frame3.T</p>
<p>内部字典的键会被联合，排序，但是如果显式指明索引，键不会被排列</p>
<p>frame3.index.name 和 frame3.columns.name 也是可以设置的</p>
<p>如果列是不同的dtypes，那么values的dtype会自动选择适合所有列的类型</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>reindex([]) 创建一个符合新索引的新对象</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

In <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3
Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>      blue
<span class="token number">2</span>    yellow
<span class="token number">4</span>     green
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>

In <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> obj3<span class="token punctuation">.</span>reindex<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">'ffill'</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
<span class="token number">0</span>      blue
<span class="token number">1</span>      blue
<span class="token number">2</span>    yellow
<span class="token number">3</span>    yellow
<span class="token number">4</span>     green
<span class="token number">5</span>     green
dtype<span class="token punctuation">:</span> <span class="token builtin">object</span>
<span class="token comment">#ffill会将值向前传递</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-python" data-language="python"><code class="language-python">reindex方法的参数
index <span class="token comment">#作为默认参数，可以省略</span>
columns <span class="token operator">=</span> xx <span class="token comment">#此关键字用于重建列的索引</span>
ps<span class="token punctuation">:</span>可以用frame<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">[</span>行索引<span class="token punctuation">]</span>，<span class="token punctuation">[</span>列索引<span class="token punctuation">]</span><span class="token punctuation">]</span>
method <span class="token comment">#ffill前向，bfiil后向填充</span>
fill_value <span class="token comment">#选择缺失时使用的替代值</span>
limit <span class="token comment">#前后填充时，填充的最大元素数量</span>
tolerance <span class="token comment">#前后填充时，填充的最大绝对数字距离</span>
copy <span class="token comment">#True时总是复制底层数据，False在索引相同时不复制数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>删除</strong></p>
<p>data.drop([xxx])删除索引，默认是轴9</p>
<p>data.drop([xxx],axis = 1) #也可以写axis = ‘columns’ 只删除一个的就不用列表</p>
<p>像drop这类函数会修改Series或DataFrame的尺寸或形状，直接操作原对象，不返回新对象</p>
<h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><p>不可变的，用obj.index拿出来，构造Series和DataFrame时，内部产生索引对象</p>
<p>可以用pd.Index([list])显式生成</p>
<p>它具备集合的特征，比如使用 in方法</p>
<p>但是它可以包含重复标签，根据重复标签筛选会选取所有匹配的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">append<span class="token punctuation">(</span><span class="token punctuation">)</span>
difference
intersection
union
isin
delete<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">#删除位置i的索引并产生新的索引</span>
drop<span class="token punctuation">(</span><span class="token string">'xx'</span><span class="token punctuation">)</span><span class="token comment">#删除xx索引并产生新的索引,可以传递列表来删除多个</span>
insert<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
is_monotonic <span class="token comment">#是否递增</span>
is_unique <span class="token comment">#是否唯一</span>
unique <span class="token comment">#得到索引的唯一值序列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Series</strong> 既可以使用obj[2:4]这样传统的顺序，也可以使用obj[[‘b’,’c’]]用索引里截取的列表来</p>
<p><strong>甚至可以obj[‘b’:’c’] 而且这个是包含尾部的</strong>，series只有一列，这些都是选择行</p>
<p><strong>对dataFrame可以直接用obj[‘two’]来索引某一列或用一个列表来选择！这是列选择语法</strong></p>
<p><strong>但是切片语法obj[2:4]时选择行的（这才是特殊的），传入单个/列表只能选择列！！！</strong></p>
<p><strong>loc和iloc选择(更准确，更无歧义)</strong></p>
<p>date.loc [[],[]] 前者选择行，后者选择列，必须是索引名</p>
<p>date.iloc [ xxx ]就只能用数字索引</p>
<p>当用列表时形式和原来相仿，当选了某一个行时，会发生转置</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data
Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
          one  two  three  four
OHIO        <span class="token number">0</span>    <span class="token number">1</span>      <span class="token number">2</span>     <span class="token number">3</span>
COLORADO    <span class="token number">4</span>    <span class="token number">5</span>      <span class="token number">6</span>     <span class="token number">7</span>
UTAH        <span class="token number">8</span>    <span class="token number">9</span>     <span class="token number">10</span>    <span class="token number">11</span>
NEWYORK    <span class="token number">12</span>   <span class="token number">13</span>     <span class="token number">14</span>    <span class="token number">15</span>

In <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">'OHIO'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
one      <span class="token number">0</span>
three    <span class="token number">2</span>
Name<span class="token punctuation">:</span> OHIO<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32
        
In <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span> 
three    <span class="token number">2</span>
two      <span class="token number">1</span>
Name<span class="token punctuation">:</span> OHIO<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两种方法是可以使用切片的</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span>val<span class="token punctuation">]</span> 选择单列或列序列，特殊是数字切片选择行
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>val<span class="token punctuation">]</span> 选择行
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>val<span class="token punctuation">]</span> 选择列
df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>val1<span class="token punctuation">,</span>val2<span class="token punctuation">]</span>选择某部分
df<span class="token punctuation">.</span>iloc同理
df<span class="token punctuation">.</span>ai<span class="token punctuation">[</span>label_i<span class="token punctuation">,</span>label_j<span class="token punctuation">]</span>根据索引选择单个标量
df<span class="token punctuation">.</span>iat<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span>根据位置选择单个标量
get_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>ps:当对标签使用切片时是包含尾部的，比如loc里面和series的标签切片，即使有时候标签就是数字</strong></p>
<h3 id="算数和数据对齐"><a href="#算数和数据对齐" class="headerlink" title="算数和数据对齐"></a>算数和数据对齐</h3><p>相加对象时，当索引对不同，返回结果的索引将时索引对的并集，没有交叠的部分全都变成NaN</p>
<p>灵活算术方法</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">add<span class="token punctuation">,</span>radd
sub<span class="token punctuation">,</span>rsub
div<span class="token punctuation">,</span>rdiv
floordiv<span class="token punctuation">,</span>rfloordiv
mul<span class="token punctuation">,</span>rmul
<span class="token builtin">pow</span><span class="token punctuation">,</span>rpow
参数fill_value设定了以后有必要会保留两边的，带r的都是参数翻转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>DataFrame和Series间的操作</strong></p>
<p>类似不同维度数组间的操作类似</p>
<p>当arr(np数组)减去一行时，减法依次在每一行进行了操作，这就是所谓的广播机制</p>
<p>二DataFrame和Series之间的操作是类似的，Series的索引和DataFrame的列进行匹配，然后广播到各行</p>
<p>如果索引值不在DataFrame的列中，也不在Series的索引中，对象会重建索引并进行联合。补NaN</p>
<p>如果想在行上匹配，列上广播，必须得用算术方法，然后指定参数axis = ‘index’或axis = 0</p>
<p>Numpy的通用函数们可以直接使用到pandas对象进行逐元素操作</p>
<p>DataFrame的apply方法可以将函数应用到一列或一行上，默认是对每一列调用一次，</p>
<p>用axis = ‘columns’ 或 1来对行调用，索引仍保留对应的，但大部分常用的功能都已经实现了</p>
<p>applymap就是对每个元素使用！</p>
<p>先到这吧</p>
<h2 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h2><p>有一大坨，我挑了几个</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">read_csv 从文件，url，文件型对象读取分隔好的数据，逗号是默认分隔符
read_table从文件，url，文件型对象读取分隔好的数据，制表符是默认分隔符
read_fwf 从特定宽度格式的文件中读取数据（无分隔符）
read_excel
read_html
read_json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于现实世界的数据非常混乱，随着时间推移，一些数据加载函数的可选参数变得非常复杂，pandas的在线文档中有大量实例展示，可以借鉴</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">一些参数
path
sep<span class="token operator">/</span>delimiter 分隔符，可以是正则表达式
header 用作列名的行号
index_col 用作行索引的列好<span class="token operator">/</span>列名
names 列名列表，必须header <span class="token operator">=</span> <span class="token boolean">None</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p>如果不是用了%matplot notebook/inline，就得用plt.</p>
<p>最终目标可能是构建网络交互式可视化</p>
<p>matplotlib用来制作静态或动态的可视化文件，生成出版级质量图表（一般二维）</p>
<p>matplotlib支持所有操作系统上的各种GUI后端，还可以导出为常见的矢量和光栅图形格式！</p>
<p>现在有了一些matplotlib数据可视化的附加工具包，（调用matplotlib进行底层绘图）比如seaborn</p>
<p><strong>尽管seaborn等库和pandas内建的绘图函数可以处理大部分绘图的普通细节，但是要更好的定制，必须得学习一些maplotlib的API</strong></p>
<p><strong>导入惯例</strong></p>
<p>import matplotlib.pyplot as plt</p>
<p>首先在jupyter notebook 来一句 %matplotlib notebook(Ipython则是%matplotlib)</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>这些图位于图片（Figure）对象中，可以使用plt.figure()生成一个新的图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114242.png" alt="image-20210503162615865"></p>
<p>Jupyter好像优化了，不仅可以提前显示，而且在后续单元格执行时不会重置图表</p>
<p>当再绘图时，会在最后一个子图上画画</p>
<p>fig.add_subplot返回的是Axes Subplot对象，可以调用这些对象绘图</p>
<p>可以去matplotlib官方文档找完整的图形类型</p>
<p>使用子图网格创建图片时非常常见的任务，所以有一个方法plt.subplots(size)，返回包含了已生成的子图对象的Numpy数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114253.png" alt="image-20210503171947679"></p>
<p>牛批啊，fig是一个尺寸对象Figure，axes则是返回的numpy数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114249.png" alt="image-20210503172248820"></p>
<p>有几个参数，sharex(True/all  False/None) sharey</p>
<p>subplot_kw：可选的，字典类型。包含传递给用于创建子图的调用add_subplot的关键字参数。</p>
<p>gridspec_kw：可选的，字典类型。包含传递给用于创建子图网格的GridSpec构造函数的关键字参数。</p>
<p>**fig_kw：所有传递给matplotlib.pyplot.figure调用的额外关键字参数。</p>
<p>比如plt.subplots(2,2,figsize = (8,6)最后一项传入figure对象</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><a href="https://blog.csdn.net/htuhxf/article/details/82863630">https://blog.csdn.net/htuhxf/article/details/82863630</a></p>
<p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html</a></p>
<p>可以用图对象的subplots_adjust方法，或者当作顶层函数用，调整间距</p>
<p>fig.subplots_adjust(left,bottom,right,top,wspace,hspace)</p>
<p>很多配置字符串可以合到一起，也可以分开来使得表达清晰</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'ko--'</span><span class="token punctuation">)</span>
等价于
ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>color <span class="token operator">=</span><span class="token string">'k'</span><span class="token punctuation">,</span>linestyle <span class="token operator">=</span> <span class="token string">'dashed'</span><span class="token punctuation">,</span>marker <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>大多数图表修饰工作有两种主要的方式：<strong>程序性的pyplot接口或更多面向对象的原生matplotlib API</strong></p>
<p>pyplot接口设计为交互式使用，包含xlim,xticks,xticklabels方法，他们在没有函数参数时返回当前参数值，在传入参数时设置参数值，<strong>他们默认在当前活动或最新创建的AxeSubplot上生效</strong>。他们分别对应于子图的两个方法，比如xlim对应于ax.get_lim和ax.set_lim，<strong>后者更为显式，单独操作子图</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#实例</span>
fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ticks <span class="token operator">=</span> ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">250</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">750</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置刻度</span>
labels <span class="token operator">=</span> ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token string">'five'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>rotation <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>fontsize <span class="token operator">=</span> <span class="token string">'small'</span><span class="token punctuation">)</span><span class="token comment">#设置标签</span>
ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'My first matplotlib plot'</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'Stages'</span><span class="token punctuation">)</span>

<span class="token comment">#也可以这样设置</span>
props<span class="token operator">=</span><span class="token punctuation">&#123;</span>
    <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token string">'My first matplotlib plot'</span><span class="token punctuation">,</span>
    <span class="token string">'xlabel'</span><span class="token punctuation">:</span><span class="token string">'Stages'</span>
<span class="token punctuation">&#125;</span>
ax<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token operator">**</span>props<span class="token punctuation">)</span><span class="token comment">#通用的一种方法</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>ticks<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114302.png" alt="image-20210503194818033"></p>
<p><strong>添加图例</strong></p>
<p>最简单的式在添加图表的时候ax.plot(加一个参数label = ‘xx’)</p>
<p>再执行ax.lengend(loc =’xx’)或者plt.legend就能自动生成图例，best会找到最合适的位置</p>
<p>好文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/110656183">一，折线图调整</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110902615">二，坐标轴</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/110976210">三，挪动坐标轴</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111108841">四，设置label</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111331057">五，散点图</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/113657235">六，柱状图</a></p>
<p><strong>注释与子图加工</strong></p>
<p>text,arrow,annote方法可以添加注释和文本</p>
<p>比如：ax.text(x,y,’Hello world!’,family = ‘monospace’,fontsize = 10)</p>
<p>matplotlib含有表示多种常见图形的对象，这些对象的引用时patched。</p>
<p>全集位于matplotlib.patched中，少部分比如Rectangle和Circle可以在matplotlib.pyplot中找到</p>
<p>这个暂时用不到。。先略过吧</p>
<h3 id="保存到文件"><a href="#保存到文件" class="headerlink" title="保存到文件"></a>保存到文件</h3><p>使用plt.savefig将活动图片保存到文件，等价于图片对象的savefig实例方法</p>
<p>plt.savefig( ‘  xxx . svg’)文件类型会从文件拓展名自动推断</p>
<p>其他的参数/选项：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fname <span class="token comment">#默认参数，是一个路径+文件型对象名</span>
dpi <span class="token comment">#每英寸点数的分辨率，默认100</span>
facecolor<span class="token punctuation">,</span>edgecolor <span class="token comment">#图形背景的颜色，默认是'w'就是白色</span>
<span class="token builtin">format</span> <span class="token comment">#文件格式，比如'png','pdf',svg,ps,eps啥的，好像时可以覆盖</span>
bbox_inched <span class="token comment">#要保存的图片范围，如果是'tight'，将会去掉图片周围空白的部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>matplotlib配置</strong></p>
<p>几乎所有的默认行为都可以通过广泛的全局参数来定制，者通过plt.rc来实现</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#第一个参数时要自定义的组件,比如'figure',axes,xtick,ytick,grid,legend</span>
然后其他的就可以自定义了<span class="token punctuation">,</span>比如：
font_options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">'family'</span> <span class="token punctuation">:</span> <span class="token string">'monospace'</span><span class="token punctuation">,</span>
    <span class="token string">'weight'</span> <span class="token punctuation">:</span> <span class="token string">'bold'</span><span class="token punctuation">,</span>
    <span class="token string">'size'</span> <span class="token punctuation">:</span> <span class="token string">'5'</span>
<span class="token punctuation">&#125;</span>
plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'font'</span><span class="token punctuation">,</span> <span class="token operator">**</span>font_options<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="使用pandas和seaborn绘图"><a href="#使用pandas和seaborn绘图" class="headerlink" title="使用pandas和seaborn绘图"></a>使用pandas和seaborn绘图</h2><p>pandas有很多内建的方法简化dataframe和series对象生成可视化的过程，另一个库时seaborn</p>
<p>导入seaborn会修改默认的matplot配色方案和绘图央视</p>
<p>Series.plot的参数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">label 
ax 选用的子图对象，默认是当前活动的
style
alpha
kind 默认<span class="token string">'line'</span>
logy <span class="token comment">#在y上使用对数缩放</span>
use_index 使用对象索引刻度标签（默认x，水平图则是y）
rot
xticks
yticks
xlim
ylim
grid <span class="token comment">#展示轴网格，默认打开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>DataFrame的plot参数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">subplots <span class="token comment">#将每一列绘制在独立的子图中</span>
sharex<span class="token operator">/</span>sharey <span class="token comment">#当独立子图时可以设置的</span>
figsize 生成图片尺寸的元组
title 标题字符串
legend 添加子图图例，默认是<span class="token boolean">True</span>
sort_columns 按字母顺序绘制各列，默认为<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>折线图</strong></p>
<p>会把Series索引默认当作x轴</p>
<p>DataFrame默认划到一起去，可以设置</p>
<p>注意到DataFrame的列名称(column.name)成为了图例标题</p>
<p><strong>柱状图</strong></p>
<p>plot.bar() 竖直 plot.barh()水平柱状图,同样索引默认当作x轴、y轴</p>
<p>注意到DataFrame的列名称(column.name)成为了图例标题</p>
<p>stackedd = True 参数可以让DataFrame每一行的值叠在一起</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darren-greenhand/Darren-greenhand-image//img/20210504114307.png" alt="image-20210503205130179"></p>
<p><strong>直方图和密度图</strong></p>
<p>hist和density</p>
]]></content>
      <categories>
        <category>date</category>
      </categories>
  </entry>
  <entry>
    <title>《十年一梦》</title>
    <url>/2021/06/15/%E5%8D%81%E5%B9%B4%E4%B8%80%E6%A2%A6/</url>
    <content><![CDATA[<h1 id="十年一梦"><a href="#十年一梦" class="headerlink" title="十年一梦"></a>十年一梦</h1><p>第一篇<strong>读书笔记</strong>，我也不知道该咋写。。</p>
<h2 id="序1-唯有事实"><a href="#序1-唯有事实" class="headerlink" title="序1 唯有事实"></a>序1 唯有事实</h2><p>我们的认知需要建立在确切的<strong>事实</strong>上，不然就是无根之萍。事实应该包括两个方面，一个是我们自己，另一个是我们所面对的对象，在面对市场的时候，通常假定谁也改变不了市场，只能适应市场，因此我们更有理由重视“自己”</p>
<p>我们通常忽略自己，但是这是致命的错误，<strong>我们应该主动适应市场</strong>，成为行动的主体但是要认清自己实在是太难了，我们一言一行对周围的影响远超我们的外观。然而我们对这方面<strong>缺乏足够的参照物</strong>，在社会上，这些后果需要相当长的周期才能看得到，以至于我们可能忘记了前因后果，更何况大部分人总是缺乏反思和改正的想法。</p>
<p>对于学习市场操作，其实很不错，因为反馈是即刻的，这对于认知自己非常有效，但是我们要注意改进和纠正</p>
<p>另一方面，认清我们面对的对象也并非易事，每个人都有特定而局限的角度和立场，而这些不一定是最佳的，更不可能是全面的，甚至还随时间而改变。关于对象，我们获得的信息也总是滞后、有限的，观察方法和工具也受到时代的限制和自身能力的限制。</p>
<p>因此，获取事实是艰难的，但是这也是人生的主课，需要我们持续学习、领悟、突破。</p>
<p>这对初入社会的大学生是一个巨大的考验，光凭自己的人生经验和脑子，很难不吃苦头。</p>
<p>不要成为环境的奴隶，被各种情绪和刺激占据了所有的心思，做出过度的反应，而是要保持平静，认清这些事实，<strong>不应该预设某种态度</strong>，<strong>应保持思想的开放而不带着偏见</strong>（我感觉我最近偏见有点多了），但是这是十分占据时间精力的，我们要精挑细选有价值、有意义的刺激，而记住，<strong>刺激的重要程度并不和刺激的强度成正比</strong>。</p>
<p>做人做事从观察事实开始，进而采取行动；在行动过程中，还得持续观察行动的实际效果，反过来调整和修正行动。得到的事实越少，则虚妄的成本越多。</p>
<p>建议多读《大学》《中庸》《论语》《老子》，还有《周易》！具有极高的实践性，特别是针对个人行为的管理和塑造。尤其适合投资交易者，关键在自己能不能应用。还有就是研究实际案例。</p>
<p>第二本书《期货交易的策略与技巧》</p>
<h2 id="前言-艰难的路"><a href="#前言-艰难的路" class="headerlink" title="前言 艰难的路"></a>前言 艰难的路</h2><p><strong>期货交易是一条艰难的路</strong></p>
<p>不要小看期货交易的艰难性，两三年，甚至十年都是远远不够称得上是精通交易、战胜市场的，更别说孔子先生所说的“从心所欲不逾矩了”。</p>
<p>青泽先生认为的难点：</p>
<ol>
<li><p>理解、把握市场价格波动的特征难</p>
<p>最刻骨民心的莫过于市场价格的反复无常、神秘莫测，不确定性、随机性。</p>
<p>很多市场参与者都有一种认知误区：<strong>追求交易的确定性，把科学的思维简单应用到投机交易中，以为预测是市场交易的全部，希望找到一种科学的预测理论，但是这所谓的科学方法主张的严密和正确，其实很多时候不但无用武之地，还可能成为成功的障碍。</strong></p>
<p>当然，很多预测工具（比如波浪理论）确实很常用，有价值，但是不要把期货投机当作一门科学，事实上，什么理论都无法保证我们的交易和市场走势。</p>
<p><strong>投机领域充满了辩证法，模糊和缺陷是美，追求完美恰恰背道而驰</strong>。</p>
<p><u>市场价格运动表面看起来往往是一个偶然性接着另一个偶然性，但是在看似完全偶然的背后，市场也不是完全混乱无序，隐隐约约透露出一定的必然性或者说是趋势性。投机成功的核心就是要去追求，把握这种必然性。</u>，交易高手就是能够从表面上看来不确定、随机的市场波动中找到相对确定、比较有把握的机会，知道什么时候<strong>成功的概率高，比较有利，什么时候静观其变</strong></p>
<p>从抽象的层面、事后的角度我们可以看清规律，但是对于未来，需要投机者有客观、定量、科学的理性分析能力，也要有灵活、变通、前瞻的艺术、直觉</p>
</li>
<li><p>良好的风险管理难</p>
<p>市场不确定性、随机性的一面决定了投机永远有<strong>博弈的成分</strong>，不可能有科学系统的预测理论。</p>
<p>良好的风险管理是投资者的立身之本。</p>
<p><u>期货交易既是一门赢的艺术，更是一门控制风险的输的艺术</u></p>
<p>成功的投资者在交易中能做到严格控制损失，<strong>即使砍掉亏损部位</strong>，对盈利头寸则做到了尽可能地扩大战果</p>
<p>短期的走势偶然性、人为性，投机者的贪婪、恐惧等心理因素，是的投机者找到适合自己的风险管理策略并非易事，但是无论是怎样的交易方式，短或长，感性、程序化，都要坚持<strong>几个原则</strong>：</p>
<ul>
<li>任何一笔交易都不要出现大的损失</li>
<li>一如既往的采取试探——加码的交易策略</li>
<li>在行情走势和自己的判断不一致时迅速止损，一致时逐步加仓，扩大利润</li>
</ul>
<p>青泽把期货交易的盈利模式分为两类：仓位取胜（博弈型）、幅度取胜（趋势性），但核心一样。</p>
</li>
<li><p>了解自己、战胜自己难</p>
<p>在某种意义上说这是一个心理游戏，投机者应该做出正确的决策而不是舒服的决策，心理上舒服的决策结果往往很不好，遵守交易技术和资金管理策略，不要被情绪左右。</p>
<p>从交易之道到市场行为，隔了 知（了解），情（心理认同），意（执行的意志力），这三者的合力才能决定行为是否理性。</p>
<p>技术和基础知识其实一两年就够了，但是稳定、良好的心态和境界，这可能是一辈子的事</p>
</li>
</ol>
<p><u>关于期货最好的忠告：在开始之前就停止行动</u></p>
<p>有奇迹的故事，更有数不胜数的尸骨和黯然的退场</p>
<p>市场交易是残酷、险恶，梦醒之后，也不要忘记当年的热情和豪言壮志（我的热情还没开始呢！</p>
<p>青泽先生的前言是一篇难得的好文章。</p>
<h2 id="一、命运之门"><a href="#一、命运之门" class="headerlink" title="一、命运之门"></a>一、命运之门</h2><p>人的命运可以自己选择吗？可以，你可以走你愿意走的路。</p>
<p>但是，一旦你上了路，回头恐怕就没有那么容易了，人生的许多事情都无法重来一次。</p>
<p>人生就像一个怪圈。有些年轻时候认为无足轻重的问题，年龄大后可能觉得很重要，比如一个人的修养、个性、习惯等；有些年轻时认为很有意义的事，以后看来往往没有想象中那么有价值，比如年轻的时候某种特别的兴趣和爱好等。</p>
<p>索罗斯：“你不可能随心所欲，又在市场中有良好的表现”</p>
<p>一念之差，一面是个哲学领域的教授、学者。一面是专业投资家，睿智的赌徒。</p>
<p><strong>期货是浓缩的人生</strong>，交易世界和现实生活有着如梦如幻的巨大反差</p>
<p>当时头脑精明点就能赚到钱，大部分人都是先扎进去，然后才开始了解基本知识，现在的股市就凶险了许多，人们的整体素质高了不少，难度暴增。</p>
<p>大多数涉足股市的新手，只要在股票上赚过一次钱，就会被吸引住，从此欲罢不能，沉迷上瘾。心乱了</p>
<p>一次偶然的急于，让他成为公司的操盘手，即使当时毫无投资理念和策略，但这就是时代和命运。</p>
<p>这给了他坐着一个巨大的发展机会，也让他的人生充满跌宕起伏，承受了许多常人无法体会的坎坷磨难。曲折的经历，平淡的人生，都在羡慕着彼此。</p>
<h2 id="二、一个与众不同的赌徒"><a href="#二、一个与众不同的赌徒" class="headerlink" title="二、一个与众不同的赌徒"></a>二、一个与众不同的赌徒</h2><p>股票市场要赚大钱，不仅要靠知识，也要靠信念；不但要靠智慧，也要靠胆量。</p>
<p><strong>新手的运气往往很好</strong></p>
<p>有观点：新手想要在投机市场中赚钱，最佳策略时找机会大赌一次，而经验丰富，有胜算和有势的人反而应该注意控制资金，减少偶然性运气的影响。<strong>投机是一个大多数人必输的游戏。</strong></p>
<hr>
<p>理解股市：</p>
<p>西方发达国家证券市场诞生的意义来自经济发展的内在需要。有人需要筹集成本，有人希望投资，这是一个公平、高效的互惠互利、各取所需市场。</p>
<p>中国早期股市却打上了深深的中国特色烙印，为国有企业融资解困。因此判断国内市场我们既要看内在的市场规律，更要高度关注政治、决策的态度，这样才能提高投资的胜算。</p>
<ol>
<li><p>用政治眼光来审视股票市场，抓住市场可能出现的重大变化。</p>
<p>青泽认为在未来相当长的一段时间内仍是政策市，因此股票市场一点出现过于离谱的暴涨暴跌，就随时可能出现外在的力量左右市场走势，回到社会政治所能容忍的范围内。<strong>政治敏感度极其重要。</strong></p>
</li>
<li><p>抓住<strong>大行情</strong>可能来临的机会，长线交易，重仓交易，不贪小利，迷恋股市，整天炒来炒去。</p>
</li>
<li><p>绝不染指垃圾股，这些股票甚至在大牛市都没有出头之日。</p>
<p>分散投资是减少垃圾股上海的一个简单策略。</p>
</li>
</ol>
<p><u>重价不重势——典型的外行炒股手法。</u></p>
<p>作者有了一些新的认识：</p>
<p>如果股市波动时循环的，而长远看指数一直在稳步上涨，那么，投机者的操作只要稍稍聪明一点，不太干愚蠢的事，在一定意义上，股票交易其实一点风险都没有。作者希望投机者深入透彻地思考👇：</p>
<ol>
<li><p>操作手法问题。大利润一定来自于大的市场波动</p>
<p>要有足够的耐心等待永恒的牛熊循环，不要整天频繁的短线交易，在市场地无需波动中迷失自我</p>
</li>
<li><p>投机者的市场信念问题</p>
<p>巴菲特：“利润有时候往往来自对市场的愚忠”，对市场没有坚定信念的人，往往拿不住很有可能带来巨大回报的仓位，不能获得市场重大波动的利润。但是还是得远离垃圾股。</p>
</li>
<li><p>参与股票交易的投资者，对市场指数高低要有一些基本常识，不能犯太离谱的错误。</p>
<p>但是指数的高低总是相对的，判断起来不是简单的问题。</p>
</li>
</ol>
<hr>
<p>股票终究不是真正的赌场，背后有企业、业绩、国家政治的影响。</p>
<p>股市大跌后再买入，耐心等待下个牛市，这是一种常识，但遵循这个简单的真理却十分困难。</p>
<p>对市场短期走势过于在意，就不宜涉足股票市场。</p>
<p>通过抓住重大趋势波动来赢利的交易模式，只是一种策略，需要眼光、胆识、魄力和长线持仓的勇气。</p>
<p><u>对于操盘手来说，一两次交易中出现亏损是非常普通的事情，但是面对重大的历史机遇，在锐利的行情中只赚了小钱，这种错误是无法原谅的。</u></p>
<h2 id="三、误入“期”途"><a href="#三、误入“期”途" class="headerlink" title="三、误入“期”途"></a>三、误入“期”途</h2><p>【我刚玩投机就误入了hh】</p>
<p>我被自我一次次打倒，却不知道敌人在哪里。</p>
<p>在股票、期货这个弱肉强食的市场，大多数散户投机者的命运，就像天空中一只断了线的风筝，一会上升，一会儿下降。散户的资金、心理承受能力、市场经验决定他们注定是被动的牺牲品。在一个不规范的市场中，主力们只要略使小计，就能杀绝大部分跟风者</p>
<p><strong>如果股票是抽烟，那么期货就是毒品</strong></p>
<p>期货投机的魔力在于，对于单独某一次交易，即使是赌博，也有50%赢的可能。</p>
<p>尽管从账面上看，很多人的本金在一天天减少，但是偶尔的几次交易赢利，会使大多数投机者产生一种幻觉，迟早能重新赚回来，还有暴富的机会。但能赚回损失的人是少数。</p>
<p>短期交易没有什么道理可言，也无从分析，只是凭着感觉对市场波动做出反应。这样的人往往成了市场短期波动的俘虏，思维、情绪被支配，变得不由自主，控制不了自己的交易冲动，不愿失去一切交易机会，过度敏感。</p>
<p>赚的时候，幻想一直保持，亏的时候十分沮丧，但是一旦进入下一次交易，不佳的心情就被忘记。</p>
<h2 id="四、绝处逢生"><a href="#四、绝处逢生" class="headerlink" title="四、绝处逢生"></a>四、绝处逢生</h2><p>327之战。</p>
<p>这是作者的运气，但是也是作者的经验告诉他选择哪一边。</p>
<p>也许是年龄增长，市场中经历过的偶然性太多了，很多事情的评价标准有时反而变得模糊了。青泽先生现在也不能完全确定当初自己的举动（全仓多头）是疯狂、鲁莽还是大胆、勇敢。这取决于角度。</p>
<p>毫无疑问，这种重仓交易、以命相搏的交易手法是自取灭亡之道。</p>
<p>尽管有时候保守和谨慎可能是一种束缚人的枷锁，短期会拖投机者的后腿，但是长远来看，保守、谨慎、稳健无疑是期货交易者的立身之本。</p>
<p><strong>一旦一个人获得了如此辉煌的战绩，无论旁观者还是他自己，都会有意无意地把这种成功归功于投机者的主观因素，而对事情发生偶然性的一面选择性忽略。</strong></p>
<p><strong>对于一个职业投机客来说，交易是一条漫长地路，局部的输赢犹过眼云烟，实在是一件无足轻重地小时。过于拘泥某一笔交易地得失，对此痛心疾首或津津乐道，并非是一种聪明、理智的态度。只能说认识浅。</strong></p>
<h2 id="五、苦闷的求索"><a href="#五、苦闷的求索" class="headerlink" title="五、苦闷的求索"></a>五、苦闷的求索</h2><p>哲学家必须从感觉世界的”洞穴“上升到理智世界</p>
<p>但是一个人总不可能平白无故地进行行动，他需要某种行为方式和标准，至于这种权威是否可靠并不重要，不然这会让他面对波动不知所措。</p>
<p><strong>从预测制胜到重视资金、仓位的风险管理到心理、人生修养是一条漫长而痛苦的路。</strong></p>
<p>短期交易，迷惑人的心智，其实是赌博罢了。</p>
<hr>
<p><u>不可能有预测制胜，没有人能精确地预测市场的未来变化。</u></p>
<p><strong>市场交易是一个动态、系统的控制过程。理解价格变化、判断未来走势只是成功交易的一个不是最重要的环节</strong></p>
<p>在实际操作中：</p>
<ul>
<li>每一次交易投入的资金多少</li>
<li>情况不利时如何处理，有利时如何加码</li>
<li>价码后出现有利、不利情况如何应对</li>
<li>影里的交易怎样既不由赢转亏，又不丧失一旦市场大波动带来的暴利等</li>
</ul>
<p><em><strong>这些问题的应对技巧、策略、方法，远比希望准确预测走势重要得多，需要投机者有一套完整、系统的交易思路。</strong></em></p>
<hr>
<p>确实，在大行情下的急剧波动，不论多空其实都无安宁。</p>
<p>据好事者统计，当年在股票、国债期货市场上赚过大钱的人，90%的结局都不太妙，这反映了一些东西。</p>
<p><u>投机市场中，一个人偶尔可以赚大钱也许并不难，难的是一直稳稳当当地赚钱，而且守得住钱。</u></p>
<p><a href="https://baike.baidu.com/item/%E7%AE%A1%E9%87%91%E7%94%9F/10343491">管金生</a></p>
<p>他们藐视法律，操纵行情，玩弄市场。</p>
<p>中经开的营业部令人向往——神奇的部门</p>
<p>早期国内股票市场、期货市场，市场操纵横行，政府法规朝令夕改，普通投机者生存环境十分恶劣，在这样的情况下，已经不能完全的归结于投机者自身的内在原因，外界因素几乎对投资者的命运起到决定性的作用</p>
<h2 id="六、纸上富贵一场梦"><a href="#六、纸上富贵一场梦" class="headerlink" title="六、纸上富贵一场梦"></a>六、纸上富贵一场梦</h2><p>1995，国债期货叫停，游资转战上海、深圳股票市场。</p>
<p>一次典型的纸上富贵——两鸟在林不如一鸟在手，但是谁有真正看得清这一点呢。</p>
<p>鞍山信托的一枝独秀——庄家也可能犯错。</p>
<p>市场里，没有庄家，往往走势清淡乏味。投机者没有机会</p>
<p>但是庄家来了以后兴风作浪。谁都不可能独善其身，包括庄家自己。</p>
<h2 id="七、单纯与复杂"><a href="#七、单纯与复杂" class="headerlink" title="七、单纯与复杂"></a>七、单纯与复杂</h2><p>——交易有那么难么</p>
<p>在成千上万的交易后，总的结果取决于投机者综合实力和心理优势，而不是一两次的市场预测能力。</p>
<p>在实际交易中，投机者会面临巨大的心理、精神压力，这是一个股评家不能完全了解和体会的。</p>
<p>一旦建立头寸，趋势就不像原先一般客观、超然、自信，你的恐惧、焦虑、患得患失等主观因素很有可能扭曲你的思维，使你陷入混乱。你当初的判断完全准确，但是你没有从中赚到钱。</p>
<p>不要依靠盘面变化和市场感觉、本能杀进杀出，这是缺乏理性的，也缺乏外在的客观约束。</p>
<p>要从长远分析市场状态和下一步变化的可能。看大势，理性审视。</p>
<p>在期货交易中，如果投机者入市后三天都没有出现利润，立刻平仓出场。</p>
<p>作者的第一个月大获成功，他在日后也感慨那段时间的美妙和带给他的信心，他总结：</p>
<ol>
<li><p>精神、心理条件非常好。</p>
<p>保持谨慎的态度，反复思考，再三权衡。</p>
<p>不要奢望一夜之间赚大钱，不要被急躁、贪婪的欲望支配。</p>
<p>没有交易的损失，没有历史包袱，不会畏手畏脚，在需要大胆行动时犹豫不决</p>
</li>
<li><p>中线顺势操作</p>
<p>中线顺势交易是期货赚钱的最佳策略</p>
</li>
<li><p>严格的风险控制</p>
</li>
<li><p>加码策略</p>
<p>试探-加码策略。在第一次投资后，如果市场走势证明判断错误，立马离场。否则便一次次加码，即使资金量不大，这样总能赚大钱，亏小钱。</p>
</li>
<li><p>时代和运气</p>
</li>
</ol>
<h2 id="八、兵败苏州红小豆"><a href="#八、兵败苏州红小豆" class="headerlink" title="八、兵败苏州红小豆"></a>八、兵败苏州红小豆</h2><p>当你将身体交给一个陌生人任意处置，你一定会感到愤慨。那么，当你将自己的精神交给一个偶遇者任意处置时，你难道不感到羞愧吗？</p>
<p><u>许多投机大师都反对利用内幕消息交易，认为这是投机者自我毁灭的捷径</u></p>
<p>因为急于翻本，作者被负面情绪支配，越做越赔，越赔越做。</p>
<h2 id="九、与天为敌"><a href="#九、与天为敌" class="headerlink" title="九、与天为敌"></a>九、与天为敌</h2><p>重仓交易的危害</p>
<p><strong>以安全性为代价追求收益率最终往往是得不偿失的</strong>。——本杰明</p>
<p>在期货交易中，一个人的心理、精神状态远比他拥有的市场知识和预测技术重要得多</p>
<p>作者准确的把握了几次做大钱的趋势，但却被短线思维所害，无法贯彻中长线交易的策略和原则。这是一种从“中长线”开始衍生出的一系列思维模式吧</p>
<p>害怕自己到手的利润得而复失，不愿继续等待利润自然而然地增长，不断换市场。仿佛非常忙碌，但一无所获</p>
<p><strong>经验不是你经历过什么，而是你从经历中学到了什么，<em>包括别人的经历</em></strong></p>
<p>期货的成功建立在一个非常危险的观念之上，就像脆弱地基上的大楼，来的快，去的也快。</p>
<p>P114生动的讲述了作者在面对期货起落的精神状态</p>
<p>来自十年后的反思：</p>
<ol>
<li><p>对于大多数人来说，即使拿出五分之一的资产来从事期货投机，也是危险的</p>
<p>保守、胆小的行为其实是高瞻远瞩，胆大妄为的重仓交易，早晚会在市场中牺牲。</p>
</li>
<li><p>坏习惯“钱烧口袋漏，一有就不留”</p>
<p>交易的姬会不是每天都有，不能凭想象行事，否则就是不尊重市场，将会受到市场的惩罚</p>
</li>
<li><p>在期货市场可以赚大钱，但需要时间，量的积累带来质的飞跃</p>
<p>重仓交易者企图战胜时间的束缚，一夜暴富，辉煌的成功靠的是以命相搏，一次意外就可能彻底失败。</p>
<p>真正成功的人，要么是拥有极其强大的意志，在赌赢后果断离场，要么靠的是长期、稳定的赢利。</p>
</li>
</ol>
<p>索罗斯：</p>
<ul>
<li>相对于近期赢利，我更关心<strong>基金资本的安全</strong></li>
<li>我主要还是着眼于<strong>限制亏损</strong>，而不是牟取暴利</li>
</ul>
<h2 id="十、激战海南咖啡"><a href="#十、激战海南咖啡" class="headerlink" title="十、激战海南咖啡"></a>十、激战海南咖啡</h2><p>面对诱惑，人的记忆力总显得太弱</p>
<p>期货市场本应是用来规避风险的地方，然而，曾几何时，在国内的一些交易所，期货却成了制造风险，激化矛盾的东西。</p>
<p>海南咖啡交易的几大特点：</p>
<ol>
<li><p>咖啡纯粹只是个符号被炒作</p>
<p>它托利里基本面因素和供求关系的制约，谁也不知道内在价值是多少。</p>
<p>没有人想阵得买进咖啡，投机者的唯一目的是赚取市场差价，最终结果是金钱的重新分配而已。</p>
<p>这不就是数字货币的雏形吗</p>
</li>
<li><p>波动巨大，虽然比不过炒币</p>
</li>
<li><p>波动方式诡异，凶狠，残酷</p>
<p>常规的风险控制措施不管用，绝对不能出现方向性的措施，连续性的跌涨停板，没有逃命的姬会。</p>
</li>
<li><p>市场主力争斗你死我活、白热化</p>
<p>大量非市场因素参与其中</p>
</li>
</ol>
<p><strong>方向判断准确只是交易成功的第一步，并且可能不是最关键的一步。</strong></p>
<p><strong>赚大钱最主要的是投机者需要有大的耐心和忍耐力，面对短期波动的不确定性、反复无常，要坚定自己的市场信念。</strong></p>
<p><em><strong>能否抵御市场短期波动的威胁、欺骗，是顺势交易最令人头疼而不得不面对的现实问题。</strong></em></p>
<p>K线完全是形而上的思维方式，用静止，片面而孤立的观点看待市场，一叶障目，应该从整体，全局，的角度看待。</p>
<h2 id="十一、逆势操作的反思"><a href="#十一、逆势操作的反思" class="headerlink" title="十一、逆势操作的反思"></a>十一、逆势操作的反思</h2><p><strong>你不可能靠风向标致富</strong>——巴菲特</p>
<p>比起重仓的谨慎，逆势者像温水里的青蛙，慢慢丧命。</p>
<p>大多数情况下，市场的趋势运动是温和、缓慢演变的，趋势都不是很明显，具有偶然性和随机性</p>
<p>所以逆势操作有可能也能赚到钱，因此其巨大危险性不易察觉，直到大势到来，恶果就暴露无遗。</p>
<p>一般来说，操纵者并不怕市场对手，他们更怕法律和市场监管。期货市场不完善和监管缺失，使他们有机可乘，那么数字货币呢？</p>
<p>这些折戟的精英们，每一件失败的事都有大量的偶然因素，但是偶然背后也有必然的一面，他们有一些共同的特点：</p>
<ol>
<li><p>自负和贪婪</p>
<p>大多数人似乎总是高估自己的判断力，过于自负</p>
<p>如果一个投资者顺势交易，他往往觉得自己没有格调，不能证明自己，一旦被套住他会觉得自己愚蠢，一旦成功他会给予自己极高的评价。</p>
<p>当自负和贪婪集中在一个人身上，尤其是掌握巨额资金的大人物身上，悲剧就开始上演了。</p>
</li>
<li><p>侥幸</p>
<p>心理学预期认为：失败的时候我们是风险的爱好者，有盈利时我们是风险的厌恶者。</p>
<p><strong>大多数人都是这样，赚小钱、亏大钱，刚好与正确的交易原则相反。</strong></p>
<p>其实，任何巨大损失的造成，除了突发性消息引起的个别意外情况，一般有从到质变的过程。</p>
<p>没有人能避免错误，我们能做的只有——止损原则。</p>
</li>
<li><p>虚荣</p>
<p><u>处于自我保护和虚荣的本能下，不愿让别人知道自己犯的错误。</u></p>
<p>一大群投机者在牛市做空的原因：</p>
<ol>
<li>市场行情看似是高估的</li>
<li>市场行情的矫正时间到了</li>
<li>他们听到一个看跌的消息，认为价格将会下跌</li>
<li>消息</li>
</ol>
</li>
</ol>
<p>人们不愿反思、正视自己的弱点，不愿承认因为缺乏自我约束而犯下的愚蠢错误，故意遗忘掉那些令人不快的痛苦经历。</p>
<p>理由是：</p>
<ol>
<li><p>短线交易方式隐含的天然缺陷</p>
<p>过于注重细节的人，往往对大事情一无所知</p>
</li>
<li><p>总比市场慢一拍的思维</p>
<p><strong>总以为历史会简单的重复</strong></p>
</li>
<li><p>作者迷失在短期波动的大海里</p>
<p>投机者很容易沉溺短线思维而失去超然的思维，让投机者不知不觉中，稀里糊涂地变成了一个逆势交易者</p>
</li>
<li><p>市场趋势会反弹吗？——思维陷阱</p>
<p>任何一个市场趋势一旦明朗，市场价格往往已经涨跌了相当幅度。</p>
<p>在这种情况下，市场趋势随时反转的可能性并非不存在。一般人很难不折不扣地遵循顺势投资地原则，就是怕趋势反转。</p>
<p><strong>在市场交易中，投机者应该做出正确地决策，而不是做出让自己感觉舒服的决策。</strong>所以说投机是反人性</p>
</li>
</ol>
<p>教训：</p>
<ol>
<li>价格变化本身透露出的消息远比指标的意义重要。</li>
<li>对投机者来说，从众是大忌，风向标不会让人赚钱</li>
<li>再次强调止损</li>
</ol>
<p>现代决策心理学的研究表明：当一个人的内心充满矛盾时，最典型的行为特征是不采取任何行动。</p>
<h2 id="十二、冥河摆渡者"><a href="#十二、冥河摆渡者" class="headerlink" title="十二、冥河摆渡者"></a>十二、冥河摆渡者</h2><p>让新手盲目进入市场是非常不负责任的</p>
<p>市场交易离不开预测，但是预测只是一个合理的交易计划的一小部分。</p>
<p>投机者一定要时时刻刻保持冷静、理智，客观、谦逊的评价自己，不论低谷或高峰。</p>
<p>投机需要技巧、时机、经验和运气，蛮干、强求是无法成功的。</p>
<h2 id="十三、与恶魔进餐"><a href="#十三、与恶魔进餐" class="headerlink" title="十三、与恶魔进餐"></a>十三、与恶魔进餐</h2><p>市场主力的目的：让大多数投机者犯错，自己从中获利。</p>
<p>作者入瓮后试图破局：</p>
<ol>
<li>在市场真正突破有意义的技术点位后入市 失败</li>
<li>设置好小亏损，止盈设置高一点，在众多指标中，找到了一种恰好比较符合的遵守</li>
</ol>
<p>作者构建了一套理解市场的核心框架工具，严格遵守。</p>
<p>大势交易准则。</p>
<h2 id="十四、Jesse-Livermore"><a href="#十四、Jesse-Livermore" class="headerlink" title="十四、Jesse Livermore"></a>十四、Jesse Livermore</h2><p>进入市场前，要爬上巨人的肩膀。</p>
<p>作者发现安了里费默的这本书。</p>
<p>本杰明、投资：《价值投资》</p>
<p>里费默、投机：《股票作手回忆录》</p>
<p>ps:大致来讲，我们可以把股市回报分为两大类：<strong>基本面和投机面</strong>。基本面是指股票自身给予投资者的回报，主要包括公司分红和盈利增长。而投机面则主要反映了大众对于市场的悲观或者乐观情绪。从比较长的时间维度来看，基本面给予投资者的回报是可以预测并且比较稳定的，而投机面则变化无常，经常在天堂和地狱之间游走。</p>
<p>全书内容大致分三类：<u>市场认识、交易策略、心理精神</u></p>
<p><strong>市场认识</strong>：对股票、期货市场的重大原则问题的基本观点。包括市场趋势出现的原因，市场价格变化的必然性、偶然性，操作行为的影响等</p>
<p><strong>交易策略</strong>：应对市场价格变化的基本方法、技巧。包括入市时机，点位选择，投入资金，利好利空策略，何谓最佳离场时机。</p>
<p><strong>心理精神</strong>：如何看待盈亏，对待金钱的态度，长线交易中对待波动的准备，还有种种投机者盲目的心里根源。</p>
<p>不能无原则的止损！趋于大势。</p>
<p>主力的力量也必须服从供求关系，经济学理论并非毫无用处，市场价格大方向上必然符合经济大规律。</p>
<p>赚大钱不能靠看盘，而在于股价整个股市行情和走势。</p>
<p><strong>试探-加码策略</strong>，<strong>好有道理</strong></p>
<p>有学者认为投机者应该着重追市，在发生突破后再进入市场。</p>
<h2 id="十六、离市场远一点"><a href="#十六、离市场远一点" class="headerlink" title="十六、离市场远一点"></a>十六、离市场远一点</h2><p>在缓慢上涨的行情中，如果市场涨姿突然加速，这可能是市场要见顶。。</p>
<p>大行情要有一个发展过程，投机者必须给市场足够的时间，投机者是不是不该天天注意市场细节，而是离他远一点呢？</p>
<p>一个看图经验，在大幅下跌后的市场行情中，如果市场价格连续两周上涨，周K线都是中等长度阳线，后市往往极度看好。</p>
<p>既然自己把持不住短期波动的扰乱，那就躲远一点吧！</p>
<h2 id="十七、投机者"><a href="#十七、投机者" class="headerlink" title="十七、投机者"></a>十七、投机者</h2><p>面对相同的行情，投机者们有着完全不同的各种应对方式。</p>
<p>市场交易无非一买一卖，但背后却隐含着投机者不同的观念、意识、目的、动机，反映出投机者的价值观、交易理念、对待风险、金钱的态度等。</p>
<p>投机者在金融领域的最终命运，深层次的原因取决于一个投机者的综合素质——人生修养和境界。</p>
<p>这建立在两个方面上：</p>
<ul>
<li><u>对市场的理解</u>，对市场交易中一些重大的原则性问题的基本态度</li>
<li><u>对自我的认识</u>，既包括对人类本性的洞察，也包括对自身独特弱点、性格缺陷的反省</li>
</ul>
<p>心理游戏，与人斗，与自己斗。</p>
<p>很多人们都能随口说出的朴素、简单的经验，投机者都为之可能付出过惨痛的代价才能铭刻于心</p>
<p>投资的特性让人们容易忘记错误，沉迷于数字上涨的愉悦，忘记反省，便多出了无数的错误成本。</p>
<p>投机里的止损、冲动性交易等问题，其实都不是孤立的，投机者整体的交易理念、境界达不到一定的高度，就难以彻底</p>
<p><strong>冲动性交易是一种超级短线交易</strong></p>
<p>缺乏自我控制能力，沉迷于短时间赚大钱的欲望。</p>
<p>平静、淡然的欣赏市场的变化，也审视着自己的内心世界，这种境界。。</p>
<p><strong>止损需要莫大的勇气</strong></p>
<p>再交易不利时果断止损，推翻原来的市场判断是沉重的。这还涉及投机者的市场认识，投机策略，交易思路是否正确，更要求极高的精神境界。</p>
<p>每一次交易中，具体止损点位的设立，也是个复杂问题。不然就可能来回割肉，被市场愚弄</p>
<p>不能孤立、静止、机械地看待市场交易中的止损问题。如果一个人的盈利不能弥补止损的损失，那也毫无用处，止损对长线更有意义，因为利润远远大于损失。</p>
<ul>
<li>天下唯一确定的事情就是不确定性</li>
<li>任何决策都是均衡几率的结果</li>
<li>一旦做出决定就要立刻付出行动</li>
<li>决策者的品质远远比决策结果重要</li>
</ul>
<p>这是一个长期的培养、追求、领悟过程。</p>
<p>面对市场的不确定性，哲学的世界观、方法论、价值观和抽象思维模式也许能帮助投机者把握市场脉络。</p>
<p>高手之间的较量是投资哲学的较量，心态和境界的较量。</p>
<h2 id="十八、你能摆脱地星引力吗"><a href="#十八、你能摆脱地星引力吗" class="headerlink" title="十八、你能摆脱地星引力吗"></a>十八、你能摆脱地星引力吗</h2><p>理智的最后一步就是意识到有无数事物是它力所不及的。</p>
<p>不知命无以为君子。市场中人的因素重要，偶然性，同样重要。</p>
<p>环境、机遇和运气对一个的影响也是很大的，过于强调自我的意志、智慧和天赋，难免陷入幼稚和狂妄，付出惨痛的代价。</p>
<ol>
<li>社会政治、经济环境</li>
<li>政策因素，尤其在中国，一定要看得懂国家的态度，做出准确判断</li>
<li>市场本身，挑选市场，不同市场的规律不同，蕴含的机会也不同，波动大的市场蕴含更多的机会。</li>
<li>不公平竞争，几十年前市场的公平、公正原则荡然无存，内部勾结严重，尤其是交易所</li>
</ol>
<p>不要赌性太重，不要去做那些毫无把握的交易，珍惜已有的东西，善待自己，善待人生。</p>
<p>要根据环境的变化，审时度势，难免会被市场淘汰。</p>
<h2 id="十九、里费默之死"><a href="#十九、里费默之死" class="headerlink" title="十九、里费默之死"></a>十九、里费默之死</h2><p>生命本质的非理性之谜</p>
<p>人难胜天</p>
<p>一个富有想象力的人，在他的生活中，总是看到自己的生活具有传奇色彩，这就决定了他的生活方式——与其说他想创造美好的生活，不如说他想使他的生活成为一个美妙的故事。</p>
<p>没有人是绝对理性的，哪怕是传奇。</p>
<p>人性的困境如此悲哀。金融工程是不是就是为了解决这个问题？</p>
<p>忍不住好奇心，厌倦呆板的交易策略，迷失在探索市场奥妙的旅程，沉溺交易的快感，最后一无所有。</p>
<p>难道有什么比让自己心里愉悦更重要的吗？高明的交易原则在内心面前，也显得苍白无力</p>
<p>投机遵守的规矩是反人性的，领悟市场交易的局限性、危险性、悲剧性——性格决定命运</p>
<p>投机算的上是工作吗？——天空不留下鸟的痕迹，但我已飞过。</p>
<p>期货交易要赚钱，不但要有心，更要有运，多少年轻人都死在里面了。</p>
<p>市场交易中没有持续、安全、稳定的成功之路。</p>
<p>在西方国家，大众参与期货交易的方式往往是间接的，一般是通过基金让专业人士来操作，而我国期货市场80%都是散户，期货市场的残酷和凶险最后必然会淘汰大部分人，并使他们收到严重的伤害。</p>
<p>人啊，也许根本就无法战胜非理智地一面。</p>
<p>张爱玲《非走不可的弯路》</p>
<p>一个交易经验丰富、市场理解深刻的投机者，经历了长时间的摸索和尝试以后，往往能够建立起自己的交易模式、套路，具有明确的交易思路和交易风格。其思维和行为方式具有逻辑性和前后一致性。</p>
<p>成功操盘手的几个特征：</p>
<ol>
<li><p>拥有一套相对稳定的，有优势、有胜算的交易模式</p>
<p>这样才能明确自己在市场中关注什么，什么时候采取行动。</p>
</li>
<li><p>交易策略和风险控制的始终一贯性</p>
<p>坚持每一笔交易都不要出现重大损失；每一次都采取试探—加码策略。</p>
<p>限制亏损，发展利润</p>
</li>
<li><p>市场判断和操作的前后一致性</p>
<p>紧握头寸，把持住长期的确定性</p>
</li>
<li><p>哲学境界</p>
<p>武士道、茶道等东方哲学，在这个孤独的心里搏斗游戏中，如何贯彻一套哲学</p>
</li>
</ol>
]]></content>
      <categories>
        <category>finance</category>
      </categories>
      <tags>
        <tag>股市心理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据科学导论</title>
    <url>/2021/06/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数据科学导论"><a href="#数据科学导论" class="headerlink" title="数据科学导论"></a>数据科学导论</h1><h2 id="1-基础理论"><a href="#1-基础理论" class="headerlink" title="1 基础理论"></a>1 基础理论</h2><p>数据富足时代——大数据时代</p>
<ul>
<li>现代处理器功能增强，密集度up</li>
<li>存储、管理成本降低，新的存储技术使得数据运行更快，规模up</li>
<li>跨计算机集群分布计算处理能力，提高了分析复杂数据的能力</li>
<li>有更多业务数据集可供分析，而且大部分提供了API</li>
<li>机器学习算法的开源社区日渐庞大</li>
<li>可视化更容易使用</li>
</ul>
<p>很多过去的研究方法和理论思维有明显的“面向数据贫乏时代”特点，不再适用</p>
<h3 id="1-1-术语定义"><a href="#1-1-术语定义" class="headerlink" title="1.1 术语定义"></a>1.1 术语定义</h3><p>数据、信息、知识、智慧</p>
<p>结构化数据、半结构化数据、非结构化数据 （可否用传统关系数据库存储）</p>
<p><strong>结构化：先有结构，再捕获数据</strong></p>
<p>4V： Volume  Variety  Value  Velocity</p>
<p>涌现：质变</p>
<p>理解数据科学：现实映射到数据，研究问题，对现实进行预测、洞见、解释、决策</p>
<h3 id="1-2-研究目的"><a href="#1-2-研究目的" class="headerlink" title="1.2 研究目的"></a>1.2 研究目的</h3><p>最终目标：实现数据、物质、能量间的转换，降低后两者损耗、提高后两者效果和效率</p>
<p>具体：</p>
<ul>
<li>揭示大数据内容，元数据特征、规律，帮助人们理解大数据的本质特征</li>
<li>从数据到智慧的转换 P11</li>
<li>数据洞见：将数据转化为实际行动</li>
<li>数据业务化</li>
<li>数据驱动型决策支持，将数据当作驱动方式</li>
<li>数据产品研发：<strong>0-3次数据 原生 干净 增值 洞见数据</strong></li>
<li>数据生态系统建设<ul>
<li>数据生产</li>
<li>数据采集</li>
<li>数据处理</li>
<li>业务流程</li>
</ul>
</li>
</ul>
<h3 id="1-3-研究视角"><a href="#1-3-研究视角" class="headerlink" title="1.3 研究视角"></a>1.3 研究视角</h3><p>原本：我能为数据做什么</p>
<p>​            传统的数据工程、数据结构、数据库、数据仓库、数据挖掘都是这个</p>
<p>​            强调通过人的努力改变数据，使数据更有价值，便于后续利用</p>
<p>现在：数据能为我做什么</p>
<p>​            大数据辅助决策、决策支持，带来商业机会，降低不确定性，发现可用的新模式</p>
<p>​            新术语：数据驱动、数据业务化、让数据说话、以数据为中心、数据柔术 都强调该视角</p>
<h3 id="1-4-理论体系"><a href="#1-4-理论体系" class="headerlink" title="1.4 理论体系"></a>1.4 理论体系</h3><p>领域知识：决定数据科学的主要关注点、应用领域和未来发展，重要</p>
<p>理论基础：统计学、机器学习、数据可视化与故事化</p>
<p>核心内容：</p>
<ul>
<li>基础理论：理念、方法、技术、工具、原则、目标等等</li>
<li>数据加工：融入3C精神，更强调<strong>增值活动</strong></li>
<li>数据计算：过渡至云计算，则关注的问题发生根本变化</li>
<li>数据管理：出现新兴的NoSQL、NewSQL和关系云等</li>
<li>数据分析</li>
<li>数据产品开发</li>
</ul>
<h3 id="1-5-基本原则"><a href="#1-5-基本原则" class="headerlink" title="1.5 基本原则"></a>1.5 基本原则</h3><ol>
<li><p>三世界原则</p>
<p>数据世界，使用“痕迹数据”，更加客观，而不是”采访数据“</p>
<p>第四范式：数据密集型科学发现范式——更注重相关性而不是因果</p>
</li>
<li><p>三要素</p>
<p>理论、实践、精神（3C）</p>
<p>提升实践能力：参加竞赛+参加开源项目</p>
<p>Creative Working</p>
<p>Critical Thinking</p>
<p>Curious Asking</p>
</li>
<li><p>数据密集型原则</p>
<p>挑战来自数据本身复杂性而不是计算</p>
</li>
<li><p>数据中心原则</p>
<p>从数据出发，改变业务</p>
</li>
<li><p>数据范式</p>
<p><strong>用数据直接解决问题</strong></p>
</li>
<li><p>数据复杂性原则</p>
<p>复杂性被认为是大数据不可分割的属性，数据在先，模式在后或无模式</p>
</li>
<li><p>数据资产原则</p>
</li>
<li><p>数据驱动原则</p>
</li>
<li><p>协同原则</p>
</li>
<li><p>从简原则</p>
<p>数据科学追求简单高效，面向具体应用需求，不考虑通用而复杂的算法</p>
</li>
</ol>
<h3 id="1-6-能力要求"><a href="#1-6-能力要求" class="headerlink" title="1.6 能力要求"></a>1.6 能力要求</h3><ul>
<li>创新精神、独特视角、不断进取</li>
<li>团队合作、协同工作</li>
<li>提出“nice”研究假设和问题，能够完成对应试验设计</li>
<li>参与项目的经验</li>
<li>灵活运用领域实务知识经验</li>
<li>研发数据产品</li>
</ul>
<h3 id="1-7-学习"><a href="#1-7-学习" class="headerlink" title="1.7 学习"></a>1.7 学习</h3><p>加法：操作系极强，培养动手操作能力，利用python和R</p>
<p>减法：不同学科领域对数据科学的研究视角和侧重点不同，应优先学习领域共性的数据科学，再日后专精</p>
<p>乘法：经典理论X最佳实践，优先学习最代表数据科学的理论和实践，数据科学里<strong>实践领先于理论</strong></p>
<p>除法：注意学习知识的完整性和逻辑性，用最简单的逻辑和最清楚的语言来学习</p>
<p>八个步骤：</p>
<ol>
<li><p>数学、统计学、机器学习</p>
</li>
<li><p>学会写代码</p>
</li>
<li><p>理解数据库</p>
</li>
<li><p>探索数据科学流程</p>
<p>采集、探索、加工、建模、验证、报告</p>
</li>
<li><p>重视并学习大数据</p>
</li>
<li><p>竞赛，建立自己的项目，培养精神</p>
</li>
<li><p>实习、集训、进入职场</p>
</li>
<li><p>参与社区</p>
</li>
</ol>
<h2 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2 理论基础"></a>2 理论基础</h2><h3 id="2-1-学科地位"><a href="#2-1-学科地位" class="headerlink" title="2.1 学科地位"></a>2.1 学科地位</h3><p>跨学科视角</p>
<p>关注理论研究和<strong>领域务实知识（需要相关专家参与）</strong>的结合</p>
<p>主要精神是hacker精神</p>
<h3 id="2-2-统计"><a href="#2-2-统计" class="headerlink" title="2.2 统计"></a>2.2 统计</h3><p>从行为目的和思维方式看</p>
<p>描述统计+推断统计</p>
<p>从方法论角度看</p>
<p>基本分析法：对低层数据（0次1次）分析</p>
<p>回归、分类、时间序列、线性分析、方差分析、聚类分析、其他</p>
<p>元分析法：对高层数据（尤其是基本分析法得出的）进一步分析</p>
<p>方向：</p>
<ul>
<li>不再是随机样本，而是全体数据</li>
<li>不是精确性，而是复杂性，目的不再是追求精确性，而是提升效率</li>
<li>不是因果关系，而是相关关系</li>
</ul>
<h3 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h3><p>基础理论来自多个学科：</p>
<p>人工智能、贝叶斯方法、计算复杂性理论、控制论、信息论、哲学、心理学与神经生物学、统计学</p>
<p>分类P62</p>
<p>按照输出结果：</p>
<ul>
<li>概念学习：用结果推出未知的布尔函数，找到最好你和训练样本的假设</li>
<li>决策树学习：逼近离散值目标函数过程</li>
<li>分析学习：用先验知识分析每个样本，推算各特征与目标函数的相关性</li>
<li>归纳学习</li>
</ul>
<p>按照学习方式：</p>
<ul>
<li>人工神经网络</li>
<li>贝叶斯学习</li>
<li>遗传算法</li>
<li>基于实例学习</li>
<li>增强学习</li>
</ul>
<p>按照学习任务不同：</p>
<ul>
<li>监督学习<ul>
<li>最近邻</li>
<li>朴素贝叶斯</li>
<li>决策树</li>
<li>随机森林</li>
<li>线性回归</li>
<li>支持向量机</li>
<li>神经网络分析</li>
<li>。。。。</li>
</ul>
</li>
<li>无监督学习<ul>
<li>K-Means聚类</li>
<li>主成分分析</li>
<li>关联规则分析</li>
</ul>
</li>
<li>半监督学习<ul>
<li>半监督分类：生成式、判别式</li>
<li>半监督回归：基于差异、基于流形学习</li>
<li>半监督聚类：基于距离、大间隔方法</li>
<li>半监督降维：基于类标签、基于成对约束</li>
</ul>
</li>
</ul>
<p><strong>挑战</strong>：</p>
<ul>
<li><p>过拟合（Overfitting）</p>
<p>训练集准确率高，测试集准确率低</p>
</li>
<li><p>维度灾难（Curse of Dimensionality）</p>
<p>低维算法难以移植到高维</p>
</li>
<li><p>特征工程（Feature Engineering）</p>
<p>还得考虑相关领域知识</p>
</li>
<li><p>算法可拓展性（Scalability）</p>
</li>
</ul>
<p>P74常用统计模型和机器学习算法</p>
<h2 id="3-流程与方法"><a href="#3-流程与方法" class="headerlink" title="3. 流程与方法"></a>3. 流程与方法</h2><p><em><strong>数据科学没有统一的流程，不同专家、应用场景中所提出的流程可能不同，学习数据科学流程的母的在于掌握活动类型，而不是活动之间的严格先后顺序。</strong></em></p>
<h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>图P83</p>
<p>数据化、数据加工、数据规整化、探索性分析、数据分析与洞见、结果展现和数据产品的提供</p>
<ol>
<li><p>数据化</p>
</li>
<li><p>数据加工和规整化</p>
<p>本质是将低层数据化为高层数据0-&gt;1-&gt;2-&gt;3</p>
<p><strong>干净数据</strong>（相对脏）：质量没问题，没有缺失值，错误值和噪声信息</p>
<p><strong>规整数据</strong>（相对乱）：形态符合计算与算法要求，从数据形态分类</p>
<p>注意应该是<strong>增值过程</strong>，不等于传统的“数据预处理”和“数据工程”</p>
</li>
<li><p>探索性分析</p>
<p>在尽量少的先验假定下探索，通过作图、制表、方程拟合、计算特征量等<strong>探索数据的结构和规律</strong></p>
<p>先探索后验证</p>
<ul>
<li><p>耐抗性：</p>
<p>对局部不良行为的非敏感性，因为大数据难免有部分差错</p>
<p>耐抗性分析统计量：集中趋势、离散程度、分布状态、频度等</p>
</li>
<li><p>残差</p>
</li>
<li><p>重新表达</p>
<p>找到合适的尺度或数据表达方式进行准换，有利于化简分析，主语对称性，恒定性，线性和可加性，和线性代数概念类似，也叫变换</p>
</li>
<li><p>启示</p>
</li>
</ul>
</li>
<li><p>数据分析与洞见</p>
<p>在理解数据的基础上，设计、选择、应用具体的机器学习算法和统计模型进行分析</p>
<ul>
<li>描述性分析：转换为信息</li>
<li>预测性分析：转换为知识</li>
<li>规范性分析：转换为智慧</li>
</ul>
</li>
<li><p>结果展现，提供数据产品</p>
</li>
</ol>
<h3 id="3-2-数据加工"><a href="#3-2-数据加工" class="headerlink" title="3.2 数据加工"></a>3.2 数据加工</h3><p>需求：数据质量要求 和 数据计算要求</p>
<p>往往需要综合运用多种数据加工方法</p>
<p>图见P92</p>
<ol>
<li><p>数据清洗（多轮审计和清洗）</p>
<ul>
<li><p>缺失数据</p>
<p>识别、分析（特征，影响，原因）、处理（忽略，删除，插值）</p>
</li>
<li><p>冗余（重复、无关）数据</p>
<p>重复数据用重复过滤</p>
<p>无关数据用条件过滤</p>
</li>
<li><p>噪声（错误、虚假、异常）</p>
<p>分箱、聚类、回归</p>
</li>
</ul>
<hr>
</li>
<li><p>数据变换</p>
<p>使形式符合算法要求，常见策略：</p>
<ol>
<li>平滑处理——去噪声</li>
<li>特征构造——构造新属性，描述客观现实（体积+质量-&gt;密度）</li>
<li>聚集——汇总聚合数据，进行粗粒度计算（日销量-&gt;月销量）</li>
<li>标准化</li>
<li>离散化——用区间标签和概念标签表示属性值</li>
</ol>
</li>
<li><p>数据集成</p>
<p>内容集成：结构相同、描述不同对象，或可通过映射变为相同（同时进行冲突检测、处理等清洗操作）</p>
<p>结构集成：来源不同、描述同一对象，分结构和内容两层次，可进行<strong>属性选择</strong></p>
<p>难点：</p>
<ul>
<li>模式集成：如何匹配来自多个数据源的同一实体</li>
<li>数据冗余：冗余属性可以从其他属性推演出来，命名不一致，用相关分析P99</li>
<li>冲突检测和消除：比例尺度或编码不同（kg 和 g）</li>
</ul>
</li>
<li><p>数据脱敏（Data Masking）</p>
<ol>
<li>单向性：无法从脱敏数据 推导 出原始数据</li>
<li>无残留：用户无法用其他途径还原敏感信息，小心用户画像技术</li>
<li>易于实现：涉及数据量大，所以不能太复杂</li>
</ol>
</li>
<li><p>数据归约（Data Reduction）</p>
<p>在不影响数据完整性和分析结果正确性前提下，减少数据规模和数据量</p>
<ol>
<li><p>维归约</p>
<p>避免维度灾难，减少考虑的随机变量或属性，通常采用线代方法</p>
<p>主成分分析、奇异值分解、离散小波转换</p>
</li>
<li><p>值规约</p>
<p>用参数模型或非参数模型近似表示数据，只存储生成方法和参数？？</p>
</li>
<li><p>数据压缩</p>
<p>重构数据来压缩</p>
</li>
</ol>
</li>
<li><p>数据标注：</p>
<p>对目标数据补充必要的标签类元数据来提高检索、洞察、分析、挖掘效率</p>
<p>自动化程度：有手工、半自动、自动化标注</p>
<p>实现层次：语法标注和语义标注  不懂</p>
</li>
</ol>
<h3 id="3-3-数据审计"><a href="#3-3-数据审计" class="headerlink" title="3.3 数据审计"></a>3.3 数据审计</h3><p>按照数据质量的一般规律与评价方法审计，发现问题</p>
<p>比如缺失值、噪声值、不一致值（相互矛盾）、不完整值（被篡改或无法溯源）</p>
<p>P102</p>
<ol>
<li>预定义审计、自描述性规则</li>
<li>自定义审计</li>
<li>可视化审计</li>
</ol>
<p>常用技巧：第一数字定律、小概率原理、语言学规律、数据连续性理论、数据鉴别技术</p>
<h3 id="3-4-数据分析"><a href="#3-4-数据分析" class="headerlink" title="3.4 数据分析"></a>3.4 数据分析</h3><p>描述性-&gt;诊断性-&gt;预测性-&gt;规范性</p>
<p>​            ↑商务智能              ↑数据科学</p>
<ol>
<li><p>描述性</p>
<p>已经发生了什么</p>
<p>描述性统计分析方法</p>
</li>
<li><p>诊断性</p>
<p>为什么发生</p>
<p>关联分析法（数据科学家）和因果分析法（领域专家）</p>
</li>
<li><p>预测性</p>
<p>将要发生什么</p>
<p>分类分析方法、趋势分析方法</p>
</li>
<li><p>规范性</p>
<p>关注模拟与优化问题，如何从将要发生的事情受惠、如何优化将发生的事</p>
<p>运筹学、模拟与仿真技术</p>
</li>
</ol>
<h3 id="3-5-数据可视化"><a href="#3-5-数据可视化" class="headerlink" title="3.5 数据可视化"></a>3.5 数据可视化</h3><ol>
<li>科学可视化</li>
<li>信息可视化</li>
<li>可视分析学</li>
</ol>
<p>可视分析学以<strong>可视交互</strong>为基础，综合运用图形学、数据挖掘、人机交互，实现人机协同完成可视化任务</p>
<p>P112有一个模型，有以下特点:</p>
<ol>
<li><p>强调从数据到知识的转换过程</p>
<p>不是单纯的展示，而是转换成<strong>知识</strong>，两种途径 👇</p>
</li>
<li><p>强调可视化分析与自动化建模之间的<strong>相互作用</strong></p>
</li>
<li><p>强调数据映射和数据挖掘的重要性</p>
<p>（用来实现👆，作为重要支撑技术），配合使用</p>
</li>
<li><p>强调数据加工工作的必要性</p>
<p>不然会影响可视化效果</p>
</li>
<li><p>强调人机交互的重要性</p>
<p>人机互补和人机协同，重视互补优势</p>
</li>
</ol>
<p><strong>方法体系</strong></p>
<ol>
<li><p>方法论基础</p>
<p>主要指 <strong>视觉编码</strong> 作为数据可视化方法体系的根基</p>
<p>通常采用视觉图形元素和视觉通道两个维度进行视觉编码</p>
</li>
<li><p>基础方法</p>
<p>建立在👆之上，应用不局限于特定领域，提供高层不同应用领域的共性方法，比如统计图表、图论方法、视觉隐喻、图形符号学</p>
</li>
<li><p>领域方法</p>
<p>往往仅限于特定领域或任务范围，不具备跨领域/任务性</p>
<p>但在该领域的信度和效度高于基础方法的直接应用</p>
<p>比如地理信息可视化、时间数据可视化、不确定性、文本、媒体、实时数据之类的</p>
<p>很多领域已出现了自己独特的数据可视化方法，比如地铁路线图全球统一</p>
</li>
<li><p>视觉感知与视觉认知</p>
<p>视觉编码的关键在于找到符合目标用户群体的视觉感知习惯的表达方法</p>
<ul>
<li><p>视觉感知（Visual Perception）</p>
<p>指客观事物通过视觉感觉器官在人脑中产生直接反映的过程</p>
<p>应充分利用人类视觉感知特征</p>
</li>
<li><p>视觉认知（Visual Coginiton）</p>
<p>指个体对视觉感知信息的<strong>进一步加工</strong>处理过程</p>
<p>包括抽取、转换、存储、简化、合并、理解、决策等，很好的例子是<strong>完图法则</strong></p>
</li>
</ul>
</li>
<li><p>可视化视角下的数据类型</p>
<ul>
<li><p>定类数据</p>
<p>主要用于记录事物的所属类型或标签信息，只能进行相等判断</p>
</li>
<li><p>定序判断</p>
<p>主要记录事物的排信息，支持相等判断和大小比较运算</p>
</li>
<li><p>定距排序</p>
<p>用于记录事物的量化信息，“0”的位置具有任意性，不代表事物是否存在，如温度为0°</p>
</li>
<li><p>定比数据</p>
<p>用于记录事物的量化信息，“0”为基准，表示不存在，例如我的身高是他的1.5倍</p>
</li>
</ul>
</li>
<li><p>视觉通道的选择方法<strong>P118</strong></p>
<p>从人类的视觉感知和认知习惯看，数据类型与视觉通道时存在一定的关系的</p>
<p>一般有：位置、尺寸、数值、纹理、颜色、方向、形状，分别能够对应不同的数据类型</p>
<p>要综合考虑目标用户需求、可视化任务本身、原始数据的数据类型，成为数据可视化工作的重要挑战</p>
<p>不同视觉通道的<strong>数据表现力</strong>不同，评判标准：</p>
<ol>
<li><p>精确性</p>
<p>编码结果与原始数据间的吻合程度</p>
</li>
<li><p>可辨认性</p>
<p>字面意思，不要让视觉通道和背景混淆之类的</p>
</li>
<li><p>可分离性</p>
<p>不同视觉通道的表现力之间应具有一定的独立性，比如面积颜色表现力会受到面积大小影响</p>
</li>
<li><p>视觉突出性</p>
<p>编码结果能否在非常短的时间内迅速、精确传达出主要意图</p>
</li>
</ol>
<p>但是应注意：各种视觉通道的表现力往往是<strong>相对</strong>的，与原始数据、通道类型选择、用户感知习惯都有关</p>
</li>
<li><p>数据假象</p>
<p>不可忽视的特殊问题</p>
<p>目标用户产生的错误或不正确的视觉感知：</p>
<ol>
<li>可视化试图所处的上下文可能导致视觉假象</li>
<li>人眼对亮度和颜色的相对判断容易造成视觉假象</li>
<li>目标用户的经历和经验可能造成视觉假象</li>
</ol>
</li>
</ol>
<h3 id="3-6-数据故事化"><a href="#3-6-数据故事化" class="headerlink" title="3.6 数据故事化"></a>3.6 数据故事化</h3><p>“数据的故事化描述”是为了提